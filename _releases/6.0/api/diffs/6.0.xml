<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Guava r06"
  jdversion="1.1.1">

<package name="com.google.common.annotations">
  <!-- start class com.google.common.annotations.Beta -->
  <class name="Beta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Signifies that a public API (public class, method or field) is subject to
 incompatible changes, or even removal, in a future release. An API bearing
 this annotation is exempt from any compatibility guarantees made by its
 containing library.

 @author Kevin Bourrillion]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.Beta -->
  <!-- start class com.google.common.annotations.GwtCompatible -->
  <class name="GwtCompatible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[The presence of this annotation on a type indicates that the type may be
 used with the
 <a href="http://code.google.com/webtoolkit/">Google Web Toolkit</a> (GWT).
 When applied to a method, the return type of the method is GWT compatible.
 It's useful to indicate that an instance created by factory methods has a GWT
 serializable type.  In the following example,

 <pre style="code">
 {@literal @}GwtCompatible
 class Lists {
   ...
   {@literal @}GwtCompatible(serializable = true)
   static &lt;E> List&lt;E> newArrayList(E... elements) {
     ...
   }
 }
 </pre>
 The return value of {@code Lists.newArrayList(E[])} has GWT
 serializable type.  It is also useful in specifying contracts of interface
 methods.  In the following example,

 <pre style="code">
 {@literal @}GwtCompatible
 interface ListFactory {
   ...
   {@literal @}GwtCompatible(serializable = true)
   &lt;E> List&lt;E> newArrayList(E... elements);
 }
 </pre>
 The {@code newArrayList(E[])} method of all implementations of {@code
 ListFactory} is expected to return a value with a GWT serializable type.

 <p>Note that a {@code GwtCompatible} type may have some {@link
 GwtIncompatible} methods.

 @author Charles Fry
 @author Hayward Chan]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.GwtCompatible -->
  <!-- start class com.google.common.annotations.GwtIncompatible -->
  <class name="GwtIncompatible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[The presence of this annotation on a method indicates that the method may
 <em>not</em> be used with the
 <a href="http://code.google.com/webtoolkit/">Google Web Toolkit</a> (GWT),
 even though its type is annotated as {@link GwtCompatible} and accessible in
 GWT.  They can cause GWT compilation errors or simply unexpected exceptions
 when used in GWT.

 <p>Note that this annotation should only be applied to methods, fields, or
 inner classes of types which are annotated as {@link GwtCompatible}.

 @author Charles Fry]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.GwtIncompatible -->
  <!-- start class com.google.common.annotations.VisibleForTesting -->
  <class name="VisibleForTesting"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[An annotation that indicates that the visibility of a type or member has
 been relaxed to make the code testable.

 @author Johannes Henkel]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.VisibleForTesting -->
</package>
<package name="com.google.common.base">
  <!-- start class com.google.common.base.CaseFormat -->
  <class name="CaseFormat" extends="java.lang.Enum&lt;com.google.common.base.CaseFormat&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.base.CaseFormat[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.base.CaseFormat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="to" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="com.google.common.base.CaseFormat"/>
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Converts the specified {@code String s} from this format to the specified {@code format}. A
 "best effort" approach is taken; if {@code s} does not conform to the assumed format, then the
 behavior of this method is undefined but we make a reasonable effort at converting anyway.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class for converting between various ASCII case formats.

 @author Mike Bostock
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CaseFormat -->
  <!-- start class com.google.common.base.CharMatcher -->
  <class name="CharMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Predicate&lt;java.lang.Character&gt;"/>
    <constructor name="CharMatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="is" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches only one specified character.]]>
      </doc>
    </method>
    <method name="isNot" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character except the one specified.

 <p>To negate another {@code CharMatcher}, use {@link #negate()}.]]>
      </doc>
    </method>
    <method name="anyOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character present in the given character
 sequence.]]>
      </doc>
    </method>
    <method name="noneOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character not present in the given character
 sequence.]]>
      </doc>
    </method>
    <method name="inRange" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startInclusive" type="char"/>
      <param name="endInclusive" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character in a given range (both endpoints are
 inclusive). For example, to match any lowercase letter of the English alphabet, use {@code
 CharMatcher.inRange('a', 'z')}.

 @throws IllegalArgumentException if {@code endInclusive < startInclusive}]]>
      </doc>
    </method>
    <method name="forPredicate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super java.lang.Character&gt;"/>
      <doc>
      <![CDATA[Returns a matcher with identical behavior to the given {@link Character}-based predicate, but
 which operates on primitive {@code char} instances instead.]]>
      </doc>
    </method>
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Determines a true or false value for the given character.]]>
      </doc>
    </method>
    <method name="negate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher that matches any character not matched by this matcher.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by both this matcher and {@code other}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by either this matcher or {@code other}.]]>
      </doc>
    </method>
    <method name="precomputed" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to
 query than the original; your mileage may vary. Precomputation takes time and is likely to be
 worthwhile only if the precomputed matcher is queried many thousands of times.

 <p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a
 precomputed matcher is faster, but it certainly consumes more memory, which doesn't seem like a
 worthwhile tradeoff in a browser.]]>
      </doc>
    </method>
    <method name="matchesAllOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains only matching characters.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code false} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches every character in the sequence, including when
         the sequence is empty]]>
      </doc>
    </method>
    <method name="matchesNoneOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains no matching characters.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code false} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches every character in the sequence, including when
         the sequence is empty]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the first matching character in a character sequence, or {@code -1} if no
 matching character is present.

 <p>The default implementation iterates over the sequence in forward order calling {@link
 #matches} for each character.

 @param sequence the character sequence to examine from the beginning
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first matching character in a character sequence, starting from a
 given position, or {@code -1} if no character matches after that position.

 <p>The default implementation iterates over the sequence in forward order, beginning at {@code
 start}, calling {@link #matches} for each character.

 @param sequence the character sequence to examine
 @param start the first index to examine; must be nonnegative and no greater than {@code
        sequence.length()}
 @return the index of the first matching character, guaranteed to be no less than {@code start},
         or {@code -1} if no character matches
 @throws IndexOutOfBoundsException if start is negative or greater than {@code
         sequence.length()}]]>
      </doc>
    </method>
    <method name="lastIndexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the last matching character in a character sequence, or {@code -1} if no
 matching character is present.

 <p>The default implementation iterates over the sequence in reverse order calling {@link
 #matches} for each character.

 @param sequence the character sequence to examine from the end
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="countIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the number of matching characters found in a character sequence.]]>
      </doc>
    </method>
    <method name="removeFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all non-matching characters of a character sequence, in order. For
 example: <pre>   {@code

   CharMatcher.is('a').removeFrom("bazaar")}</pre>

 ... returns {@code "bzr"}.]]>
      </doc>
    </method>
    <method name="retainFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all matching characters of a character sequence, in order. For
 example: <pre>   {@code

   CharMatcher.is('a').retainFrom("bazaar")}</pre>

 ... returns {@code "aaa"}.]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each character that matches this
 matcher replaced by a given replacement character. For example: <pre>   {@code

   CharMatcher.is('a').replaceFrom("radar", 'o')}</pre>

 ... returns {@code "rodor"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching
 character, then iterates the remainder of the sequence calling {@link #matches(char)} for each
 character.

 @param sequence the character sequence to replace matching characters in
 @param replacement the character to append to the result string in place of each matching
        character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each character that matches this
 matcher replaced by a given replacement sequence. For example: <pre>   {@code

   CharMatcher.is('a').replaceFrom("yaha", "oo")}</pre>

 ... returns {@code "yoohoo"}.

 <p><b>Note:</b> If the replacement is a fixed string with only one character, you are better
 off calling {@link #replaceFrom(CharSequence, char)} directly.

 @param sequence the character sequence to replace matching characters in
 @param replacement the characters to append to the result string in place of each matching
        character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all characters this matcher
 matches from the beginning and from the end of the string. For example: <pre>   {@code

   CharMatcher.anyOf("ab").trimFrom("abacatbab")}</pre>

 ... returns {@code "cat"}.

 <p>Note that: <pre>   {@code

   CharMatcher.inRange('\0', ' ').trimFrom(str)}</pre>

 ... is equivalent to {@link String#trim()}.]]>
      </doc>
    </method>
    <method name="trimLeadingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all characters this matcher
 matches from the beginning of the string. For example: <pre> {@code

   CharMatcher.anyOf("ab").trimLeadingFrom("abacatbab")}</pre>

 ... returns {@code "catbab"}.]]>
      </doc>
    </method>
    <method name="trimTrailingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all characters this matcher
 matches from the end of the string. For example: <pre> {@code

   CharMatcher.anyOf("ab").trimTrailingFrom("abacatbab")}</pre>

 ... returns {@code "abacat"}.]]>
      </doc>
    </method>
    <method name="collapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each group of consecutive
 characters that match this matcher replaced by a single replacement character. For example:
 <pre>   {@code

   CharMatcher.anyOf("eko").collapseFrom("bookkeeper", '-')}</pre>

 ... returns {@code "b-p-r"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching
 character, then iterates the remainder of the sequence calling {@link #matches(char)} for each
 character.

 @param sequence the character sequence to replace matching groups of characters in
 @param replacement the character to append to the result string in place of each group of
        matching characters in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimAndCollapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that
 groups of matching characters at the start or end of the sequence are removed without
 replacement.]]>
      </doc>
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="character" type="java.lang.Character"/>
      <doc>
      <![CDATA[Returns {@code true} if this matcher matches the given character.

 @throws NullPointerException if {@code character} is null]]>
      </doc>
    </method>
    <field name="WHITESPACE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is whitespace according to the latest Unicode standard, as
 illustrated
 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.
 This is not the same definition used by other Java APIs. (See a
 <a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">comparison of several
 definitions of "whitespace"</a>.)

 <p><b>Note:</b> as the Unicode definition evolves, we will modify this constant to keep it up
 to date.]]>
      </doc>
    </field>
    <field name="BREAKING_WHITESPACE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a breaking whitespace (that is, a whitespace which can be
 interpreted as a break between words for formatting purposes). See {@link #WHITESPACE} for a
 discussion of that term.

 @since 2]]>
      </doc>
    </field>
    <field name="ASCII" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is ASCII, meaning that its code point is less than 128.]]>
      </doc>
    </field>
    <field name="DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a digit according to
 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">Unicode</a>.]]>
      </doc>
    </field>
    <field name="JAVA_WHITESPACE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is whitespace according to {@link Character#isWhitespace(char)
 Java's definition}; it is usually preferable to use {@link #WHITESPACE}. (See a
 <a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">comparison of several
 definitions of "whitespace"</a>.)]]>
      </doc>
    </field>
    <field name="JAVA_DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a digit according to {@link Character#isDigit(char) Java's
 definition}. If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.]]>
      </doc>
    </field>
    <field name="JAVA_LETTER" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a letter according to {@link Character#isLetter(char) Java's
 definition}. If you only care to match letters of the Latin alphabet, you can use {@code
 inRange('a', 'z').or(inRange('A', 'Z'))}.]]>
      </doc>
    </field>
    <field name="JAVA_LETTER_OR_DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a letter or digit according to {@link
 Character#isLetterOrDigit(char) Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_UPPER_CASE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is upper case according to {@link Character#isUpperCase(char)
 Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_LOWER_CASE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is lower case according to {@link Character#isLowerCase(char)
 Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_ISO_CONTROL" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is an ISO control character as specified by {@link
 Character#isISOControl(char)}.]]>
      </doc>
    </field>
    <field name="INVISIBLE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is invisible; that is, if its Unicode category is any of
 SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and
 PRIVATE_USE according to ICU4J.]]>
      </doc>
    </field>
    <field name="SINGLE_WIDTH" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is single-width (not double-width). When in doubt, this matcher
 errs on the side of returning {@code false} (that is, it tends to assume a character is
 double-width).

 <p><b>Note:</b> as the reference file evolves, we will modify this constant to keep it up to
 date.]]>
      </doc>
    </field>
    <field name="ANY" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches any character.]]>
      </doc>
    </field>
    <field name="NONE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches no characters.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does
 for any {@link Object}. Also offers basic text processing methods based on this function.
 Implementations are strongly encouraged to be side-effect-free and immutable.

 <p>Throughout the documentation of this class, the phrase "matching character" is used to mean
 "any character {@code c} for which {@code this.matches(c)} returns {@code true}".

 <p><b>Note:</b> This class deals only with {@code char} values; it does not understand
 supplementary Unicode code points in the range {@code 0x10000} to {@code 0x10FFFF}. Such logical
 characters are encoded into a {@code String} using surrogate pairs, and a {@code CharMatcher}
 treats these just as two separate characters.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CharMatcher -->
  <!-- start class com.google.common.base.Charsets -->
  <class name="Charsets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="US_ASCII" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[US-ASCII: seven-bit ASCII, a.k.a. ISO646-US, a.k.a the Basic Latin block of the Unicode
 character set.]]>
      </doc>
    </field>
    <field name="ISO_8859_1" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[ISO-8859-1. ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.]]>
      </doc>
    </field>
    <field name="UTF_8" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-8: eight-bit UCS Transformation Format.]]>
      </doc>
    </field>
    <field name="UTF_16BE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16BE: sixteen-bit UCS Transformation Format, big-endian byte order.]]>
      </doc>
    </field>
    <field name="UTF_16LE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16LE: sixteen-bit UCS Transformation Format, little-endian byte order.]]>
      </doc>
    </field>
    <field name="UTF_16" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16: sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order
 mark.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Contains constant definitions for the six standard {@link Charset} instances, which are
 guaranteed to be supported by all Java platform implementations.

 @author Mike Bostock
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Charsets -->
  <!-- start class com.google.common.base.Defaults -->
  <class name="Defaults" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="defaultValue" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the default value of {@code type} as defined by JLS --- {@code 0} for numbers, {@code
 false} for {@code boolean} and {@code '\0'} for {@code char}. For non-primitive types and
 {@code void}, null is returned.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides default values for all Java types, as defined by the JLS.

 @author Ben Yu]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Defaults -->
  <!-- start interface com.google.common.base.Equivalence -->
  <interface name="Equivalence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="equivalent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="T"/>
      <param name="b" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if the given objects are considered equivalent.

 <p>The <code>equivalent</code> method implements an equivalence relation on non-null object
 references:

 <ul>
 <li>It is <i>reflexive</i>: for any non-null reference value {@code x}, {@code x.equals(x)}
     should return {@code true}.
 <li>It is <i>symmetric</i>: for any non-null reference values {@code x} and {@code y}, {@code
     x.equals(y)} should return {@code true} if and only if {@code y.equals(x)} returns {@code
     true}.
 <li>It is <i>transitive</i>: for any non-null reference values {@code x}, {@code y}, and {@code
     z}, if {@code x.equals(y)} returns {@code true} and {@code y.equals(z)} returns {@code
     true}, then {@code x.equals(z)} should return {@code true}.
 <li>It is <i>consistent</i>: for any non-null reference values {@code x} and {@code y},
     multiple invocations of {@code x.equals(y)} consistently return {@code true} or
     consistently return {@code false}, provided no information used in {@code equals}
     comparisons on the objects is modified.
 <li>For any non-null reference value {@code x}, {@code x.equals(null)} should return {@code
     false}.
 </ul>]]>
      </doc>
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns a hash code for {@code object}. This function <b>must</b> return the same value for
 any two instances which are {@link #equivalent}, and should as often as possible return a
 distinct value for instances which are not equivalent.

 @see Object#hashCode the same contractual obligations apply here
 @throws NullPointerException if t is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A strategy for determining whether two instances are considered equivalent. Examples of
 equivalences are the {@link Equivalences#identity() identity equivalence} and {@link
 Equivalences#equals equals equivalence}.

 @author Bob Lee
 @since 4]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Equivalence -->
  <!-- start class com.google.common.base.Equivalences -->
  <class name="Equivalences" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="equals" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence that delegates to {@link Object#equals} and {@link Object#hashCode}.
 Does not support null values.]]>
      </doc>
    </method>
    <method name="nullAwareEquals" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence that delegates to {@link Object#equals} and {@link Object#hashCode}.
 {@link Equivalence#equivalent} returns {@code true} if both values are null, or if neither
 value is null and {@link Object#equals} returns {@code true}. {@link Equivalence#hash} throws a
 {@link NullPointerException} if passed a null value.]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence that uses {@code ==} to compare values and {@link
 System#identityHashCode(Object)} to compute the hash code.  {@link Equivalence#equivalent}
 returns {@code true} if both values are null, or if neither value is null and {@code ==}
 returns {@code true}. {@link Equivalence#hash} throws a {@link NullPointerException} if passed
 a null value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static factory methods for creating {@code Equivalence} instances.

 <p>All methods returns serializable instances.

 @author Bob Lee
 @since 4]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Equivalences -->
  <!-- start class com.google.common.base.FinalizablePhantomReference -->
  <class name="FinalizablePhantomReference" extends="java.lang.ref.PhantomReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizablePhantomReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable phantom reference.

 @param referent to phantom reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Phantom reference with a {@code finalizeReferent()} method which a background thread invokes
 after the garbage collector reclaims the referent. This is a simpler alternative to using a
 {@link ReferenceQueue}.

 <p>Unlike a normal phantom reference, this reference will be cleared automatically.

 @author Bob Lee
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizablePhantomReference -->
  <!-- start interface com.google.common.base.FinalizableReference -->
  <interface name="FinalizableReference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="finalizeReferent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoked on a background thread after the referent has been garbage collected unless security
 restrictions prevented starting a background thread, in which case this method is invoked when
 new references are created.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implemented by references that have code to run after garbage collection of their referents.

 @see FinalizableReferenceQueue
 @author Bob Lee
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.FinalizableReference -->
  <!-- start class com.google.common.base.FinalizableReferenceQueue -->
  <class name="FinalizableReferenceQueue" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FinalizableReferenceQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new queue.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A reference queue with an associated background thread that dequeues references and invokes
 {@link FinalizableReference#finalizeReferent()} on them.

 <p>Keep a strong reference to this object until all of the associated referents have been
 finalized. If this object is garbage collected earlier, the backing thread will not invoke {@code
 finalizeReferent()} on the remaining references.

 @author Bob Lee
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableReferenceQueue -->
  <!-- start class com.google.common.base.FinalizableSoftReference -->
  <class name="FinalizableSoftReference" extends="java.lang.ref.SoftReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizableSoftReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable soft reference.

 @param referent to softly reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Soft reference with a {@code finalizeReferent()} method which a background thread invokes after
 the garbage collector reclaims the referent. This is a simpler alternative to using a {@link
 ReferenceQueue}.

 @author Bob Lee
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableSoftReference -->
  <!-- start class com.google.common.base.FinalizableWeakReference -->
  <class name="FinalizableWeakReference" extends="java.lang.ref.WeakReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizableWeakReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable weak reference.

 @param referent to weakly reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Weak reference with a {@code finalizeReferent()} method which a background thread invokes after
 the garbage collector reclaims the referent. This is a simpler alternative to using a {@link
 ReferenceQueue}.

 @author Bob Lee
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableWeakReference -->
  <!-- start interface com.google.common.base.Function -->
  <interface name="Function"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="F"/>
      <doc>
      <![CDATA[Applies the function to an object of type {@code F}, resulting in an object of type {@code T}.
 Note that types {@code F} and {@code T} may or may not be the same.

 @param from the source object
 @return the resulting object]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Indicates whether some other object is equal to this {@code Function}. This method can return
 {@code true} <i>only</i> if the specified object is also a {@code Function} and, for every
 input object {@code o}, it returns exactly the same value. Thus, {@code
 function1.equals(function2)} implies that either {@code function1.apply(o)} and {@code
 function2.apply(o)} are both null, or {@code function1.apply(o).equals(function2.apply(o))}.

 <p>Note that it is always safe <i>not</i> to override {@link Object#equals}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A transformation from one object to another. For example, a string-to-integer function would
 implement {@code Function<String, Integer>} to convert integer values in text form into {@code
 Integer} form.

 <p>Implementations which may cause side effects upon evaluation are strongly encouraged to state
 this fact clearly in their API documentation.

 @param <F> the type of the function input
 @param <T> the type of the function output
 @author Kevin Bourrillion
 @author Scott Bonneau
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Function -->
  <!-- start class com.google.common.base.Functions -->
  <class name="Functions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toStringFunction" return="com.google.common.base.Function&lt;java.lang.Object, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a function that calls {@code toString()} on its argument. The function does not accept
 nulls; it will throw a {@link NullPointerException} when applied to {@code null}.]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Function&lt;E, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the identity function.]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.base.Function&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a function which performs a map lookup. The returned function throws an {@link
 IllegalArgumentException} if given a key that does not exist in the map.]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.base.Function&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <param name="defaultValue" type="V"/>
      <doc>
      <![CDATA[Returns a function which performs a map lookup with a default value. The function created by
 this method returns {@code defaultValue} for all inputs that do not belong to the map's key
 set.

 @param map source map that determines the function behavior
 @param defaultValue the value to return for inputs that aren't map keys
 @return function that returns {@code map.get(a)} when {@code a} is a key, or {@code
         defaultValue} otherwise]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.base.Function&lt;A, C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="g" type="com.google.common.base.Function&lt;B, C&gt;"/>
      <param name="f" type="com.google.common.base.Function&lt;A, ? extends B&gt;"/>
      <doc>
      <![CDATA[Returns the composition of two functions. For {@code f: A->B} and {@code g: B->C}, composition
 is defined as the function h such that {@code h(a) == g(f(a))} for each {@code a}.

 @param g the second function to apply
 @param f the first function to apply
 @return the composition of {@code f} and {@code g}
 @see <a href="//en.wikipedia.org/wiki/Function_composition">function composition</a>]]>
      </doc>
    </method>
    <method name="forPredicate" return="com.google.common.base.Function&lt;T, java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a function that returns the same boolean output as the given predicate for all inputs.]]>
      </doc>
    </method>
    <method name="constant" return="com.google.common.base.Function&lt;java.lang.Object, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="E"/>
      <doc>
      <![CDATA[Creates a function that returns {@code value} for any input.

 @param value the constant value for the function to return
 @return a function that always returns {@code value}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Useful functions.

 <p>All methods returns serializable functions as long as they're given serializable parameters.

 @author Mike Bostock
 @author Vlad Patryshev
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Functions -->
  <!-- start class com.google.common.base.Joiner -->
  <class name="Joiner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="on" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a joiner which automatically places {@code separator} between consecutive elements.]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a joiner which automatically places {@code separator} between consecutive elements.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends to {@code appendable} the string representation of each of the remaining arguments.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Appends to {@code builder} the string representation of each of the remaining arguments.
 Identical to {@link #appendTo(Appendable, Object, Object, Object...)}, except that it does not
 throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each argument, using the previously
 configured separator between each.]]>
      </doc>
    </method>
    <method name="useForNull" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullText" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a joiner with the same behavior as this one, except automatically substituting {@code
 nullText} for any provided null elements.]]>
      </doc>
    </method>
    <method name="skipNulls" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a joiner with the same behavior as this joiner, except automatically skipping over any
 provided null elements.]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Joiner.MapJoiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValueSeparator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as
 this {@code Joiner} otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object which joins pieces of text (specified as an array, {@link Iterable}, varargs or even a
 {@link Map}) with a separator. It either appends the results to an {@link Appendable} or returns
 them as a {@link String}. Example: <pre>   {@code

   Joiner joiner = Joiner.on("; ").skipNulls();
    . . .
   return joiner.join("Harry", null, "Ron", "Hermione");}</pre>

 This returns the string {@code "Harry; Ron; Hermione"}. Note that all input elements are
 converted to strings using {@link Object#toString()} before being appended.

 <p>If neither {@link #skipNulls()} nor {@link #useForNull(String)} is specified, the joining
 methods will throw {@link NullPointerException} if any given element is null.

 <p><b>Warning: joiner instances are always immutable</b>; a configuration method such as {@code
 useForNull} has no effect on the instance it is invoked on! You must store and use the new joiner
 instance returned by the method. This makes joiners thread-safe, and safe to store as {@code
 static final} constants. <pre>   {@code

   // Bad! Do not do this!
   Joiner joiner = Joiner.on(',');
   joiner.skipNulls(); // does nothing!
   return joiner.join("wrong", null, "wrong");}</pre>

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Joiner -->
  <!-- start class com.google.common.base.Joiner.MapJoiner -->
  <class name="Joiner.MapJoiner" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each entry of {@code map}, using the previously
 configured separator and key-value separator, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each entry of {@code map}, using the previously
 configured separator and key-value separator, to {@code builder}. Identical to {@link
 #appendTo(Appendable, Map)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each entry of {@code map}, using the
 previously configured separator and key-value separator.]]>
      </doc>
    </method>
    <method name="useForNull" return="com.google.common.base.Joiner.MapJoiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullText" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a map joiner with the same behavior as this one, except automatically substituting
 {@code nullText} for any provided null keys or values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that joins map entries in the same manner as {@code Joiner} joins iterables and
 arrays. Like {@code Joiner}, it is thread-safe and immutable.]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Joiner.MapJoiner -->
  <!-- start class com.google.common.base.Objects -->
  <class name="Objects" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
      <param name="b" type="java.lang.Object"/>
      <doc>
      <![CDATA[Determines whether two possibly-null objects are equal. Returns:

 <ul>
 <li>{@code true} if {@code a} and {@code b} are both null.
 <li>{@code true} if {@code a} and {@code b} are both non-null and they are
     equal according to {@link Object#equals(Object)}.
 <li>{@code false} in all other situations.
 </ul>

 <p>This assumes that any non-null objects passed to this function conform
 to the {@code equals()} contract.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Generates a hash code for multiple values. The hash code is generated by
 calling {@link Arrays#hashCode(Object[])}.

 <p>This is useful for implementing {@link Object#hashCode()}. For example,
 in an object that has three properties, {@code x}, {@code y}, and
 {@code z}, one could write:
 <pre>
 public int hashCode() {
   return Objects.hashCode(getX(), getY(), getZ());
 }</pre>

 <b>Warning</b>: When a single object is supplied, the returned hash code
 does not equal the hash code of that object.]]>
      </doc>
    </method>
    <method name="toStringHelper" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="self" type="java.lang.Object"/>
      <doc>
      <![CDATA[Creates an instance of {@link ToStringHelper}.

 <p>This is helpful for implementing {@link Object#toString()}. For
 example, in an object that contains two member variables, {@code x},
 and {@code y}, one could write:<pre>   <tt>
   public class ClassName {
     public String toString() {
       return Objects.toStringHelper(this)
           .add("x", x)
           .add("y", y)
           .toString();
     }
   }</tt>
 </pre>

 Assuming the values of {@code x} and {@code y} are 1 and 2,
 this code snippet returns the string <tt>"ClassName{x=1, y=2}"</tt>.

 @param self the object to generate the string for (typically {@code this}),
        used only for its class name
 @since 2]]>
      </doc>
    </method>
    <method name="firstNonNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="T"/>
      <param name="second" type="T"/>
      <doc>
      <![CDATA[Returns the first of two given parameters that is not {@code null}, if
 either is, or otherwise throws a {@link NullPointerException}.

 @return {@code first} if {@code first} is not {@code null}, or
     {@code second} if {@code first} is {@code null} and {@code second} is
     not {@code null}
 @throws NullPointerException if both {@code first} and {@code second} were
     {@code null}
 @since 3]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper functions that can operate on any {@code Object}.

 @author Laurence Gonsalves
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Objects -->
  <!-- start class com.google.common.base.Objects.ToStringHelper -->
  <class name="Objects.ToStringHelper" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format. If {@code value} is {@code null}, the string {@code "null"}
 is used.]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds a value to the formatted output in {@code value} format.<p/>

 It is strongly encouraged to use {@link #add(String, Object)} instead and
 give value a readable name.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the formatted string.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Support class for {@link Objects#toStringHelper}.

 @author Jason Lee
 @since 2]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Objects.ToStringHelper -->
  <!-- start class com.google.common.base.Preconditions -->
  <class name="Preconditions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @throws IllegalArgumentException if {@code expression} is false
 @throws NullPointerException if the check fails and either {@code
     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
     this happen)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @throws IllegalStateException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @throws IllegalStateException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @throws IllegalStateException if {@code expression} is false
 @throws NullPointerException if the check fails and either {@code
     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
     this happen)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array,
 list or string of size {@code size}. An element index may range from zero,
 inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list
     or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not
     less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array,
 list or string of size {@code size}. An element index may range from zero,
 inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list
     or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not
     less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array,
 list or string of size {@code size}. A position index may range from zero
 to {@code size}, inclusive.

 @param index a user-supplied index identifying a position in an array, list
     or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is
     greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array,
 list or string of size {@code size}. A position index may range from zero
 to {@code size}, inclusive.

 @param index a user-supplied index identifying a position in an array, list
     or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is
     greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndexes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code start} and {@code end} specify a valid <i>positions</i>
 in an array, list or string of size {@code size}, and are in order. A
 position index may range from zero to {@code size}, inclusive.

 @param start a user-supplied index identifying a starting position in an
     array, list or string
 @param end a user-supplied index identifying a ending position in an array,
     list or string
 @param size the size of that array, list or string
 @throws IndexOutOfBoundsException if either index is negative or is
     greater than {@code size}, or if {@code end} is less than {@code start}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple static methods to be called at the start of your own methods to verify
 correct arguments and state. This allows constructs such as
 <pre>
     if (count <= 0) {
       throw new IllegalArgumentException("must be positive: " + count);
     }</pre>

 to be replaced with the more compact
 <pre>
     checkArgument(count > 0, "must be positive: %s", count);</pre>

 Note that the sense of the expression is inverted; with {@code Preconditions}
 you declare what you expect to be <i>true</i>, just as you do with an
 <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/assert.html">
 {@code assert}</a> or a JUnit {@code assertTrue} call.

 <p><b>Warning:</b> only the {@code "%s"} specifier is recognized as a
 placeholder in these messages, not the full range of {@link
 String#format(String, Object[])} specifiers.

 <p>Take care not to confuse precondition checking with other similar types
 of checks! Precondition exceptions -- including those provided here, but also
 {@link IndexOutOfBoundsException}, {@link NoSuchElementException}, {@link
 UnsupportedOperationException} and others -- are used to signal that the
 <i>calling method</i> has made an error. This tells the caller that it should
 not have invoked the method when it did, with the arguments it did, or
 perhaps ever. Postcondition or other invariant failures should not throw
 these types of exceptions.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Preconditions -->
  <!-- start interface com.google.common.base.Predicate -->
  <interface name="Predicate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="T"/>
      <doc>
      <![CDATA[Applies this predicate to the given object.

 @param input the input that the predicate should act on
 @return the value of this predicate when applied to the input {@code t}]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Indicates whether some other object is equal to this {@code Predicate}.
 This method can return {@code true} <i>only</i> if the specified object is
 also a {@code Predicate} and, for every input object {@code input}, it
 returns exactly the same value. Thus, {@code predicate1.equals(predicate2)}
 implies that either {@code predicate1.apply(input)} and
 {@code predicate2.apply(input)} are both {@code true} or both
 {@code false}.

 <p>Note that it is always safe <i>not</i> to override
 {@link Object#equals}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Determines a true or false value for a given input. For example, a
 {@code RegexPredicate} might implement {@code Predicate<String>}, and return
 {@code true} for any string that matches its given regular expression.

 <p>Implementations which may cause side effects upon evaluation are strongly
 encouraged to state this fact clearly in their API documentation.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Predicate -->
  <!-- start class com.google.common.base.Predicates -->
  <class name="Predicates" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="alwaysTrue" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that always evaluates to {@code true}.]]>
      </doc>
    </method>
    <method name="alwaysFalse" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that always evaluates to {@code false}.]]>
      </doc>
    </method>
    <method name="isNull" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference
 being tested is null.]]>
      </doc>
    </method>
    <method name="notNull" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference
 being tested is not null.]]>
      </doc>
    </method>
    <method name="not" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the given predicate
 evaluates to {@code false}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="java.lang.Iterable&lt;? extends com.google.common.base.Predicate&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if each of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a false
 predicate is found. It defensively copies the iterable passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 true}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="com.google.common.base.Predicate[]"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if each of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a false
 predicate is found. It defensively copies the array passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 true}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="second" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if both of its
 components evaluate to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a false
 predicate is found.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="java.lang.Iterable&lt;? extends com.google.common.base.Predicate&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if any one of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a
 true predicate is found. It defensively copies the iterable passed in, so
 future changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 false}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="com.google.common.base.Predicate[]"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if any one of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a
 true predicate is found. It defensively copies the array passed in, so
 future changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 false}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="second" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if either of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a
 true predicate is found.]]>
      </doc>
    </method>
    <method name="equalTo" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object being
 tested {@code equals()} the given target or both are null.]]>
      </doc>
    </method>
    <method name="instanceOf" return="com.google.common.base.Predicate&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object being
 tested is an instance of the given class. If the object being tested
 is {@code null} this predicate evaluates to {@code false}.

 <p>If you want to filter an {@code Iterable} to narrow its type, consider
 using {@link com.google.common.collect.Iterables#filter(Iterable, Class)}
 in preference.]]>
      </doc>
    </method>
    <method name="in" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.util.Collection&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference
 being tested is a member of the given collection. It does not defensively
 copy the collection passed in, so future changes to it will alter the
 behavior of the predicate.

 This method can technically accept any Collection<?>, but using a typed
 collection helps prevent bugs. This approach doesn't block any potential
 users since it is always possible to use {@code Predicates.<Object>in()}.

 @param target the collection that may contain the function input]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.base.Predicate&lt;A&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;B&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;A, ? extends B&gt;"/>
      <doc>
      <![CDATA[Returns the composition of a function and a predicate. For every {@code x},
 the generated predicate returns {@code predicate(function(x))}.

 @return the composition of the provided function and predicate]]>
      </doc>
    </method>
    <method name="containsPattern" return="com.google.common.base.Predicate&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the
 {@code CharSequence} being tested contains any match for the given
 regular expression pattern. The test used is equivalent to
 {@code Pattern.compile(pattern).matcher(arg).find()}

 @throws java.util.regex.PatternSyntaxException if the pattern is invalid
 @since 3]]>
      </doc>
    </method>
    <method name="contains" return="com.google.common.base.Predicate&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the
 {@code CharSequence} being tested contains any match for the given
 regular expression pattern. The test used is equivalent to
 {@code regex.matcher(arg).find()}

 @since 3]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static factory methods for creating {@code Predicate} instances.

 <p>All methods returns serializable predicates as long as they're given
 serializable parameters.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Predicates -->
  <!-- start interface com.google.common.base.Service -->
  <interface name="Service"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service state is {@link State#NEW}, this initiates service startup
 and returns immediately. If the service has already been started, this
 method returns immediately without taking action. A stopped service may not
 be restarted.

 @return a future for the startup result, regardless of whether this call
     initiated startup. Calling {@link Future#get} will block until the
     service has finished starting, and returns one of {@link
     State#RUNNING}, {@link State#STOPPING} or {@link State#TERMINATED}. If
     the service fails to start, {@link Future#get} will throw an {@link
     ExecutionException}, and the service's state will be {@link
     State#FAILED}. If it has already finished starting, {@link Future#get}
     returns immediately. Cancelling the returned future is unsupported and
     always returns {@code false}.]]>
      </doc>
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service startup (if necessary), returning once the service has
 finished starting. Unlike calling {@code start().get()}, this method throws
 no checked exceptions.

 @throws InterruptedRuntimeException if the thread was interrupted while
      waiting for the service to finish starting up.
 @throws RuntimeException if startup failed
 @return the state of the service when startup finished.]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this service is {@link State#RUNNING running}.]]>
      </doc>
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lifecycle state of the service.]]>
      </doc>
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service is {@link State#STARTING} or {@link State#RUNNING}, this
 initiates service shutdown and returns immediately. If this is {@link
 State#NEW}, it is {@link State#TERMINATED terminated} without having been
 started nor stopped.  If the service has already been stopped, this
 method returns immediately without taking action.

 @return a future for the shutdown result, regardless of whether this call
     initiated shutdown. Calling {@link Future#get} will block until the
     service has finished shutting down, and either returns {@link
     State#TERMINATED} or throws an {@link ExecutionException}. If it has
     already finished stopping, {@link Future#get} returns immediately.
     Cancelling this future is unsupported and always returns {@code
     false}.]]>
      </doc>
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service shutdown (if necessary), returning once the service has
 finished stopping. If this is {@link State#STARTING}, startup will be
 cancelled. If this is {@link State#NEW}, it is {@link State#TERMINATED
 terminated} without having been started nor stopped. Unlike calling {@code
 stop().get()}, this method throws no checked exceptions.

 @throws InterruptedRuntimeException if the thread was interrupted while
      waiting for the service to finish shutting down.
 @throws RuntimeException if shutdown failed
 @return the state of the service when shutdown finished.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object with an operational state, plus asynchronous {@link #start()} and
 {@link #stop()} lifecycle methods to transfer into and out of this state.
 Example services include webservers, RPC servers and timers. The normal
 lifecycle of a service is:
 <ul>
   <li>{@link State#NEW} -&gt;</li>
   <li>{@link State#STARTING} -&gt;</li>
   <li>{@link State#RUNNING} -&gt;</li>
   <li>{@link State#STOPPING} -&gt;</li>
   <li>{@link State#TERMINATED}</li>
 </ul>

 If the service fails while starting, running or stopping, its state will be
 {@link State#FAILED}, and its behavior is undefined. Such a service cannot be
 started nor stopped.

 <p>Implementors of this interface are strongly encouraged to extend {@link
 com.google.common.util.concurrent.AbstractService} or {@link
 com.google.common.util.concurrent.AbstractExecutionThreadService}, which make
 the threading and state management easier.

 @author Jesse Wilson
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Service -->
  <!-- start class com.google.common.base.Service.State -->
  <class name="Service.State" extends="java.lang.Enum&lt;com.google.common.base.Service.State&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.base.Service.State[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The lifecycle states of a service.]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Service.State -->
  <!-- start class com.google.common.base.Splitter -->
  <class name="Splitter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given single-character separator. For
 example, {@code Splitter.on(',').split("foo,,bar")} returns an iterable
 containing {@code ["foo", "", "bar"]}.

 @param separator the character to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorMatcher" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that considers any single character matched by the
 given {@code CharMatcher} to be a separator. For example, {@code
 Splitter.on(CharMatcher.anyOf(";,")).split("foo,;bar,quux")} returns an
 iterable containing {@code ["foo", "", "bar", "quux"]}.

 @param separatorMatcher a {@link CharMatcher} that determines whether a
     character is a separator
 @return a splitter, with default settings, that uses this matcher]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given fixed string as a separator. For
 example, {@code Splitter.on(", ").split("foo, bar, baz,qux")} returns an
 iterable containing {@code ["foo", "bar", "baz,qux"]}.

 @param separator the literal, nonempty string to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching {@code
 pattern} to be a separator. For example, {@code
 Splitter.on(Pattern.compile("\r?\n")).split(entireFile)} splits a string
 into lines whether it uses DOS-style or UNIX-style line terminators.

 @param separatorPattern the pattern that determines whether a subsequence
     is a separator. This pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws IllegalArgumentException if {@code separatorPattern} matches the
     empty string]]>
      </doc>
    </method>
    <method name="onPattern" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching a given
 pattern (regular expression) to be a separator. For example, {@code
 Splitter.onPattern("\r?\n").split(entireFile)} splits a string into lines
 whether it uses DOS-style or UNIX-style line terminators. This is
 equivalent to {@code Splitter.on(Pattern.compile(pattern))}.

 @param separatorPattern the pattern that determines whether a subsequence
     is a separator. This pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws java.util.regex.PatternSyntaxException if {@code separatorPattern}
     is a malformed expression
 @throws IllegalArgumentException if {@code separatorPattern} matches the
     empty string]]>
      </doc>
    </method>
    <method name="fixedLength" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a splitter that divides strings into pieces of the given length.
 For example, {@code Splitter.fixedLength(2).split("abcde")} returns an
 iterable containing {@code ["ab", "cd", "e"]}. The last piece can be
 smaller than {@code length} but will never be empty.

 @param length the desired length of pieces after splitting
 @return a splitter, with default settings, that can split into fixed sized
     pieces]]>
      </doc>
    </method>
    <method name="omitEmptyStrings" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 automatically omits empty strings from the results. For example, {@code
 Splitter.on(',').omitEmptyStrings().split(",a,,,b,c,,")} returns an
 iterable containing only {@code ["a", "b", "c"]}.

 <p>If either {@code trimResults} option is also specified when creating a
 splitter, that splitter always trims results first before checking for
 emptiness. So, for example, {@code
 Splitter.on(':').omitEmptyStrings().trimResults().split(": : : ")} returns
 an empty iterable.

 <p>Note that it is ordinarily not possible for {@link #split(CharSequence)}
 to return an empty iterable, but when using this option, it can (if the
 input sequence consists of nothing but separators).

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 automatically removes leading and trailing {@linkplain
 CharMatcher#WHITESPACE whitespace} from each returned substring; equivalent
 to {@code trimResults(CharMatcher.WHITESPACE)}. For example, {@code
 Splitter.on(',').trimResults().split(" a, b  ,c  ")} returns an iterable
 containing {@code ["a", "b", "c"]}.

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trimmer" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 removes all leading or trailing characters matching the given {@code
 CharMatcher} from each returned substring. For example, {@code
 Splitter.on(',').trimResults(CharMatcher.is('_')).split("_a ,_b_ ,c__")}
 returns an iterable containing {@code ["a ", "b_ ", "c"]}.

 @param trimmer a {@link CharMatcher} that determines whether a character
     should be removed from the beginning/end of a subsequence
 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="split" return="java.lang.Iterable&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits the {@link CharSequence} passed in parameter.

 @param sequence the sequence of characters to split
 @return an iteration over the segments split from the parameter.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that divides strings (or other instances of {@code CharSequence})
 into substrings, by recognizing a <i>separator</i> (a.k.a. "delimiter")
 which can be expressed as a single character, literal string, regular
 expression, {@code CharMatcher}, or by using a fixed substring length. This
 class provides the complementary functionality to {@link Joiner}.

 <p>Here is the most basic example of {@code Splitter} usage: <pre>   {@code

   Splitter.on(',').split("foo,bar")}</pre>

 This invocation returns an {@code Iterable<String>} containing {@code "foo"}
 and {@code "bar"}, in that order.

 <p>By default {@code Splitter}'s behavior is very simplistic: <pre>   {@code

   Splitter.on(',').split("foo,,bar,  quux")}</pre>

 This returns an iterable containing {@code ["foo", "", "bar", "  quux"]}.
 Notice that the splitter does not assume that you want empty strings removed,
 or that you wish to trim whitespace. If you want features like these, simply
 ask for them: <pre> {@code

   private static final Splitter MY_SPLITTER = Splitter.on(',')
       .trimResults()
       .omitEmptyStrings();}</pre>

 Now {@code MY_SPLITTER.split("foo, ,bar,  quux,")} returns an iterable
 containing just {@code ["foo", "bar", "quux"]}. Note that the order in which
 the configuration methods are called is never significant; for instance,
 trimming is always applied first before checking for an empty result,
 regardless of the order in which the {@link #trimResults()} and
 {@link #omitEmptyStrings()} methods were invoked.

 <p><b>Warning: splitter instances are always immutable</b>; a configuration
 method such as {@code omitEmptyStrings} has no effect on the instance it
 is invoked on! You must store and use the new splitter instance returned by
 the method. This makes splitters thread-safe, and safe to store as {@code
 static final} constants (as illustrated above). <pre>   {@code

   // Bad! Do not do this!
   Splitter splitter = Splitter.on('/');
   splitter.trimResults(); // does nothing!
   return splitter.split("wrong / wrong / wrong");}</pre>

 The separator recognized by the splitter does not have to be a single
 literal character as in the examples above. See the methods {@link
 #on(String)}, {@link #on(Pattern)} and {@link #on(CharMatcher)} for examples
 of other ways to specify separators.

 <p><b>Note:</b> this class does not mimic any of the quirky behaviors of
 similar JDK methods; for instance, it does not silently discard trailing
 separators, as does {@link String#split(String)}, nor does it have a default
 behavior of using five particular whitespace characters as separators, like
 {@link java.util.StringTokenizer}.

 @author Julien Silland
 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Splitter -->
  <!-- start class com.google.common.base.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nullToEmpty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the given string if it is non-null; the empty string otherwise.

 @param string the string to test and possibly return
 @return {@code string} itself if it is non-null; {@code ""} if it is null]]>
      </doc>
    </method>
    <method name="emptyToNull" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the given string if it is nonempty; {@code null} otherwise.

 @param string the string to test and possibly return
 @return {@code string} itself if it is nonempty; {@code null} if it is
     empty or null]]>
      </doc>
    </method>
    <method name="isNullOrEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the given string is null or is the empty string.

 <p>Consider normalizing your string references with {@link #nullToEmpty}.
 If you do, you can use {@link String#isEmpty()} instead of this
 method, and you won't need special null-safe forms of methods like {@link
 String#toUpperCase} either. Or, if you'd like to normalize "in the other
 direction," converting empty strings to {@code null}, you can use {@link
 #emptyToNull}.

 @param string a string reference to check
 @return {@code true} if the string is null or is the empty string]]>
      </doc>
    </method>
    <method name="padStart" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="minLength" type="int"/>
      <param name="padChar" type="char"/>
      <doc>
      <![CDATA[Returns a string, of length at least {@code minLength}, consisting of
 {@code string} prepended with as many copies of {@code padChar} as are
 necessary to reach that length. For example,

 <ul>
 <li>{@code padStart("7", 3, '0')} returns {@code "007"}
 <li>{@code padStart("2010", 3, '0')} returns {@code "2010"}
 </ul>

 <p>See {@link Formatter} for a richer set of formatting capabilities.

 @param string the string which should appear at the end of the result
 @param minLength the minimum length the resulting string must have. Can be
     zero or negative, in which case the input string is always returned.
 @param padChar the character to insert at the beginning of the result until
     the minimum length is reached
 @return the padded string]]>
      </doc>
    </method>
    <method name="padEnd" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="minLength" type="int"/>
      <param name="padChar" type="char"/>
      <doc>
      <![CDATA[Returns a string, of length at least {@code minLength}, consisting of
 {@code string} appended with as many copies of {@code padChar} as are
 necessary to reach that length. For example,

 <ul>
 <li>{@code padEnd("4.", 5, '0')} returns {@code "4.000"}
 <li>{@code padEnd("2010", 3, '!')} returns {@code "2010"}
 </ul>

 <p>See {@link Formatter} for a richer set of formatting capabilities.

 @param string the string which should appear at the beginning of the result
 @param minLength the minimum length the resulting string must have. Can be
     zero or negative, in which case the input string is always returned.
 @param padChar the character to append to the end of the result until the
     minimum length is reached
 @return the padded string]]>
      </doc>
    </method>
    <method name="repeat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Returns a string consisting of a specific number of concatenated copies of
 an input string. For example, {@code repeat("hey", 3)} returns the string
 {@code "heyheyhey"}.

 @param string any non-null string
 @param count the number of times to repeat it; a nonnegative integer
 @return a string containing {@code string} repeated {@code count} times
     (the empty string if {@code count} is zero)
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code String} or {@code CharSequence}
 instances.

 @author Kevin Bourrillion
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Strings -->
  <!-- start interface com.google.common.base.Supplier -->
  <interface name="Supplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves an instance of the appropriate type. The returned object may or
 may not be a new instance, depending on the implementation.

 @return an instance of the appropriate type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that can supply objects of a single type.  Semantically, this could
 be a factory, generator, builder, closure, or something else entirely. No
 guarantees are implied by this interface.

 @author Harry Heymann
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Supplier -->
  <!-- start class com.google.common.base.Suppliers -->
  <class name="Suppliers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compose" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super F, T&gt;"/>
      <param name="supplier" type="com.google.common.base.Supplier&lt;F&gt;"/>
      <doc>
      <![CDATA[Returns a new supplier which is the composition of the provided function
 and supplier. In other words, the new supplier's value will be computed by
 retrieving the value from {@code supplier}, and then applying
 {@code function} to that value. Note that the resulting supplier will not
 call {@code supplier} or invoke {@code function} until it is called.]]>
      </doc>
    </method>
    <method name="memoize" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a supplier which caches the instance retrieved during the first
 call to {@code get()} and returns that value on subsequent calls to
 {@code get()}. See:
 <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>

 <p>The returned supplier is thread-safe. The supplier's serialized form
 does not contain the cached value, which will be recalculated when {@code
 get()} is called on the reserialized instance.]]>
      </doc>
    </method>
    <method name="memoizeWithExpiration" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns a supplier that caches the instance supplied by the delegate and
 removes the cached value after the specified time has passed. Subsequent
 calls to {@code get()} return the cached value if the expiration time has
 not passed. After the expiration time, a new value is retrieved, cached,
 and returned. See:
 <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>

 <p>The returned supplier is thread-safe. The supplier's serialized form
 does not contain the cached value, which will be recalculated when {@code
 get()} is called on the reserialized instance.

 @param duration the length of time after a value is created that it
     should stop being returned by subsequent {@code get()} calls
 @param unit the unit that {@code duration} is expressed in
 @throws IllegalArgumentException if {@code duration} is not positive
 @since 2]]>
      </doc>
    </method>
    <method name="ofInstance" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Returns a supplier that always supplies {@code instance}.]]>
      </doc>
    </method>
    <method name="synchronizedSupplier" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a supplier whose {@code get()} method synchronizes on
 {@code delegate} before calling it, making it thread-safe.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Useful suppliers.

 <p>All methods return serializable suppliers as long as they're given
 serializable parameters.

 @author Laurence Gonsalves
 @author Harry Heymann
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Suppliers -->
  <!-- start class com.google.common.base.Throwables -->
  <class name="Throwables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="propagateIfInstanceOf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@code declaredType}.  Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfInstanceOf(t, IOException.class);
     Throwables.propagateIfInstanceOf(t, SQLException.class);
     throw Throwables.propagate(t);
   }
 </pre>]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException} or {@link Error}.  Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfPossible(t);
     throw new RuntimeException("unexpected", t);
   }
 </pre>]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException}, {@link Error}, or
 {@code declaredType}. Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfPossible(t, OtherException.class);
     throw new RuntimeException("unexpected", t);
   }
 </pre>

 @param throwable the Throwable to possibly propagate
 @param declaredType the single checked exception type declared by the
     calling method]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType1" type="java.lang.Class&lt;X1&gt;"/>
      <param name="declaredType2" type="java.lang.Class&lt;X2&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException}, {@link Error}, {@code declaredType1},
 or {@code declaredType2}.  In the unlikely case that you have three or more
 declared checked exception types, you can handle them all by invoking these
 methods repeatedly. See usage example in {@link
 #propagateIfPossible(Throwable, Class)}.

 @param throwable the Throwable to possibly propagate
 @param declaredType1 any checked exception type declared by the calling
     method
 @param declaredType2 any other checked exception type declared by the
     calling method]]>
      </doc>
    </method>
    <method name="propagate" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} as-is if it is an instance of
 {@link RuntimeException} or {@link Error}, or else as a last resort, wraps
 it in a {@code RuntimeException} then propagates.
 <p>
 This method always throws an exception. The {@code RuntimeException} return
 type is only for client code to make Java type system happy in case a
 return value is required by the enclosing method. Example usage:
 <pre>
   T doSomething() {
     try {
       return someMethodThatCouldThrowAnything();
     } catch (IKnowWhatToDoWithThisException e) {
       return handle(e);
     } catch (Throwable t) {
       throw Throwables.propagate(t);
     }
   }
 </pre>

 @param throwable the Throwable to propagate
 @return nothing will ever be returned; this return type is only for your
     convenience, as illustrated in the example above]]>
      </doc>
    </method>
    <method name="getRootCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns the innermost cause of {@code throwable}. The first throwable in a
 chain provides context from when the error or exception was initially
 detected. Example usage:
 <pre>
   assertEquals("Unable to assign a customer id",
       Throwables.getRootCause(e).getMessage());
 </pre>]]>
      </doc>
    </method>
    <method name="getCausalChain" return="java.util.List&lt;java.lang.Throwable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Gets a {@code Throwable} cause chain as a list.  The first entry in the
 list will be {@code throwable} followed by its cause hierarchy.  Note
 that this is a snapshot of the cause chain and will not reflect
 any subsequent changes to the cause chain.

 <p>Here's an example of how it can be used to find specific types
 of exceptions in the cause chain:

 <pre>
 Iterables.filter(Throwables.getCausalChain(e), IOException.class));
 </pre>

 @param throwable the non-null {@code Throwable} to extract causes from
 @return an unmodifiable list containing the cause chain starting with
     {@code throwable}]]>
      </doc>
    </method>
    <method name="getStackTraceAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns a string containing the result of
 {@link Throwable#toString() toString()}, followed by the full, recursive
 stack trace of {@code throwable}. Note that you probably should not be
 parsing the resulting string; if you need programmatic access to the stack
 frames, you can call {@link Throwable#getStackTrace()}.]]>
      </doc>
    </method>
    <method name="throwCause" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Exception"/>
      <param name="combineStackTraces" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Rethrows the cause exception of a given throwable, discarding the original
 throwable. Optionally, the stack frames of the cause and the outer
 exception are combined and the stack trace of the cause is set to this
 combined trace. If there is no cause the original exception is rethrown
 unchanged in all cases.

 @param exception the exception from which to extract the cause
 @param combineStackTraces if true the stack trace of the cause will be
     replaced by the concatenation of the trace from the exception and the
     trace from the cause.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to instances of {@link Throwable}.

 @author Kevin Bourrillion
 @author Ben Yu
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Throwables -->
</package>
<package name="com.google.common.base.internal">
  <!-- start class com.google.common.base.internal.Finalizer -->
  <class name="Finalizer" extends="java.lang.Thread"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="startFinalizer" return="java.lang.ref.ReferenceQueue&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="finalizableReferenceClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="frq" type="java.lang.Object"/>
      <doc>
      <![CDATA[Starts the Finalizer thread. FinalizableReferenceQueue calls this method
 reflectively.

 @param finalizableReferenceClass FinalizableReference.class
 @param frq reference to instance of FinalizableReferenceQueue that started
  this thread
 @return ReferenceQueue which Finalizer will poll]]>
      </doc>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Loops continuously, pulling references off the queue and cleaning them up.]]>
      </doc>
    </method>
    <method name="getInheritableThreadLocalsField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thread that finalizes referents. All references should implement
 {@code com.google.common.base.FinalizableReference}.

 <p>While this class is public, we consider it to be *internal* and not part
 of our published API. It is public so we can access it reflectively across
 class loaders in secure environments.

 <p>This class can't depend on other Google Collections code. If we were
 to load this class in the same class loader as the rest of
 Google Collections, this thread would keep an indirect strong reference
 to the class loader and prevent it from being garbage collected. This
 poses a problem for environments where you want to throw away the class
 loader. For example, dynamically reloading a web application or unloading
 an OSGi bundle.

 <p>{@code com.google.common.base.FinalizableReferenceQueue} loads this class
 in its own class loader. That way, this class doesn't prevent the main
 class loader from getting garbage collected, and this class can detect when
 the main class loader has been garbage collected and stop itself.]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.internal.Finalizer -->
</package>
<package name="com.google.common.collect">
  <!-- start class com.google.common.collect.AbstractIterator -->
  <class name="AbstractIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractIterator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="computeNext" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element. <b>Note:</b> the implementation must call {@link
 #endOfData()} when there are no elements left in the iteration. Failure to
 do so could result in an infinite loop.

 <p>The initial invocation of {@link #hasNext()} or {@link #next()} calls
 this method, as does the first invocation of {@code hasNext} or {@code
 next} following each successful call to {@code next}. Once the
 implementation either invokes {@code endOfData} or throws an exception,
 {@code computeNext} is guaranteed to never be called again.

 <p>If this method throws an exception, it will propagate outward to the
 {@code hasNext} or {@code next} invocation that invoked this method. Any
 further attempts to use the iterator will result in an {@link
 IllegalStateException}.

 <p>The implementation of this method may not invoke the {@code hasNext},
 {@code next}, or {@link #peek()} methods on this instance; if it does, an
 {@code IllegalStateException} will result.

 @return the next element if there was one. If {@code endOfData} was called
     during execution, the return value will be ignored.
 @throws RuntimeException if any unrecoverable error happens. This exception
     will propagate outward to the {@code hasNext()}, {@code next()}, or
     {@code peek()} invocation that invoked this method. Any further
     attempts to use the iterator will result in an
     {@link IllegalStateException}.]]>
      </doc>
    </method>
    <method name="endOfData" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementations of {@code computeNext} <b>must</b> invoke this method when
 there are no elements left in the iteration.

 @return {@code null}; a convenience so your {@link #computeNext}
     implementation can use the simple statement {@code return endOfData();}]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element in the iteration without advancing the iteration,
 according to the contract of {@link PeekingIterator#peek()}.

 <p>Implementations of {@code AbstractIterator} that wish to expose this
 functionality should implement {@code PeekingIterator}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Iterator}
 interface, to make this interface easier to implement for certain types of
 data sources.

 <p>{@code Iterator} requires its implementations to support querying the
 end-of-data status without changing the iterator's state, using the {@link
 #hasNext} method. But many data sources, such as {@link
 java.io.Reader#read()}), do not expose this information; the only way to
 discover whether there is any data left is by trying to retrieve it. These
 types of data sources are ordinarily difficult to write iterators for. But
 using this class, one must implement only the {@link #computeNext} method,
 and invoke the {@link #endOfData} method when appropriate.

 <p>Another example is an iterator that skips over null elements in a backing
 iterator. This could be implemented as: <pre>   {@code

   public static Iterator<String> skipNulls(final Iterator<String> in) {
     return new AbstractIterator<String>() {
       protected String computeNext() {
         while (in.hasNext()) {
           String s = in.next();
           if (s != null) {
             return s;
           }
         }
         return endOfData();
       }
     };
   }}</pre>

 This class supports iterators that include null elements.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AbstractIterator -->
  <!-- start class com.google.common.collect.ArrayListMultimap -->
  <class name="ArrayListMultimap" extends="com.google.common.collect.AbstractListMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code ArrayListMultimap} with the default initial
 capacities.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code ArrayListMultimap} with enough capacity to hold
 the specified numbers of keys and values without resizing.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code
      expectedValuesPerKey} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs an {@code ArrayListMultimap} with the same mappings as the
 specified multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="trimToSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reduces the memory used by this {@code ArrayListMultimap}, if feasible.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} that uses an {@code ArrayList} to store
 the values for a given key. A {@link HashMap} associates each key with an
 {@link ArrayList} of values.

 <p>When iterating through the collections supplied by this class, the
 ordering of values for a given key agrees with the order in which the values
 were added.

 <p>This multimap allows duplicate key-value pairs. After adding a new
 key-value pair equal to an existing key-value pair, the {@code
 ArrayListMultimap} will contain entries for both the new value and the old
 value.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>The lists returned by {@link #get}, {@link #removeAll}, and {@link
 #replaceValues} all implement {@link java.util.RandomAccess}.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedListMultimap}.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ArrayListMultimap -->
  <!-- start class com.google.common.collect.AsynchronousComputationException -->
  <class name="AsynchronousComputationException" extends="com.google.common.collect.ComputationException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AsynchronousComputationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Wraps an exception that occured during a computation in a different thread.

 @author Bob Lee]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AsynchronousComputationException -->
  <!-- start interface com.google.common.collect.BiMap -->
  <interface name="BiMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws IllegalArgumentException if the given value is already bound to a
     different key in this bimap. The bimap will remain unmodified in this
     event. To avoid this exception, call {@link #forcePut} instead.]]>
      </doc>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[An alternate form of {@code put} that silently removes any existing entry
 with the value {@code value} before proceeding with the {@link #put}
 operation. If the bimap previously contained the provided key-value
 mapping, this method has no effect.

 <p>Note that a successful call to this method could cause the size of the
 bimap to increase by one, stay the same, or even decrease by one.

 <p><b>Warning</b>: If an existing entry with this value is removed, the key
 for that entry is discarded and not returned.

 @param key the key with which the specified value is to be associated
 @param value the value to be associated with the specified key
 @return the value which was previously associated with the key, which may
     be {@code null}, or {@code null} if there was no previous entry]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Warning:</b> the results of calling this method may vary depending on
 the iteration order of {@code map}.

 @throws IllegalArgumentException if an attempt to {@code put} any
     entry fails. Note that some map entries may have been added to the
     bimap before the exception was thrown.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a bimap has unique values, this method returns a {@link Set},
 instead of the {@link java.util.Collection} specified in the {@link Map}
 interface.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.BiMap&lt;V, K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the inverse view of this bimap, which maps each of this bimap's
 values to its associated key. The two bimaps are backed by the same data;
 any changes to one will appear in the other.

 <p><b>Note:</b>There is no guaranteed correspondence between the iteration
 order of a bimap and that of its inverse.

 @return the inverse view of this bimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A bimap (or "bidirectional map") is a map that preserves the uniqueness of
 its values as well as that of its keys. This constraint enables bimaps to
 support an "inverse view", which is another bimap containing the same entries
 as this bimap but with reversed keys and values.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.BiMap -->
  <!-- start interface com.google.common.collect.ClassToInstanceMap -->
  <interface name="ClassToInstanceMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"/>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value the specified class is mapped to, or {@code null} if no
 entry for this class is present. This will only return a value that was
 bound to this specific class, not a value that may have been bound to a
 subtype.]]>
      </doc>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Maps the specified class to the specified value. Does <i>not</i> associate
 this value with any of the class's supertypes.

 @return the value previously associated with this class (possibly {@code
     null}), or {@code null} if there was no previous entry.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map, each entry of which maps a Java
 <a href="http://tinyurl.com/2cmwkz">raw type</a> to an instance of that type.
 In addition to implementing {@code Map}, the additional type-safe operations
 {@link #putInstance} and {@link #getInstance} are available.

 <p>Like any other {@code Map<Class, Object>}, this map may contain entries
 for primitive types, and a primitive type and its corresponding wrapper type
 may map to different values.

 @param <B> the common supertype that all entries must share; often this is
     simply {@link Object}

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.ClassToInstanceMap -->
  <!-- start class com.google.common.collect.Collections2 -->
  <class name="Collections2" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="filter" return="java.util.Collection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Collection&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The
 returned collection is a live view of {@code unfiltered}; changes to one
 affect the other.

 <p>The resulting collection's iterator does not support {@code remove()},
 but all other collection methods are supported. The collection's
 {@code add()} and {@code addAll()} methods throw an
 {@link IllegalArgumentException} if an element that doesn't satisfy the
 predicate is provided. When methods such as {@code removeAll()} and
 {@code clear()} are called on the filtered collection, only elements that
 satisfy the filter will be removed from the underlying collection.

 <p>The returned collection isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered collection's methods, such as {@code size()},
 iterate across every element in the underlying collection and determine
 which elements satisfy the filter. When a live view is <i>not</i> needed,
 it may be faster to copy {@code Iterables.filter(unfiltered, predicate)}
 and use the copy.]]>
      </doc>
    </method>
    <method name="transform" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromCollection" type="java.util.Collection&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, T&gt;"/>
      <doc>
      <![CDATA[Returns a collection that applies {@code function} to each element of
 {@code fromCollection}. The returned collection is a live view of {@code
 fromCollection}; changes to one affect the other.

 <p>The returned collection's {@code add()} and {@code addAll()} methods
 throw an {@link UnsupportedOperationException}. All other collection
 methods are supported, as long as {@code fromCollection} supports them.

 <p>The returned collection isn't threadsafe or serializable, even if
 {@code fromCollection} is.

 <p>When a live view is <i>not</i> needed, it may be faster to copy the
 transformed collection and use the copy.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods for working with {@code Collection} instances.

 @author Chris Povirk
 @author Mike Bostock
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Collections2 -->
  <!-- start class com.google.common.collect.ComparisonChain -->
  <class name="ComparisonChain" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start" return="com.google.common.collect.ComparisonChain"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Begins a new chained comparison statement. See example in the class
 documentation.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.lang.Comparable&lt;?&gt;"/>
      <param name="right" type="java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Compares two comparable objects as specified by {@link
 Comparable#compareTo}, <i>if</i> the result of this comparison chain
 has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="T"/>
      <param name="right" type="T"/>
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Compares two objects using a comparator, <i>if</i> the result of this
 comparison chain has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="int"/>
      <param name="right" type="int"/>
      <doc>
      <![CDATA[Compares two {@code int} values as specified by {@link Ints#compare},
 <i>if</i> the result of this comparison chain has not already been
 determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="long"/>
      <param name="right" type="long"/>
      <doc>
      <![CDATA[Compares two {@code long} values as specified by {@link Longs#compare},
 <i>if</i> the result of this comparison chain has not already been
 determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="float"/>
      <param name="right" type="float"/>
      <doc>
      <![CDATA[Compares two {@code float} values as specified by {@link
 Float#compare}, <i>if</i> the result of this comparison chain has not
 already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="double"/>
      <param name="right" type="double"/>
      <doc>
      <![CDATA[Compares two {@code double} values as specified by {@link
 Double#compare}, <i>if</i> the result of this comparison chain has not
 already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="boolean"/>
      <param name="right" type="boolean"/>
      <doc>
      <![CDATA[Compares two {@code boolean} values as specified by {@link
 Booleans#compare}, <i>if</i> the result of this comparison chain has not
 already been determined.]]>
      </doc>
    </method>
    <method name="result" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ends this comparison chain and returns its result: a value having the
 same sign as the first nonzero comparison result in the chain, or zero if
 every result was zero.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A utility for performing a "lazy" chained comparison statement, which 
 performs comparisons only until it finds a nonzero result. For example:

 <pre class="code">   {@code

   public int compareTo(Foo that) {
     return ComparisonChain.start()
         .compare(this.aString, that.aString)
         .compare(this.anInt, that.anInt)
         .compare(this.anEnum, that.anEnum, Ordering.natural().nullsLast())
         .result();
   }}</pre>

 The value of this expression will have the same sign as the <i>first
 nonzero</i> comparison result in the chain, or will be zero if every
 comparison result was zero.

 <p>Once any comparison returns a nonzero value, remaining comparisons are
 "short-circuited".

 @author Mark Davis
 @author Kevin Bourrillion
 @since 2]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ComparisonChain -->
  <!-- start class com.google.common.collect.ComputationException -->
  <class name="ComputationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ComputationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Wraps an exception that occured during a computation.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ComputationException -->
  <!-- start class com.google.common.collect.ConcurrentHashMultiset -->
  <class name="ConcurrentHashMultiset" extends="com.google.common.collect.AbstractMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code ConcurrentHashMultiset} using the default
 initial capacity, load factor, and concurrency settings.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ConcurrentHashMultiset} containing the specified
 elements, using the default initial capacity, load factor, and concurrency
 settings.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of occurrences of {@code element} in this multiset.

 @param element the element to look for
 @return the nonnegative number of occurrences of the element]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If the data in the multiset is modified by any other threads during this
 method, it is undefined which (if any) of these modifications will be
 reflected in the result.]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of the specified element to this multiset.

 @param element the element to add
 @param occurrences the number of occurrences to add
 @return the previous count of the element before the operation; possibly
     zero
 @throws IllegalArgumentException if {@code occurrences} is negative, or if
     the resulting amount would exceed {@link Integer#MAX_VALUE}]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes a number of occurrences of the specified element from this
 multiset. If the multiset contains fewer than this number of occurrences to
 begin with, all occurrences will be removed.

 @param element the element whose occurrences should be removed
 @param occurrences the number of occurrences of the element to remove
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative]]>
      </doc>
    </method>
    <method name="removeExactly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes exactly the specified number of occurrences of {@code element}, or
 makes no change if this is not possible.

 <p>This method, in contrast to {@link #remove(Object, int)}, has no effect
 when the element count is smaller than {@code occurrences}.

 @param element the element to remove
 @param occurrences the number of occurrences of {@code element} to remove
 @return {@code true} if the removal was possible (including if {@code
     occurrences} is zero)]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes occurrences of {@code element} such that the {@link #count}
 of the element becomes {@code count}.

 @return the count of {@code element} in the multiset before this call
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Sets the number of occurrences of {@code element} to {@code newCount}, but
 only if the count is currently {@code oldCount}. If {@code element} does
 not appear in the multiset exactly {@code oldCount} times, no changes will
 be made.

 @return {@code true} if the change was successful. This usually indicates
     that the multiset has been modified, but not always: in the case that
     {@code oldCount == newCount}, the method will return {@code true} if
     the condition was met.
 @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is
     negative]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A multiset that supports concurrent modifications and that provides atomic
 versions of most {@code Multiset} operations (exceptions where noted). Null
 elements are not supported.

 @author Cliff L. Biffle
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ConcurrentHashMultiset -->
  <!-- start interface com.google.common.collect.Constraint -->
  <interface name="Constraint"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="checkElement" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Throws a suitable {@code RuntimeException} if the specified element is
 illegal. Typically this is either a {@link NullPointerException}, an
 {@link IllegalArgumentException}, or a {@link ClassCastException}, though
 an application-specific exception class may be used if appropriate.

 @param element the element to check
 @return the provided element]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a brief human readable description of this constraint, such as
 "Not null" or "Positive number".]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constraint that an element must satisfy in order to be added to a
 collection. For example, {@link Constraints#notNull()}, which prevents a
 collection from including any null elements, could be implemented like this:
 <pre>   {@code

   public Object checkElement(Object element) {
     if (element == null) {
       throw new NullPointerException();
     }
     return element;
   }}</pre>

 In order to be effective, constraints should be deterministic; that is,
 they should not depend on state that can change (such as external state,
 random variables, and time) and should only depend on the value of the
 passed-in element. A non-deterministic constraint cannot reliably enforce
 that all the collection's elements meet the constraint, since the constraint
 is only enforced when elements are added.

 @see Constraints
 @see MapConstraint
 @author Mike Bostock
 @since 3]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Constraint -->
  <!-- start class com.google.common.collect.Constraints -->
  <class name="Constraints" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="notNull" return="com.google.common.collect.Constraint&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a constraint that verifies that the element is not null. If the
 element is null, a {@link NullPointerException} is thrown.]]>
      </doc>
    </method>
    <method name="constrainedCollection" return="java.util.Collection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified collection, using the specified
 constraint. Any operations that add new elements to the collection will
 call the provided constraint. However, this method does not verify that
 existing elements satisfy the constraint.

 <p>The returned collection is not serializable.

 @param collection the collection to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the collection]]>
      </doc>
    </method>
    <method name="constrainedSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified set, using the specified
 constraint. Any operations that add new elements to the set will call the
 provided constraint. However, this method does not verify that existing
 elements satisfy the constraint.

 <p>The returned set is not serializable.

 @param set the set to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the set]]>
      </doc>
    </method>
    <method name="constrainedSortedSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedSet" type="java.util.SortedSet&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified sorted set, using the specified
 constraint. Any operations that add new elements to the sorted set will
 call the provided constraint. However, this method does not verify that
 existing elements satisfy the constraint.

 <p>The returned set is not serializable.

 @param sortedSet the sorted set to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the sorted set]]>
      </doc>
    </method>
    <method name="constrainedList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified list, using the specified
 constraint. Any operations that add new elements to the list will call the
 provided constraint. However, this method does not verify that existing
 elements satisfy the constraint.

 <p>If {@code list} implements {@link RandomAccess}, so will the returned
 list. The returned list is not serializable.

 @param list the list to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the list]]>
      </doc>
    </method>
    <method name="constrainedMultiset" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified multiset, using the specified
 constraint. Any operations that add new elements to the multiset will call
 the provided constraint. However, this method does not verify that
 existing elements satisfy the constraint.

 <p>The returned multiset is not serializable.

 @param multiset the multiset to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the multiset]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories and utilities pertaining to the {@link Constraint} interface.

 @see MapConstraints
 @author Mike Bostock
 @author Jared Levy
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Constraints -->
  <!-- start class com.google.common.collect.EnumBiMap -->
  <class name="EnumBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new, empty {@code EnumBiMap} using the specified key and value
 types.

 @param keyType the key type
 @param valueType the value type]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a new bimap with the same mappings as the specified map. If the
 specified map is an {@code EnumBiMap}, the new bimap has the same types as
 the provided map. Otherwise, the specified map must contain at least one
 mapping, in order to determine the key and value types.

 @param map the map whose mappings are to be placed in this map
 @throws IllegalArgumentException if map is not an {@code EnumBiMap}
     instance and contains no mappings]]>
      </doc>
    </method>
    <method name="keyType" return="java.lang.Class&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated key type.]]>
      </doc>
    </method>
    <method name="valueType" return="java.lang.Class&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated value type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code BiMap} backed by two {@code EnumMap} instances. Null keys and values
 are not permitted. An {@code EnumBiMap} and its inverse are both
 serializable.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumBiMap -->
  <!-- start class com.google.common.collect.EnumHashBiMap -->
  <class name="EnumHashBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumHashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a new, empty {@code EnumHashBiMap} using the specified key type.

 @param keyType the key type]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumHashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a new bimap with the same mappings as the specified map. If the
 specified map is an {@code EnumHashBiMap} or an {@link EnumBiMap}, the new
 bimap has the same key type as the input bimap. Otherwise, the specified
 map must contain at least one mapping, in order to determine the key type.

 @param map the map whose mappings are to be placed in this map
 @throws IllegalArgumentException if map is not an {@code EnumBiMap} or an
     {@code EnumHashBiMap} instance and contains no mappings]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Enum&lt;K&gt;"/>
      <param name="value" type="V"/>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Enum&lt;K&gt;"/>
      <param name="value" type="V"/>
    </method>
    <method name="keyType" return="java.lang.Class&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated key type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code BiMap} backed by an {@code EnumMap} instance for keys-to-values, and
 a {@code HashMap} instance for values-to-keys. Null keys are not permitted,
 but null values are. An {@code EnumHashBiMap} and its inverse are both
 serializable.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumHashBiMap -->
  <!-- start class com.google.common.collect.EnumMultiset -->
  <class name="EnumMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code EnumMultiset}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code EnumMultiset} containing the specified elements.

 @param elements the elements that the multiset should contain
 @throws IllegalArgumentException if {@code elements} is empty]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Multiset implementation backed by an {@link EnumMap}.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumMultiset -->
  <!-- start class com.google.common.collect.ForwardingCollection -->
  <class name="ForwardingCollection" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <constructor name="ForwardingCollection"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Collection&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A collection which forwards all its method calls to another collection.
 Subclasses should override one or more methods to modify the behavior of
 the backing collection as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingCollection -->
  <!-- start class com.google.common.collect.ForwardingConcurrentMap -->
  <class name="ForwardingConcurrentMap" extends="com.google.common.collect.ForwardingMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"/>
    <constructor name="ForwardingConcurrentMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="putIfAbsent" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="replace" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="replace" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="oldValue" type="V"/>
      <param name="newValue" type="V"/>
    </method>
    <doc>
    <![CDATA[A concurrent map which forwards all its method calls to another concurrent
 map. Subclasses should override one or more methods to modify the behavior of
 the backing map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Charles Fry
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingConcurrentMap -->
  <!-- start class com.google.common.collect.ForwardingIterator -->
  <class name="ForwardingIterator" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;T&gt;"/>
    <constructor name="ForwardingIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Iterator&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An iterator which forwards all its method calls to another iterator.
 Subclasses should override one or more methods to modify the behavior of the
 backing iterator as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingIterator -->
  <!-- start class com.google.common.collect.ForwardingList -->
  <class name="ForwardingList" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.List&lt;E&gt;"/>
    <constructor name="ForwardingList"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.List&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="listIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="remove" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="set" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
    </method>
    <method name="subList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A list which forwards all its method calls to another list. Subclasses should
 override one or more methods to modify the behavior of the backing list as
 desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>This class does not implement {@link java.util.RandomAccess}. If the
 delegate supports random access, the {@code ForwardingList} subclass should
 implement the {@code RandomAccess} interface.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingList -->
  <!-- start class com.google.common.collect.ForwardingListIterator -->
  <class name="ForwardingListIterator" extends="com.google.common.collect.ForwardingIterator&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.ListIterator&lt;E&gt;"/>
    <constructor name="ForwardingListIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.ListIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
    </method>
    <method name="hasPrevious" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="previous" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="previousIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
    </method>
    <doc>
    <![CDATA[A list iterator which forwards all its method calls to another list
 iterator. Subclasses should override one or more methods to modify the
 behavior of the backing iterator as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingListIterator -->
  <!-- start class com.google.common.collect.ForwardingListMultimap -->
  <class name="ForwardingListMultimap" extends="com.google.common.collect.ForwardingMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingListMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A list multimap which forwards all its method calls to another list multimap.
 Subclasses should override one or more methods to modify the behavior of
 the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kurt Alfred Kluever
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingListMultimap -->
  <!-- start class com.google.common.collect.ForwardingMap -->
  <class name="ForwardingMap" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <constructor name="ForwardingMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Map&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A map which forwards all its method calls to another map. Subclasses should
 override one or more methods to modify the behavior of the backing map as
 desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap -->
  <!-- start class com.google.common.collect.ForwardingMapEntry -->
  <class name="ForwardingMapEntry" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map.Entry&lt;K, V&gt;"/>
    <constructor name="ForwardingMapEntry"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A map entry which forwards all its method calls to another map entry.
 Subclasses should override one or more methods to modify the behavior of the
 backing map entry as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMapEntry -->
  <!-- start class com.google.common.collect.ForwardingMultimap -->
  <class name="ForwardingMultimap" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <constructor name="ForwardingMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entries" return="java.util.Collection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="removeAll" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A multimap which forwards all its method calls to another multimap.
 Subclasses should override one or more methods to modify the behavior of
 the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Robert Konigsberg
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultimap -->
  <!-- start class com.google.common.collect.ForwardingMultiset -->
  <class name="ForwardingMultiset" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multiset&lt;E&gt;"/>
    <constructor name="ForwardingMultiset"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="elementSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
    </method>
    <doc>
    <![CDATA[A multiset which forwards all its method calls to another multiset.
 Subclasses should override one or more methods to modify the behavior of the
 backing multiset as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultiset -->
  <!-- start class com.google.common.collect.ForwardingObject -->
  <class name="ForwardingObject" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingObject"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the backing delegate instance that methods are forwarded to.
 Abstract subclasses generally override this method with an abstract method
 that has a more specific return type, such as {@link
 ForwardingSet#delegate}. Concrete subclasses override this method to supply
 the instance being decorated.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the string representation generated by the delegate's
 {@code toString} method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract base class for implementing the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.
 The {@link #delegate()} method must be overridden to return the instance
 being decorated.

 This class does <i>not</i> forward the {@code hashCode} and {@code equals}
 methods through to the backing object, but relies on {@code Object}'s
 implementation. This is necessary to preserve the symmetry of {@code equals}.
 Custom definitions of equality are usually based on an interface, such as
 {@code Set} or {@code List}, so that the implementation of {@code equals} can
 cast the object being tested for equality to the custom interface. {@code
 ForwardingObject} implements no such custom interfaces directly; they
 are implemented only in subclasses. Therefore, forwarding {@code equals}
 would break symmetry, as the forwarding object might consider itself equal to
 the object being tested, but the reverse could not be true. This behavior is
 consistent with the JDK's collection wrappers, such as
 {@link java.util.Collections#unmodifiableCollection}. Use an
 interface-specific subclass of {@code ForwardingObject}, such as {@link
 ForwardingList}, to preserve equality behavior, or override {@code equals}
 directly.

 <p>The {@code toString} method is forwarded to the delegate. Although this
 class does not implement {@link Serializable}, a serializable subclass may be
 created since this class has a parameter-less constructor.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingObject -->
  <!-- start class com.google.common.collect.ForwardingQueue -->
  <class name="ForwardingQueue" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Queue&lt;E&gt;"/>
    <constructor name="ForwardingQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Queue&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="E"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="element" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A queue which forwards all its method calls to another queue. Subclasses
 should override one or more methods to modify the behavior of the backing
 queue as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingQueue -->
  <!-- start class com.google.common.collect.ForwardingSet -->
  <class name="ForwardingSet" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set&lt;E&gt;"/>
    <constructor name="ForwardingSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A set which forwards all its method calls to another set. Subclasses should
 override one or more methods to modify the behavior of the backing set as
 desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSet -->
  <!-- start class com.google.common.collect.ForwardingSetMultimap -->
  <class name="ForwardingSetMultimap" extends="com.google.common.collect.ForwardingMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingSetMultimap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="removeAll" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A set multimap which forwards all its method calls to another set multimap.
 Subclasses should override one or more methods to modify the behavior of
 the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kurt Alfred Kluever
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSetMultimap -->
  <!-- start class com.google.common.collect.ForwardingSortedMap -->
  <class name="ForwardingSortedMap" extends="com.google.common.collect.ForwardingMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedMap&lt;K, V&gt;"/>
    <constructor name="ForwardingSortedMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="firstKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
    </method>
    <method name="lastKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
    </method>
    <method name="tailMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
    </method>
    <doc>
    <![CDATA[A sorted map which forwards all its method calls to another sorted map.
 Subclasses should override one or more methods to modify the behavior of
 the backing sorted map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedMap -->
  <!-- start class com.google.common.collect.ForwardingSortedSet -->
  <class name="ForwardingSortedSet" extends="com.google.common.collect.ForwardingSet&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedSet&lt;E&gt;"/>
    <constructor name="ForwardingSortedSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.SortedSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="first" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
    </method>
    <method name="last" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="toElement" type="E"/>
    </method>
    <method name="tailSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
    </method>
    <doc>
    <![CDATA[A sorted set which forwards all its method calls to another sorted set.
 Subclasses should override one or more methods to modify the behavior of the
 backing sorted set as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedSet -->
  <!-- start class com.google.common.collect.ForwardingSortedSetMultimap -->
  <class name="ForwardingSortedSetMultimap" extends="com.google.common.collect.ForwardingSetMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingSortedSetMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="removeAll" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="valueComparator" return="java.util.Comparator&lt;? super V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A sorted set multimap which forwards all its method calls to another sorted
 set multimap. Subclasses should override one or more methods to modify the
 behavior of the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kurt Alfred Kluever
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedSetMultimap -->
  <!-- start class com.google.common.collect.HashBiMap -->
  <class name="HashBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty {@code HashBiMap} with the default initial capacity
 (16).]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Constructs a new, empty bimap with the specified expected size.

 @param expectedSize the expected number of entries
 @throws IllegalArgumentException if the specified expected size is
     negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a new bimap containing initial values from {@code map}. The
 bimap is created with an initial capacity sufficient to hold the mappings
 in the specified map.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <doc>
    <![CDATA[A {@link BiMap} backed by two {@link HashMap} instances. This implementation
 allows null keys and values. A {@code HashBiMap} and its inverse are both
 serializable.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashBiMap -->
  <!-- start class com.google.common.collect.HashMultimap -->
  <class name="HashMultimap" extends="com.google.common.collect.AbstractSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultimap} with the default initial
 capacities.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code HashMultimap} with enough capacity to hold the
 specified numbers of keys and values without rehashing.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code
      expectedValuesPerKey} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code HashMultimap} with the same mappings as the specified
 multimap. If a key-value mapping appears multiple times in the input
 multimap, it only appears once in the constructed multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@link Multimap} using hash tables.

 <p>The multimap does not store duplicate key-value pairs. Adding a new
 key-value pair equal to an existing key-value pair has no effect.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedSetMultimap}.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashMultimap -->
  <!-- start class com.google.common.collect.HashMultiset -->
  <class name="HashMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultiset} using the default initial
 capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distinctElements" type="int"/>
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultiset} with the specified expected
 number of distinct elements.

 @param distinctElements the expected number of distinct elements
 @throws IllegalArgumentException if {@code distinctElements} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code HashMultiset} containing the specified elements.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Multiset implementation backed by a {@link HashMap}.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashMultiset -->
  <!-- start class com.google.common.collect.ImmutableBiMap -->
  <class name="ImmutableBiMap" extends="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.BiMap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty bimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable bimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable bimap containing the same entries as {@code map}. If
 {@code map} somehow contains entries with duplicate keys (for example, if
 it is a {@code SortedMap} whose comparator is not <i>consistent with
 equals</i>), the results of this method are undefined.

 <p><b>Note:</b> If {@code map} is an {@code ImmutableBiMap}, the given map
 itself will be returned.

 @throws IllegalArgumentException if two keys have the same value
 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableBiMap&lt;V, K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The inverse of an {@code ImmutableBiMap} is another
 {@code ImmutableBiMap}.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the values in this map. The values are in the
 same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the bimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable {@link BiMap} with reliable user-specified iteration order. Does
 not permit null keys or values. An {@code ImmutableBiMap} and its inverse
 have the same iteration ordering.

 <p>An instance of {@code ImmutableBiMap} contains its own data and will
 <i>never</i> change. {@code ImmutableBiMap} is convenient for
 {@code public static final} maps ("constant maps") and also lets you easily
 make a "defensive copy" of a bimap provided to your class by a caller.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class are
 guaranteed to be immutable.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableBiMap -->
  <!-- start class com.google.common.collect.ImmutableBiMap.Builder -->
  <class name="ImmutableBiMap.Builder" extends="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableBiMap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableBiMap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built bimap. Duplicate
 keys or values are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built bimap.
 Duplicate keys or values are not allowed, and will cause {@link #build}
 to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable bimap.

 @throws IllegalArgumentException if duplicate keys or values were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable bimap instances, especially {@code public
 static final} bimaps ("constant bimaps"). Example: <pre>   {@code

   static final ImmutableBiMap<String, Integer> WORD_TO_INT =
       new ImmutableBiMap.Builder<String, Integer>()
           .put("one", 1)
           .put("two", 2)
           .put("three", 3)
           .build();}</pre>

 For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods
 are even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple bimaps in series. Each bimap is a superset
 of the bimaps created before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableBiMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableClassToInstanceMap -->
  <class name="ImmutableClassToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ClassToInstanceMap&lt;B&gt;"/>
    <method name="builder" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.Class&lt;? extends S&gt;, ? extends S&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}. If
 {@code map} somehow contains entries with duplicate keys (for example, if
 it is a {@code SortedMap} whose comparator is not <i>consistent with
 equals</i>), the results of this method are undefined.

 <p><b>Note:</b> Despite what the method name suggests, if {@code map} is
 an {@code ImmutableClassToInstanceMap}, no copy will actually be performed.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws ClassCastException if any value is not an instance of the type
     specified by its key]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class-to-instance map backed by an {@link ImmutableMap}. See also {@link
 MutableClassToInstanceMap}.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableClassToInstanceMap -->
  <!-- start class com.google.common.collect.ImmutableClassToInstanceMap.Builder -->
  <class name="ImmutableClassToInstanceMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableClassToInstanceMap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.Class&lt;? extends T&gt;, ? extends T&gt;"/>
      <doc>
      <![CDATA[Associates all of {@code map's} keys and values in the built map.
 Duplicate keys are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws ClassCastException if any value is not an instance of the type
     specified by its key]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable class-to-instance map containing the entries
 provided to this builder.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable class-to-instance maps. Example:
 <pre>   {@code

   static final ImmutableClassToInstanceMap<Handler> HANDLERS =
       new ImmutableClassToInstanceMap.Builder<Handler>()
           .put(FooHandler.class, new FooHandler())
           .put(BarHandler.class, new SubBarHandler())
           .put(Handler.class, new QuuxHandler())
           .build();}</pre>

 <p>After invoking {@link #build()} it is still possible to add more
 entries and build again. Thus each map generated by this builder will be
 a superset of any map generated before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableClassToInstanceMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableCollection -->
  <class name="ImmutableCollection" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable iterator across the elements in this collection.]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="T[]"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targets" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="oldElements" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="elementsToKeep" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list view of the collection.

 @since 2]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable collection. Does not permit null elements.

 <p>In addition to the {@link Collection} methods, this class has an {@link
 #asList()} method, which returns a list view of the collection's elements.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed
 outside of this package as it has no public or protected constructors. Thus,
 instances of this type are guaranteed to be immutable.

 @author Jesse Wilson
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableCollection -->
  <!-- start class com.google.common.collect.ImmutableList -->
  <class name="ImmutableList" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.List&lt;E&gt;"/>
    <implements name="java.util.RandomAccess"/>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable list. This set behaves and performs comparably
 to {@link Collections#emptyList}, and is preferable mainly for consistency
 and maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing a single element. This list behaves
 and performs comparably to {@link Collections#singleton}, but will not
 accept a null element. It is preferable mainly for consistency and
 maintainability of your code.

 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <param name="e11" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <param name="e11" type="E"/>
      <param name="e12" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 3 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #copyOf(Object[])}">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @deprecated use {@link #copyOf(Object[])}
 @throws NullPointerException if any of {@code elements} is null
 @since 2 (changed from varargs in release 3)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order. If
 {@code elements} is a {@link Collection}, this method behaves exactly as
 {@link #copyOf(Collection)}; otherwise, it behaves exactly as {@code
 copyOf(elements.iterator()}.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements}
 is an {@code ImmutableList}, no copy will actually be performed, and the
 given list itself will be returned.

 <p>Note that if {@code list} is a {@code List<String>}, then {@code
 ImmutableList.copyOf(list)} returns an {@code ImmutableList<String>}
 containing each of the strings in {@code list}, while
 ImmutableList.of(list)} returns an {@code ImmutableList<List<String>>}
 containing one element (the given list itself).

 <p>This method is safe to use even when {@code elements} is a synchronized
 or concurrent collection that is currently being modified by another
 thread.

 @throws NullPointerException if any of {@code elements} is null
 @since 2 (Iterable overload existed previously)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any of {@code elements} is null
 @since 3]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="indexOf" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="subList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Returns an immutable list of the elements between the specified {@code
 fromIndex}, inclusive, and {@code toIndex}, exclusive. (If {@code
 fromIndex} and {@code toIndex} are equal, the empty immutable list is
 returned.)]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="set" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this list instance.

 @since 2]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A high-performance, immutable, random-access {@code List} implementation.
 Does not permit null elements.

 <p>Unlike {@link Collections#unmodifiableList}, which is a <i>view</i> of a
 separate collection that can still change, an instance of {@code
 ImmutableList} contains its own private data and will <i>never</i> change.
 {@code ImmutableList} is convenient for {@code public static final} lists
 ("constant lists") and also lets you easily make a "defensive copy" of a list
 provided to your class by a caller.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this type are
 guaranteed to be immutable.

 @see ImmutableMap
 @see ImmutableSet
 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableList -->
  <!-- start class com.google.common.collect.ImmutableList.Builder -->
  <class name="ImmutableList.Builder" extends="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableList.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableList#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableList}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableList} based on the contents of
 the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable list instances, especially
 {@code public static final} lists ("constant lists").

 <p>Example:
 <pre>   {@code
   public static final ImmutableList<Color> GOOGLE_COLORS
       = new ImmutableList.Builder<Color>()
           .addAll(WEBSAFE_COLORS)
           .add(new Color(0, 191, 255))
           .build();}</pre>

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple lists in series. Each new list
 contains the one created before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableList.Builder -->
  <!-- start class com.google.common.collect.ImmutableListMultimap -->
  <class name="ImmutableListMultimap" extends="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty multimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the same mappings as
 {@code multimap}. The generated multimap's key and value orderings
 correspond to the iteration ordering of the {@code multimap.asMap()} view.

 <p><b>Note:</b> Despite what the method name suggests, if
 {@code multimap} is an {@code ImmutableListMultimap}, no copy will actually
 be performed, and the given multimap itself will be returned.

 @throws NullPointerException if any key or value in {@code multimap} is
     null]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable list of the values for the given key.  If no mappings
 in the multimap have the provided key, an empty immutable list is
 returned. The values are in the same order as the parameters used to build
 this multimap.]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@link ListMultimap} with reliable user-specified key and value
 iteration order. Does not permit null keys or values.

 <p>Unlike {@link Multimaps#unmodifiableListMultimap(ListMultimap)}, which is
 a <i>view</i> of a separate multimap which can still change, an instance of
 {@code ImmutableListMultimap} contains its own data and will <i>never</i>
 change. {@code ImmutableListMultimap} is convenient for
 {@code public static final} multimaps ("constant multimaps") and also lets
 you easily make a "defensive copy" of a multimap provided to your class by
 a caller.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class
 are guaranteed to be immutable.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableListMultimap -->
  <!-- start class com.google.common.collect.ImmutableListMultimap.Builder -->
  <class name="ImmutableListMultimap.Builder" extends="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableListMultimap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableListMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds a key-value mapping to the built multimap.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key in the built multimap.

 @throws NullPointerException if {@code key}, {@code values}, or any
     element in {@code values} is null. The builder is left in an invalid
     state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
      <doc>
      <![CDATA[Stores an array of values with the same key in the built multimap.

 @throws NullPointerException if the key or any value is null. The builder
     is left in an invalid state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Stores another multimap's entries in the built multimap. The generated
 multimap's key and value orderings correspond to the iteration ordering
 of the {@code multimap.asMap()} view, with new keys and values following
 any existing keys and values.

 @throws NullPointerException if any key or value in {@code multimap} is
     null. The builder is left in an invalid state.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable {@code ListMultimap} instances, especially
 {@code public static final} multimaps ("constant multimaps"). Example:
 <pre>   {@code

   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
       new ImmutableListMultimap.Builder<String, Integer>()
           .put("one", 1)
           .putAll("several", 1, 2, 3)
           .putAll("many", 1, 2, 3, 4, 5)
           .build();}</pre>

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple multimaps in series. Each multimap
 contains the key-value mappings in the previously created multimaps.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableListMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMap -->
  <class name="ImmutableMap" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty map. This map behaves and performs comparably to
 {@link Collections#emptyMap}, and is preferable mainly for consistency
 and maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing a single entry. This map behaves and
 performs comparably to {@link Collections#singletonMap} but will not accept
 a null key or value. It is preferable mainly for consistency and
 maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}. If
 {@code map} somehow contains entries with duplicate keys (for example, if
 it is a {@code SortedMap} whose comparator is not <i>consistent with
 equals</i>), the results of this method are undefined.

 <p><b>Note:</b> Despite what the method name suggests, if {@code map} is an
 {@code ImmutableMap}, no copy will actually be performed, and the given map
 itself will be returned.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="K"/>
      <param name="v" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the mappings in this map. The entries are in
 the same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the keys in this map. These keys are in
 the same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this map. The values are
 in the same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable, hash-based {@link Map} with reliable user-specified iteration
 order. Does not permit null keys or values.

 <p>Unlike {@link Collections#unmodifiableMap}, which is a <i>view</i> of a
 separate map which can still change, an instance of {@code ImmutableMap}
 contains its own data and will <i>never</i> change. {@code ImmutableMap} is
 convenient for {@code public static final} maps ("constant maps") and also
 lets you easily make a "defensive copy" of a map provided to your class by a
 caller.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class are
 guaranteed to be immutable.

 @see ImmutableList
 @see ImmutableSet
 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMap -->
  <!-- start class com.google.common.collect.ImmutableMap.Builder -->
  <class name="ImmutableMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableMap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableMap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built map.
 Duplicate keys are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable map.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable map instances, especially {@code public
 static final} maps ("constant maps"). Example: <pre>   {@code

   static final ImmutableMap<String, Integer> WORD_TO_INT =
       new ImmutableMap.Builder<String, Integer>()
           .put("one", 1)
           .put("two", 2)
           .put("three", 3)
           .build();}</pre>

 For <i>small</i> immutable maps, the {@code ImmutableMap.of()} methods are
 even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple maps in series. Each map is a superset of
 the maps created before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMultimap -->
  <class name="ImmutableMultimap" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty multimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the same mappings as
 {@code multimap}. The generated multimap's key and value orderings
 correspond to the iteration ordering of the {@code multimap.asMap()} view.

 <p><b>Note:</b> Despite what the method name suggests, if
 {@code multimap} is an {@code ImmutableMultimap}, no copy will actually be
 performed, and the given multimap itself will be returned.

 @throws NullPointerException if any key or value in {@code multimap} is
     null]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable collection of the values for the given key.  If no
 mappings in the multimap have the provided key, an empty immutable
 collection is returned. The values are in the same order as the parameters
 used to build this multimap.]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the distinct keys in this multimap. These keys
 are ordered according to when they first appeared during the construction
 of this multimap.]]>
      </doc>
    </method>
    <method name="asMap" return="com.google.common.collect.ImmutableMap&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable map that associates each key with its corresponding
 values in the multimap.]]>
      </doc>
    </method>
    <method name="entries" return="com.google.common.collect.ImmutableCollection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of all key-value pairs in the multimap. Its
 iterator traverses the values for the first key, the values for the second
 key, and so on.]]>
      </doc>
    </method>
    <method name="keys" return="com.google.common.collect.ImmutableMultiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection, which may contain duplicates, of all keys. The number
 of times a key appears in the returned multiset equals the number of
 mappings the key has in the multimap. Duplicate keys appear consecutively
 in the multiset's iteration order.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this multimap. Its
 iterator traverses the values for the first key, the values for the second
 key, and so on.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@link Multimap}. Does not permit null keys or values.

 <p>Unlike {@link Multimaps#unmodifiableMultimap(Multimap)}, which is
 a <i>view</i> of a separate multimap which can still change, an instance of
 {@code ImmutableMultimap} contains its own data and will <i>never</i>
 change. {@code ImmutableMultimap} is convenient for
 {@code public static final} multimaps ("constant multimaps") and also lets
 you easily make a "defensive copy" of a multimap provided to your class by
 a caller.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class
 are guaranteed to be immutable.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultimap -->
  <!-- start class com.google.common.collect.ImmutableMultimap.Builder -->
  <class name="ImmutableMultimap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableMultimap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds a key-value mapping to the built multimap.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key in the built multimap.

 @throws NullPointerException if {@code key}, {@code values}, or any
     element in {@code values} is null. The builder is left in an invalid
     state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
      <doc>
      <![CDATA[Stores an array of values with the same key in the built multimap.

 @throws NullPointerException if the key or any value is null. The builder
     is left in an invalid state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Stores another multimap's entries in the built multimap. The generated
 multimap's key and value orderings correspond to the iteration ordering
 of the {@code multimap.asMap()} view, with new keys and values following
 any existing keys and values.

 @throws NullPointerException if any key or value in {@code multimap} is
     null. The builder is left in an invalid state.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multimap instances, especially
 {@code public static final} multimaps ("constant multimaps"). Example:
 <pre>   {@code

   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
       new ImmutableMultimap.Builder<String, Integer>()
           .put("one", 1)
           .putAll("several", 1, 2, 3)
           .putAll("many", 1, 2, 3, 4, 5)
           .build();}</pre>

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple multimaps in series. Each multimap
 contains the key-value mappings in the previously created multimaps.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMultiset -->
  <class name="ImmutableMultiset" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multiset&lt;E&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable multiset.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing a single element.

 @throws NullPointerException if {@code element} is null
 @since 6 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #copyOf(Object[])}.">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements.

 <p>The multiset is ordered by the first occurrence of each element. For
 example, {@code ImmutableMultiset.of(2, 3, 1, 3)} yields a multiset with
 elements in the order {@code 2, 3, 3, 1}.

 @throws NullPointerException if any of {@code elements} is null
 @deprecated use {@link #copyOf(Object[])}.
 @since 2 (changed from varargs in release 6)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements.

 <p>The multiset is ordered by the first occurrence of each element. For
 example, {@code ImmutableMultiset.copyOf([2, 3, 1, 3])} yields a multiset
 with elements in the order {@code 2, 3, 3, 1}.

 @throws NullPointerException if any of {@code elements} is null
 @since 6]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements.

 <p>The multiset is ordered by the first occurrence of each element. For
 example, {@code ImmutableMultiset.copyOf(Arrays.asList(2, 3, 1, 3))} yields
 a multiset with elements in the order {@code 2, 3, 3, 1}.

 <p>Note that if {@code c} is a {@code Collection<String>}, then {@code
 ImmutableMultiset.copyOf(c)} returns an {@code ImmutableMultiset<String>}
 containing each of the strings in {@code c}, while
 {@code ImmutableMultiset.of(c)} returns an
 {@code ImmutableMultiset<Collection<String>>} containing one element (the
 given collection itself).

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements}
 is an {@code ImmutableMultiset}, no copy will actually be performed, and
 the given multiset itself will be returned.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements.

 <p>The multiset is ordered by the first occurrence of each element. For
 example,
 {@code ImmutableMultiset.copyOf(Arrays.asList(2, 3, 1, 3).iterator())}
 yields a multiset with elements in the order {@code 2, 3, 3, 1}.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="elementSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable hash-based multiset. Does not permit null elements.

 <p>Its iterator orders elements according to the first appearance of the
 element among the items passed to the factory method or builder. When the
 multiset contains multiple instances of an element, those instances are
 consecutive in the iteration order.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultiset -->
  <!-- start class com.google.common.collect.ImmutableMultiset.Builder -->
  <class name="ImmutableMultiset.Builder" extends="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableMultiset.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableMultiset#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableMultiset}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="addCopies" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this {@code
 ImmutableMultiset}.

 @param element the element to add
 @param occurrences the number of occurrences of the element to add. May
     be zero, in which case no change will be made.
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code occurrences} is negative, or
     if this operation would result in more than {@link Integer#MAX_VALUE}
     occurrences of the element]]>
      </doc>
    </method>
    <method name="setCount" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the
 element attains the desired count.

 @param element the element to add or remove occurrences of
 @param count the desired count of the element in this multiset
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the {@code Iterable} to add to the {@code
     ImmutableMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the elements to add to the {@code ImmutableMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableMultiset} based on the contents
 of the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multiset instances, especially
 {@code public static final} multisets ("constant multisets").

 <p>Example:
 <pre>   {@code
   public static final ImmutableMultiset<Bean> BEANS
       = new ImmutableMultiset.Builder<Bean>()
           .addCopies(Bean.COCOA, 4)
           .addCopies(Bean.GARDEN, 6)
           .addCopies(Bean.RED, 8)
           .addCopies(Bean.BLACK_EYED, 10)
           .build();}</pre>

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple multisets in series. Each multiset
 is a superset of the multiset created before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultiset.Builder -->
  <!-- start class com.google.common.collect.ImmutableSet -->
  <class name="ImmutableSet" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set&lt;E&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable set. This set behaves and performs comparably
 to {@link Collections#emptySet}, and is preferable mainly for consistency
 and maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing a single element. This set behaves and
 performs comparably to {@link Collections#singleton}, but will not accept
 a null element. It is preferable mainly for consistency and
 maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null
 @since 3 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #copyOf(Object[])}.">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @deprecated use {@link #copyOf(Object[])}.
 @throws NullPointerException if any of {@code elements} is null
 @since 2 (changed from varargs in release 3)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any of {@code elements} is null
 @since 3]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored. This method iterates over {@code elements} at most
 once.

 <p>Note that if {@code s} is a {@code Set<String>}, then {@code
 ImmutableSet.copyOf(s)} returns an {@code ImmutableSet<String>} containing
 each of the strings in {@code s}, while {@code ImmutableSet.of(s)} returns
 a {@code ImmutableSet<Set<String>>} containing one element (the given set
 itself).

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements}
 is an {@code ImmutableSet} (but not an {@code ImmutableSortedSet}), no copy
 will actually be performed, and the given set itself will be returned.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A high-performance, immutable {@code Set} with reliable, user-specified
 iteration order. Does not permit null elements.

 <p>Unlike {@link Collections#unmodifiableSet}, which is a <i>view</i> of a
 separate collection that can still change, an instance of this class contains
 its own private data and will <i>never</i> change. This class is convenient
 for {@code public static final} sets ("constant sets") and also lets you
 easily make a "defensive copy" of a set provided to your class by a caller.

 <p><b>Warning:</b> Like most sets, an {@code ImmutableSet} will not function
 correctly if an element is modified after being placed in the set. For this
 reason, and to avoid general confusion, it is strongly recommended to place
 only immutable objects into this collection.

 <p>This class has been observed to perform significantly better than {@link
 HashSet} for objects with very fast {@link Object#hashCode} implementations
 (as a well-behaved immutable object should). While this class's factory
 methods create hash-based instances, the {@link ImmutableSortedSet} subclass
 performs binary searches instead.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed
 outside its package as it has no public or protected constructors. Thus,
 instances of this type are guaranteed to be immutable.

 @see ImmutableList
 @see ImmutableMap
 @author Kevin Bourrillion
 @author Nick Kralevich
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSet -->
  <!-- start class com.google.common.collect.ImmutableSet.Builder -->
  <class name="ImmutableSet.Builder" extends="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSet.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSet#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSet}.  If the {@code
 ImmutableSet} already contains {@code element}, then {@code add} has no
 effect (only the previously added element is retained).

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the {@code Iterable} to add to the {@code ImmutableSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSet} based on the contents of
 the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable set instances, especially
 {@code public static final} sets ("constant sets").

 <p>Example:
 <pre>{@code
   public static final ImmutableSet<Color> GOOGLE_COLORS
       = new ImmutableSet.Builder<Color>()
           .addAll(WEBSAFE_COLORS)
           .add(new Color(0, 191, 255))
           .build();}</pre>

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple sets in series. Each set
 is a superset of the set created before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSet.Builder -->
  <!-- start class com.google.common.collect.ImmutableSetMultimap -->
  <class name="ImmutableSetMultimap" extends="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty multimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@link Builder}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set multimap containing the same mappings as
 {@code multimap}. The generated multimap's key and value orderings
 correspond to the iteration ordering of the {@code multimap.asMap()} view.
 Repeated occurrences of an entry in the multimap after the first are
 ignored.

 <p><b>Note:</b> Despite what the method name suggests, if
 {@code multimap} is an {@code ImmutableSetMultimap}, no copy will actually
 be performed, and the given multimap itself will be returned.

 @throws NullPointerException if any key or value in {@code multimap} is
     null]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable set of the values for the given key.  If no mappings
 in the multimap have the provided key, an empty immutable set is returned.
 The values are in the same order as the parameters used to build this
 multimap.]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="entries" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of all key-value pairs in the multimap.
 Its iterator traverses the values for the first key, the values for the
 second key, and so on.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@link SetMultimap} with reliable user-specified key and value
 iteration order. Does not permit null keys or values.

 <p>Unlike {@link Multimaps#unmodifiableSetMultimap(SetMultimap)}, which is
 a <i>view</i> of a separate multimap which can still change, an instance of
 {@code ImmutableSetMultimap} contains its own data and will <i>never</i>
 change. {@code ImmutableSetMultimap} is convenient for
 {@code public static final} multimaps ("constant multimaps") and also lets
 you easily make a "defensive copy" of a multimap provided to your class by
 a caller.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class
 are guaranteed to be immutable.

 @author Mike Ward
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSetMultimap -->
  <!-- start class com.google.common.collect.ImmutableSetMultimap.Builder -->
  <class name="ImmutableSetMultimap.Builder" extends="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSetMultimap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSetMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds a key-value mapping to the built multimap if it is not already
 present.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key in the built multimap.

 @throws NullPointerException if {@code key}, {@code values}, or any
     element in {@code values} is null. The builder is left in an invalid
     state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
      <doc>
      <![CDATA[Stores an array of values with the same key in the built multimap.

 @throws NullPointerException if the key or any value is null. The
     builder is left in an invalid state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Stores another multimap's entries in the built multimap. The generated
 multimap's key and value orderings correspond to the iteration ordering
 of the {@code multimap.asMap()} view, with new keys and values following
 any existing keys and values.

 @throws NullPointerException if any key or value in {@code multimap} is
     null. The builder is left in an invalid state.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable set multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable {@code SetMultimap} instances, especially
 {@code public static final} multimaps ("constant multimaps"). Example:
 <pre>   {@code

   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
       new ImmutableSetMultimap.Builder<String, Integer>()
           .put("one", 1)
           .putAll("several", 1, 2, 3)
           .putAll("many", 1, 2, 3, 4, 5)
           .build();}</pre>

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple multimaps in series. Each multimap
 contains the key-value mappings in the previously created multimaps.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSetMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedMap -->
  <class name="ImmutableSortedMap" extends="com.google.common.collect.ImmutableSortedMapFauxverideShim&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedMap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty sorted map.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if the two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if any two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if any two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if any two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}, sorted
 by the natural ordering of the keys.

 <p><b>Note:</b> Despite what the method name suggests, if {@code map} is an
 {@code ImmutableSortedMap}, it may be returned instead of a copy.

 <p>This method is not type-safe, as it may be called on a map with keys
 that are not mutually comparable.

 @throws ClassCastException if the keys in {@code map} are not mutually
     comparable
 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}, with
 keys sorted by the provided comparator.

 <p><b>Note:</b> Despite what the method name suggests, if {@code map} is an
 {@code ImmutableSortedMap}, it may be returned instead of a copy.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to
     the comparator]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as the provided sorted
 map, with the same ordering.

 <p><b>Note:</b> Despite what the method name suggests, if {@code map} is an
 {@code ImmutableSortedMap}, it may be returned instead of a copy.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps whose keys are
 ordered by their natural ordering. The sorted maps use {@link
 Ordering#natural()} as the comparator.

 <p>Note: the type parameter {@code K} extends {@code Comparable<K>} rather
 than {@code Comparable<? super K>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps with an explicit
 comparator. If the comparator has a more general type than the map's keys,
 such as creating a {@code SortedMap<Integer, String>} with a {@code
 Comparator<Number>}, use the {@link Builder} constructor instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps whose keys are
 ordered by the reverse of their natural ordering.

 <p>Note: the type parameter {@code K} extends {@code Comparable<K>} rather
 than {@code Comparable<? super K>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the mappings in this map, sorted by the key
 ordering.]]>
      </doc>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable sorted set of the keys in this map.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this map, sorted by the
 ordering of the corresponding keys.]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the keys, which is
 {@link Ordering#natural()} when the natural ordering of the keys is used.
 Note that its behavior is not consistent with {@link TreeMap#comparator()},
 which returns {@code null} to indicate natural ordering.]]>
      </doc>
    </method>
    <method name="firstKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lastKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys are less than {@code toKey}.

 <p>The {@link SortedMap#headMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code toKey}
 greater than an earlier {@code toKey}. However, this method doesn't throw
 an exception in that situation, but instead keeps the original {@code
 toKey}.]]>
      </doc>
    </method>
    <method name="subMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys ranges from {@code fromKey}, inclusive, to {@code toKey},
 exclusive.

 <p>The {@link SortedMap#subMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code
 fromKey} less than an earlier {@code fromKey}. However, this method doesn't
 throw an exception in that situation, but instead keeps the original {@code
 fromKey}. Similarly, this method keeps the original {@code toKey}, instead
 of throwing an exception, if passed a {@code toKey} greater than an earlier
 {@code toKey}.]]>
      </doc>
    </method>
    <method name="tailMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys are greater than or equals to {@code fromKey}.

 <p>The {@link SortedMap#tailMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code
 fromKey} less than an earlier {@code fromKey}. However, this method doesn't
 throw an exception in that situation, but instead keeps the original {@code
 fromKey}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@link SortedMap}. Does not permit null keys or values.

 <p>Unlike {@link Collections#unmodifiableSortedMap}, which is a <i>view</i>
 of a separate map which can still change, an instance of {@code
 ImmutableSortedMap} contains its own data and will <i>never</i> change.
 {@code ImmutableSortedMap} is convenient for {@code public static final} maps
 ("constant maps") and also lets you easily make a "defensive copy" of a map
 provided to your class by a caller.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class are
 guaranteed to be immutable.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMap -->
  <!-- start class com.google.common.collect.ImmutableSortedMap.Builder -->
  <class name="ImmutableSortedMap.Builder" extends="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSortedMap.Builder" type="java.util.Comparator&lt;? super K&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSortedMap#orderedBy}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys, according to the comparator (which might be the keys' natural
 order), are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built map.
 Duplicate keys, according to the comparator (which might be the keys'
 natural order), are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable sorted map.

 @throws IllegalArgumentException if any two keys are equal according to
     the comparator (which might be the keys' natural order)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable sorted map instances, especially {@code
 public static final} maps ("constant maps"). Example: <pre>   {@code

   static final ImmutableSortedMap<Integer, String> INT_TO_WORD =
       new ImmutableSortedMap.Builder<Integer, String>(Ordering.natural())
           .put(1, "one")
           .put(2, "two")
           .put(3, "three")
           .build();}</pre>

 For <i>small</i> immutable sorted maps, the {@code ImmutableSortedMap.of()}
 methods are even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple maps in series. Each map is a superset of
 the maps created before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedSet -->
  <class name="ImmutableSortedSet" extends="com.google.common.collect.ImmutableSortedSetFauxverideShim&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedSet&lt;E&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable sorted set.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing a single element.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e6" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="remaining" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null
 @since 3 (source-compatible since release 2)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #copyOf(Comparable[])}.">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any of {@code elements} is null
 @deprecated use {@link #copyOf(Comparable[])}.
 @since 2 (changed from varargs in release 3)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any of {@code elements} is null
 @since 3]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@code compareTo()}, only the first one specified is included. To create a
 copy of a {@code SortedSet} that preserves the comparator, call
 {@link #copyOfSorted} instead. This method iterates over {@code elements}
 at most once.

 <p>Note that if {@code s} is a {@code Set<String>}, then
 {@code ImmutableSortedSet.copyOf(s)} returns an
 {@code ImmutableSortedSet<String>} containing each of the strings in
 {@code s}, while {@code ImmutableSortedSet.of(s)} returns an
 {@code ImmutableSortedSet<Set<String>>} containing one element (the given
 set itself).

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements}
 is an {@code ImmutableSortedSet}, it may be returned instead of a copy.

 <p>This method is not type-safe, as it may be called on elements that are
 not mutually comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@code compareTo()}, only the first one specified is included.

 <p>This method is not type-safe, as it may be called on elements that are
 not mutually comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 the given {@code Comparator}. When multiple elements are equivalent
 according to {@code compare()}, only the first one specified is
 included. This method iterates over {@code elements} at most once.

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements}
 is an {@code ImmutableSortedSet}, it may be returned instead of a copy.

 @throws NullPointerException if {@code comparator} or any of
     {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 the given {@code Comparator}. When multiple elements are equivalent
 according to {@code compareTo()}, only the first one specified is
 included.

 @throws NullPointerException if {@code comparator} or any of
     {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedSet" type="java.util.SortedSet&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the elements of a sorted set,
 sorted by the same {@code Comparator}. That behavior differs from
 {@link #copyOf(Iterable)}, which always uses the natural ordering of the
 elements.

 <p><b>Note:</b> Despite what the method name suggests, if {@code sortedSet}
 is an {@code ImmutableSortedSet}, it may be returned instead of a copy.

 @throws NullPointerException if {@code sortedSet} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="withExplicitOrder" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.List&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the elements in the given list
 in the same order. It is useful when the elements already have the desired
 order but constructing the appropriate comparator is difficult.

 @throws NullPointerException if any of the elements is null
 @throws IllegalArgumentException if {@code elements} contains any
     duplicate values (according to {@link Object#equals})
 @since 3]]>
      </doc>
    </method>
    <method name="withExplicitOrder" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="firstElement" type="E"/>
      <param name="remainingElementsInOrder" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the provided elements in the
 same order. It is useful when the elements already have the desired order
 but constructing the appropriate comparator is difficult.

 @param firstElement the value which should appear first in the generated
     set
 @param remainingElementsInOrder the rest of the values in the generated
     set, in the order they should appear
 @throws NullPointerException if any of the elements is null
 @throws IllegalArgumentException if any duplicate values (according to
     {@link Object#equals(Object)}) are present among the method arguments
 @since 3]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets with an explicit
 comparator. If the comparator has a more general type than the set being
 generated, such as creating a {@code SortedSet<Integer>} with a
 {@code Comparator<Number>}, use the {@link Builder} constructor instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets whose elements are
 ordered by the reverse of their natural ordering.

 <p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather
 than {@code Comparable<? super E>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets whose elements are
 ordered by their natural ordering. The sorted sets use {@link
 Ordering#natural()} as the comparator. This method provides more
 type-safety than {@link #builder}, as it can be called only for classes
 that implement {@link Comparable}.

 <p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather
 than {@code Comparable<? super E>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the elements, which is
 {@link Ordering#natural()} when the natural ordering of the
 elements is used. Note that its behavior is not consistent with
 {@link SortedSet#comparator()}, which returns {@code null} to indicate
 natural ordering.]]>
      </doc>
    </method>
    <method name="headSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#headSet} documentation states that a subset of a
 subset throws an {@link IllegalArgumentException} if passed a
 {@code toElement} greater than an earlier {@code toElement}. However, this
 method doesn't throw an exception in that situation, but instead keeps the
 original {@code toElement}.]]>
      </doc>
    </method>
    <method name="subSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#subSet} documentation states that a subset of a
 subset throws an {@link IllegalArgumentException} if passed a
 {@code fromElement} smaller than an earlier {@code fromElement}. However,
 this method doesn't throw an exception in that situation, but instead keeps
 the original {@code fromElement}. Similarly, this method keeps the
 original {@code toElement}, instead of throwing an exception, if passed a
 {@code toElement} greater than an earlier {@code toElement}.]]>
      </doc>
    </method>
    <method name="tailSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#tailSet} documentation states that a subset of a
 subset throws an {@link IllegalArgumentException} if passed a
 {@code fromElement} smaller than an earlier {@code fromElement}. However,
 this method doesn't throw an exception in that situation, but instead keeps
 the original {@code fromElement}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@code SortedSet} that stores its elements in a sorted array.
 Some instances are ordered by an explicit comparator, while others follow the
 natural sort ordering of their elements. Either way, null elements are not
 supported.

 <p>Unlike {@link Collections#unmodifiableSortedSet}, which is a <i>view</i>
 of a separate collection that can still change, an instance of {@code
 ImmutableSortedSet} contains its own private data and will <i>never</i>
 change. This class is convenient for {@code public static final} sets
 ("constant sets") and also lets you easily make a "defensive copy" of a set
 provided to your class by a caller.

 <p>The sets returned by {@link #headSet}, {@link #tailSet}, and
 {@link #subSet} methods share the same array as the original set, preventing
 that array from being garbage collected. If this is a concern, the data may
 be copied into a correctly-sized array by calling {@link #copyOfSorted}.

 <p><b>Note on element equivalence:</b> The {@link #contains(Object)},
 {@link #containsAll(Collection)}, and {@link #equals(Object)}
 implementations must check whether a provided object is equivalent to an
 element in the collection. Unlike most collections, an
 {@code ImmutableSortedSet} doesn't use {@link Object#equals} to determine if
 two elements are equivalent. Instead, with an explicit comparator, the
 following relation determines whether elements {@code x} and {@code y} are
 equivalent: <pre>   {@code

   {(x, y) | comparator.compare(x, y) == 0}}</pre>

 With natural ordering of elements, the following relation determines whether
 two elements are equivalent: <pre>   {@code

   {(x, y) | x.compareTo(y) == 0}}</pre>

 <b>Warning:</b> Like most sets, an {@code ImmutableSortedSet} will not
 function correctly if an element is modified after being placed in the set.
 For this reason, and to avoid general confusion, it is strongly recommended
 to place only immutable objects into this collection.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this type are
 guaranteed to be immutable.

 @see ImmutableSet
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedSet -->
  <!-- start class com.google.common.collect.ImmutableSortedSet.Builder -->
  <class name="ImmutableSortedSet.Builder" extends="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSortedSet.Builder" type="java.util.Comparator&lt;? super E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSortedSet#orderedBy}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSortedSet}.  If the
 {@code ImmutableSortedSet} already contains {@code element}, then
 {@code add} has no effect. (only the previously added element
 is retained).

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSortedSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSortedSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSortedSet} based on the contents
 of the {@code Builder} and its comparator.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable sorted set instances, especially
 {@code public static final} sets ("constant sets"), with a given
 comparator.

 <p>Example:
 <pre>{@code
   public static final ImmutableSortedSet<Number> LUCKY_NUMBERS
       = new ImmutableSortedSet.Builder<Number>(ODDS_FIRST_COMPARATOR)
           .addAll(SINGLE_DIGIT_PRIMES)
           .add(42)
           .build();}</pre>

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple sets in series. Each set
 is a superset of the set created before it.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedSet.Builder -->
  <!-- start interface com.google.common.collect.Interner -->
  <interface name="Interner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="intern" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="E"/>
      <doc>
      <![CDATA[Chooses and returns the representative instance for any of a collection of
 instances that are equal to each other. If two {@link Object#equals equal}
 inputs are given to this method, both calls will return the same instance.
 That is, {@code intern(a).equals(a)} always holds, and {@code intern(a) ==
 intern(b)} if and only if {@code a.equals(b)}. Note that {@code intern(a)}
 is permitted to return one instance now and a different instance later if
 the original interned instance was garbage-collected.

 <p><b>Warning:</b> do not use with mutable objects.

 @throws NullPointerException if {@code sample} is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides equivalent behavior to {@link String#intern} for other immutable
 types.

 @author Kevin Bourrillion
 @since 3]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Interner -->
  <!-- start class com.google.common.collect.Interners -->
  <class name="Interners" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newStrongInterner" return="com.google.common.collect.Interner&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread-safe interner which retains a strong reference to
 each instance it has interned, thus preventing these instances from being
 garbage-collected. If this retention is acceptable, this implementation may
 perform better than {@link #newWeakInterner}.]]>
      </doc>
    </method>
    <method name="newWeakInterner" return="com.google.common.collect.Interner&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread-safe interner which retains a weak reference to each
 instance it has interned, and so does not prevent these instances from
 being garbage-collected. This most likely does not perform as well as
 {@link #newStrongInterner}, but is the best alternative when the memory
 usage of that implementation is unacceptable.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static methods pertaining to instances of {@link Interner}.

 @author Kevin Bourrillion
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Interners -->
  <!-- start class com.google.common.collect.Iterables -->
  <class name="Iterables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="unmodifiableIterable" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of {@code iterable}.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the number of elements in {@code iterable}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code iterable} contains {@code element}; that is,
 any object for which {@code equals(element)} is true.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that belongs to the provided
 collection.

 <p>This method calls {@link Collection#removeAll} if {@code iterable} is a
 collection, and {@link Iterators#removeAll} otherwise.

 @param removeFrom the iterable to (potentially) remove elements from
 @param elementsToRemove the elements to remove
 @return {@code true} if any elements are removed from {@code iterable}]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that does not belong to the
 provided collection.

 <p>This method calls {@link Collection#retainAll} if {@code iterable} is a
 collection, and {@link Iterators#retainAll} otherwise.

 @param removeFrom the iterable to (potentially) remove elements from
 @param elementsToRetain the elements to retain
 @return {@code true} if any elements are removed from {@code iterable}]]>
      </doc>
    </method>
    <method name="removeIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that satisfies the provided
 predicate.

 @param removeFrom the iterable to (potentially) remove elements from
 @param predicate a predicate that determines whether an element should
     be removed
 @return {@code true} if any elements were removed from the iterable

 @throws UnsupportedOperationException if the iterable does not support
     {@code remove()}.
 @since 2]]>
      </doc>
    </method>
    <method name="elementsEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable1" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="iterable2" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines whether two iterables contain equal elements in the same order.
 More specifically, this method returns {@code true} if {@code iterable1}
 and {@code iterable2} contain the same number of elements and every element
 of {@code iterable1} is equal to the corresponding element of
 {@code iterable2}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string representation of {@code iterable}, with the format
 {@code [e1, e2, ..., en]}.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterable}.

 @throws NoSuchElementException if the iterable is empty
 @throws IllegalArgumentException if the iterable contains multiple
     elements]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterable}, or {@code
 defaultValue} if the iterable is empty.

 @throws IllegalArgumentException if the iterator contains multiple
     elements]]>
      </doc>
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Copies an iterable's elements into an array.

 @param iterable the iterable to copy
 @param type the type of the elements
 @return a newly-allocated array into which all the elements of the iterable
     have been copied]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addTo" type="java.util.Collection&lt;T&gt;"/>
      <param name="elementsToAdd" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Adds all elements in {@code iterable} to {@code collection}.

 @return {@code true} if {@code collection} was modified as a result of this
     operation.]]>
      </doc>
    </method>
    <method name="frequency" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of elements in the specified iterable that equal the
 specified object.

 @see Collections#frequency]]>
      </doc>
    </method>
    <method name="cycle" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an iterable whose iterators cycle indefinitely over the elements of
 {@code iterable}.

 <p>That iterator supports {@code remove()} if {@code iterable.iterator()}
 does. After {@code remove()} is called, subsequent cycles omit the removed
 element, which is no longer in {@code iterable}. The iterator's
 {@code hasNext()} method returns {@code true} until {@code iterable} is
 empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.

 <p>To cycle over the iterable {@code n} times, use the following:
 {@code Iterables.concat(Collections.nCopies(n, iterable))}]]>
      </doc>
    </method>
    <method name="cycle" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterable whose iterators cycle indefinitely over the provided
 elements.

 <p>After {@code remove} is invoked on a generated iterator, the removed
 element will no longer appear in either that iterator or any other iterator
 created from the same source iterable. That is, this method behaves exactly
 as {@code Iterables.cycle(Lists.newArrayList(elements))}. The iterator's
 {@code hasNext} method returns {@code true} until all of the original
 elements have been removed.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.

 <p>To cycle over the elements {@code n} times, use the following:
 {@code Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines two iterables into a single iterable. The returned iterable has an
 iterator that traverses the elements in {@code a}, followed by the elements
 in {@code b}. The source iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines three iterables into a single iterable. The returned iterable has
 an iterator that traverses the elements in {@code a}, followed by the
 elements in {@code b}, followed by the elements in {@code c}. The source
 iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="d" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines four iterables into a single iterable. The returned iterable has
 an iterator that traverses the elements in {@code a}, followed by the
 elements in {@code b}, followed by the elements in {@code c}, followed by
 the elements in {@code d}. The source iterators are not polled until
 necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable[]"/>
      <doc>
      <![CDATA[Combines multiple iterables into a single iterable. The returned iterable
 has an iterator that traverses the elements of each iterable in
 {@code inputs}. The input iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.

 @throws NullPointerException if any of the provided iterables is null]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable&lt;? extends java.lang.Iterable&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Combines multiple iterables into a single iterable. The returned iterable
 has an iterator that traverses the elements of each iterable in
 {@code inputs}. The input iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it. The methods of the returned
 iterable may throw {@code NullPointerException} if any of the input
 iterators are null.]]>
      </doc>
    </method>
    <method name="partition" return="java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterable into unmodifiable sublists of the given size (the final
 iterable may be smaller). For example, partitioning an iterable containing
 {@code [a, b, c, d, e]} with a partition size of 3 yields {@code
 [[a, b, c], [d, e]]} -- an outer iterable containing two inner lists of
 three and two elements, all in the original order.

 <p>Iterators returned by the returned iterable do not support the {@link
 Iterator#remove()} method. The returned lists implement {@link
 RandomAccess}, whether or not the input list does.

 <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link
 Lists#partition(List, int)} instead.

 @param iterable the iterable to return a partitioned view of
 @param size the desired size of each partition (the last may be smaller)
 @return an iterable of unmodifiable lists containing the elements of {@code
     iterable} divided into partitions
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="paddedPartition" return="java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterable into unmodifiable sublists of the given size, padding
 the final iterable with null values if necessary. For example, partitioning
 an iterable containing {@code [a, b, c, d, e]} with a partition size of 3
 yields {@code [[a, b, c], [d, e, null]]} -- an outer iterable containing
 two inner lists of three elements each, all in the original order.

 <p>Iterators returned by the returned iterable do not support the {@link
 Iterator#remove()} method.

 @param iterable the iterable to return a partitioned view of
 @param size the desired size of each partition
 @return an iterable of unmodifiable lists containing the elements of {@code
     iterable} divided into partitions (the final iterable may have
     trailing null elements)
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="filter" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The
 resulting iterable's iterator does not support {@code remove()}.]]>
      </doc>
    </method>
    <method name="filter" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns all instances of class {@code type} in {@code unfiltered}. The
 returned iterable has elements whose class is {@code type} or a subclass of
 {@code type}. The returned iterable's iterator does not support
 {@code remove()}.

 @param unfiltered an iterable containing objects of any type
 @param type the type of elements desired
 @return an unmodifiable iterable containing all elements of the original
     iterable that were of the requested type]]>
      </doc>
    </method>
    <method name="any" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if one or more elements in {@code iterable} satisfy
 the predicate.]]>
      </doc>
    </method>
    <method name="all" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element in {@code iterable} satisfies the
 predicate. If {@code iterable} is empty, {@code true} is returned.]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterable} that satisfies the given
 predicate.

 @throws NoSuchElementException if no element in {@code iterable} matches
     the given predicate]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the index in {@code iterable} of the first element that satisfies
 the provided {@code predicate}, or {@code -1} if the Iterable has no such
 elements.

 <p>More formally, returns the lowest index {@code i} such that
 {@code predicate.apply(Iterables.get(iterable, i))} is {@code true} or
 {@code -1} if there is no such index.

 @since 2]]>
      </doc>
    </method>
    <method name="transform" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIterable" type="java.lang.Iterable&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns an iterable that applies {@code function} to each element of {@code
 fromIterable}.

 <p>The returned iterable's iterator supports {@code remove()} if the
 provided iterator does. After a successful {@code remove()} call,
 {@code fromIterable} no longer contains the corresponding element.]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the element at the specified position in an iterable.

 @param position position of the element to return
 @return the element at the specified position in {@code iterable}
 @throws IndexOutOfBoundsException if {@code position} is negative or
     greater than or equal to the size of {@code iterable}]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="position" type="int"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the element at the specified position in an iterable or a default
 value otherwise.

 @param position position of the element to return
 @param defaultValue the default value to return if {@code position} is
     greater than or equal to the size of the iterable
 @return the element at the specified position in {@code iterable} or
     {@code defaultValue} if {@code iterable} contains fewer than
     {@code position + 1} elements.
 @throws IndexOutOfBoundsException if {@code position} is negative
 @since 4]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the last element of {@code iterable}.

 @return the last element of {@code iterable}
 @throws NoSuchElementException if the iterable has no elements]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the last element of {@code iterable} or {@code defaultValue} if
 the iterable is empty.

 @param defaultValue the value to return if {@code iterable} is empty
 @return the last element of {@code iterable} or the default value
 @since 3]]>
      </doc>
    </method>
    <method name="skip" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="numberToSkip" type="int"/>
      <doc>
      <![CDATA[Returns a view of {@code iterable} that skips its first
 {@code numberToSkip} elements. If {@code iterable} contains fewer than
 {@code numberToSkip} elements, the returned iterable skips all of its
 elements.

 <p>Modifications to the underlying {@link Iterable} before a call to
 {@code iterator()} are reflected in the returned iterator. That is, the
 iterator skips the first {@code numberToSkip} elements that exist when the
 {@code Iterator} is created, not when {@code skip()} is called.

 <p>The returned iterable's iterator supports {@code remove()} if the
 iterator of the underlying iterable supports it. Note that it is
 <i>not</i> possible to delete the last skipped element by immediately
 calling {@code remove()} on that iterator, as the {@code Iterator}
 contract states that a call to {@code remove()} before a call to
 {@code next()} will throw an {@link IllegalStateException}.

 @since 3]]>
      </doc>
    </method>
    <method name="limit" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="limitSize" type="int"/>
      <doc>
      <![CDATA[Creates an iterable with the first {@code limitSize} elements of the given
 iterable. If the original iterable does not contain that many elements, the
 returned iterator will have the same behavior as the original iterable. The
 returned iterable's iterator supports {@code remove()} if the original
 iterator does.

 @param iterable the iterable to limit
 @param limitSize the maximum number of elements in the returned iterator
 @throws IllegalArgumentException if {@code limitSize} is negative
 @since 3]]>
      </doc>
    </method>
    <method name="consumingIterable" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of the supplied iterable that wraps each generated
 {@link Iterator} through {@link Iterators#consumingIterator(Iterator)}.

 @param iterable the iterable to wrap
 @return a view of the supplied iterable that wraps each generated iterator
     through {@link Iterators#consumingIterator(Iterator)}

 @see Iterators#consumingIterator(Iterator)
 @since 2]]>
      </doc>
    </method>
    <method name="reverse" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;T&gt;"/>
      <doc>
      <![CDATA[Adapts a list to an iterable with reversed iteration order. It is
 especially useful in foreach-style loops: <pre class="code">   {@code

   List<String> mylist = ...
   for (String str : Iterables.reverse(mylist)) {
     ...
   }}</pre>

 There is no corresponding method in {@link Iterators}, since {@link
 Iterable#iterator} can simply be invoked on the result of calling this
 method.

 @return an iterable with the same elements as the list, in reverse]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Determines if the given iterable contains no elements.

 <p>There is no precise {@link Iterator} equivalent to this method, since
 one can only ask an iterator whether it has any elements <i>remaining</i>
 (which one does using {@link Iterator#hasNext}).

 @return {@code true} if the iterable contains no elements]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class contains static utility methods that operate on or return objects
 of type {@code Iterable}. Except as noted, each method has a corresponding
 {@link Iterator}-based method in the {@link Iterators} class.

 <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables
 produced in this class are <i>lazy</i>, which means that their iterators
 only advance the backing iteration when absolutely necessary.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Iterables -->
  <!-- start class com.google.common.collect.Iterators -->
  <class name="Iterators" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="emptyIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty iterator.

 <p>The {@link Iterable} equivalent of this method is {@link
 Collections#emptySet}.]]>
      </doc>
    </method>
    <method name="unmodifiableIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of {@code iterator}.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the number of elements remaining in {@code iterator}. The iterator
 will be left exhausted: its {@code hasNext()} method will return
 {@code false}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code iterator} contains {@code element}.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;?&gt;"/>
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Traverses an iterator and removes every element that belongs to the
 provided collection. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param elementsToRemove the elements to remove
 @return {@code true} if any elements are removed from {@code iterator}]]>
      </doc>
    </method>
    <method name="removeIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Removes every element that satisfies the provided predicate from the
 iterator. The iterator will be left exhausted: its {@code hasNext()}
 method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param predicate a predicate that determines whether an element should
     be removed
 @return {@code true} if any elements were removed from the iterator
 @since 2]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;?&gt;"/>
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Traverses an iterator and removes every element that does not belong to the
 provided collection. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param elementsToRetain the elements to retain
 @return {@code true} if any elements are removed from {@code iterator}]]>
      </doc>
    </method>
    <method name="elementsEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator1" type="java.util.Iterator&lt;?&gt;"/>
      <param name="iterator2" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines whether two iterators contain equal elements in the same order.
 More specifically, this method returns {@code true} if {@code iterator1}
 and {@code iterator2} contain the same number of elements and every element
 of {@code iterator1} is equal to the corresponding element of
 {@code iterator2}.

 <p>Note that this will modify the supplied iterators, since they will have
 been advanced some number of elements forward.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string representation of {@code iterator}, with the format
 {@code [e1, e2, ..., en]}. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterator}.

 @throws NoSuchElementException if the iterator is empty
 @throws IllegalArgumentException if the iterator contains multiple
     elements.  The state of the iterator is unspecified.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterator}, or {@code
 defaultValue} if the iterator is empty.

 @throws IllegalArgumentException if the iterator contains multiple
     elements.  The state of the iterator is unspecified.]]>
      </doc>
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Copies an iterator's elements into an array. The iterator will be left
 exhausted: its {@code hasNext()} method will return {@code false}.

 @param iterator the iterator to copy
 @param type the type of the elements
 @return a newly-allocated array into which all the elements of the iterator
         have been copied]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addTo" type="java.util.Collection&lt;T&gt;"/>
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Adds all elements in {@code iterator} to {@code collection}. The iterator
 will be left exhausted: its {@code hasNext()} method will return
 {@code false}.

 @return {@code true} if {@code collection} was modified as a result of this
         operation]]>
      </doc>
    </method>
    <method name="frequency" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of elements in the specified iterator that equal the
 specified object. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.

 @see Collections#frequency]]>
      </doc>
    </method>
    <method name="cycle" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an iterator that cycles indefinitely over the elements of {@code
 iterable}.

 <p>The returned iterator supports {@code remove()} if the provided iterator
 does. After {@code remove()} is called, subsequent cycles omit the removed
 element, which is no longer in {@code iterable}. The iterator's
 {@code hasNext()} method returns {@code true} until {@code iterable} is
 empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.]]>
      </doc>
    </method>
    <method name="cycle" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterator that cycles indefinitely over the provided elements.

 <p>The returned iterator supports {@code remove()} if the provided iterator
 does. After {@code remove()} is called, subsequent cycles omit the removed
 element, but {@code elements} does not change. The iterator's
 {@code hasNext()} method returns {@code true} until all of the original
 elements have been removed.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines two iterators into a single iterator. The returned iterator
 iterates across the elements in {@code a}, followed by the elements in
 {@code b}. The source iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="c" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines three iterators into a single iterator. The returned iterator
 iterates across the elements in {@code a}, followed by the elements in
 {@code b}, followed by the elements in {@code c}. The source iterators
 are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="c" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="d" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines four iterators into a single iterator. The returned iterator
 iterates across the elements in {@code a}, followed by the elements in
 {@code b}, followed by the elements in {@code c}, followed by the elements
 in {@code d}. The source iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.util.Iterator[]"/>
      <doc>
      <![CDATA[Combines multiple iterators into a single iterator. The returned iterator
 iterates across the elements of each iterator in {@code inputs}. The input
 iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.

 @throws NullPointerException if any of the provided iterators is null]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.util.Iterator&lt;? extends java.util.Iterator&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Combines multiple iterators into a single iterator. The returned iterator
 iterates across the elements of each iterator in {@code inputs}. The input
 iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it. The methods of the returned iterator may throw
 {@code NullPointerException} if any of the input iterators are null.]]>
      </doc>
    </method>
    <method name="partition" return="com.google.common.collect.UnmodifiableIterator&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterator into unmodifiable sublists of the given size (the final
 list may be smaller). For example, partitioning an iterator containing
 {@code [a, b, c, d, e]} with a partition size of 3 yields {@code
 [[a, b, c], [d, e]]} -- an outer iterator containing two inner lists of
 three and two elements, all in the original order.

 <p>The returned lists implement {@link java.util.RandomAccess}.

 @param iterator the iterator to return a partitioned view of
 @param size the desired size of each partition (the last may be smaller)
 @return an iterator of immutable lists containing the elements of {@code
     iterator} divided into partitions
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="paddedPartition" return="com.google.common.collect.UnmodifiableIterator&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterator into unmodifiable sublists of the given size, padding
 the final iterator with null values if necessary. For example, partitioning
 an iterator containing {@code [a, b, c, d, e]} with a partition size of 3
 yields {@code [[a, b, c], [d, e, null]]} -- an outer iterator containing
 two inner lists of three elements each, all in the original order.

 <p>The returned lists implement {@link java.util.RandomAccess}.

 @param iterator the iterator to return a partitioned view of
 @param size the desired size of each partition
 @return an iterator of immutable lists containing the elements of {@code
     iterator} divided into partitions (the final iterable may have
     trailing null elements)
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate.]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Iterator&lt;?&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns all instances of class {@code type} in {@code unfiltered}. The
 returned iterator has elements whose class is {@code type} or a subclass of
 {@code type}.

 @param unfiltered an iterator containing objects of any type
 @param type the type of elements desired
 @return an unmodifiable iterator containing all elements of the original
     iterator that were of the requested type]]>
      </doc>
    </method>
    <method name="any" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if one or more elements returned by {@code iterator}
 satisfy the given predicate.]]>
      </doc>
    </method>
    <method name="all" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element returned by {@code iterator}
 satisfies the given predicate. If {@code iterator} is empty, {@code true}
 is returned.]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterator} that satisfies the given
 predicate.  If no such element is found, the iterator will be left
 exhausted: its {@code hasNext()} method will return {@code false}.

 @throws NoSuchElementException if no element in {@code iterator} matches
     the given predicate]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the index in {@code iterator} of the first element that satisfies
 the provided {@code predicate}, or {@code -1} if the Iterator has no such
 elements.

 <p>More formally, returns the lowest index {@code i} such that
 {@code predicate.apply(Iterators.get(iterator, i))} is {@code true}, or
 {@code -1} if there is no such index.

 <p>If -1 is returned, the iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.  Otherwise,
 the iterator will be set to the element which satisfies the
 {@code predicate}.

 @since 2]]>
      </doc>
    </method>
    <method name="transform" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIterator" type="java.util.Iterator&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns an iterator that applies {@code function} to each element of {@code
 fromIterator}.

 <p>The returned iterator supports {@code remove()} if the provided iterator
 does. After a successful {@code remove()} call, {@code fromIterator} no
 longer contains the corresponding element.]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Advances {@code iterator} {@code position + 1} times, returning the
 element at the {@code position}th position.

 @param position position of the element to return
 @return the element at the specified position in {@code iterator}
 @throws IndexOutOfBoundsException if {@code position} is negative or
     greater than or equal to the number of elements remaining in
     {@code iterator}]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="position" type="int"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Advances {@code iterator} {@code position + 1} times, returning the
 element at the {@code position}th position or {@code defaultValue}
 otherwise.

 @param position position of the element to return
 @param defaultValue the default value to return if the iterator is empty
     or if {@code position} is greater than the number of elements
     remaining in {@code iterator}
 @return the element at the specified position in {@code iterator} or
     {@code defaultValue} if {@code iterator} produces fewer than
     {@code position + 1} elements.
 @throws IndexOutOfBoundsException if {@code position} is negative
 @since 4]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Advances {@code iterator} to the end, returning the last element.

 @return the last element of {@code iterator}
 @throws NoSuchElementException if the iterator has no remaining elements]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Advances {@code iterator} to the end, returning the last element or
 {@code defaultValue} if the iterator is empty.

 @param defaultValue the default value to return if the iterator is empty
 @return the last element of {@code iterator}
 @since 3]]>
      </doc>
    </method>
    <method name="skip" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="numberToSkip" type="int"/>
      <doc>
      <![CDATA[Calls {@code next()} on {@code iterator}, either {@code numberToSkip} times
 or until {@code hasNext()} returns {@code false}, whichever comes first.

 @return the number of elements skipped
 @since 3]]>
      </doc>
    </method>
    <method name="limit" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="limitSize" type="int"/>
      <doc>
      <![CDATA[Creates an iterator returning the first {@code limitSize} elements of the
 given iterator. If the original iterator does not contain that many
 elements, the returned iterator will have the same behavior as the original
 iterator. The returned iterator supports {@code remove()} if the original
 iterator does.

 @param iterator the iterator to limit
 @param limitSize the maximum number of elements in the returned iterator
 @throws IllegalArgumentException if {@code limitSize} is negative
 @since 3]]>
      </doc>
    </method>
    <method name="consumingIterator" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of the supplied {@code iterator} that removes each element
 from the supplied {@code iterator} as it is returned.

 <p>The provided iterator must support {@link Iterator#remove()} or
 else the returned iterator will fail on the first call to {@code
 next}.

 @param iterator the iterator to remove and return elements from
 @return an iterator that removes and returns elements from the
     supplied iterator
 @since 2]]>
      </doc>
    </method>
    <method name="forArray" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterator containing the elements of {@code array} in order. The
 returned iterator is a view of the array; subsequent changes to the array
 will be reflected in the iterator.

 <p><b>Note:</b> It is often preferable to represent your data using a
 collection type, for example using {@link Arrays#asList(Object[])}, making
 this method unnecessary.

 <p>The {@code Iterable} equivalent of this method is either {@link
 Arrays#asList(Object[])}, {@link ImmutableList#copyOf(Object[])}},
 or {@link ImmutableList#of}.]]>
      </doc>
    </method>
    <method name="singletonIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Returns an iterator containing only {@code value}.

 <p>The {@link Iterable} equivalent of this method is {@link
 Collections#singleton}.]]>
      </doc>
    </method>
    <method name="forEnumeration" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumeration" type="java.util.Enumeration&lt;T&gt;"/>
      <doc>
      <![CDATA[Adapts an {@code Enumeration} to the {@code Iterator} interface.

 <p>This method has no equivalent in {@link Iterables} because viewing an
 {@code Enumeration} as an {@code Iterable} is impossible. However, the
 contents can be <i>copied</i> into a collection using {@link
 Collections#list}.]]>
      </doc>
    </method>
    <method name="asEnumeration" return="java.util.Enumeration&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Adapts an {@code Iterator} to the {@code Enumeration} interface.

 <p>The {@code Iterable} equivalent of this method is either {@link
 Collections#enumeration} (if you have a {@link Collection}), or
 {@code Iterators.asEnumeration(collection.iterator())}.]]>
      </doc>
    </method>
    <method name="peekingIterator" return="com.google.common.collect.PeekingIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a {@code PeekingIterator} backed by the given iterator.

 <p>Calls to the {@code peek} method with no intervening calls to {@code
 next} do not affect the iteration, and hence return the same object each
 time. A subsequent call to {@code next} is guaranteed to return the same
 object again. For example: <pre>   {@code

   PeekingIterator<String> peekingIterator =
       Iterators.peekingIterator(Iterators.forArray("a", "b"));
   String a1 = peekingIterator.peek(); // returns "a"
   String a2 = peekingIterator.peek(); // also returns "a"
   String a3 = peekingIterator.next(); // also returns "a"}</pre>

 Any structural changes to the underlying iteration (aside from those
 performed by the iterator's own {@link PeekingIterator#remove()} method)
 will leave the iterator in an undefined state.

 <p>The returned iterator does not support removal after peeking, as
 explained by {@link PeekingIterator#remove()}.

 <p>Note: If the given iterator is already a {@code PeekingIterator},
 it <i>might</i> be returned to the caller, although this is neither
 guaranteed to occur nor required to be consistent.  For example, this
 method <i>might</i> choose to pass through recognized implementations of
 {@code PeekingIterator} when the behavior of the implementation is
 known to meet the contract guaranteed by this method.

 <p>There is no {@link Iterable} equivalent to this method, so use this
 method to wrap each individual iterator as it is generated.

 @param iterator the backing iterator. The {@link PeekingIterator} assumes
     ownership of this iterator, so users should cease making direct calls
     to it after calling this method.
 @return a peeking iterator backed by that iterator. Apart from the
     additional {@link PeekingIterator#peek()} method, this iterator behaves
     exactly the same as {@code iterator}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class contains static utility methods that operate on or return objects
 of type {@link Iterator}. Except as noted, each method has a corresponding
 {@link Iterable}-based method in the {@link Iterables} class.

 <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators
 produced in this class are <i>lazy</i>, which means that they only advance
 the backing iteration when absolutely necessary.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Iterators -->
  <!-- start class com.google.common.collect.LinkedHashMultimap -->
  <class name="LinkedHashMultimap" extends="com.google.common.collect.AbstractSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultimap} with the default initial
 capacities.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code LinkedHashMultimap} with enough capacity to hold
 the specified numbers of keys and values without rehashing.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code
      expectedValuesPerKey} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code LinkedHashMultimap} with the same mappings as the
 specified multimap. If a key-value mapping appears multiple times in the
 input multimap, it only appears once in the constructed multimap. The new
 multimap has the same {@link Multimap#entries()} iteration order as the
 input multimap, except for excluding duplicate mappings.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If {@code values} is not empty and the multimap already contains a
 mapping for {@code key}, the {@code keySet()} ordering is unchanged.
 However, the provided values always come last in the {@link #entries()} and
 {@link #values()} iteration orderings.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of all key-value pairs. Changes to the returned set will
 update the underlying multimap, and vice versa. The entries set does not
 support the {@code add} or {@code addAll} operations.

 <p>The iterator generated by the returned set traverses the entries in the
 order they were added to the multimap.

 <p>Each entry is an immutable snapshot of a key-value mapping in the
 multimap, taken at the time the entry is returned by a method call to the
 collection or its iterator.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all values in the multimap. Changes to the returned
 collection will update the underlying multimap, and vice versa.

 <p>The iterator generated by the returned collection traverses the values
 in the order they were added to the multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} that does not allow duplicate key-value
 entries and that returns collections whose iterators follow the ordering in
 which the data was added to the multimap.

 <p>The collections returned by {@code keySet}, {@code keys}, and {@code
 asMap} iterate through the keys in the order they were first added to the
 multimap. Similarly, {@code get}, {@code removeAll}, and {@code
 replaceValues} return collections that iterate through the values in the
 order they were added. The collections generated by {@code entries} and
 {@code values} iterate across the key-value mappings in the order they were
 added to the multimap.

 <p>The iteration ordering of the collections generated by {@code keySet},
 {@code keys}, and {@code asMap} has a few subtleties. As long as the set of
 keys remains unchanged, adding or removing mappings does not affect the key
 iteration order. However, if you remove all values associated with a key and
 then add the key back to the multimap, that key will come last in the key
 iteration order.

 <p>The multimap does not store duplicate key-value pairs. Adding a new
 key-value pair equal to an existing key-value pair has no effect.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedSetMultimap}.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedHashMultimap -->
  <!-- start class com.google.common.collect.LinkedHashMultiset -->
  <class name="LinkedHashMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultiset} using the default initial
 capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distinctElements" type="int"/>
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultiset} with the specified expected
 number of distinct elements.

 @param distinctElements the expected number of distinct elements
 @throws IllegalArgumentException if {@code distinctElements} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code LinkedHashMultiset} containing the specified elements.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multiset} implementation with predictable iteration order. Its
 iterator orders elements according to when the first occurrence of the
 element was added. When the multiset contains multiple instances of an
 element, those instances are consecutive in the iteration order. If all
 occurrences of an element are removed, after which that element is added to
 the multiset, the element will appear at the end of the iteration.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedHashMultiset -->
  <!-- start class com.google.common.collect.LinkedListMultimap -->
  <class name="LinkedListMultimap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedListMultimap} with the default initial
 capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code LinkedListMultimap} with enough capacity to hold
 the specified number of keys without rehashing.

 @param expectedKeys the expected number of distinct keys
 @throws IllegalArgumentException if {@code expectedKeys} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code LinkedListMultimap} with the same mappings as the
 specified {@code Multimap}. The new multimap has the same
 {@link Multimap#entries()} iteration order as the input multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Stores a key-value pair in the multimap.

 @param key key to store in the multimap
 @param value value to store in the multimap
 @return {@code true} always]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If any entries for the specified {@code key} already exist in the
 multimap, their values are changed in-place without affecting the iteration
 order.

 <p>The returned list is immutable and implements
 {@link java.util.RandomAccess}.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The returned list is immutable and implements
 {@link java.util.RandomAccess}.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If the multimap is modified while an iteration over the list is in
 progress (except through the iterator's own {@code add}, {@code set} or
 {@code remove} operations) the results of the iteration are undefined.

 <p>The returned list is not serializable and does not have random access.]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator generated by the returned collection traverses the values
 in the order they were added to the multimap.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Collection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator generated by the returned collection traverses the entries
 in the order they were added to the multimap.

 <p>An entry's {@link Entry#getKey} method always returns the same key,
 regardless of what happens subsequently. As long as the corresponding
 key-value mapping is not removed from the multimap, {@link Entry#getValue}
 returns the value from the multimap, which may change over time, and {@link
 Entry#setValue} modifies that value. Removing the mapping from the
 multimap does not alter the value returned by {@code getValue()}, though a
 subsequent {@code setValue()} call won't update the multimap but will lead
 to a revised value being returned by {@code getValue()}.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code ListMultimap} instances are equal if, for each key, they
 contain the same values in the same order. If the value orderings disagree,
 the multimaps will not be considered equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multimap.

 <p>The hash code of a multimap is defined as the hash code of the map view,
 as returned by {@link Multimap#asMap}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the multimap, generated by calling
 {@code toString} on the map returned by {@link Multimap#asMap}.

 @return a string representation of the multimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of {@code ListMultimap} that supports deterministic
 iteration order for both keys and values. The iteration order is preserved
 across non-distinct key values. For example, for the following multimap
 definition: <pre>   {@code

   Multimap<K, V> multimap = LinkedListMultimap.create();
   multimap.put(key1, foo);
   multimap.put(key2, bar);
   multimap.put(key1, baz);}</pre>

 ... the iteration order for {@link #keys()} is {@code [key1, key2, key1]},
 and similarly for {@link #entries()}. Unlike {@link LinkedHashMultimap}, the
 iteration order is kept consistent between keys, entries and values. For
 example, calling: <pre>   {@code

   map.remove(key1, foo);}</pre>

 changes the entries iteration order to {@code [key2=bar, key1=baz]} and the
 key iteration order to {@code [key2, key1]}. The {@link #entries()} iterator
 returns mutable map entries, and {@link #replaceValues} attempts to preserve
 iteration order as much as possible.

 <p>The collections returned by {@link #keySet} and {@link #asMap} iterate
 through the keys in the order they were first added to the multimap.
 Similarly, {@link #get}, {@link #removeAll}, and {@link #replaceValues}
 return collections that iterate through the values in the order they were
 added. The collections generated by {@link #entries}, {@link #keys}, and
 {@link #values} iterate across the key-value mappings in the order they were
 added to the multimap.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>The methods {@link #get}, {@link #keySet}, {@link #keys}, {@link #values},
 {@link #entries}, and {@link #asMap} return collections that are views of the
 multimap. If the multimap is modified while an iteration over any of those
 collections is in progress, except through the iterator's own {@code remove}
 operation, the results of the iteration are undefined.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedListMultimap}.

 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedListMultimap -->
  <!-- start interface com.google.common.collect.ListMultimap -->
  <interface name="ListMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the
 insertion ordering, this method returns a {@link List}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the
 insertion ordering, this method returns a {@link List}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the
 insertion ordering, this method returns a {@link List}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Though the method signature doesn't say so explicitly, the returned map
 has {@link List} values.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code ListMultimap} instances are equal if, for each key, they
 contain the same values in the same order. If the value orderings disagree,
 the multimaps will not be considered equal.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multimap} that can hold duplicate key-value pairs and that maintains
 the insertion ordering of values for a given key.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods
 each return a {@link List} of values. Though the method signature doesn't say
 so explicitly, the map returned by {@link #asMap} has {@code List} values.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.ListMultimap -->
  <!-- start class com.google.common.collect.Lists -->
  <class name="Lists" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code ArrayList} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableList#of()} instead.

 @return a new, empty {@code ArrayList}]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given
 elements.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use an overload of {@link ImmutableList#of()} (for varargs) or
 {@link ImmutableList#copyOf(Object[])} (for an array) instead.

 @param elements the elements that the list should contain, in order
 @return a new {@code ArrayList} containing those elements]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given
 elements.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableList#copyOf(Iterator)} instead.

 @param elements the elements that the list should contain, in order
 @return a new {@code ArrayList} containing those elements]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given
 elements.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableList#copyOf(Iterator)} instead.

 @param elements the elements that the list should contain, in order
 @return a new {@code ArrayList} containing those elements]]>
      </doc>
    </method>
    <method name="newArrayListWithCapacity" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialArraySize" type="int"/>
      <doc>
      <![CDATA[Creates an {@code ArrayList} instance backed by an array of the
 <i>exact</i> size specified; equivalent to
 {@link ArrayList#ArrayList(int)}.

 <p><b>Note:</b> if you know the exact size your list will be, consider
 using a fixed-size list ({@link Arrays#asList(Object[])}) or an {@link
 ImmutableList} instead of a growable {@link ArrayList}.

 <p><b>Note:</b> If you have only an <i>estimate</i> of the eventual size of
 the list, consider padding this estimate by a suitable amount, or simply
 use {@link #newArrayListWithExpectedSize(int)} instead.

 @param initialArraySize the exact size of the initial backing array for
     the returned array list ({@code ArrayList} documentation calls this
     value the "capacity")
 @return a new, empty {@code ArrayList} which is guaranteed not to resize
     itself unless its size reaches {@code initialArraySize + 1}
 @throws IllegalArgumentException if {@code initialArraySize} is negative]]>
      </doc>
    </method>
    <method name="newArrayListWithExpectedSize" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="estimatedSize" type="int"/>
      <doc>
      <![CDATA[Creates an {@code ArrayList} instance sized appropriately to hold an
 <i>estimated</i> number of elements without resizing. A small amount of
 padding is added in case the estimate is low.

 <p><b>Note:</b> If you know the <i>exact</i> number of elements the list
 will hold, or prefer to calculate your own amount of padding, refer to
 {@link #newArrayListWithCapacity(int)}.

 @param estimatedSize an estimate of the eventual {@link List#size()} of
     the new list
 @return a new, empty {@code ArrayList}, sized appropriately to hold the
     estimated number of elements
 @throws IllegalArgumentException if {@code estimatedSize} is negative]]>
      </doc>
    </method>
    <method name="newLinkedList" return="java.util.LinkedList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code LinkedList} instance.

 <p><b>Note:</b> if you need an immutable empty {@link List}, use
 {@link Collections#emptyList} instead.

 @return a new, empty {@code LinkedList}]]>
      </doc>
    </method>
    <method name="newLinkedList" return="java.util.LinkedList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code LinkedList} instance containing the given elements.

 @param elements the elements that the list should contain, in order
 @return a new {@code LinkedList} containing those elements]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="E"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns an unmodifiable list containing the specified first element and
 backed by the specified array of additional elements. Changes to the {@code
 rest} array will be reflected in the returned list. Unlike {@link
 Arrays#asList}, the returned list is unmodifiable.

 <p>This is useful when a varargs method needs to use a signature such as
 {@code (Foo firstFoo, Foo... moreFoos)}, in order to avoid overload
 ambiguity or to enforce a minimum argument count.

 <p>The returned list is serializable and implements {@link RandomAccess}.

 @param first the first element
 @param rest an array of additional elements, possibly empty
 @return an unmodifiable list containing the specified elements]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="E"/>
      <param name="second" type="E"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns an unmodifiable list containing the specified first and second
 element, and backed by the specified array of additional elements. Changes
 to the {@code rest} array will be reflected in the returned list. Unlike
 {@link Arrays#asList}, the returned list is unmodifiable.

 <p>This is useful when a varargs method needs to use a signature such as
 {@code (Foo firstFoo, Foo secondFoo, Foo... moreFoos)}, in order to avoid
 overload ambiguity or to enforce a minimum argument count.

 <p>The returned list is serializable and implements {@link RandomAccess}.

 @param first the first element
 @param second the second element
 @param rest an array of additional elements, possibly empty
 @return an unmodifiable list containing the specified elements]]>
      </doc>
    </method>
    <method name="transform" return="java.util.List&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromList" type="java.util.List&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a list that applies {@code function} to each element of {@code
 fromList}. The returned list is a transformed view of {@code fromList};
 changes to {@code fromList} will be reflected in the returned list and vice
 versa.

 <p>Since functions are not reversible, the transform is one-way and new
 items cannot be stored in the returned list. The {@code add},
 {@code addAll} and {@code set} methods are unsupported in the returned
 list.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned list to be a view, but it means that the function will be
 applied many times for bulk operations like {@link List#contains} and
 {@link List#hashCode}. For this to perform well, {@code function} should be
 fast. To avoid lazy evaluation when the returned list doesn't need to be a
 view, copy the returned list into a new list of your choosing.

 <p>If {@code fromList} implements {@link RandomAccess}, so will the
 returned list. The returned list always implements {@link Serializable},
 but serialization will succeed only when {@code fromList} and
 {@code function} are serializable. The returned list is threadsafe if the
 supplied list and function are.]]>
      </doc>
    </method>
    <method name="partition" return="java.util.List&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,
 each of the same size (the final list may be smaller). For example,
 partitioning a list containing {@code [a, b, c, d, e]} with a partition
 size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing
 two inner lists of three and two elements, all in the original order.

 <p>The outer list is unmodifiable, but reflects the latest state of the
 source list. The inner lists are sublist views of the original list,
 produced on demand using {@link List#subList(int, int)}, and are subject
 to all the usual caveats about modification as explained in that API.

 @param list the list to return consecutive sublists of
 @param size the desired size of each sublist (the last may be
     smaller)
 @return a list of consecutive sublists
 @throws IllegalArgumentException if {@code partitionSize} is nonpositive]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link List} instances. Also see this
 class's counterparts {@link Sets} and {@link Maps}.

 @author Kevin Bourrillion
 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Lists -->
  <!-- start interface com.google.common.collect.MapConstraint -->
  <interface name="MapConstraint"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="checkKeyValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Throws a suitable {@code RuntimeException} if the specified key or value is
 illegal. Typically this is either a {@link NullPointerException}, an
 {@link IllegalArgumentException}, or a {@link ClassCastException}, though
 an application-specific exception class may be used if appropriate.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a brief human readable description of this constraint, such as
 "Not null".]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constraint on the keys and values that may be added to a {@code Map} or
 {@code Multimap}. For example, {@link MapConstraints#notNull()}, which
 prevents a map from including any null keys or values, could be implemented
 like this: <pre>   {@code

   public void checkKeyValue(Object key, Object value) {
     if (key == null || value == null) {
       throw new NullPointerException();
     }
   }}</pre>

 In order to be effective, constraints should be deterministic; that is, they
 should not depend on state that can change (such as external state, random
 variables, and time) and should only depend on the value of the passed-in key
 and value. A non-deterministic constraint cannot reliably enforce that all
 the collection's elements meet the constraint, since the constraint is only
 enforced when elements are added.

 @author Mike Bostock
 @see MapConstraints
 @see Constraint
 @since 3]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapConstraint -->
  <!-- start class com.google.common.collect.MapConstraints -->
  <class name="MapConstraints" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="notNull" return="com.google.common.collect.MapConstraint&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a constraint that verifies that neither the key nor the value is
 null. If either is null, a {@link NullPointerException} is thrown.]]>
      </doc>
    </method>
    <method name="constrainedMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified map, using the specified
 constraint. Any operations that add new mappings will call the provided
 constraint. However, this method does not verify that existing mappings
 satisfy the constraint.

 <p>The returned map is not serializable.

 @param map the map to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified map]]>
      </doc>
    </method>
    <method name="constrainedMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified multimap, using the specified
 constraint. Any operations that add new mappings will call the provided
 constraint. However, this method does not verify that existing mappings
 satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.

 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the multimap]]>
      </doc>
    </method>
    <method name="constrainedListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified list multimap, using the
 specified constraint. Any operations that add new mappings will call the
 provided constraint. However, this method does not verify that existing
 mappings satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.

 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified multimap]]>
      </doc>
    </method>
    <method name="constrainedSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified set multimap, using the
 specified constraint. Any operations that add new mappings will call the
 provided constraint. However, this method does not verify that existing
 mappings satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.
 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified multimap]]>
      </doc>
    </method>
    <method name="constrainedSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified sorted-set multimap, using the
 specified constraint. Any operations that add new mappings will call the
 provided constraint. However, this method does not verify that existing
 mappings satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.
 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified multimap]]>
      </doc>
    </method>
    <method name="constrainedBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified bimap, using the specified
 constraint. Any operations that modify the bimap will have the associated
 keys and values verified with the constraint.

 <p>The returned bimap is not serializable.

 @param map the bimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified bimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory and utilities pertaining to the {@code MapConstraint} interface.

 @see Constraints
 @author Mike Bostock
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MapConstraints -->
  <!-- start interface com.google.common.collect.MapDifference -->
  <interface name="MapDifference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="areEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there are no differences between the two maps;
 that is, if the maps are equal.]]>
      </doc>
    </method>
    <method name="entriesOnlyOnLeft" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries from the left map whose
 keys are not present in the right map.]]>
      </doc>
    </method>
    <method name="entriesOnlyOnRight" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries from the right map whose
 keys are not present in the left map.]]>
      </doc>
    </method>
    <method name="entriesInCommon" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries that appear in both
 maps; that is, the intersection of the two maps.]]>
      </doc>
    </method>
    <method name="entriesDiffering" return="java.util.Map&lt;K, com.google.common.collect.MapDifference.ValueDifference&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map describing keys that appear in both maps, but
 with different values.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this instance for equality. Returns
 {@code true} if the given object is also a {@code MapDifference} and the
 values returned by the {@link #entriesOnlyOnLeft()}, {@link
 #entriesOnlyOnRight()}, {@link #entriesInCommon()} and {@link
 #entriesDiffering()} of the two instances are equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this instance. This is defined as the hash code
 of <pre>   {@code

   Arrays.asList(entriesOnlyOnLeft(), entriesOnlyOnRight(),
       entriesInCommon(), entriesDiffering())}</pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object representing the differences between two maps.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapDifference -->
  <!-- start interface com.google.common.collect.MapDifference.ValueDifference -->
  <interface name="MapDifference.ValueDifference"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="leftValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value from the left map (possibly null).]]>
      </doc>
    </method>
    <method name="rightValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value from the right map (possibly null).]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two instances are considered equal if their {@link #leftValue()}
 values are equal and their {@link #rightValue()} values are also equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hash code equals the value
 {@code Arrays.asList(leftValue(), rightValue()).hashCode()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A difference between the mappings from two maps with the same key. The
 {@code leftValue()} and {@code rightValue} are not equal, and one but not
 both of them may be null.]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapDifference.ValueDifference -->
  <!-- start class com.google.common.collect.MapMaker -->
  <class name="MapMaker" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapMaker"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@code MapMaker} instance with default settings,
 including strong keys, strong values, and no automatic expiration.]]>
      </doc>
    </constructor>
    <method name="initialCapacity" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Sets a custom initial capacity (defaults to 16). Resizing this or
 any other kind of hash table is a relatively slow operation, so,
 when possible, it is a good idea to provide estimates of expected
 table sizes.

 @throws IllegalArgumentException if {@code initialCapacity} is
   negative
 @throws IllegalStateException if an initial capacity was already set]]>
      </doc>
    </method>
    <method name="concurrencyLevel" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="concurrencyLevel" type="int"/>
      <doc>
      <![CDATA[Guides the allowed concurrency among update operations. Used as a
 hint for internal sizing. The table is internally partitioned to try
 to permit the indicated number of concurrent updates without
 contention.  Because placement in hash tables is essentially random,
 the actual concurrency will vary. Ideally, you should choose a value
 to accommodate as many threads as will ever concurrently modify the
 table. Using a significantly higher value than you need can waste
 space and time, and a significantly lower value can lead to thread
 contention. But overestimates and underestimates within an order of
 magnitude do not usually have much noticeable impact. A value of one
 is appropriate when it is known that only one thread will modify and
 all others will only read. Defaults to 16.

 @throws IllegalArgumentException if {@code concurrencyLevel} is
     nonpositive
 @throws IllegalStateException if a concurrency level was already set]]>
      </doc>
    </method>
    <method name="weakKeys" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each key (not value) stored in the map should be
 wrapped in a {@link WeakReference} (by default, strong references
 are used).

 <p><b>Note:</b> the map will use identity ({@code ==}) comparison
 to determine equality of weak keys, which may not behave as you expect.
 For example, storing a key in the map and then attempting a lookup
 using a different but {@link Object#equals(Object) equals}-equivalent
 key will always fail.

 @throws IllegalStateException if the key strength was already set
 @see WeakReference]]>
      </doc>
    </method>
    <method name="softKeys" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each key (not value) stored in the map should be
 wrapped in a {@link SoftReference} (by default, strong references
 are used).

 <p><b>Note:</b> the map will use identity ({@code ==}) comparison
 to determine equality of soft keys, which may not behave as you expect.
 For example, storing a key in the map and then attempting a lookup
 using a different but {@link Object#equals(Object) equals}-equivalent
 key will always fail.

 @throws IllegalStateException if the key strength was already set
 @see SoftReference]]>
      </doc>
    </method>
    <method name="weakValues" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the map should be
 wrapped in a {@link WeakReference} (by default, strong references
 are used).

 <p>Weak values will be garbage collected once they are weakly
 reachable. This makes them a poor candidate for caching; consider
 {@link #softValues()} instead.

 <p><b>Note:</b> the map will use identity ({@code ==}) comparison
 to determine equality of weak values. This will notably impact
 the behavior of {@link Map#containsValue(Object) containsValue},
 {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)},
 and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}.

 @throws IllegalStateException if the key strength was already set
 @see WeakReference]]>
      </doc>
    </method>
    <method name="softValues" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the map should be
 wrapped in a {@link SoftReference} (by default, strong references
 are used).

 <p>Soft values will be garbage collected in response to memory
 demand, and in a least-recently-used manner. This makes them a
 good candidate for caching.

 <p><b>Note:</b> the map will use identity ({@code ==}) comparison
 to determine equality of soft values. This will notably impact
 the behavior of {@link Map#containsValue(Object) containsValue},
 {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)},
 and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}.

 @throws IllegalStateException if the value strength was already set
 @see SoftReference]]>
      </doc>
    </method>
    <method name="expiration" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Specifies that each entry should be automatically removed from the
 map once a fixed duration has passed since the entry's creation.
 Note that changing the value of an entry will reset its expiration
 time.

 @param duration the length of time after an entry is created that it
     should be automatically removed
 @param unit the unit that {@code duration} is expressed in
 @throws IllegalArgumentException if {@code duration} is not positive
 @throws IllegalStateException if the expiration time was already set]]>
      </doc>
    </method>
    <method name="makeMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a map, without on-demand computation of values. This method
 does not alter the state of this {@code MapMaker} instance, so it can be
 invoked again to create multiple independent maps.

 @param <K> the type of keys to be stored in the returned map
 @param <V> the type of values to be stored in the returned map
 @return a serializable concurrent map having the requested features]]>
      </doc>
    </method>
    <method name="makeComputingMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="computingFunction" type="com.google.common.base.Function&lt;? super K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Builds a map that supports atomic, on-demand computation of values. {@link
 Map#get} either returns an already-computed value for the given key,
 atomically computes it using the supplied function, or, if another thread
 is currently computing the value for this key, simply waits for that thread
 to finish and returns its computed value. Note that the function may be
 executed concurrently by multiple threads, but only for distinct keys.

 <p>If an entry's value has not finished computing yet, query methods
 besides {@code get} return immediately as if an entry doesn't exist. In
 other words, an entry isn't externally visible until the value's
 computation completes.

 <p>{@link Map#get} on the returned map will never return {@code null}. It
 may throw:

 <ul>
 <li>{@link NullPointerException} if the key is null or the computing
     function returns null
 <li>{@link ComputationException} if an exception was thrown by the
     computing function. If that exception is already of type {@link
     ComputationException} it is propagated directly; otherwise it is
     wrapped.
 </ul>

 <p><b>Note:</b> Callers of {@code get} <i>must</i> ensure that the key
 argument is of type {@code K}. The {@code get} method accepts {@code
 Object}, so the key type is not checked at compile time. Passing an object
 of a type other than {@code K} can result in that object being unsafely
 passed to the computing function as type {@code K}, and unsafely stored in
 the map.

 <p>If {@link Map#put} is called before a computation completes, other
 threads waiting on the computation will wake up and return the stored
 value. When the computation completes, its new result will overwrite the
 value that was put in the map manually.

 <p>This method does not alter the state of this {@code MapMaker} instance,
 so it can be invoked again to create multiple independent maps.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>A {@link ConcurrentMap} builder, providing any combination of these
 features: {@linkplain SoftReference soft} or {@linkplain WeakReference
 weak} keys, soft or weak values, timed expiration, and on-demand
 computation of values. Usage example: <pre> {@code

   ConcurrentMap<Key, Graph> graphs = new MapMaker()
       .concurrencyLevel(32)
       .softKeys()
       .weakValues()
       .expiration(30, TimeUnit.MINUTES)
       .makeComputingMap(
           new Function<Key, Graph>() {
             public Graph apply(Key key) {
               return createExpensiveGraph(key);
             }
           });}</pre>

 These features are all optional; {@code new MapMaker().makeMap()}
 returns a valid concurrent map that behaves exactly like a
 {@link ConcurrentHashMap}.

 The returned map is implemented as a hash table with similar performance
 characteristics to {@link ConcurrentHashMap}. It supports all optional
 operations of the {@code ConcurrentMap} interface. It does not permit
 null keys or values. It is serializable; however, serializing a map that
 uses soft or weak references can give unpredictable results.

 <p><b>Note:</b> by default, the returned map uses equality comparisons
 (the {@link Object#equals(Object) equals} method) to determine equality
 for keys or values. However, if {@link #weakKeys()} or {@link
 #softKeys()} was specified, the map uses identity ({@code ==})
 comparisons instead for keys. Likewise, if {@link #weakValues()} or
 {@link #softValues()} was specified, the map uses identity comparisons
 for values.

 <p>The returned map has <i>weakly consistent iteration</i>: an iterator
 over one of the map's view collections may reflect some, all or none of
 the changes made to the map after the iterator was created.

 <p>An entry whose key or value is reclaimed by the garbage collector
 immediately disappears from the map. (If the default settings of strong
 keys and strong values are used, this will never happen.) The client can
 never observe a partially-reclaimed entry. Any {@link java.util.Map.Entry}
 instance retrieved from the map's {@linkplain Map#entrySet() entry set}
 is a snapshot of that entry's state at the time of retrieval; such entries
 do, however, support {@link java.util.Map.Entry#setValue}.

 <p>{@code new MapMaker().weakKeys().makeMap()} can almost always be
 used as a drop-in replacement for {@link java.util.WeakHashMap}, adding
 concurrency, asynchronous cleanup, identity-based equality for keys, and
 great flexibility.

 @author Bob Lee
 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MapMaker -->
  <!-- start class com.google.common.collect.Maps -->
  <class name="Maps" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newHashMap" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code HashMap} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#of()} instead.

 <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link
 #newEnumMap} instead.

 @return a new, empty {@code HashMap}]]>
      </doc>
    </method>
    <method name="newHashMapWithExpectedSize" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates a {@code HashMap} instance with enough capacity to hold the
 specified number of elements without rehashing.

 @param expectedSize the expected size
 @return a new, empty {@code HashMap} with enough capacity to hold {@code
         expectedSize} elements without rehashing
 @throws IllegalArgumentException if {@code expectedSize} is negative]]>
      </doc>
    </method>
    <method name="newHashMap" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as
 the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#copyOf(Map)} instead.

 <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link
 #newEnumMap} instead.

 @param map the mappings to be placed in the new map
 @return a new {@code HashMap} initialized with the mappings from {@code
         map}]]>
      </doc>
    </method>
    <method name="newLinkedHashMap" return="java.util.LinkedHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}
 instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#of()} instead.

 @return a new, empty {@code LinkedHashMap}]]>
      </doc>
    </method>
    <method name="newLinkedHashMap" return="java.util.LinkedHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance
 with the same mappings as the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#copyOf(Map)} instead.

 @param map the mappings to be placed in the new map
 @return a new, {@code LinkedHashMap} initialized with the mappings from
         {@code map}]]>
      </doc>
    </method>
    <method name="newConcurrentMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a general-purpose instance of {@code ConcurrentMap}, which supports
 all optional operations of the ConcurrentMap interface. It does not permit
 null keys or values. It is serializable.

 <p>This is currently accomplished by calling {@link MapMaker#makeMap()}.

 <p>It is preferable to use {@code MapMaker} directly (rather than through
 this method), as it presents numerous useful configuration options,
 such as the concurrency level, load factor, key/value reference types,
 and value computation.

 @return a new, empty {@code ConcurrentMap}
 @since 3]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural
 ordering of its elements.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedMap#of()} instead.

 @return a new, empty {@code TreeMap}]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as
 the specified map and using the same ordering as the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedMap#copyOfSorted(SortedMap)} instead.

 @param map the sorted map whose mappings are to be placed in the new map
        and whose comparator is to be used to sort the new map
 @return a new {@code TreeMap} initialized with the mappings from {@code
         map} and using the comparator of {@code map}]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;C&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given
 comparator.

 <p><b>Note:</b> if mutability is not required, use {@code
 ImmutableSortedMap.orderedBy(comparator).build()} instead.

 @param comparator the comparator to sort the keys with
 @return a new, empty {@code TreeMap}]]>
      </doc>
    </method>
    <method name="newEnumMap" return="java.util.EnumMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;K&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumMap} instance.

 @param type the key type for this map
 @return a new, empty {@code EnumMap}]]>
      </doc>
    </method>
    <method name="newEnumMap" return="java.util.EnumMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumMap} with the same mappings as the specified map.

 @param map the map from which to initialize this {@code EnumMap}
 @return a new {@code EnumMap} initialized with the mappings from {@code
         map}
 @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}
         instance and contains no mappings]]>
      </doc>
    </method>
    <method name="newIdentityHashMap" return="java.util.IdentityHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an {@code IdentityHashMap} instance.

 @return a new, empty {@code IdentityHashMap}]]>
      </doc>
    </method>
    <method name="synchronizedBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bimap" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) bimap backed by the specified bimap.
 In order to guarantee serial access, it is critical that <b>all</b> access
 to the backing bimap is accomplished through the returned bimap.

 <p>It is imperative that the user manually synchronize on the returned map
 when accessing any of its collection views: <pre>   {@code

   BiMap<Long, String> map = Maps.synchronizedBiMap(
       HashBiMap.<Long, String>create());
    ...
   Set<Long> set = map.keySet();  // Needn't be in synchronized block
    ...
   synchronized (map) {  // Synchronizing on map, not set!
     Iterator<Long> it = set.iterator(); // Must be in synchronized block
     while (it.hasNext()) {
       foo(it.next());
     }
   }}</pre>

 Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned bimap will be serializable if the specified bimap is
 serializable.

 @param bimap the bimap to be wrapped in a synchronized view
 @return a sychronized view of the specified bimap]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.MapDifference&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="right" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Computes the difference between two maps. This difference is an immutable
 snapshot of the state of the maps at the time this method is called. It
 will never change, even if the maps change at a later time.

 <p>Since this method uses {@code HashMap} instances internally, the keys of
 the supplied maps must be well-behaved with respect to
 {@link Object#equals} and {@link Object#hashCode}.

 <p><b>Note:</b>If you only need to know whether two maps have the same
 mappings, call {@code left.equals(right)} instead of this method.

 @param left the map to treat as the "left" map for purposes of comparison
 @param right the map to treat as the "right" map for purposes of comparison
 @return the difference between the two maps]]>
      </doc>
    </method>
    <method name="uniqueIndex" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map for which the {@link Map#values} are the given
 elements in the given order, and each key is the product of invoking a
 supplied function on its corresponding value.

 @param values the values to use when constructing the {@code Map}
 @param keyFunction the function used to produce the key for each value
 @return a map mapping the result of evaluating the function {@code
         keyFunction} on each value in the input collection to that value
 @throws IllegalArgumentException if {@code keyFunction} produces the same
         key for more than one value in the input collection
 @throws NullPointerException if any elements of {@code values} is null, or
         if {@code keyFunction} produces {@code null} for any value]]>
      </doc>
    </method>
    <method name="fromProperties" return="com.google.common.collect.ImmutableMap&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates an {@code ImmutableMap<String, String>} from a {@code Properties}
 instance. Properties normally derive from {@code Map<Object, Object>}, but
 they typically contain strings, which is awkward. This method lets you get
 a plain-old-{@code Map} out of a {@code Properties}.

 @param properties a {@code Properties} object to be converted
 @return an immutable map containing all the entries in {@code properties}
 @throws ClassCastException if any key in {@code Properties} is not a {@code
         String}
 @throws NullPointerException if any key or value in {@code Properties} is
         null]]>
      </doc>
    </method>
    <method name="immutableEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map entry with the specified key and value. The {@link
 Entry#setValue} operation throws an {@link UnsupportedOperationException}.

 <p>The returned entry is serializable.

 @param key the key to be associated with the returned entry
 @param value the value to be associated with the returned entry]]>
      </doc>
    </method>
    <method name="unmodifiableBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bimap" type="com.google.common.collect.BiMap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified bimap. This method allows
 modules to provide users with "read-only" access to internal bimaps. Query
 operations on the returned bimap "read through" to the specified bimap, and
 attemps to modify the returned map, whether direct or via its collection
 views, result in an {@code UnsupportedOperationException}.

 <p>The returned bimap will be serializable if the specified bimap is
 serializable.

 @param bimap the bimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified bimap]]>
      </doc>
    </method>
    <method name="transformValues" return="java.util.Map&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.Map&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a map where each value is transformed by a function. All
 other properties of the map, such as iteration order, are left intact. For
 example, the code: <pre>   {@code

   Map<String, Integer> map = ImmutableMap.of("a", 4, "b", 9);
   Function<Integer, Double> sqrt =
       new Function<Integer, Double>() {
         public Double apply(Integer in) {
           return Math.sqrt((int) in);
         }
       };
   Map<String, Double> transformed = Maps.transformValues(map, sqrt);
   System.out.println(transformed);}</pre>

 ... prints {@code {a=2.0, b=3.0}}.

 <p>Changes in the underlying map are reflected in this view. Conversely,
 this view supports removal operations, and these are reflected in the
 underlying map.

 <p>It's acceptable for the underlying map to contain null keys, and even
 null values provided that the function is capable of accepting null input.
 The transformed map might contain null values, if the function sometimes
 gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the
 underlying map is.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned map to be a view, but it means that the function will be
 applied many times for bulk operations like {@link Map#containsValue} and
 {@code Map.toString()}. For this to perform well, {@code function} should
 be fast. To avoid lazy evaluation when the returned map doesn't need to be
 a view, copy the returned map into a new map of your choosing.]]>
      </doc>
    </method>
    <method name="filterKeys" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} whose keys
 satisfy a predicate. The returned map is a live view of {@code unfiltered};
 changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. The map's {@code
 put()} and {@code putAll()} methods throw an {@link
 IllegalArgumentException} if a key that doesn't satisfy the predicate is
 provided.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings whose keys satisfy the
 filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.]]>
      </doc>
    </method>
    <method name="filterValues" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} whose values
 satisfy a predicate. The returned map is a live view of {@code unfiltered};
 changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. The {@link Map#put},
 {@link Map#putAll}, and {@link Entry#setValue} methods throw an {@link
 IllegalArgumentException} if a value that doesn't satisfy the predicate is
 provided.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings whose values satisfy the
 filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.]]>
      </doc>
    </method>
    <method name="filterEntries" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} that satisfy a
 predicate. The returned map is a live view of {@code unfiltered}; changes
 to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. The map's {@code
 put()} and {@code putAll()} methods throw an {@link
 IllegalArgumentException} if a key/value pair that doesn't satisfy the
 predicate is provided. Similarly, the map's entries have a {@link
 Entry#setValue} method that throws an {@link IllegalArgumentException} when
 the existing key and the provided value don't satisfy the predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings that satisfy the filter
 will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Map} instances. Also see this
 class's counterparts {@link Lists} and {@link Sets}.

 @author Kevin Bourrillion
 @author Mike Bostock
 @author Isaac Shum
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Maps -->
  <!-- start interface com.google.common.collect.Multimap -->
  <interface name="Multimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value pairs in the multimap.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains no key-value pairs.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains any values for the specified
 key.

 @param key key to search for in multimap]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains the specified value for any
 key.

 @param value value to search for in multimap]]>
      </doc>
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains the specified key-value pair.

 @param key key to search for in multimap
 @param value value to search for in multimap]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Stores a key-value pair in the multimap.

 <p>Some multimap implementations allow duplicate key-value pairs, in which
 case {@code put} always adds a new key-value pair and increases the
 multimap size by 1. Other implementations prohibit duplicates, and storing
 a key-value pair that's already in the multimap has no effect.

 @param key key to store in the multimap
 @param value value to store in the multimap
 @return {@code true} if the method increased the size of the multimap, or
     {@code false} if the multimap already contained the key-value pair and
     doesn't allow duplicates]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes a key-value pair from the multimap.

 @param key key of entry to remove from the multimap
 @param value value of entry to remove the multimap
 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key.

 @param key key to store in the multimap
 @param values values to store in the multimap
 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Copies all of another multimap's key-value pairs into this multimap. The
 order in which the mappings are added is determined by
 {@code multimap.entries()}.

 @param multimap mappings to store in this multimap
 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key, replacing any existing
 values for that key.

 @param key key to store in the multimap
 @param values values to store in the multimap
 @return the collection of replaced values, or an empty collection if no
     values were previously associated with the key. The collection
     <i>may</i> be modifiable, but updating it will have no effect on the
     multimap.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes all values associated with a given key.

 @param key key of entries to remove from the multimap
 @return the collection of removed values, or an empty collection if no
     values were associated with the provided key. The collection
     <i>may</i> be modifiable, but updating it will have no effect on the
     multimap.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all key-value pairs from the multimap.]]>
      </doc>
    </method>
    <method name="get" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns a collection view of all values associated with a key. If no
 mappings in the multimap have the provided key, an empty collection is
 returned.

 <p>Changes to the returned collection will update the underlying multimap,
 and vice versa.

 @param key key to search for in multimap
 @return the collection of values that the key maps to]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of all keys, each appearing once in the returned set.
 Changes to the returned set will update the underlying multimap, and vice
 versa.

 @return the collection of distinct keys]]>
      </doc>
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection, which may contain duplicates, of all keys. The number
 of times of key appears in the returned multiset equals the number of
 mappings the key has in the multimap. Changes to the returned multiset will
 update the underlying multimap, and vice versa.

 @return a multiset with keys corresponding to the distinct keys of the
     multimap and frequencies corresponding to the number of values that
     each key maps to]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all values in the multimap. Changes to the returned
 collection will update the underlying multimap, and vice versa.

 @return collection of values, which may include the same value multiple
     times if it occurs in multiple mappings]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Collection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all key-value pairs. Changes to the returned
 collection will update the underlying multimap, and vice versa. The entries
 collection does not support the {@code add} or {@code addAll} operations.

 @return collection of map entries consisting of key-value pairs]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map view that associates each key with the corresponding values
 in the multimap. Changes to the returned map, such as element removal,
 will update the underlying multimap. The map does not support
 {@code setValue()} on its entries, {@code put}, or {@code putAll}.

 <p>The collections returned by {@code asMap().get(Object)} have the same
 behavior as those returned by {@link #get}.

 @return a map view from a key to its collection of values]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this multimap for equality. Two
 multimaps are equal when their map views, as returned by {@link #asMap},
 are also equal.

 <p>In general, two multimaps with identical key-value mappings may or may
 not be equal, depending on the implementation. For example, two
 {@link SetMultimap} instances with the same key-value mappings are equal,
 but equality of two {@link ListMultimap} instances depends on the ordering
 of the values for each key.

 <p>A non-empty {@link SetMultimap} cannot be equal to a non-empty
 {@link ListMultimap}, since their {@link #asMap} views contain unequal
 collections as values. However, any two empty multimaps are equal, because
 they both have empty {@link #asMap} views.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multimap.

 <p>The hash code of a multimap is defined as the hash code of the map view,
 as returned by {@link Multimap#asMap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection similar to a {@code Map}, but which may associate multiple
 values with a single key. If you call {@link #put} twice, with the same key
 but different values, the multimap contains mappings from the key to both
 values.

 <p>The methods {@link #get}, {@link #keySet}, {@link #keys}, {@link #values},
 {@link #entries}, and {@link #asMap} return collections that are views of the
 multimap. If the multimap is modifiable, updating it can change the contents
 of those collections, and updating the collections will change the multimap.
 In contrast, {@link #replaceValues} and {@link #removeAll} return collections
 that are independent of subsequent multimap changes.

 <p>Depending on the implementation, a multimap may or may not allow duplicate
 key-value pairs. In other words, the multimap contents after adding the same
 key and value twice varies between implementations. In multimaps allowing
 duplicates, the multimap will contain two mappings, and {@code get} will
 return a collection that includes the value twice. In multimaps not
 supporting duplicates, the multimap will contain a single mapping from the
 key to the value, and {@code get} will return a collection that includes the
 value once.

 <p>All methods that alter the multimap are optional, and the views returned
 by the multimap may or may not be modifiable. When modification isn't
 supported, those methods will throw an {@link UnsupportedOperationException}.

 @author Jared Levy
 @param <K> the type of keys maintained by this multimap
 @param <V> the type of mapped values
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multimap -->
  <!-- start class com.google.common.collect.Multimaps -->
  <class name="Multimaps" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Collection&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code Multimap} that uses the provided map and factory. It
 can generate a multimap based on arbitrary {@link Map} and
 {@link Collection} classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()}
 does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 collections generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedMultimap}.

 <p>Call this method only when the simpler methods
 {@link ArrayListMultimap#create()}, {@link HashMultimap#create()},
 {@link LinkedHashMultimap#create()}, {@link LinkedListMultimap#create()},
 {@link TreeMultimap#create()}, and
 {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the collections returned by {@code factory}. Those objects should not be
 manually updated and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty collections that will each hold all
     values for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.List&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListMultimap} that uses the provided map and factory.
 It can generate a multimap based on arbitrary {@link Map} and {@link List}
 classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. The multimap's {@code get}, {@code
 removeAll}, and {@code replaceValues} methods return {@code RandomAccess}
 lists if the factory does. However, the multimap's {@code get} method
 returns instances of a different class than does {@code factory.get()}.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 lists generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedListMultimap}.

 <p>Call this method only when the simpler methods
 {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}
 won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the lists returned by {@code factory}. Those objects should not be manually
 updated and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty lists that will each hold all values
     for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Set&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code SetMultimap} that uses the provided map and factory.
 It can generate a multimap based on arbitrary {@link Map} and {@link Set}
 classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()}
 does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 sets generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedSetMultimap}.

 <p>Call this method only when the simpler methods
 {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},
 {@link TreeMultimap#create()}, and
 {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the sets returned by {@code factory}. Those objects should not be manually
 updated and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty sets that will each hold all values
     for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.SortedSet&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code SortedSetMultimap} that uses the provided map and
 factory. It can generate a multimap based on arbitrary {@link Map} and
 {@link SortedSet} classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()}
 does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 sets generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedSortedSetMultimap}.

 <p>Call this method only when the simpler methods
 {@link TreeMultimap#create()} and
 {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the sets returned by {@code factory}. Those objects should not be manually
 updated and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty sorted sets that will each hold
     all values for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="invertFrom" return="M extends com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.common.collect.Multimap&lt;? extends V, ? extends K&gt;"/>
      <param name="dest" type="M extends com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Copies each key-value mapping in {@code source} into {@code dest}, with
 its key and value reversed.

 @param source any multimap
 @param dest the multimap to copy into; usually empty
 @return {@code dest}]]>
      </doc>
    </method>
    <method name="synchronizedMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) multimap backed by the specified
 multimap. In order to guarantee serial access, it is critical that
 <b>all</b> access to the backing multimap is accomplished through the
 returned multimap.

 <p>It is imperative that the user manually synchronize on the returned
 multimap when accessing any of its collection views: <pre>  {@code

  Multimap<K, V> m = Multimaps.synchronizedMultimap(
      HashMultimap.<K, V>create());
  ...
  Set<K> s = m.keySet();  // Needn't be in synchronized block
  ...
  synchronized (m) {  // Synchronizing on m, not s!
    Iterator<K> i = s.iterator(); // Must be in synchronized block
    while (i.hasNext()) {
      foo(i.next());
    }
  }}</pre>

 Failure to follow this advice may result in non-deterministic behavior.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that aren't
 synchronized.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param multimap the multimap to be wrapped in a synchronized view
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified multimap. Query operations on
 the returned multimap "read through" to the specified multimap, and
 attempts to modify the returned multimap, either directly or through the
 multimap's views, result in an {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="synchronizedSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code SetMultimap} backed by the
 specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code SetMultimap}. Query
 operations on the returned multimap "read through" to the specified
 multimap, and attempts to modify the returned multimap, either directly or
 through the multimap's views, result in an
 {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="synchronizedSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by
 the specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code SortedSetMultimap}.
 Query operations on the returned multimap "read through" to the specified
 multimap, and attempts to modify the returned multimap, either directly or
 through the multimap's views, result in an
 {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="synchronizedListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code ListMultimap} backed by the
 specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code ListMultimap}. Query
 operations on the returned multimap "read through" to the specified
 multimap, and attempts to modify the returned multimap, either directly or
 through the multimap's views, result in an
 {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a multimap view of the specified map. The multimap is backed by the
 map, so changes to the map are reflected in the multimap, and vice versa.
 If the map is modified while an iteration over one of the multimap's
 collection views is in progress (except through the iterator's own {@code
 remove} operation, or through the {@code setValue} operation on a map entry
 returned by the iterator), the results of the iteration are undefined.

 <p>The multimap supports mapping removal, which removes the corresponding
 mapping from the map. It does not support any operations which might add
 mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.

 <p>The returned multimap will be serializable if the specified map is
 serializable.

 @param map the backing map for the returned multimap view]]>
      </doc>
    </method>
    <method name="index" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Creates an index {@code ImmutableMultimap} that contains the results of
 applying a specified function to each item in an {@code Iterable} of
 values. Each value will be stored as a value in the resulting multimap,
 yielding a multimap with the same size as the input iterable. The key used
 to store that value in the multimap will be the result of calling the
 function on that value. The resulting multimap is created as an immutable
 snapshot, it does <em>not</em> reflect subsequent changes on the input
 iterable.

 <p>For example, <pre class="code">  {@code

  List<String> badGuys
      = Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
  Function<String, Integer> stringLengthFunction = ...;
  Multimap<Integer, String> index
      = Multimaps.index(badGuys, stringLengthFunction);
  System.out.println(index);}</pre>

 prints <pre class="code">  {@code

  {4=[Inky], 5=[Pinky, Pinky, Clyde], 6=[Blinky]}}</pre>

 <p>The returned multimap is serializable if its keys and values are all
 serializable.

 @param values the values to use when constructing the {@code
     ImmutableMultimap}
 @param keyFunction the function used to produce the key for each value
 @return {@code ImmutableMultimap} mapping the result of evaluating the
     function {@code keyFunction} on each value in the input collection to
     that value
 @throws NullPointerException if any of the following cases is true: <ul>
 <li> {@code values} is null
 <li> {@code keyFunction} is null
 <li> An element in {@code values} is null
 <li> {@code keyFunction} returns null for any element of {@code values}
 </ul>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods acting on or generating a {@code Multimap}.

 @author Jared Levy
 @author Robert Konigsberg
 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Multimaps -->
  <!-- start interface com.google.common.collect.Multiset -->
  <interface name="Multiset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of occurrences of an element in this multiset (the
 <i>count</i> of the element). Note that for an {@link Object#equals}-based
 multiset, this gives the same result as {@link Collections#frequency}
 (which would presumably perform more poorly).

 <p><b>Note:</b> the utility method {@link Iterables#frequency} generalizes
 this operation; it correctly delegates to this method when dealing with a
 multiset, but it can also accept any other iterable type.

 @param element the element to count occurrences of
 @return the number of occurrences of the element in this multiset; possibly
     zero but never negative]]>
      </doc>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this multiset. Note that if
 {@code occurrences == 1}, this method has the identical effect to {@link
 #add(Object)}. This method is functionally equivalent (except in the case
 of overflow) to the call {@code addAll(Collections.nCopies(element,
 occurrences))}, which would presumably perform much more poorly.

 @param element the element to add occurrences of; may be {@code null} only
     if explicitly allowed by the implementation
 @param occurrences the number of occurrences of the element to add. May be
     zero, in which case no change will be made.
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative, or if
     this operation would result in more than {@link Integer#MAX_VALUE}
     occurrences of the element
 @throws NullPointerException if {@code element} is null and this
     implementation does not permit null elements. Note that if {@code
     occurrences} is zero, the implementation may opt to return normally.]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes a number of occurrences of the specified element from this
 multiset. If the multiset contains fewer than this number of occurrences to
 begin with, all occurrences will be removed.  Note that if
 {@code occurrences == 1}, this is functionally equivalent to the call
 {@code remove(element)}.

 @param element the element to conditionally remove occurrences of
 @param occurrences the number of occurrences of the element to remove. May
     be zero, in which case no change will be made.
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the
 element attains the desired count.

 @param element the element to add or remove occurrences of; may be null
     only if explicitly allowed by the implementation
 @param count the desired count of the element in this multiset
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code count} is negative
 @throws NullPointerException if {@code element} is null and this
     implementation does not permit null elements. Note that if {@code
     count} is zero, the implementor may optionally return zero instead.]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Conditionally sets the count of an element to a new value, as described in
 {@link #setCount(Object, int)}, provided that the element has the expected
 current count. If the current count is not {@code oldCount}, no change is
 made.

 @param element the element to conditionally set the count of; may be null
     only if explicitly allowed by the implementation
 @param oldCount the expected present count of the element in this multiset
 @param newCount the desired count of the element in this multiset
 @return {@code true} if the condition for modification was met. This
     implies that the multiset was indeed modified, unless
     {@code oldCount == newCount}.
 @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is
     negative
 @throws NullPointerException if {@code element} is null and the
     implementation does not permit null elements. Note that if {@code
     oldCount} and {@code newCount} are both zero, the implementor may
     optionally return {@code true} instead.]]>
      </doc>
    </method>
    <method name="elementSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of distinct elements contained in this multiset. The
 element set is backed by the same data as the multiset, so any change to
 either is immediately reflected in the other. The order of the elements in
 the element set is unspecified.

 <p>If the element set supports any removal operations, these necessarily
 cause <b>all</b> occurrences of the removed element(s) to be removed from
 the multiset. Implementations are not expected to support the add
 operations, although this is possible.

 <p>A common use for the element set is to find the number of distinct
 elements in the multiset: {@code elementSet().size()}.

 @return a view of the set of distinct elements in this multiset]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of the contents of this multiset, grouped into {@code
 Multiset.Entry} instances, each providing an element of the multiset and
 the count of that element. This set contains exactly one entry for each
 distinct element in the multiset (thus it always has the same size as the
 {@link #elementSet}). The order of the elements in the element set is
 unspecified.

 <p>The entry set is backed by the same data as the multiset, so any change
 to either is immediately reflected in the other. However, multiset changes
 may or may not be reflected in any {@code Entry} instances already
 retrieved from the entry set (this is implementation-dependent).
 Furthermore, implementations are not required to support modifications to
 the entry set at all, and the {@code Entry} instances themselves don't
 even have methods for modification. See the specific implementation class
 for more details on how its entry set handles modifications.

 @return a set of entries representing the data of this multiset]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this multiset for equality. Returns
 {@code true} if the given object is also a multiset and contains equal
 elements with equal counts, regardless of order.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multiset. This is defined as the sum of

 <pre>  (element == null ? 0 : element.hashCode()) ^ count(element)</pre>

 over all distinct elements in the multiset. It follows that a multiset and
 its entry set always have the same hash code.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>It is recommended, though not mandatory, that this method return the
 result of invoking {@link #toString} on the {@link #entrySet}, yielding a
 result such as
 <pre>
     [a x 3, c, d x 2, e]
 </pre>]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Elements that occur multiple times in the multiset will appear
 multiple times in this iterator, though not necessarily sequentially.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Determines whether this multiset contains the specified element.

 <p>This method refines {@link Collection#contains} to further specify that
 it <b>may not</b> throw an exception in response to {@code element} being
 null or of the wrong type.

 @param element the element to check for
 @return {@code true} if this multiset contains at least one occurrence of
     the element]]>
      </doc>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if this multiset contains at least one occurrence of
 each element in the specified collection.

 <p>This method refines {@link Collection#containsAll} to further specify
 that it <b>may not</b> throw an exception in response to any of {@code
 elements} being null or of the wrong type.

 <p><b>Note:</b> this method does not take into account the occurrence
 count of an element in the two collections; it may still return {@code
 true} even if {@code elements} contains several occurrences of an element
 and this multiset contains only one. This is no different than any other
 collection type like {@link List}, but it may be unexpected to the user of
 a multiset.

 @param elements the collection of elements to be checked for containment in
     this multiset
 @return {@code true} if this multiset contains at least one occurrence of
     each element contained in {@code elements}
 @throws NullPointerException if {@code elements} is null]]>
      </doc>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds a single occurrence of the specified element to this multiset.

 <p>This method refines {@link Collection#add}, which only <i>ensures</i>
 the presence of the element, to further specify that a successful call must
 always increment the count of the element, and the overall size of the
 collection, by one.

 @param element the element to add one occurrence of; may be null only if
     explicitly allowed by the implementation
 @return {@code true} always, since this call is required to modify the
     multiset, unlike other {@link Collection} types
 @throws NullPointerException if {@code element} is null and this
     implementation does not permit null elements
 @throws IllegalArgumentException if {@link Integer#MAX_VALUE} occurrences
     of {@code element} are already contained in this multiset]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes a <i>single</i> occurrence of the specified element from this
 multiset, if present.

 <p>This method refines {@link Collection#remove} to further specify that it
 <b>may not</b> throw an exception in response to {@code element} being null
 or of the wrong type.

 @param element the element to remove one occurrence of
 @return {@code true} if an occurrence was found and removed]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method refines {@link Collection#removeAll} to further specify that
 it <b>may not</b> throw an exception in response to any of {@code elements}
 being null or of the wrong type.]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method refines {@link Collection#retainAll} to further specify that
 it <b>may not</b> throw an exception in response to any of {@code elements}
 being null or of the wrong type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection that supports order-independent equality, like {@link Set}, but
 may have duplicate elements. A multiset is also sometimes called a
 <i>bag</i>.

 <p>Elements of a multiset that are equal to one another (see "Note on
 element equivalence", below) are referred to as <i>occurrences</i> of the
 same single element. The total number of occurrences of an element in a
 multiset is called the <i>count</i> of that element (the terms "frequency"
 and "multiplicity" are equivalent, but not used in this API). Since the count
 of an element is represented as an {@code int}, a multiset may never contain
 more than {@link Integer#MAX_VALUE} occurrences of any one element.

 <p>{@code Multiset} refines the specifications of several methods from
 {@code Collection}. It also defines an additional query operation, {@link
 #count}, which returns the count of an element. There are five new
 bulk-modification operations, for example {@link #add(Object, int)}, to add
 or remove multiple occurrences of an element at once, or to set the count of
 an element to a specific value. These modification operations are optional,
 but implementations which support the standard collection operations {@link
 #add(Object)} or {@link #remove(Object)} are encouraged to implement the
 related methods as well. Finally, two collection views are provided: {@link
 #elementSet} contains the distinct elements of the multiset "with duplicates
 collapsed", and {@link #entrySet} is similar but contains {@link Entry
 Multiset.Entry} instances, each providing both a distinct element and the
 count of that element.

 <p>In addition to these required methods, implementations of {@code
 Multiset} are expected to provide two {@code static} creation methods:
 {@code create()}, returning an empty multiset, and {@code
 create(Iterable<? extends E>)}, returning a multiset containing the
 given initial elements. This is simply a refinement of {@code Collection}'s
 constructor recommendations, reflecting the new developments of Java 5.

 <p>As with other collection types, the modification operations are optional,
 and should throw {@link UnsupportedOperationException} when they are not
 implemented. Most implementations should support either all add operations
 or none of them, all removal operations or none of them, and if and only if
 all of these are supported, the {@code setCount} methods as well.

 <p>A multiset uses {@link Object#equals} to determine whether two instances
 should be considered "the same," <i>unless specified otherwise</i> by the
 implementation.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multiset -->
  <!-- start interface com.google.common.collect.Multiset.Entry -->
  <interface name="Multiset.Entry"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getElement" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the multiset element corresponding to this entry. Multiple calls
 to this method always return the same instance.

 @return the element corresponding to this entry]]>
      </doc>
    </method>
    <method name="getCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the count of the associated element in the underlying multiset.
 This count may either be an unchanging snapshot of the count at the time
 the entry was retrieved, or a live view of the current count of the
 element in the multiset, depending on the implementation. Note that in
 the former case, this method can never return zero, while in the latter,
 it will return zero if all occurrences of the element were since removed
 from the multiset.

 @return the count of the element; never negative]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Returns {@code true} if the given object is also a multiset entry and
 the two entries represent the same element and count. More formally, two
 entries {@code a} and {@code b} are equal if:

 <pre>  ((a.getElement() == null)
      ? (b.getElement() == null) : a.getElement().equals(b.getElement()))
    && (a.getCount() == b.getCount())</pre>]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The hash code of a multiset entry for element {@code element} and
 count {@code count} is defined as:

 <pre>  (element == null ? 0 : element.hashCode()) ^ count</pre>]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the canonical string representation of this entry, defined as
 follows. If the count for this entry is one, this is simply the string
 representation of the corresponding element. Otherwise, it is the string
 representation of the element, followed by the three characters {@code
 " x "} (space, letter x, space), followed by the count.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An unmodifiable element-count pair for a multiset. The {@link
 Multiset#entrySet} method returns a view of the multiset whose elements
 are of this class. A multiset implementation may return Entry instances
 that are either live "read-through" views to the Multiset, or immutable
 snapshots. Note that this type is unrelated to the similarly-named type
 {@code Map.Entry}.]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multiset.Entry -->
  <!-- start class com.google.common.collect.Multisets -->
  <class name="Multisets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="unmodifiableMultiset" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset" type="com.google.common.collect.Multiset&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified multiset. Query operations on
 the returned multiset "read through" to the specified multiset, and
 attempts to modify the returned multiset result in an
 {@link UnsupportedOperationException}.

 <p>The returned multiset will be serializable if the specified multiset is
 serializable.

 @param multiset the multiset for which an unmodifiable view is to be
     generated
 @return an unmodifiable view of the multiset]]>
      </doc>
    </method>
    <method name="immutableEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns an immutable multiset entry with the specified element and count.

 @param e the element to be associated with the returned entry
 @param n the count to be associated with the returned entry
 @throws IllegalArgumentException if {@code n} is negative]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset1" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <param name="multiset2" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the intersection of two multisets.
 An element's count in the multiset is the smaller of its counts in the two
 backing multisets. The iteration order of the returned multiset matches the
 element set of {@code multiset1}, with repeated occurrences of the same
 element appearing consecutively.

 <p>Results are undefined if {@code multiset1} and {@code multiset2} are
 based on different equivalence relations (as {@code HashMultiset} and
 {@code TreeMultiset} are).

 @since 2]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static utility methods for creating and working with {@link
 Multiset} instances.

 @author Kevin Bourrillion
 @author Mike Bostock
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Multisets -->
  <!-- start class com.google.common.collect.MutableClassToInstanceMap -->
  <class name="MutableClassToInstanceMap" extends="com.google.common.collect.MapConstraints.ConstrainedMap&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ClassToInstanceMap&lt;B&gt;"/>
    <method name="create" return="com.google.common.collect.MutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@code MutableClassToInstanceMap} instance backed by a {@link
 HashMap} using the default initial capacity and load factor.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code MutableClassToInstanceMap} instance backed by a given
 empty {@code backingMap}. The caller surrenders control of the backing map,
 and thus should not allow any direct references to it to remain accessible.]]>
      </doc>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A mutable class-to-instance map backed by an arbitrary user-provided map.
 See also {@link ImmutableClassToInstanceMap}.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MutableClassToInstanceMap -->
  <!-- start class com.google.common.collect.ObjectArrays -->
  <class name="ObjectArrays" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a new array of the given length with the specified component type.

 @param type the component type
 @param length the length of the new array]]>
      </doc>
    </method>
    <method name="newArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a new array of the given length with the same type as a reference
 array.

 @param reference any array of the desired type
 @param length the length of the new array]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="T[]"/>
      <param name="second" type="T[]"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new array that contains the concatenated contents of two arrays.

 @param first the first array of elements to concatenate
 @param second the second array of elements to concatenate
 @param type the component type of the returned array]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="T"/>
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[Returns a new array that prepends {@code element} to {@code array}.

 @param element the element to prepend to the front of {@code array}
 @param array the array of elements to append
 @return an array whose size is one larger than {@code array}, with
     {@code element} occupying the first position, and the
     elements of {@code array} occupying the remaining elements.]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <param name="element" type="T"/>
      <doc>
      <![CDATA[Returns a new array that appends {@code element} to {@code array}.

 @param array the array of elements to prepend
 @param element the element to append to the end
 @return an array whose size is one larger than {@code array}, with
     the same contents as {@code array}, plus {@code element} occupying the
     last position.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to object arrays.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ObjectArrays -->
  <!-- start class com.google.common.collect.Ordering -->
  <class name="Ordering" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator&lt;T&gt;"/>
    <constructor name="Ordering"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class (only invokable by the subclass
 constructor, typically implicit).]]>
      </doc>
    </constructor>
    <method name="natural" return="com.google.common.collect.Ordering&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable ordering that uses the natural order of the values.
 The ordering throws a {@link NullPointerException} when passed a null
 parameter.

 <p>The type specification is {@code <C extends Comparable>}, instead of
 the technically correct {@code <C extends Comparable<? super C>>}, to
 support legacy types from before Java 5.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an ordering for a pre-existing {@code comparator}. Note
 that if the comparator is not pre-existing, and you don't require
 serialization, you can subclass {@code Ordering} and implement its
 {@link #compare(Object, Object) compare} method instead.

 @param comparator the comparator that defines the order]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="ordering" type="com.google.common.collect.Ordering&lt;T&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this]]>
      </doc>
    </method>
    <method name="explicit" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valuesInOrder" type="java.util.List&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an ordering that compares objects according to the order in
 which they appear in the given list. Only objects present in the list
 (according to {@link Object#equals}) may be compared. This comparator
 imposes a "partial ordering" over the type {@code T}. Subsequent changes
 to the {@code valuesInOrder} list will have no effect on the returned
 comparator. Null values in the list are not supported.

 <p>The returned comparator throws an {@link ClassCastException} when it
 receives an input parameter that isn't among the provided values.

 <p>The generated comparator is serializable if all the provided values are
 serializable.

 @param valuesInOrder the values that the returned comparator will be able
     to compare, in the order the comparator should induce
 @return the comparator described above
 @throws NullPointerException if any of the provided values is null
 @throws IllegalArgumentException if {@code valuesInOrder} contains any
     duplicate values (according to {@link Object#equals})]]>
      </doc>
    </method>
    <method name="explicit" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leastValue" type="T"/>
      <param name="remainingValuesInOrder" type="T[]"/>
      <doc>
      <![CDATA[Returns an ordering that compares objects according to the order in
 which they are given to this method. Only objects present in the argument
 list (according to {@link Object#equals}) may be compared. This comparator
 imposes a "partial ordering" over the type {@code T}. Null values in the
 argument list are not supported.

 <p>The returned comparator throws a {@link ClassCastException} when it
 receives an input parameter that isn't among the provided values.

 <p>The generated comparator is serializable if all the provided values are
 serializable.

 @param leastValue the value which the returned comparator should consider
     the "least" of all values
 @param remainingValuesInOrder the rest of the values that the returned
     comparator will be able to compare, in the order the comparator should
     follow
 @return the comparator described above
 @throws NullPointerException if any of the provided values is null
 @throws IllegalArgumentException if any duplicate values (according to
     {@link Object#equals(Object)}) are present among the method arguments]]>
      </doc>
    </method>
    <method name="arbitrary" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary ordering over all objects, for which {@code compare(a,
 b) == 0} implies {@code a == b} (identity equality). There is no meaning
 whatsoever to the order imposed, but it is constant for the life of the VM.

 <p>Because the ordering is identity-based, it is not "consistent with
 {@link Object#equals(Object)}" as defined by {@link Comparator}. Use
 caution when building a {@link SortedSet} or {@link SortedMap} from it, as
 the resulting collection will not behave exactly according to spec.

 <p>This ordering is not serializable, as its implementation relies on
 {@link System#identityHashCode(Object)}, so its behavior cannot be
 preserved across serialization.

 @since 2]]>
      </doc>
    </method>
    <method name="usingToString" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that compares objects by the natural ordering of their
 string representations as returned by {@code toString()}. It does not
 support null values.

 <p>The comparator is serializable.]]>
      </doc>
    </method>
    <method name="compound" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparators" type="java.lang.Iterable&lt;? extends java.util.Comparator&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an ordering which tries each given comparator in order until a
 non-zero result is found, returning that result, and returning zero only if
 all comparators return zero. The returned ordering is based on the state of
 the {@code comparators} iterable at the time it was provided to this
 method.

 <p>The returned ordering is equivalent to that produced using {@code
 Ordering.from(comp1).compound(comp2).compound(comp3) . . .}.

 <p><b>Warning:</b> Supplying an argument with undefined iteration order,
 such as a {@link HashSet}, will produce non-deterministic results.

 @param comparators the comparators to try in order]]>
      </doc>
    </method>
    <method name="compound" return="com.google.common.collect.Ordering&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="secondaryComparator" type="java.util.Comparator&lt;? super U&gt;"/>
      <doc>
      <![CDATA[Returns an ordering which first uses the ordering {@code this}, but which
 in the event of a "tie", then delegates to {@code secondaryComparator}.
 For example, to sort a bug list first by status and second by priority, you
 might use {@code byStatus.compound(byPriority)}. For a compound ordering
 with three or more components, simply chain multiple calls to this method.

 <p>An ordering produced by this method, or a chain of calls to this method,
 is equivalent to one created using {@link Ordering#compound(Iterable)} on
 the same component comparators.]]>
      </doc>
    </method>
    <method name="reverse" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reverse of this ordering; the {@code Ordering} equivalent to
 {@link Collections#reverseOrder(Comparator)}.]]>
      </doc>
    </method>
    <method name="onResultOf" return="com.google.common.collect.Ordering&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a new ordering on {@code F} which orders elements by first applying
 a function to them, then comparing those results using {@code this}. For
 example, to compare objects by their string forms, in a case-insensitive
 manner, use: <pre>   {@code

   Ordering.from(String.CASE_INSENSITIVE_ORDER)
       .onResultOf(Functions.toStringFunction())}</pre>]]>
      </doc>
    </method>
    <method name="lexicographical" return="com.google.common.collect.Ordering&lt;java.lang.Iterable&lt;S&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new ordering which sorts iterables by comparing corresponding
 elements pairwise until a nonzero result is found; imposes "dictionary
 order". If the end of one iterable is reached, but not the other, the
 shorter iterable is considered to be less than the longer one. For example,
 a lexicographical natural ordering over integers considers {@code
 [] < [1] < [1, 1] < [1, 2] < [2]}.

 <p>Note that {@code ordering.lexicographical().reverse()} is not
 equivalent to {@code ordering.reverse().lexicographical()} (consider how
 each would order {@code [1]} and {@code [1, 1]}).

 @since 2]]>
      </doc>
    </method>
    <method name="nullsFirst" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that treats {@code null} as less than all other values
 and uses {@code this} to compare non-null values.]]>
      </doc>
    </method>
    <method name="nullsLast" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that treats {@code null} as greater than all other
 values and uses this ordering to compare non-null values.]]>
      </doc>
    </method>
    <method name="binarySearch" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedList" type="java.util.List&lt;? extends T&gt;"/>
      <param name="key" type="T"/>
      <doc>
      <![CDATA[{@link Collections#binarySearch(List, Object, Comparator) Searches}
 {@code sortedList} for {@code key} using the binary search algorithm. The
 list must be sorted using this ordering.

 @param sortedList the list to be searched
 @param key the key to be searched for]]>
      </doc>
    </method>
    <method name="sortedCopy" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a copy of the given iterable sorted by this ordering. The input is
 not modified. The returned list is modifiable, serializable, and has random
 access.

 <p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard
 elements that are duplicates according to the comparator. The sort
 performed is <i>stable</i>, meaning that such elements will appear in the
 resulting list in the same order they appeared in the input.

 @param iterable the elements to be copied and sorted
 @return a new list containing the given elements in sorted order]]>
      </doc>
    </method>
    <method name="immutableSortedCopy" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an <i>immutable</i> copy of the given iterable sorted by this
 ordering. The input is not modified.

 <p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard
 elements that are duplicates according to the comparator. The sort
 performed is <i>stable</i>, meaning that such elements will appear in the
 resulting list in the same order they appeared in the input.

 @param iterable the elements to be copied and sorted
 @return a new immutable list containing the given elements in sorted order
 @throws NullPointerException if {@code iterable} or any of its elements is
     null
 @since 3]]>
      </doc>
    </method>
    <method name="isOrdered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is
 greater than or equal to the element that preceded it, according to this
 ordering. Note that this is always true when the iterable has fewer than
 two elements.]]>
      </doc>
    </method>
    <method name="isStrictlyOrdered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is
 <i>strictly</i> greater than the element that preceded it, according to
 this ordering. Note that this is always true when the iterable has fewer
 than two elements.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the largest of the specified values according to this ordering. If
 there are multiple largest values, the first of those is returned.

 @param iterable the iterable whose maximum element is to be determined
 @throws NoSuchElementException if {@code iterable} is empty
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <param name="c" type="E extends T"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns the largest of the specified values according to this ordering. If
 there are multiple largest values, the first of those is returned.

 @param a value to compare, returned if greater than or equal to the rest.
 @param b value to compare
 @param c value to compare
 @param rest values to compare
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <doc>
      <![CDATA[Returns the larger of the two values according to this ordering. If the
 values compare as 0, the first is returned.

 <p><b>Implementation note:</b> this method is invoked by the default
 implementations of the other {@code max} overloads, so overriding it will
 affect their behavior.

 @param a value to compare, returned if greater than or equal to b.
 @param b value to compare.
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the smallest of the specified values according to this ordering. If
 there are multiple smallest values, the first of those is returned.

 @param iterable the iterable whose minimum element is to be determined
 @throws NoSuchElementException if {@code iterable} is empty
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <param name="c" type="E extends T"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns the smallest of the specified values according to this ordering. If
 there are multiple smallest values, the first of those is returned.

 @param a value to compare, returned if less than or equal to the rest.
 @param b value to compare
 @param c value to compare
 @param rest values to compare
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <doc>
      <![CDATA[Returns the smaller of the two values according to this ordering. If the
 values compare as 0, the first is returned.

 <p><b>Implementation note:</b> this method is invoked by the default
 implementations of the other {@code min} overloads, so overriding it will
 affect their behavior.

 @param a value to compare, returned if less than or equal to b.
 @param b value to compare.
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A comparator with added methods to support common functions. For example:
 <pre>   {@code

   if (Ordering.from(comparator).reverse().isOrdered(list)) { ... }}</pre>

 <p>The {@link #from(Comparator)} method returns the equivalent {@code
 Ordering} instance for a pre-existing comparator. You can also skip the
 comparator step and extend {@code Ordering} directly: <pre>   {@code

   Ordering<String> byLengthOrdering = new Ordering<String>() {
     public int compare(String left, String right) {
       return Ints.compare(left.length(), right.length());
     }
   };}</pre>

 Except as noted, the orderings returned by the factory methods of this
 class are serializable if and only if the provided instances that back them
 are. For example, if {@code ordering} and {@code function} can themselves be
 serialized, then {@code ordering.onResultOf(function)} can as well.

 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Ordering -->
  <!-- start interface com.google.common.collect.PeekingIterator -->
  <interface name="PeekingIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <method name="peek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element in the iteration, without advancing the iteration.

 <p>Calls to {@code peek()} should not change the state of the iteration,
 except that it <i>may</i> prevent removal of the most recent element via
 {@link #remove()}.

 @throws NoSuchElementException if the iteration has no more elements
     according to {@link #hasNext()}]]>
      </doc>
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The objects returned by consecutive calls to {@link #peek()} then {@link
 #next()} are guaranteed to be equal to each other.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Implementations may or may not support removal when a call to {@link
 #peek()} has occurred since the most recent call to {@link #next()}.

 @throws IllegalStateException if there has been a call to {@link #peek()}
     since the most recent call to {@link #next()} and this implementation
     does not support this sequence of calls (optional)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator that supports a one-element lookahead while iterating.

 @author Mick Killianey
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.PeekingIterator -->
  <!-- start interface com.google.common.collect.SetMultimap -->
  <interface name="SetMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.

 <p>Any duplicates in {@code values} will be stored in the multimap once.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Though the method signature doesn't say so explicitly, the returned map
 has {@link Set} values.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code SetMultimap} instances are equal if, for each key, they
 contain the same values. Equality does not depend on the ordering of keys
 or values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multimap} that cannot hold duplicate key-value pairs. Adding a
 key-value pair that's already in the multimap has no effect.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods
 each return a {@link Set} of values, while {@link #entries} returns a {@code
 Set} of map entries. Though the method signature doesn't say so explicitly,
 the map returned by {@link #asMap} has {@code Set} values.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SetMultimap -->
  <!-- start class com.google.common.collect.Sets -->
  <class name="Sets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="immutableEnumSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="anElement" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="otherElements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set instance containing the given enum elements.
 Internally, the returned set will be backed by an {@link EnumSet}.

 <p>The iteration order of the returned set follows the enum's iteration
 order, not the order in which the elements are provided to the method.

 @param anElement one of the elements the set should contain
 @param otherElements the rest of the elements the set should contain
 @return an immutable set containing those elements, minus duplicates]]>
      </doc>
    </method>
    <method name="immutableEnumSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set instance containing the given enum elements.
 Internally, the returned set will be backed by an {@link EnumSet}.

 <p>The iteration order of the returned set follows the enum's iteration
 order, not the order in which the elements appear in the given collection.

 @param elements the elements, all of the same {@code enum} type, that the
     set should contain
 @return an immutable set containing those elements, minus duplicates]]>
      </doc>
    </method>
    <method name="newEnumSet" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="elementType" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code EnumSet} instance containing the given elements.
 Unlike {@link EnumSet#copyOf(Collection)}, this method does not produce an
 exception on an empty collection, and it may be called on any iterable, not
 just a {@code Collection}.]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code HashSet} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSet#of()} instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link
 EnumSet#noneOf} instead.

 @return a new, empty {@code HashSet}]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given
 elements in unspecified order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use an overload of {@link ImmutableSet#of()} (for varargs) or
 {@link ImmutableSet#copyOf(Object[])} (for an array) instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link
 EnumSet#of(Enum, Enum[])} instead.

 @param elements the elements that the set should contain
 @return a new {@code HashSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newHashSetWithExpectedSize" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates an empty {@code HashSet} instance with enough capacity to hold the
 specified number of elements without rehashing.

 @param expectedSize the expected size
 @return a new, empty {@code HashSet} with enough capacity to hold {@code
     expectedSize} elements without rehashing
 @throws IllegalArgumentException if {@code expectedSize} is negative]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given
 elements in unspecified order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, use
 {@link #newEnumSet(Iterable, Class)} instead.

 @param elements the elements that the set should contain
 @return a new {@code HashSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given
 elements in unspecified order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an
 {@link EnumSet} instead.

 @param elements the elements that the set should contain
 @return a new {@code HashSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newLinkedHashSet" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSet#of()} instead.

 @return a new, empty {@code LinkedHashSet}]]>
      </doc>
    </method>
    <method name="newLinkedHashSet" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code LinkedHashSet} instance containing the
 given elements in order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.

 @param elements the elements that the set should contain, in order
 @return a new {@code LinkedHashSet} containing those elements (minus
     duplicates)]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeSet} instance sorted by the
 natural sort ordering of its elements.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedSet#of()} instead.

 @return a new, empty {@code TreeSet}]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code TreeSet} instance containing the given
 elements sorted by their natural ordering.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedSet#copyOf(Iterable)} instead.

 <p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit
 comparator, this method has different behavior than
 {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code TreeSet} with
 that comparator.

 @param elements the elements that the set should contain
 @return a new {@code TreeSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeSet} instance with the given
 comparator.

 <p><b>Note:</b> if mutability is not required, use {@code
 ImmutableSortedSet.orderedBy(comparator).build()} instead.

 @param comparator the comparator to use to sort the set
 @return a new, empty {@code TreeSet}
 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="complementOf" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumSet} consisting of all enum values that are not in
 the specified collection. If the collection is an {@link EnumSet}, this
 method has the same behavior as {@link EnumSet#complementOf}. Otherwise,
 the specified collection must contain at least one element, in order to
 determine the element type. If the collection could be empty, use
 {@link #complementOf(Collection, Class)} instead of this method.

 @param collection the collection whose complement should be stored in the
     enum set
 @return a new, modifiable {@code EnumSet} containing all values of the enum
     that aren't present in the given collection
 @throws IllegalArgumentException if {@code collection} is not an
     {@code EnumSet} instance and contains no elements]]>
      </doc>
    </method>
    <method name="complementOf" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumSet} consisting of all enum values that are not in
 the specified collection. This is equivalent to
 {@link EnumSet#complementOf}, but can act on any input collection, as long
 as the elements are of enum type.

 @param collection the collection whose complement should be stored in the
     {@code EnumSet}
 @param type the type of the elements in the set
 @return a new, modifiable {@code EnumSet} initially containing all the
     values of the enum not present in the given collection]]>
      </doc>
    </method>
    <method name="newSetFromMap" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;E, java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Returns a set backed by the specified map. The resulting set displays
 the same ordering, concurrency, and performance characteristics as the
 backing map. In essence, this factory method provides a {@link Set}
 implementation corresponding to any {@link Map} implementation. There is no
 need to use this method on a {@link Map} implementation that already has a
 corresponding {@link Set} implementation (such as {@link HashMap} or
 {@link TreeMap}).

 <p>Each method invocation on the set returned by this method results in
 exactly one method invocation on the backing map or its <tt>keySet</tt>
 view, with one exception. The <tt>addAll</tt> method is implemented as a
 sequence of <tt>put</tt> invocations on the backing map.

 <p>The specified map must be empty at the time this method is invoked,
 and should not be accessed directly after this method returns. These
 conditions are ensured if the map is created empty, passed directly
 to this method, and no reference to the map is retained, as illustrated
 in the following code fragment: <pre>  {@code

  Set<Object> identityHashSet = Sets.newSetFromMap(
      new IdentityHashMap<Object, Boolean>());}</pre>

 This method has the same behavior as the JDK 6 method
 {@code Collections.newSetFromMap()}. The returned set is serializable if
 the backing map is.

 @param map the backing map
 @return the set backed by the map
 @throws IllegalArgumentException if <tt>map</tt> is not empty]]>
      </doc>
    </method>
    <method name="union" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;? extends E&gt;"/>
      <param name="set2" type="java.util.Set&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the union of two sets. The returned
 set contains all elements that are contained in either backing set.
 Iterating over the returned set iterates first over all the elements of
 {@code set1}, then over each element of {@code set2}, in order, that is not
 contained in {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based on
 different equivalence relations (as {@link HashSet}, {@link TreeSet}, and
 the {@link Map#keySet} of an {@link IdentityHashMap} all are).

 <p><b>Note:</b> The returned view performs better when {@code set1} is the
 smaller of the two sets. If you have reason to believe one of your sets
 will generally be smaller than the other, pass it first.]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;E&gt;"/>
      <param name="set2" type="java.util.Set&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the intersection of two sets. The
 returned set contains all elements that are contained by both backing sets.
 The iteration order of the returned set matches that of {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based
 on different equivalence relations (as {@code HashSet}, {@code TreeSet},
 and the keySet of an {@code IdentityHashMap} all are).

 <p><b>Note:</b> The returned view performs slightly better when {@code
 set1} is the smaller of the two sets. If you have reason to believe one of
 your sets will generally be smaller than the other, pass it first.
 Unfortunately, since this method sets the generic type of the returned set
 based on the type of the first set passed, this could in rare cases force
 you to make a cast, for example: <pre>  {@code

  Set<Object> aFewBadObjects = ...
  Set<String> manyBadStrings = ...

  // impossible for a non-String to be in the intersection
  SuppressWarnings("unchecked")
  Set<String> badStrings = (Set) Sets.intersection(
      aFewBadObjects, manyBadStrings);}</pre>

 This is unfortunate, but should come up only very rarely.]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;E&gt;"/>
      <param name="set2" type="java.util.Set&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the difference of two sets. The
 returned set contains all elements that are contained by {@code set1} and
 not contained by {@code set2}. {@code set2} may also contain elements not
 present in {@code set1}; these are simply ignored. The iteration order of
 the returned set matches that of {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based
 on different equivalence relations (as {@code HashSet}, {@code TreeSet},
 and the keySet of an {@code IdentityHashMap} all are).]]>
      </doc>
    </method>
    <method name="symmetricDifference" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;? extends E&gt;"/>
      <param name="set2" type="java.util.Set&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the symmetric difference of two
 sets. The returned set contains all elements that are contained in either
 {@code set1} or {@code set2} but not in both. The iteration order of the
 returned set is undefined.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based
 on different equivalence relations (as {@code HashSet}, {@code TreeSet},
 and the keySet of an {@code IdentityHashMap} all are).

 @since 3]]>
      </doc>
    </method>
    <method name="filter" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Set&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The
 returned set is a live view of {@code unfiltered}; changes to one affect
 the other.

 <p>The resulting set's iterator does not support {@code remove()}, but all
 other set methods are supported. The set's {@code add()} and
 {@code addAll()} methods throw an {@link IllegalArgumentException} if an
 element that doesn't satisfy the predicate is provided. When methods such
 as {@code removeAll()} and {@code clear()} are called on the filtered set,
 only elements that satisfy the filter will be removed from the underlying
 collection.

 <p>The returned set isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered set's methods, such as {@code size()}, iterate
 across every element in the underlying set and determine which elements
 satisfy the filter. When a live view is <i>not</i> needed, it may be faster
 to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.Set&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sets" type="java.util.List&lt;? extends java.util.Set&lt;? extends B&gt;&gt;"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element
 from each of the given sets in order; the "n-ary
 <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the sets. For example: <pre class="code">   {@code

   Sets.cartesianProduct(ImmutableList.of(
       ImmutableSet.of(1, 2),
       ImmutableSet.of("A", "B", "C")))}</pre>

 returns a set containing six lists:

 <ul>
 <li>{@code ImmutableList.of(1, "A")}
 <li>{@code ImmutableList.of(1, "B")}
 <li>{@code ImmutableList.of(1, "C")}
 <li>{@code ImmutableList.of(2, "A")}
 <li>{@code ImmutableList.of(2, "B")}
 <li>{@code ImmutableList.of(2, "C")}
 </ul>

 The order in which these lists are returned is not guaranteed, however the
 position of an element inside a tuple always corresponds to the position of
 the set from which it came in the input list. Note that if any input set is
 empty, the Cartesian product will also be empty. If no sets at all are
 provided (an empty list), the resulting Cartesian product has one element,
 an empty list (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of sets of size
 {@code m, n, p} is a set of size {@code m x n x p}, its actual memory
 consumption is much smaller. When the cartesian set is constructed, the
 input sets are merely copied. Only as the resulting set is iterated are the
 individual lists created, and these are not retained after iteration.

 @param sets the sets to choose elements from, in the order that
     the elements chosen from those sets should appear in the resulting
     lists
 @param <B> any common base class shared by all axes (often just {@link
     Object})
 @return the Cartesian product, as an immutable set containing immutable
     lists
 @throws NullPointerException if {@code sets}, any one of the {@code sets},
     or any element of a provided set is null
 @since 2]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.Set&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sets" type="java.util.Set[]"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element
 from each of the given sets in order; the "n-ary
 <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the sets. For example: <pre class="code">   {@code

   Sets.cartesianProduct(
       ImmutableSet.of(1, 2),
       ImmutableSet.of("A", "B", "C"))}</pre>

 returns a set containing six lists:

 <ul>
 <li>{@code ImmutableList.of(1, "A")}
 <li>{@code ImmutableList.of(1, "B")}
 <li>{@code ImmutableList.of(1, "C")}
 <li>{@code ImmutableList.of(2, "A")}
 <li>{@code ImmutableList.of(2, "B")}
 <li>{@code ImmutableList.of(2, "C")}
 </ul>

 The order in which these lists are returned is not guaranteed, however the
 position of an element inside a tuple always corresponds to the position of
 the set from which it came in the input list. Note that if any input set is
 empty, the Cartesian product will also be empty. If no sets at all are
 provided, the resulting Cartesian product has one element, an empty list
 (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of sets of size
 {@code m, n, p} is a set of size {@code m x n x p}, its actual memory
 consumption is much smaller. When the cartesian set is constructed, the
 input sets are merely copied. Only as the resulting set is iterated are the
 individual lists created, and these are not retained after iteration.

 @param sets the sets to choose elements from, in the order that
     the elements chosen from those sets should appear in the resulting
     lists
 @param <B> any common base class shared by all axes (often just {@link
     Object})
 @return the Cartesian product, as an immutable set containing immutable
     lists
 @throws NullPointerException if {@code sets}, any one of the {@code sets},
     or any element of a provided set is null
 @since 2]]>
      </doc>
    </method>
    <method name="powerSet" return="java.util.Set&lt;java.util.Set&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the set of all possible subsets of {@code set}. For example,
 {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},
 {1}, {2}, {1, 2}}}.

 <p>Elements appear in these subsets in the same iteration order as they
 appeared in the input set. The order in which these subsets appear in the
 outer set is undefined. Note that the power set of the empty set is not the
 empty set, but a one-element set containing the empty set.

 <p>The returned set and its constituent sets use {@code equals} to decide
 whether two elements are identical, even if the input set uses a different
 concept of equivalence.

 <p><i>Performance notes:</i> while the power set of a set with size {@code
 n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the
 power set is constructed, the input set is merely copied. Only as the
 power set is iterated are the individual subsets created, and these subsets
 themselves occupy only a few bytes of memory regardless of their size.

 @param set the set of elements to construct a power set from
 @return the power set, as an immutable set of immutable sets
 @throws IllegalArgumentException if {@code set} has more than 30 unique
     elements (causing the power set size to exceed the {@code int} range)
 @throws NullPointerException if {@code set} or any of its elements is
     null
 @see <a href="http://en.wikipedia.org/wiki/Power_set">Power set article at
      Wikipedia</a>
 @since 4]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Set} instances. Also see this
 class's counterparts {@link Lists} and {@link Maps}.

 @author Kevin Bourrillion
 @author Jared Levy
 @author Chris Povirk
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Sets -->
  <!-- start class com.google.common.collect.Sets.SetView -->
  <class name="Sets.SetView" extends="java.util.AbstractSet&lt;E&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="immutableCopy" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable copy of the current contents of this set view.
 Does not support null elements.

 <p><b>Warning:</b> this may have unexpected results if a backing set of
 this view uses a nonstandard notion of equivalence, for example if it is
 a {@link TreeSet} using a comparator that is inconsistent with {@link
 Object#equals(Object)}.]]>
      </doc>
    </method>
    <method name="copyInto" return="S extends java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="S extends java.util.Set&lt;E&gt;"/>
      <doc>
      <![CDATA[Copies the current contents of this set view into an existing set. This
 method has equivalent behavior to {@code set.addAll(this)}, assuming that
 all the sets involved are based on the same notion of equivalence.

 @return a reference to {@code set}, for convenience]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An unmodifiable view of a set which may be backed by other sets; this view
 will change as the backing sets do. Contains methods to copy the data into
 a new set which will then remain stable. There is usually no reason to
 retain a reference of type {@code SetView}; typically, you either use it
 as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or
 {@link #copyInto} and forget the {@code SetView} itself.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Sets.SetView -->
  <!-- start interface com.google.common.collect.SortedSetMultimap -->
  <interface name="SortedSetMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns a collection view of all values associated with a key. If no
 mappings in the multimap have the provided key, an empty collection is
 returned.

 <p>Changes to the returned collection will update the underlying multimap,
 and vice versa.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given
 key, this method returns a {@link SortedSet}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes all values associated with a given key.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given
 key, this method returns a {@link SortedSet}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key, replacing any existing
 values for that key.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given
 key, this method returns a {@link SortedSet}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.

 <p>Any duplicates in {@code values} will be stored in the multimap once.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map view that associates each key with the corresponding values
 in the multimap. Changes to the returned map, such as element removal,
 will update the underlying multimap. The map never supports
 {@code setValue()} on the map entries, {@code put}, or {@code putAll}.

 <p>The collections returned by {@code asMap().get(Object)} have the same
 behavior as those returned by {@link #get}.

 <p>Though the method signature doesn't say so explicitly, the returned map
 has {@link SortedSet} values.]]>
      </doc>
    </method>
    <method name="valueComparator" return="java.util.Comparator&lt;? super V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the multimap values, with a {@code null}
 indicating that natural ordering is used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code SetMultimap} whose set of values for a given key are kept sorted;
 that is, they comprise a {@link SortedSet}. It cannot hold duplicate
 key-value pairs; adding a key-value pair that's already in the multimap has
 no effect. This interface does not specify the ordering of the multimap's
 keys.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods
 each return a {@link SortedSet} of values, while {@link Multimap#entries()}
 returns a {@link Set} of map entries. Though the method signature doesn't say
 so explicitly, the map returned by {@link #asMap} has {@code SortedSet}
 values.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SortedSetMultimap -->
  <!-- start class com.google.common.collect.TreeMultimap -->
  <class name="TreeMultimap" extends="com.google.common.collect.AbstractSortedSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code TreeMultimap} ordered by the natural ordering of
 its keys and values.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code TreeMultimap} instance using explicit comparators.
 Neither comparator may be null; use {@link Ordering#natural()} to specify
 natural order.

 @param keyComparator the comparator that determines the key ordering
 @param valueComparator the comparator that determines the value ordering]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code TreeMultimap}, ordered by the natural ordering of its
 keys and values, with the same mappings as the specified multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="keyComparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the multimap keys.]]>
      </doc>
    </method>
    <method name="valueComparator" return="java.util.Comparator&lt;? super V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.SortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeMultimap} has unique sorted keys, this method
 returns a {@link SortedSet}, instead of the {@link Set} specified in the
 {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.SortedMap&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeMultimap} has unique sorted keys, this method
 returns a {@link SortedMap}, instead of the {@link java.util.Map} specified
 in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} whose keys and values are ordered by
 their natural ordering or by supplied comparators. In all cases, this
 implementation uses {@link Comparable#compareTo} or {@link
 Comparator#compare} instead of {@link Object#equals} to determine
 equivalence of instances.

 <p><b>Warning:</b> The comparators or comparables used must be <i>consistent
 with equals</i> as explained by the {@link Comparable} class specification.
 Otherwise, the resulting multiset will violate the general contract of {@link
 SetMultimap}, which it is specified in terms of {@link Object#equals}.

 <p>The collections returned by {@code keySet} and {@code asMap} iterate
 through the keys according to the key comparator ordering or the natural
 ordering of the keys. Similarly, {@code get}, {@code removeAll}, and {@code
 replaceValues} return collections that iterate through the values according
 to the value comparator ordering or the natural ordering of the values. The
 collections generated by {@code entries}, {@code keys}, and {@code values}
 iterate across the keys according to the above key ordering, and for each
 key they iterate across the values according to the value ordering.

 <p>The multimap does not store duplicate key-value pairs. Adding a new
 key-value pair equal to an existing key-value pair has no effect.

 <p>Depending on the comparators, null keys and values may or may not be
 supported. The natural ordering does not support nulls. All optional multimap
 methods are supported, and all returned views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedSortedSetMultimap}.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeMultimap -->
  <!-- start class com.google.common.collect.TreeMultiset -->
  <class name="TreeMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty multiset, sorted according to the elements' natural
 order. All elements inserted into the multiset must implement the
 {@code Comparable} interface. Furthermore, all such elements must be
 <i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a
 {@code ClassCastException} for any elements {@code e1} and {@code e2} in
 the multiset. If the user attempts to add an element to the multiset that
 violates this constraint (for example, the user attempts to add a string
 element to a set whose elements are integers), the {@code add(Object)}
 call will throw a {@code ClassCastException}.

 <p>The type specification is {@code <E extends Comparable>}, instead of the
 more specific {@code <E extends Comparable<? super E>>}, to support
 classes defined without generics.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Creates a new, empty multiset, sorted according to the specified
 comparator. All elements inserted into the multiset must be <i>mutually
 comparable</i> by the specified comparator: {@code comparator.compare(e1,
 e2)} must not throw a {@code ClassCastException} for any elements {@code
 e1} and {@code e2} in the multiset. If the user attempts to add an element
 to the multiset that violates this constraint, the {@code add(Object)} call
 will throw a {@code ClassCastException}.

 @param comparator the comparator that will be used to sort this multiset. A
     null value indicates that the elements' <i>natural ordering</i> should
     be used.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an empty multiset containing the given initial elements, sorted
 according to the elements' natural order.

 <p>The type specification is {@code <E extends Comparable>}, instead of the
 more specific {@code <E extends Comparable<? super E>>}, to support
 classes defined without generics.]]>
      </doc>
    </method>
    <method name="elementSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>In {@code TreeMultiset}, the return type of this method is narrowed
 from {@link Set} to {@link SortedSet}.]]>
      </doc>
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A multiset which maintains the ordering of its elements, according to either
 their natural order or an explicit {@link Comparator}. In all cases, this
 implementation uses {@link Comparable#compareTo} or {@link
 Comparator#compare} instead of {@link Object#equals} to determine
 equivalence of instances.

 <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as
 explained by the {@link Comparable} class specification. Otherwise, the
 resulting multiset will violate the {@link Collection} contract, which it is
 specified in terms of {@link Object#equals}.

 @author Neal Kanodia
 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeMultiset -->
  <!-- start class com.google.common.collect.UnmodifiableIterator -->
  <class name="UnmodifiableIterator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <constructor name="UnmodifiableIterator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the underlying data unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator that does not support {@link #remove}.

 @author Jared Levy
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.UnmodifiableIterator -->
</package>
<package name="com.google.common.io">
  <!-- start interface com.google.common.io.ByteArrayDataInput -->
  <interface name="ByteArrayDataInput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataInput"/>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="skipBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUTF" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An extension of {@code DataInput} for reading from in-memory byte arrays; its
 methods offer identical functionality but do not throw {@link IOException}.
 If any method encounters the end of the array prematurely, it throws {@link
 IllegalStateException}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataInput -->
  <!-- start interface com.google.common.io.ByteArrayDataOutput -->
  <interface name="ByteArrayDataOutput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataOutput"/>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="boolean"/>
    </method>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeShort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeChar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
    </method>
    <method name="writeChars"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeUTF"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method is dangerous as it discards the high byte of
 every character. For UTF-8, use {@code write(s.getBytes(Charsets.UTF_8))}.">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated This method is dangerous as it discards the high byte of
 every character. For UTF-8, use {@code write(s.getBytes(Charsets.UTF_8))}.]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contents that have been written to this instance,
 as a byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An extension of {@code DataOutput} for writing to in-memory byte arrays; its
 methods offer identical functionality but do not throw {@link IOException}.

 @author Jayaprabhakar Kadarkarai
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataOutput -->
  <!-- start interface com.google.common.io.ByteProcessor -->
  <interface name="ByteProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processBytes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called for each chunk of bytes in an
 input stream. The implementation should process the bytes
 from {@code buf[off]} through {@code buf[off + len - 1]}
 (inclusive).

 @param buf the byte array containing the data to process
 @param off the initial offset into the array
 @param len the length of data to be processed
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the bytes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback interface to process bytes from a stream.

 <p>{@link #processBytes} will be called for each line that is read, and
 should return {@code false} when you want to stop processing.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteProcessor -->
  <!-- start class com.google.common.io.ByteStreams -->
  <class name="ByteStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.ByteArrayInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link ByteArrayInputStream} that read from the given byte array.

 @param b the input buffer
 @return the factory]]>
      </doc>
    </method>
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.ByteArrayInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link ByteArrayInputStream} that read from the given byte array.

 @param b the input buffer
 @param off the offset in the buffer of the first byte to read
 @param len the maximum number of bytes to read from the buffer
 @return the factory]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="byte[]"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a byte array to an output stream from the given supplier.

 @param from the bytes to write
 @param to the output supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens input and output streams from the given suppliers, copies all
 bytes from the input to the output, and closes the streams.

 @param from the input factory
 @param to the output factory
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an input stream from the supplier, copies all bytes from the
 input to the output, and closes the input stream. Does not close
 or flush the output stream.

 @param from the input factory
 @param to the output stream to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.InputStream"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the input stream to the output stream.
 Does not close or flush either stream.

 @param from the input stream to read from
 @param to the output stream to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.nio.channels.ReadableByteChannel"/>
      <param name="to" type="java.nio.channels.WritableByteChannel"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the readable channel to the writable channel.
 Does not close or flush either channel.

 @param from the readable channel to read from
 @param to the writable channel to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from an input stream into a byte array.
 Does not close the stream.

 @param in the input stream to read from
 @return a byte array containing all the bytes from the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the data from a {@link InputStream} factory as a byte array.

 @param supplier the factory
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code
 bytes} array from the beginning.]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code
 bytes} array, starting at the given position.

 @throws IndexOutOfBoundsException if {@code start} is negative or greater
     than the length of the array]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance with a default size.]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance sized to hold
 {@code size} bytes before resizing.

 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the length of a supplied input stream, in bytes.]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier1" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="supplier2" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the supplied input streams contain the same bytes.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read enough bytes from the stream to fill the given byte array,
 with the same behavior as {@link DataInput#readFully(byte[])}.
 Does not close the stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @throws EOFException if this stream reaches the end before reading all
     the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read {@code len} bytes from the stream into the given array
 starting at {@code off}, with the same behavior as
 {@link DataInput#readFully(byte[], int, int)}. Does not close the
 stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @param off an int specifying the offset into the data.
 @param len an int specifying the number of bytes to read.
 @throws EOFException if this stream reaches the end before reading all
     the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} bytes of data from the input stream. This method
 will block until the full amount has been skipped. Does not close the
 stream.

 @param in the input stream to read from
 @param n the number of bytes to skip
 @throws EOFException if this stream reaches the end before skipping all
     the bytes
 @throws IOException if an I/O error occurs, or the stream does not
     support skipping]]>
      </doc>
    </method>
    <method name="readBytes" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of a supplied stream

 @param supplier the input stream factory
 @param processor the object to which to pass the bytes of the stream
 @return the result of the byte processor
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getChecksum" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="checksum" type="java.util.zip.Checksum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the checksum value for a supplied input stream.
 The checksum object is reset when this method returns successfully.

 @param supplier the input stream factory
 @param checksum the checksum object
 @return the result of {@link Checksum#getValue} after updating the
     checksum object with all of the bytes in the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getDigest" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="md" type="java.security.MessageDigest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the digest value for a supplied input stream.
 The digest object is reset when this method returns successfully.

 @param supplier the input stream factory
 @param md the digest object
 @return the result of {@link MessageDigest#digest()} after updating the
     digest object with all of the bytes in the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads some bytes from an input stream and stores them into the buffer array
 {@code b}. This method blocks until {@code len} bytes of input data have
 been read into the array, or end of file is detected. The number of bytes
 read is returned, possibly zero. Does not close the stream.

 <p>A caller can detect EOF if the number of bytes read is less than
 {@code len}. All subsequent calls on the same stream will return zero.

 <p>If {@code b} is null, a {@code NullPointerException} is thrown. If
 {@code off} is negative, or {@code len} is negative, or {@code off+len} is
 greater than the length of the array {@code b}, then an
 {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then
 no bytes are read. Otherwise, the first byte read is stored into element
 {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number
 of bytes read is, at most, equal to {@code len}.

 @param in the input stream to read from
 @param b the buffer into which the data is read
 @param off an int specifying the offset into the data
 @param len an int specifying the number of bytes to read
 @return the number of bytes read
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="slice" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="offset" type="long"/>
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Returns an {@link InputSupplier} that returns input streams from the
 an underlying supplier, where each stream starts at the given
 offset and is limited to the specified number of bytes.

 @param supplier the supplier from which to get the raw streams
 @param offset the offset in bytes into the underlying stream where
     the returned streams will start
 @param length the maximum length of the returned streams
 @throws IllegalArgumentException if offset or length are negative]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="java.lang.Iterable&lt;? extends com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;&gt;"/>
      <doc>
      <![CDATA[Joins multiple {@link InputStream} suppliers into a single supplier.
 Streams returned from the supplier will contain the concatenated data from
 the streams of the underlying suppliers.

 <p>Only one underlying input stream will be open at a time. Closing the
 joined stream will close the open underlying stream.

 <p>Reading from the joined stream will throw a {@link NullPointerException}
 if any of the suppliers are null or return null.

 @param suppliers the suppliers to concatenate
 @return a supplier that will return a stream containing the concatenated
     stream data]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="com.google.common.io.InputSupplier[]"/>
      <doc>
      <![CDATA[Varargs form of {@link #join(Iterable)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with byte arrays and I/O streams.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.ByteStreams -->
  <!-- start class com.google.common.io.CharStreams -->
  <class name="CharStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.StringReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link StringReader} that
 read a string value.

 @param value the string to read
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link InputStreamReader},
 using the given {@link InputStream} factory and character set.

 @param in the factory that will be used to open input streams
 @param charset the character set used to decode the input stream
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter},
 using the given {@link OutputStream} factory and character set.

 @param out the factory that will be used to open output streams
 @param charset the character set used to encode the output stream
 @return the factory]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a character sequence (such as a string) to an appendable
 object from the given supplier.

 @param from the character sequence to write
 @param to the output supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens {@link Readable} and {@link Appendable} objects from the
 given factories, copies all characters between the two, and closes
 them.

 @param from the input factory
 @param to the output factory
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a {@link Readable} object from the supplier, copies all characters
 to the {@link Appendable} object, and closes the input. Does not close
 or flush the output.

 @param from the input factory
 @param to the object to write to
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.Readable"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters between the {@link Readable} and {@link Appendable}
 objects. Does not close or flush either object.

 @param from the object to read from
 @param to the object to write to
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a {@link Readable} object into a {@link String}.
 Does not close the {@code Readable}.

 @param r the object to read from
 @return a string containing all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the characters from a {@link Readable} & {@link Closeable} object
 supplied by a factory as a {@link String}.

 @param supplier the factory to read from
 @return a string containing all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFirstLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line from a {@link Readable} & {@link Closeable} object
 supplied by a factory. The line does not include line-termination
 characters, but does include other leading and trailing whitespace.

 @param supplier the factory to read from
 @return the first line, or null if the reader is empty
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a {@link Readable} & {@link Closeable} object
 supplied by a factory. The lines do not include line-termination
 characters, but do include other leading and trailing whitespace.

 @param supplier the factory to read from
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a {@link Readable} object. The lines do
 not include line-termination characters, but do include other
 leading and trailing whitespace.

 <p>Does not close the {@code Readable}. If reading files or resources you
 should use the {@link Files#readLines} and {@link Resources#readLines}
 methods.

 @param r the object to read from
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link Readable} and {@link Closeable} object
 supplied by a factory, stopping when our callback returns false, or we
 have read all of the lines.

 @param supplier the factory to read from
 @param callback the LineProcessor to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.Reader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="java.lang.Iterable&lt;? extends com.google.common.io.InputSupplier&lt;? extends java.io.Reader&gt;&gt;"/>
      <doc>
      <![CDATA[Joins multiple {@link Reader} suppliers into a single supplier.
 Reader returned from the supplier will contain the concatenated data
 from the readers of the underlying suppliers.

 <p>Reading from the joined reader will throw a {@link NullPointerException}
 if any of the suppliers are null or return null.

 <p>Only one underlying reader will be open at a time. Closing the
 joined reader will close the open underlying reader.

 @param suppliers the suppliers to concatenate
 @return a supplier that will return a reader containing the concatenated
     data]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.Reader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="com.google.common.io.InputSupplier[]"/>
      <doc>
      <![CDATA[Varargs form of {@link #join(Iterable)}.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} characters of data from the reader. This method
 will block until the full amount has been skipped. Does not close the
 reader.

 @param reader the reader to read from
 @param n the number of characters to skip
 @throws EOFException if this stream reaches the end before skipping all
     the bytes
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="asWriter" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.Appendable"/>
      <doc>
      <![CDATA[Returns a Writer that sends all output to the given {@link Appendable}
 target. Closing the writer will close the target if it is {@link
 Closeable}, and flushing the writer will flush the target if it is {@link
 java.io.Flushable}.

 @param target the object to which output will be sent
 @return a new Writer object, unless target is a Writer, in which case the
     target is returned]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with character streams.

 <p>All method parameters must be non-null unless documented otherwise.

 <p>Some of the methods in this class take arguments with a generic type of
 {@code Readable & Closeable}. A {@link java.io.Reader} implements both of
 those interfaces. Similarly for {@code Appendable & Closeable} and
 {@link java.io.Writer}.

 @author Chris Nokleberg
 @author Bin Zhu
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CharStreams -->
  <!-- start class com.google.common.io.Closeables -->
  <class name="Closeables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.io.Closeable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes a {@link Closeable}, with control over whether an
 {@code IOException} may be thrown. This is primarily useful in a
 finally block, where a thrown exception needs to be logged but not
 propagated (otherwise the original exception will be lost).

 <p>If {@code swallowIOException} is true then we never throw
 {@code IOException} but merely log it.

 <p>Example:

 <p><pre>public void useStreamNicely() throws IOException {
 SomeStream stream = new SomeStream("foo");
 boolean threw = true;
 try {
   // Some code which does something with the Stream. May throw a
   // Throwable.
   threw = false; // No throwable thrown.
 } finally {
   // Close the stream.
   // If an exception occurs, only rethrow it if (threw==false).
   Closeables.close(stream, threw);
 }
 </pre>

 @param closeable the {@code Closeable} object to be closed, or null,
     in which case this method does nothing
 @param swallowIOException if true, don't propagate IO exceptions
     thrown by the {@code close} methods
 @throws IOException if {@code swallowIOException} is false and
     {@code close} throws an {@code IOException}.]]>
      </doc>
    </method>
    <method name="closeQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.io.Closeable"/>
      <doc>
      <![CDATA[Equivalent to calling {@code close(closeable, true)}, but with no
 IOException in the signature.
 @param closeable the {@code Closeable} object to be closed, or null, in
      which case this method does nothing]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Closeable} objects.

 @author Michael Lancaster
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Closeables -->
  <!-- start class com.google.common.io.CountingInputStream -->
  <class name="CountingInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, counting the number of bytes read.

 @param in the input stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes read.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that counts the number of bytes read.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingInputStream -->
  <!-- start class com.google.common.io.CountingOutputStream -->
  <class name="CountingOutputStream" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another output stream, counting the number of bytes written.

 @param out the output stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes written.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An OutputStream that counts the number of bytes written.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingOutputStream -->
  <!-- start class com.google.common.io.FileBackedOutputStream -->
  <class name="FileBackedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileBackedOutputStream" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold.
 Equivalent to {@code ThresholdOutputStream(fileThreshold, false)}.

 @param fileThreshold the number of bytes before the stream should
     switch to buffering to a file]]>
      </doc>
    </constructor>
    <constructor name="FileBackedOutputStream" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold, and
 optionally resets the data when the {@link InputSupplier} returned
 by {@link #getSupplier} is finalized.

 @param fileThreshold the number of bytes before the stream should
     switch to buffering to a file
 @param resetOnFinalize if true, the {@link #reset} method will
     be called when the {@link InputSupplier} returned by {@link
     #getSupplier} is finalized]]>
      </doc>
    </constructor>
    <method name="getSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a supplier that may be used to retrieve the data buffered
 by this stream.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calls {@link #close} if not already closed, and then resets this
 object back to its initial state, for reuse. If data was buffered
 to a file, it will be deleted.

 @throws IOException if an I/O error occurred while deleting the file buffer]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link OutputStream} that starts buffering to a byte array, but
 switches to file buffering once the data reaches a configurable size.

 <p>This class is thread-safe.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.FileBackedOutputStream -->
  <!-- start class com.google.common.io.Files -->
  <class name="Files" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReader" return="java.io.BufferedReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered reader that reads from a file using the given
 character set.

 @param file the file to read from
 @param charset the character set used when writing the file
 @return the buffered reader]]>
      </doc>
    </method>
    <method name="newWriter" return="java.io.BufferedWriter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered writer that writes to a file using the given
 character set.

 @param file the file to write to
 @param charset the character set used when writing the file
 @return the buffered writer]]>
      </doc>
    </method>
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.FileInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileInputStream}
 that read from a file.

 @param file the file to read from
 @return the factory]]>
      </doc>
    </method>
    <method name="newOutputStreamSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.FileOutputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileOutputStream}
 that write to a file.

 @param file the file to write to
 @return the factory]]>
      </doc>
    </method>
    <method name="newOutputStreamSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.FileOutputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="append" type="boolean"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileOutputStream}
 that write to or append to a file.

 @param file the file to write to
 @param append if true, the encoded characters will be appended to the file;
     otherwise the file is overwritten
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link InputStreamReader} that read a file using the given character set.

 @param file the file to read from
 @param charset the character set used when reading the file
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter}
 that write to a file using the given character set.

 @param file the file to write to
 @param charset the character set used when writing the file
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="append" type="boolean"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter}
 that write to or append to a file using the given character set.

 @param file the file to write to
 @param charset the character set used when writing the file
 @param append if true, the encoded characters will be appended to the file;
     otherwise the file is overwritten
 @return the factory]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a file into a byte array.

 @param file the file to read from
 @return a byte array containing all the bytes from file
 @throws IllegalArgumentException if the file is bigger than the largest
     possible byte array (2^31 - 1)
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a file into a {@link String}, using the given
 character set.

 @param file the file to read from
 @param charset the character set used when reading the file
 @return a string containing all the characters from the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies to a file all bytes from an {@link InputStream} supplied by a
 factory.

 @param from the input factory
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="byte[]"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Overwrites a file with the contents of a byte array.

 @param from the bytes to write
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a file to an {@link OutputStream} supplied by
 a factory.

 @param from the source file
 @param to the output factory
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a file to an output stream.

 @param from the source file
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all the bytes from one file to another.
.
 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies to a file all characters from a {@link Readable} and
 {@link Closeable} object supplied by a factory, using the given
 character set.

 @param from the readable supplier
 @param to the destination file
 @param charset the character set used when writing the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a character sequence (such as a string) to a file using the given
 character set.

 @param from the character sequence to write
 @param to the destination file
 @param charset the character set used when writing the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends a character sequence (such as a string) to a file using the given
 character set.

 @param from the character sequence to append
 @param to the destination file
 @param charset the character set used when writing the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters from a file to a {@link Appendable} &
 {@link Closeable} object supplied by a factory, using the given
 character set.

 @param from the source file
 @param charset the character set used when reading the file
 @param to the appendable supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters from a file to an appendable object,
 using the given character set.

 @param from the source file
 @param charset the character set used when reading the file
 @param to the appendable object
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file1" type="java.io.File"/>
      <param name="file2" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the files contains the same bytes.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="createTempDir" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atomically creates a new directory somewhere beneath the system's
 temporary directory (as defined by the {@code java.io.tmpdir} system
 property), and returns its name.

 <p>Use this method instead of {@link File#createTempFile(String, String)}
 when you wish to create a directory, not a regular file.  A common pitfall
 is to call {@code createTempFile}, delete the file and create a
 directory in its place, but this leads a race condition which can be
 exploited to create security vulnerabilities, especially when executable
 files are to be written into the directory.

 <p>This method assumes that the temporary volume is writable, has free
 inodes and free blocks, and that it will not be called thousands of times
 per second.

 @return the newly-created directory
 @throws IllegalStateException if the directory could not be created]]>
      </doc>
    </method>
    <method name="touch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates an empty file or updates the last updated timestamp on the
 same as the unix command of the same name.

 @param file the file to create or update
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="createParentDirs"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates any necessary but nonexistent parent directories of the specified
 file. Note that if this operation fails it may have succeeded in creating
 some (but not all) of the necessary parent directories.

 @throws IOException if an I/O error occurs, or if any necessary but
     nonexistent parent directories of the specified file could not be
     created.
 @since 4]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Moves the file from one path to another. This method can rename a file or
 move it to a different directory, like the Unix {@code mv} command.

 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="deleteDirectoryContents"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="directory" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes all the files within a directory. Does not delete the
 directory itself.

 <p>If the file argument is a symbolic link or there is a symbolic
 link in the path leading to the directory, this method will do
 nothing. Symbolic links within the directory are not followed.

 @param directory the directory to delete the contents of
 @throws IllegalArgumentException if the argument is not a directory
 @throws IOException if an I/O error occurs
 @see #deleteRecursively]]>
      </doc>
    </method>
    <method name="deleteRecursively"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes a file or directory and all contents recursively.

 <p>If the file argument is a symbolic link the link will be deleted
 but not the target of the link. If the argument is a directory,
 symbolic links within the directory will not be followed.

 @param file the file to delete
 @throws IOException if an I/O error occurs
 @see #deleteDirectoryContents]]>
      </doc>
    </method>
    <method name="readFirstLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line from a file. The line does not include
 line-termination characters, but does include other leading and
 trailing whitespace.

 @param file the file to read from
 @param charset the character set used when writing the file
 @return the first line, or null if the file is empty
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a file. The lines do not include
 line-termination characters, but do include other leading and
 trailing whitespace.

 @param file the file to read from
 @param charset the character set used when writing the file
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link File}, stopping when our callback returns
 false, or we have read all of the lines.

 @param file the file to read from
 @param charset the character set used when writing the file
 @param callback the {@link LineProcessor} to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readBytes" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of a file.

 <p>(If this seems too complicated, maybe you're looking for
 {@link #toByteArray}.)

 @param file the file to read
 @param processor the object to which the bytes of the file are passed.
 @return the result of the byte processor
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getChecksum" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="checksum" type="java.util.zip.Checksum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the checksum value for a file.
 The checksum object is reset when this method returns successfully.

 @param file the file to read
 @param checksum the checksum object
 @return the result of {@link Checksum#getValue} after updating the
     checksum object with all of the bytes in the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getDigest" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="md" type="java.security.MessageDigest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the digest value for a file.
 The digest object is reset when this method returns successfully.

 @param file the file to read
 @param md the digest object
 @return the result of {@link MessageDigest#digest()} after updating the
     digest object with all of the bytes in this file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully maps a file read-only in to memory as per
 {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.

 <p>Files are mapped from offset 0 to its length.

 <p>This only works for files <= {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @return a read-only buffer reflecting {@code file}
 @throws FileNotFoundException if the {@code file} does not exist
 @throws IOException if an I/O error occurs

 @see FileChannel#map(MapMode, long, long)
 @since 2]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="mode" type="java.nio.channels.FileChannel.MapMode"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully maps a file in to memory as per
 {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}
 using the requested {@link MapMode}.

 <p>Files are mapped from offset 0 to its length.

 <p>This only works for files <= {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @param mode the mode to use when mapping {@code file}
 @return a buffer reflecting {@code file}
 @throws FileNotFoundException if the {@code file} does not exist
 @throws IOException if an I/O error occurs

 @see FileChannel#map(MapMode, long, long)
 @since 2]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="mode" type="java.nio.channels.FileChannel.MapMode"/>
      <param name="size" type="long"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Maps a file in to memory as per
 {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}
 using the requested {@link MapMode}.

 <p>Files are mapped from offset 0 to {@code size}.

 <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist,
 it will be created with the requested {@code size}. Thus this method is
 useful for creating memory mapped files which do not yet exist.

 <p>This only works for files <= {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @param mode the mode to use when mapping {@code file}
 @return a buffer reflecting {@code file}
 @throws IOException if an I/O error occurs

 @see FileChannel#map(MapMode, long, long)
 @since 2]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with files.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Files -->
  <!-- start class com.google.common.io.Flushables -->
  <class name="Flushables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush a {@link Flushable}, with control over whether an
 {@code IOException} may be thrown.

 <p>If {@code swallowIOException} is true, then we don't rethrow
 {@code IOException}, but merely log it.

 @param flushable the {@code Flushable} object to be flushed.
 @param swallowIOException if true, don't propagate IO exceptions
     thrown by the {@code flush} method
 @throws IOException if {@code swallowIOException} is false and
     {@link Flushable#flush} throws an {@code IOException}.
 @see Closeables#close]]>
      </doc>
    </method>
    <method name="flushQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <doc>
      <![CDATA[Equivalent to calling {@code flush(flushable, true)}, but with no
 {@code IOException} in the signature.

 @param flushable the {@code Flushable} object to be flushed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Flushable} objects.

 @author Michael Lancaster
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Flushables -->
  <!-- start interface com.google.common.io.InputSupplier -->
  <interface name="InputSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getInput" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A factory for readable streams of bytes or characters.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.InputSupplier -->
  <!-- start class com.google.common.io.LimitInputStream -->
  <class name="LimitInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LimitInputStream" type="java.io.InputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, limiting the number of bytes which can be read.

 @param in the input stream to be wrapped
 @param limit the maximum number of bytes to be read]]>
      </doc>
    </constructor>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An InputStream that limits the number of bytes which can be read.

 @author Charles Fry
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LimitInputStream -->
  <!-- start interface com.google.common.io.LineProcessor -->
  <interface name="LineProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processLine" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="line" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called once for each line.

 @param line the line read from the input, without delimiter
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the lines.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback to be used with the streaming {@code readLines} methods.

 <p>{@link #processLine} will be called for each line that is read, and
 should return {@code false} when you want to stop processing.

 @author Miles Barr
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.LineProcessor -->
  <!-- start class com.google.common.io.LineReader -->
  <class name="LineReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LineReader" type="java.lang.Readable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that will read lines from the given
 {@code Readable} object.]]>
      </doc>
    </constructor>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a line of text. A line is considered to be terminated by any
 one of a line feed ({@code '\n'}), a carriage return
 ({@code '\r'}), or a carriage return followed immediately by a linefeed
 ({@code "\r\n"}).

 @return a {@code String} containing the contents of the line, not
     including any line-termination characters, or {@code null} if the
     end of the stream has been reached.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for reading lines of text. Provides the same functionality
 as {@link java.io.BufferedReader#readLine()} but for all {@link Readable}
 objects, not just instances of {@link Reader}.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LineReader -->
  <!-- start class com.google.common.io.NullOutputStream -->
  <class name="NullOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullOutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Discards the specified byte.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Discards the specified byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@link OutputStream} that simply discards written bytes.

 @author Spencer Kimball
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.NullOutputStream -->
  <!-- start interface com.google.common.io.OutputSupplier -->
  <interface name="OutputSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getOutput" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An factory for writable streams of bytes or characters.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.OutputSupplier -->
  <!-- start class com.google.common.io.PatternFilenameFilter -->
  <class name="PatternFilenameFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.FilenameFilter"/>
    <constructor name="PatternFilenameFilter" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.
 @param patternStr the pattern string on which to filter file names

 @throws PatternSyntaxException if pattern compilation fails (runtime)]]>
      </doc>
    </constructor>
    <constructor name="PatternFilenameFilter" type="java.util.regex.Pattern"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.
 @param pattern the pattern on which to filter file names]]>
      </doc>
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="fileName" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[File name filter that only accepts files matching a regular expression.

 @author Apple Chow
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.PatternFilenameFilter -->
  <!-- start class com.google.common.io.Resources -->
  <class name="Resources" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link InputStream} that
 read from the given URL.

 @param url the URL to read from
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link InputStreamReader} that read a URL using the given character set.

 @param url the URL to read from
 @param charset the character set used when reading the URL contents
 @return the factory]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a URL into a byte array.

 @param url the URL to read from
 @return a byte array containing all the bytes from the URL
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a URL into a {@link String}, using the given
 character set.

 @param url the URL to read from
 @param charset the character set used when reading the URL
 @return a string containing all the characters from the URL
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a URL, stopping when our callback returns false, or we
 have read all of the lines.

 @param url the URL to read from
 @param charset the character set used when reading the URL
 @param callback the LineProcessor to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a URL. The lines do not include
 line-termination characters, but do include other leading and trailing
 whitespace.

 @param url the URL to read from
 @param charset the character set used when writing the file
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.net.URL"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a URL to an output stream.

 @param from the URL to read from
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code URL} pointing to {@code resourceName} if the resource is
 found in the class path. {@code Resources.class.getClassLoader()} is used
 to locate the resource.
 
 @throws IllegalArgumentException if resource is not found]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code URL} pointing to {@code resourceName} that is relative to
 {@code contextClass}, if the resource is found in the class path. 
 
 @throws IllegalArgumentException if resource is not found]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with resources in the classpath.
 Note that even though these methods use {@link URL} parameters, they
 are usually not appropriate for HTTP or other non-classpath resources.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @author Ben Yu
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Resources -->
</package>
<package name="com.google.common.net">
  <!-- start class com.google.common.net.HostSpecifier -->
  <class name="HostSpecifier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="fromValid" return="com.google.common.net.HostSpecifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code HostSpecifier} built from the provided {@code specifier},
 which is already known to be valid.  If the {@code specifier} might be
 valid, use {@link #from(String)} instead.

 <p>The specifier must be in one of these formats:
 <ul>
 <li>A domain name, like {@code google.com}
 <li>A IPv4 address string, like {@code 127.0.0.1}
 <li>An IPv6 address string with or without brackets, like
     {@code [2001:db8::1]} or {@code 2001:db8::1}
 <li>An IPv6 address string enclosed in square brackets, like
     {[2001:db8::1]}
 </ul>

 @throws IllegalArgumentException if the specifier is not valid.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.net.HostSpecifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <exception name="ParseException" type="java.text.ParseException"/>
      <doc>
      <![CDATA[Attempts to return a {@code HostSpecifier} for the given string, throwing
 an exception if parsing fails. Always use this method in preference to
 {@link #fromValid(String)} for a specifier that is not already known to be
 valid.

 @throws ParseException if the specifier is not valid.]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Determines whether {@code specifier} represents a valid
 {@link HostSpecifier} as described in the documentation for
 {@link #fromValid(String)}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the host specifier suitable for
 inclusion in a URI.  If the host specifier is a domain name, the
 string will be normalized to all lower case.  If the specifier was
 an IPv6 address without brackets, brackets are added so that the
 result will be usable in the host part of a URI.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A syntactically valid host specifier, suitable for use in a URI.
 This may be either a numeric IP address in IPv4 or IPv6 notation, or a
 domain name.

 <p>Because this class is intended to represent host specifiers which can
 reasonably be used in a URI, the domain name case is further restricted to
 include only those domain names which end in a recognized public suffix; see
 {@link InternetDomainName#isPublicSuffix()} for details.

 <p>Note that no network lookups are performed by any {@code HostSpecifier}
 methods.  No attempt is made to verify that a provided specifier corresponds
 to a real or accessible host.  Only syntactic and pattern-based checks are
 performed.

 <p>If you know that a given string represents a numeric IP address, use
 {@link InetAddresses} to obtain and manipulate a
 {@link java.net.InetAddress} instance from it rather than using this class.
 Similarly, if you know that a given string represents a domain name, use
 {@link InternetDomainName} rather than this class.

 @author Craig Berry
 @since 5]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HostSpecifier -->
  <!-- start class com.google.common.net.InetAddresses -->
  <class name="InetAddresses" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="forString" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the {@link InetAddress} having the given string
 representation.

 <p>This deliberately avoids all nameservice lookups (e.g. no DNS).

 @param ipString {@code String} containing an IPv4 or IPv6 string literal,
                 e.g. {@code "192.168.0.1"} or {@code "2001:db8::1"}
 @return {@link InetAddress} representing the argument
 @throws IllegalArgumentException if the argument is not a valid
         IP string literal]]>
      </doc>
    </method>
    <method name="isInetAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the supplied string is a valid IP string
 literal, {@code false} otherwise.

 @param ipString {@code String} to evaluated as an IP string literal
 @return {@code true} if the argument is a valid IP string literal]]>
      </doc>
    </method>
    <method name="toUriString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns the string representation of an {@link InetAddress} suitable
 for inclusion in a URI.

 <p>For IPv4 addresses, this is identical to
 {@link InetAddress#getHostAddress()}, but for IPv6 addresses it
 surrounds this text with square brackets; for example
 {@code "[2001:db8::1]"}.

 <p>Per section 3.2.2 of
 <a target="_parent"
    href="http://tools.ietf.org/html/rfc3986#section-3.2.2"
  >http://tools.ietf.org/html/rfc3986</a>,
 a URI containing an IPv6 string literal is of the form
 {@code "http://[2001:db8::1]:8888/index.html"}.

 <p>Use of either {@link InetAddress#getHostAddress()} or this
 method is recommended over {@link InetAddress#toString()} when an
 IP address string literal is desired.  This is because
 {@link InetAddress#toString()} prints the hostname and the IP
 address string joined by a "/".

 @param ip {@link InetAddress} to be converted to URI string literal
 @return {@code String} containing URI-safe string literal]]>
      </doc>
    </method>
    <method name="forUriString" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostAddr" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an InetAddress representing the literal IPv4 or IPv6 host
 portion of a URL, encoded in the format specified by RFC 3986 section 3.2.2.

 <p>This function is similar to {@link InetAddresses#forString(String)},
 however, it requires that IPv6 addresses are surrounded by square brackets.

 <p>This function is the inverse of
 {@link InetAddresses#toUriString(java.net.InetAddress)}.

 @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address
 @return an InetAddress representing the address in {@code hostAddr}
 @throws IllegalArgumentException if {@code hostAddr} is not a valid
     IPv4 address, or IPv6 address surrounded by square brackets]]>
      </doc>
    </method>
    <method name="isUriInetAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the supplied string is a valid URI IP string
 literal, {@code false} otherwise.

 @param ipString {@code String} to evaluated as an IP URI host string literal
 @return {@code true} if the argument is a valid IP URI host]]>
      </doc>
    </method>
    <method name="isCompatIPv4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an IPv6 "compat" address.

 <p>An "IPv4 compatible", or "compat", address is one with 96 leading
 bits of zero, with the remaining 32 bits interpreted as an
 IPv4 address.  These are conventionally represented in string
 literals as {@code "::192.168.0.1"}, though {@code "::c0a8:1"} is
 also considered an IPv4 compatible address (and equivalent to
 {@code "::192.168.0.1"}).

 <p>For more on IPv4 compatible addresses see section 2.5.5.1 of
 <a target="_parent"
    href="http://tools.ietf.org/html/rfc4291#section-2.5.5.1"
    >http://tools.ietf.org/html/rfc4291</a>

 <p>NOTE: This method is different from
 {@link Inet6Address#isIPv4CompatibleAddress} in that it more
 correctly classifies {@code "::"} and {@code "::1"} as
 proper IPv6 addresses (which they are), NOT IPv4 compatible
 addresses (which they are generally NOT considered to be).

 @param ip {@link Inet6Address} to be examined for embedded IPv4
           compatible address format
 @return {@code true} if the argument is a valid "compat" address]]>
      </doc>
    </method>
    <method name="getCompatIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in an IPv4 compatible address.

 @param ip {@link Inet6Address} to be examined for an embedded
           IPv4 address
 @return {@link Inet4Address} of the embedded IPv4 address
 @throws IllegalArgumentException if the argument is not a valid
         IPv4 compatible address]]>
      </doc>
    </method>
    <method name="is6to4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is a 6to4 address.

 <p>6to4 addresses begin with the {@code "2002::/16"} prefix.
 The next 32 bits are the IPv4 address of the host to which
 IPv6-in-IPv4 tunneled packets should be routed.

 <p>For more on 6to4 addresses see section 2 of
 <a target="_parent" href="http://tools.ietf.org/html/rfc3056#section-2"
    >http://tools.ietf.org/html/rfc3056</a>

 @param ip {@link Inet6Address} to be examined for 6to4 address
        format
 @return {@code true} if the argument is a 6to4 address]]>
      </doc>
    </method>
    <method name="get6to4IPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in a 6to4 address.

 @param ip {@link Inet6Address} to be examined for embedded IPv4
           in 6to4 address.
 @return {@link Inet4Address} of embedded IPv4 in 6to4 address.
 @throws IllegalArgumentException if the argument is not a valid
         IPv6 6to4 address.]]>
      </doc>
    </method>
    <method name="isTeredoAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is a Teredo address.

 <p>Teredo addresses begin with the {@code "2001::/32"} prefix.

 @param ip {@link Inet6Address} to be examined for Teredo address
        format.
 @return {@code true} if the argument is a Teredo address]]>
      </doc>
    </method>
    <method name="getTeredoInfo" return="com.google.common.net.InetAddresses.TeredoInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the Teredo information embedded in a Teredo address.

 @param ip {@link Inet6Address} to be examined for embedded Teredo
           information
 @return extracted {@code TeredoInfo}
 @throws IllegalArgumentException if the argument is not a valid
         IPv6 Teredo address]]>
      </doc>
    </method>
    <method name="isIsatapAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an ISATAP address.

 <p>From RFC 5214: "ISATAP interface identifiers are constructed in
 Modified EUI-64 format [...] by concatenating the 24-bit IANA OUI
 (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit IPv4
 address in network byte order [...]"

 <p>For more on ISATAP addresses see section 6.1 of
 <a target="_parent" href="http://tools.ietf.org/html/rfc5214#section-6.1"
    >http://tools.ietf.org/html/rfc5214</a>

 @param ip {@link Inet6Address} to be examined for ISATAP address
        format.
 @return {@code true} if the argument is an ISATAP address]]>
      </doc>
    </method>
    <method name="getIsatapIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in an ISATAP address.

 @param ip {@link Inet6Address} to be examined for embedded IPv4
           in ISATAP address
 @return {@link Inet4Address} of embedded IPv4 in an ISATAP address
 @throws IllegalArgumentException if the argument is not a valid
         IPv6 ISATAP address]]>
      </doc>
    </method>
    <method name="getEmbeddedIPv4ClientAddress" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Examines the InetAddress to extract the embedded IPv4 client address
 if the InetAddress is an IPv6 address of one of the specified address
 types that contain an embedded IPv4 address.

 <p>NOTE: ISATAP addresses are explicitly excluded from this method
 due to their trivial spoofability.  With other transition addresses
 spoofing involves (at least) infection of Google's BGP routing table.

 @param ip {@link Inet6Address} to be examined for embedded IPv4
           client address.
 @return {@link Inet4Address} of embedded IPv4 client address.
 @throws IllegalArgumentException if the argument does not have a valid
         embedded IPv4 address.]]>
      </doc>
    </method>
    <method name="fromInteger" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="int"/>
      <doc>
      <![CDATA[Returns an Inet4Address having the integer value specified by
 the argument.

 @param address {@code int}, the 32bit integer address to be converted
 @return {@link Inet4Address} equivalent of the argument]]>
      </doc>
    </method>
    <method name="fromLittleEndianByteArray" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="byte[]"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns an address from a <b>little-endian ordered</b> byte array
 (the opposite of what {@link InetAddress#getByAddress} expects).

 <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array
 must be 16 bytes long.

 @param addr the raw IP address in little-endian byte order
 @return an InetAddress object created from the raw IP address
 @throws UnknownHostException if IP address is of illegal length]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link InetAddress} instances.

 <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the
 methods of this class never cause DNS services to be accessed. For
 this reason, you should prefer these methods as much as possible over
 their JDK equivalents whenever you are expecting to handle only
 IP address string literals -- there is no blocking DNS penalty for a
 malformed string.

 <p>This class hooks into the {@code sun.net.util.IPAddressUtil} class
 to make use of the {@code textToNumericFormatV4} and
 {@code textToNumericFormatV6} methods directly as a means to avoid
 accidentally traversing all nameservices (it can be vitally important
 to avoid, say, blocking on DNS at times).

 <p>When dealing with {@link Inet4Address} and {@link Inet6Address}
 objects as byte arrays (vis. {@code InetAddress.getAddress()}) they
 are 4 and 16 bytes in length, respectively, and represent the address
 in network byte order.

 <p>Examples of IP addresses and their byte representations:
 <ul>
 <li>The IPv4 loopback address, {@code "127.0.0.1"}.<br/>
     {@code 7f 00 00 01}

 <li>The IPv6 loopback address, {@code "::1"}.<br/>
     {@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}

 <li>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}),
     {@code "2001:db8::1"}.<br/>
     {@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}

 <li>An IPv6 "IPv4 compatible" (or "compat") address,
     {@code "::192.168.0.1"}.<br/>
     {@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}

 <li>An IPv6 "IPv4 mapped" address, {@code "::ffff:192.168.0.1"}.<br/>
     {@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}
 </ul>

 <p>A few notes about IPv6 "IPv4 mapped" addresses and their observed
 use in Java.
 <br><br>
 "IPv4 mapped" addresses were originally a representation of IPv4
 addresses for use on an IPv6 socket that could receive both IPv4
 and IPv6 connections (by disabling the {@code IPV6_V6ONLY} socket
 option on an IPv6 socket).  Yes, it's confusing.  Nevertheless,
 these "mapped" addresses were never supposed to be seen on the
 wire.  That assumption was dropped, some say mistakenly, in later
 RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.

 <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire
 format of a "mapped" address, as shown above, and transmit it in an
 IPv6 packet header.  However, Java's InetAddress creation methods
 appear to adhere doggedly to the original intent of the "mapped"
 address: all "mapped" addresses return {@link Inet4Address} objects.

 <p>For added safety, it is common for IPv6 network operators to filter
 all packets where either the source or destination address appears to
 be a "compat" or "mapped" address.  Filtering suggestions usually
 recommend discarding any packets with source or destination addresses
 in the invalid range {@code ::/3}, which includes both of these bizarre
 address formats.  For more information on "bogons", including lists
 of IPv6 bogon space, see:

 <ul>
 <li><a target="_parent"
        href="http://en.wikipedia.org/wiki/Bogon_filtering"
       >http://en.wikipedia.org/wiki/Bogon_filtering</a>
 <li><a target="_parent"
        href="http://www.cymru.com/Bogons/ipv6.txt"
       >http://www.cymru.com/Bogons/ipv6.txt</a>
 <li><a target="_parent"
        href="http://www.cymru.com/Bogons/v6bogon.html"
       >http://www.cymru.com/Bogons/v6bogon.html</a>
 <li><a target="_parent"
        href="http://www.space.net/~gert/RIPE/ipv6-filters.html"
       >http://www.space.net/~gert/RIPE/ipv6-filters.html</a>
 </ul>

 @author Erik Kline
 @since 5]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InetAddresses -->
  <!-- start class com.google.common.net.InetAddresses.TeredoInfo -->
  <class name="InetAddresses.TeredoInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InetAddresses.TeredoInfo" type="java.net.Inet4Address, java.net.Inet4Address, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TeredoInfo instance.

 <p>Both server and client can be {@code null}, in which case the
 value {@code "0.0.0.0"} will be assumed.

 @throws IllegalArgumentException if either of the {@code port}
         or the {@code flags} arguments are out of range of an
         unsigned short]]>
      </doc>
    </constructor>
    <method name="getServer" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClient" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFlags" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simple data class to encapsulate the information to be found in a
 Teredo address.

 <p>All of the fields in this class are encoded in various portions
 of the IPv6 address as part of the protocol.  More protocols details
 can be found at:
 <a target="_parent" href="http://en.wikipedia.org/wiki/Teredo_tunneling"
    >http://en.wikipedia.org/wiki/Teredo_tunneling</a>.

 <p>The RFC can be found here:
 <a target="_parent" href="http://tools.ietf.org/html/rfc4380"
    >http://tools.ietf.org/html/rfc4380</a>.

 @since 5]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InetAddresses.TeredoInfo -->
  <!-- start class com.google.common.net.InternetDomainName -->
  <class name="InternetDomainName" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="from" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <doc>
      <![CDATA[A factory method for creating {@code InternetDomainName} objects.

 @param domain A domain name (not IP address)
 @throws IllegalArgumentException If name is not syntactically valid]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the domain name, normalized to all lower case.]]>
      </doc>
    </method>
    <method name="parts" return="com.google.common.collect.ImmutableList&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the individual components of this domain name, normalized to all
 lower case. For example, for the domain name {@code mail.google.com}, this
 method returns the list {@code ["mail", "google", "com"]}.]]>
      </doc>
    </method>
    <method name="isRecognizedTld" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #isPublicSuffix()}">
      <doc>
      <![CDATA[Old location of {@link #isPublicSuffix()}.

 @deprecated use {@link #isPublicSuffix()}]]>
      </doc>
    </method>
    <method name="isUnderRecognizedTld" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #isUnderPublicSuffix()}">
      <doc>
      <![CDATA[Old location of {@link #isUnderPublicSuffix()}.

 @deprecated use {@link #isUnderPublicSuffix()}]]>
      </doc>
    </method>
    <method name="hasRecognizedTld" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #hasPublicSuffix()}">
      <doc>
      <![CDATA[Old location of {@link #hasPublicSuffix()}.

 @deprecated use {@link #hasPublicSuffix()}]]>
      </doc>
    </method>
    <method name="recognizedTld" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #publicSuffix()}">
      <doc>
      <![CDATA[Old location of {@link #publicSuffix()}.

 @deprecated use {@link #publicSuffix()}]]>
      </doc>
    </method>
    <method name="isImmediatelyUnderTld" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #isTopPrivateDomain()}">
      <doc>
      <![CDATA[Old location of {@link #isTopPrivateDomain()}.

 @deprecated use {@link #isTopPrivateDomain()}]]>
      </doc>
    </method>
    <method name="topCookieDomain" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #topPrivateDomain()}">
      <doc>
      <![CDATA[Old location of {@link #topPrivateDomain()}.

 @deprecated use {@link #topPrivateDomain()}]]>
      </doc>
    </method>
    <method name="rightmostNonTldPart" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use the first {@linkplain #parts part} of the {@link
     #topPrivateDomain()}">
      <doc>
      <![CDATA[Returns the rightmost non-{@linkplain #isRecognizedTld() TLD} domain name
 part.  For example
 {@code new InternetDomainName("www.google.com").rightmostNonTldPart()}
 returns {@code "google"}.  Returns null if either no
 {@linkplain #isRecognizedTld() TLD} is found, or the whole domain name is
 itself a {@linkplain #isRecognizedTld() TLD}.

 @deprecated use the first {@linkplain #parts part} of the {@link
     #topPrivateDomain()}]]>
      </doc>
    </method>
    <method name="isPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name represents a <i>public suffix</i>, as
 defined by the Mozilla Foundation's
 <a href="http://publicsuffix.org/">Public Suffix List</a> (PSL). A public
 suffix is one under which Internet users can directly register names, such
 as {@code com}, {@code co.uk} or {@code pvt.k12.wy.us}. Examples of domain
 names that are <i>not</i> public suffixes include {@code google}, {@code
 google.com} and {@code foo.co.uk}.

 @return {@code true} if this domain name appears exactly on the public
     suffix list
 @since 6]]>
      </doc>
    </method>
    <method name="hasPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isPublicSuffix()
 public suffix}, including if it is a public suffix itself. For example,
 returns {@code true} for {@code www.google.com}, {@code foo.co.uk} and
 {@code com}, but not for {@code google} or {@code google.foo}.

 @since 6]]>
      </doc>
    </method>
    <method name="publicSuffix" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@linkplain #isPublicSuffix() public suffix} portion of the
 domain name, or {@code null} if no public suffix is present.

 @since 6]]>
      </doc>
    </method>
    <method name="isUnderPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isPublicSuffix()
 public suffix}, while not being a public suffix itself. For example,
 returns {@code true} for {@code www.google.com}, {@code foo.co.uk} and
 {@code bar.ca.us}, but not for {@code google}, {@code com}, or {@code
 google.foo}.

 @since 6]]>
      </doc>
    </method>
    <method name="isTopPrivateDomain" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name is composed of exactly one subdomain
 component followed by a {@linkplain #isPublicSuffix() public suffix}. For
 example, returns {@code true} for {@code google.com} and {@code foo.co.uk},
 but not for {@code www.google.com} or {@code co.uk}.

 @since 6]]>
      </doc>
    </method>
    <method name="topPrivateDomain" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the portion of this domain name that is one level beneath the
 public suffix. For example, for {@code x.adwords.google.co.uk} it returns
 {@code google.co.uk}, since {@code co.uk} is a public suffix. This is the
 highest-level parent of this domain for which cookies may be set, as
 cookies cannot be set on a public suffix itself.

 <p>If {@link #isTopPrivateDomain()} is true, the current domain name
 instance is returned.

 @throws IllegalStateException if this domain does not end with a
     public suffix
 @since 6]]>
      </doc>
    </method>
    <method name="hasParent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain is composed of two or more parts.]]>
      </doc>
    </method>
    <method name="parent" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code InternetDomainName} that is the immediate ancestor of
 this one; that is, the current domain with the leftmost part removed. For
 example, the parent of {@code www.google.com} is {@code google.com}.

 @throws IllegalStateException if the domain has no parent, as determined
     by {@link #hasParent}]]>
      </doc>
    </method>
    <method name="child" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leftParts" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates and returns a new {@code InternetDomainName} by prepending the
 argument and a dot to the current name. For example, {@code
 InternetDomainName.from("foo.com").child("www.bar")} returns a new {@code
 InternetDomainName} with the value {@code www.bar.foo.com}.

 @throws NullPointerException if leftParts is null
 @throws IllegalArgumentException if the resulting name is not valid]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Indicates whether the argument is a syntactically valid domain name.  This
 method is intended for the case where a {@link String} must be validated as
 a valid domain name, but no further work with that {@link String} as an
 {@link InternetDomainName} will be required. Code like the following will
 unnecessarily repeat the work of validation: <pre>   {@code

   if (InternetDomainName.isValid(name)) {
     domainName = InternetDomainName.from(name);
   } else {
     domainName = DEFAULT_DOMAIN;
   }}</pre>

 Such code could instead be written as follows: <pre>   {@code

   try {
     domainName = InternetDomainName.from(name);
   } catch (IllegalArgumentException e) {
     domainName = DEFAULT_DOMAIN;
   }}</pre>]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable well-formed internet domain name, as defined by
 <a href="http://www.ietf.org/rfc/rfc1035.txt">RFC 1035</a>, with the
 exception that names ending in {@code "."} are not supported (as they are not
 generally used in browsers, email, and other end-user applications. Examples
 include {@code com} and {@code foo.co.uk}. Only syntactic analysis is
 performed; no DNS lookups or other network interactions take place. Thus
 there is no guarantee that the domain actually exists on the internet.
 Invalid domain names throw {@link IllegalArgumentException} on construction.

 <p>It is often the case that domains of interest are those under a
 {@linkplain #isPublicSuffix() public suffix} but not themselves a public
 suffix; {@link #hasPublicSuffix()} and {@link #isTopPrivateDomain()} test for
 this. Similarly, one often needs to obtain the domain consisting of the
 public suffix plus one subdomain level, typically to obtain the highest-level
 domain for which cookies may be set. Use {@link #topPrivateDomain()} for this
 purpose.

 <p>{@linkplain #equals(Object) Equality} of domain names is case-insensitive,
 so for convenience, the {@link #name()} and {@link #parts()} methods return
 the lowercase form of the name.

 <p><a href="http://en.wikipedia.org/wiki/Internationalized_domain_name">
 internationalized domain names (IDN)</a> such as {@code .cn} are
 supported.

 @author Craig Berry
 @since 5]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InternetDomainName -->
</package>
<package name="com.google.common.primitives">
  <!-- start class com.google.common.primitives.Booleans -->
  <class name="Booleans" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Boolean) value).hashCode()}.

 @param value a primitive {@code boolean} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="boolean"/>
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Compares the two specified {@code boolean} values in the standard way
 ({@code false} is considered less than {@code true}). The sign of the
 value returned is the same as that of {@code ((Boolean) a).compareTo(b)}.

 @param a the first {@code boolean} to compare
 @param b the second {@code boolean} to compare
 @return a positive number if only {@code a} is {@code true},  a negative
     number if only {@code b} is true, or zero if {@code a == b}]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link
 BitSet} instead, replacing {@code Booleans.contains(array, true)}
 with {@code !bitSet.isEmpty()} and {@code Booleans.contains(array, false)}
 with {@code bitSet.nextClearBit(0) == sizeOfBitSet}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link BitSet}
 instead, and using {@link BitSet#nextSetBit(int)} or {@link
 BitSet#nextClearBit(int)}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="boolean[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new boolean[] {a, b}, new boolean[] {}, new
 boolean[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code boolean} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code boolean} values separated
 by {@code separator}. For example, {@code join("-", false, true, false)}
 returns the string {@code "false-true-false"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code boolean} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;boolean[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code boolean} arrays
 lexicographically. That is, it compares, using {@link
 #compare(boolean, boolean)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < [false] < [false, true] < [true]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(boolean[], boolean[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <method name="toArray" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Boolean} instances into a new array of
 primitive {@code boolean} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 <p><b>Note:</b> consider representing the collection as a {@link
 BitSet} instead.

 @param collection a collection of {@code Boolean} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Boolean} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code boolean} primitives, that are not
 already found in either {@link Boolean} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Booleans -->
  <!-- start class com.google.common.primitives.Bytes -->
  <class name="Bytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Byte) value).hashCode()}.

 @param value a primitive {@code byte} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="byte[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new byte[] {a, b}, new byte[] {}, new
 byte[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code byte} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="toArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Byte&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Byte} instances into a new array of
 primitive {@code byte} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Byte} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Byte&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="byte[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Byte} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives, that are not
 already found in either {@link Byte} or {@link Arrays}, <i>and interpret
 bytes as neither signed nor unsigned</i>. The methods which specifically
 treat bytes as signed or unsigned are found in {@link SignedBytes} and {@link
 UnsignedBytes}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Bytes -->
  <!-- start class com.google.common.primitives.Chars -->
  <class name="Chars" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Character) value).hashCode()}.

 @param value a primitive {@code char} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code char} type
 @return the {@code char} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Character#MAX_VALUE} or less than {@link Character#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code char} if it is in the range of the
     {@code char} type, {@link Character#MAX_VALUE} if it is too large,
     or {@link Character#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="char"/>
      <param name="b" type="char"/>
      <doc>
      <![CDATA[Compares the two specified {@code char} values. The sign of the value
 returned is the same as that of {@code ((Character) a).compareTo(b)}.

 @param a the first {@code char} to compare
 @param b the second {@code char} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="char[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new char[] {a, b}, new char[] {}, new
 char[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code char} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 2-element byte
 array; equivalent to {@code
 ByteBuffer.allocate(2).putChar(value).array()}.  For example, the input
 value {@code '\\u5432'} would yield the byte array {@code {0x54, 0x32}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code char} value whose big-endian representation is
 stored in the first 2 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getChar()}. For example, the input byte array
 {@code {0x54, 0x32}} would yield the {@code char} value {@code '\\u5432'}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 2
     elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code char} values separated
 by {@code separator}. For example, {@code join("-", '1', '2', '3')} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code char} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;char[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code char} arrays
 lexicographically. That is, it compares, using {@link
 #compare(char, char)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < ['a'] < ['a', 'b'] < ['b']}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(char[], char[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <method name="toArray" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Character&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Character} instances into a new array of
 primitive {@code char} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Character} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="char[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Character} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code char}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code char} primitives, that are not
 already found in either {@link Character} or {@link Arrays}.

 <p>All the operations in this class treat {@code char} values strictly
 numerically; they are neither Unicode-aware nor locale-dependent.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Chars -->
  <!-- start class com.google.common.primitives.Doubles -->
  <class name="Doubles" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Double) value).hashCode()}.

 @param value a primitive {@code double} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <doc>
      <![CDATA[Compares the two specified {@code double} values. The sign of the value
 returned is the same as that of <code>((Double) a).{@linkplain
 Double#compareTo compareTo}(b)</code>. As with that method, {@code NaN} is
 treated as greater than all other values, and {@code 0.0 > -0.0}.

 @param a the first {@code double} to compare
 @param b the second {@code double} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}. Note that this always returns {@code false} when {@code
 target} is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains
 {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of
 comparison as {@link Math#min(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules
 of comparison as {@link Math#max(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="double[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new double[] {a, b}, new double[] {}, new
 double[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code double} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code double} values, converted
 to strings as specified by {@link Double#toString(double)}, and separated
 by {@code separator}. For example, {@code join("-", 1.0, 2.0, 3.0)} returns
 the string {@code "1.0-2.0-3.0"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code double} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;double[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code double} arrays
 lexicographically. That is, it compares, using {@link
 #compare(double, double)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < [1.0] < [1.0, 2.0] < [2.0]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(double[], double[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <method name="toArray" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Double&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Double} instances into a new array of
 primitive {@code double} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Double} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="double[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Double} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code
 NaN}, or if {@code NaN} is used as a parameter to any of its methods.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code double} primitives, that are not
 already found in either {@link Double} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Doubles -->
  <!-- start class com.google.common.primitives.Floats -->
  <class name="Floats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Float) value).hashCode()}.

 @param value a primitive {@code float} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="float"/>
      <param name="b" type="float"/>
      <doc>
      <![CDATA[Compares the two specified {@code float} values using {@link
 Float#compare(float, float)}. You may prefer to invoke that method
 directly; this method exists only for consistency with the other utilities
 in this package.

 @param a the first {@code float} to compare
 @param b the second {@code float} to compare
 @return the result of invoking {@link Float#compare(float, float)}]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}. Note that this always returns {@code false} when {@code
 target} is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains
 {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of
 comparison as {@link Math#min(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules
 of comparison as {@link Math#min(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="float[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new float[] {a, b}, new float[] {}, new
 float[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code float} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code float} values, converted
 to strings as specified by {@link Float#toString(float)}, and separated by
 {@code separator}. For example, {@code join("-", 1.0f, 2.0f, 3.0f)}
 returns the string {@code "1.0-2.0-3.0"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code float} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;float[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code float} arrays
 lexicographically. That is, it compares, using {@link
 #compare(float, float)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example, {@code [] < [1.0f] < [1.0f, 2.0f]
 < [2.0f]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(float[], float[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <method name="toArray" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Float&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Float} instances into a new array of
 primitive {@code float} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Float} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Float&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="float[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Float} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code
 NaN}, or if {@code NaN} is used as a parameter to any of its methods.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code float} primitives, that are not
 already found in either {@link Float} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Floats -->
  <!-- start class com.google.common.primitives.Ints -->
  <class name="Ints" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Integer) value).hashCode()}.

 @param value a primitive {@code int} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code int} type
 @return the {@code int} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code int} if it is in the range of the
     {@code int} type, {@link Integer#MAX_VALUE} if it is too large,
     or {@link Integer#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Compares the two specified {@code int} values. The sign of the value
 returned is the same as that of {@code ((Integer) a).compareTo(b)}.

 @param a the first {@code int} to compare
 @param b the second {@code int} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="int[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new int[] {a, b}, new int[] {}, new
 int[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code int} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 4-element byte
 array; equivalent to {@code ByteBuffer.allocate(4).putInt(value).array()}.
 For example, the input value {@code 0x12131415} would yield the byte array
 {@code {0x12, 0x13, 0x14, 0x15}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code int} value whose big-endian representation is stored in
 the first 4 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getInt()}. For example, the input byte array {@code
 {0x12, 0x13, 0x14, 0x15, 0x33}} would yield the {@code int} value {@code
 0x12131415}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.

 @throws IllegalArgumentException if {@code bytes} has fewer than 4 elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code int} values separated
 by {@code separator}. For example, {@code join("-", 1, 2, 3)} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code int} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;int[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code int} arrays
 lexicographically. That is, it compares, using {@link
 #compare(int, int)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example, {@code [] < [1] < [1, 2] < [2]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(int[], int[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <method name="toArray" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Integer} instances into a new array of
 primitive {@code int} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Integer} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="int[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Integer} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code int}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code int} primitives, that are not
 already found in either {@link Integer} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Ints -->
  <!-- start class com.google.common.primitives.Longs -->
  <class name="Longs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Long) value).hashCode()}.

 @param value a primitive {@code long} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Compares the two specified {@code long} values. The sign of the value
 returned is the same as that of {@code ((Long) a).compareTo(b)}.

 @param a the first {@code long} to compare
 @param b the second {@code long} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="long[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new long[] {a, b}, new long[] {}, new
 long[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code long} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in an 8-element byte
 array; equivalent to {@code ByteBuffer.allocate(8).putLong(value).array()}.
 For example, the input value {@code 0x1213141516171819L} would yield the
 byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code long} value whose big-endian representation is
 stored in the first 8 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getLong()}. For example, the input byte array
 {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}} would yield the
 {@code long} value {@code 0x1213141516171819L}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 <p><b>Warning:</b> do not use this method in GWT. It returns wrong answers.

 @throws IllegalArgumentException if {@code bytes} has fewer than 8
     elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code long} values separated
 by {@code separator}. For example, {@code join("-", 1L, 2L, 3L)} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code long} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;long[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code long} arrays
 lexicographically. That is, it compares, using {@link
 #compare(long, long)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < [1L] < [1L, 2L] < [2L]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(long[], long[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <method name="toArray" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Long} instances into a new array of
 primitive {@code long} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Long} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="long[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Long} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code long}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code long} primitives, that are not
 already found in either {@link Long} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Longs -->
  <!-- start class com.google.common.primitives.Primitives -->
  <class name="Primitives" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="allPrimitiveTypes" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of all nine primitive types (including {@code
 void}). Note that a simpler way to test whether a {@code Class} instance
 is a member of this set is to call {@link Class#isPrimitive}.

 @since 3]]>
      </doc>
    </method>
    <method name="allWrapperTypes" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of all nine primitive-wrapper types (including
 {@link Void}).

 @since 3]]>
      </doc>
    </method>
    <method name="isWrapperType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code type} is one of the nine
 primitive-wrapper types, such as {@link Integer}.

 @see Class#isPrimitive]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding wrapper type of {@code type} if it is a primitive
 type; otherwise returns {@code type} itself. Idempotent.
 <pre>
     wrap(int.class) == Integer.class
     wrap(Integer.class) == Integer.class
     wrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <method name="unwrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding primitive type of {@code type} if it is a
 wrapper type; otherwise returns {@code type} itself. Idempotent.
 <pre>
     unwrap(Integer.class) == int.class
     unwrap(int.class) == int.class
     unwrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static utility methods pertaining to primitive types and their
 corresponding wrapper types.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Primitives -->
  <!-- start class com.google.common.primitives.Shorts -->
  <class name="Shorts" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Short) value).hashCode()}.

 @param value a primitive {@code short} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} value that is equal to {@code value}, if
 possible.

 @param value any value in the range of the {@code short} type
 @return the {@code short} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Short#MAX_VALUE} or less than {@link Short#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code short} if it is in the range of the
     {@code short} type, {@link Short#MAX_VALUE} if it is too large,
     or {@link Short#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="short"/>
      <param name="b" type="short"/>
      <doc>
      <![CDATA[Compares the two specified {@code short} values. The sign of the value
 returned is the same as that of {@code ((Short) a).compareTo(b)}.

 @param a the first {@code short} to compare
 @param b the second {@code short} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="short[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new short[] {a, b}, new short[] {}, new
 short[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code short} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 2-element byte
 array; equivalent to {@code
 ByteBuffer.allocate(2).putShort(value).array()}.  For example, the input
 value {@code (short) 0x1234} would yield the byte array {@code {0x12,
 0x34}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code short} value whose big-endian representation is stored
 in the first 2 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getShort()}. For example, the input byte array
 {@code {0x12, 0x34}} would yield the {@code short} value {@code 0x1234}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 2
     elements]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code short} values separated
 by {@code separator}. For example, {@code join("-", (short) 1, (short) 2,
 (short) 3)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code short} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;short[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code short} arrays
 lexicographically. That is, it compares, using {@link
 #compare(short, short)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example, {@code [] < [(short) 1] <
 [(short) 1, (short) 2] < [(short) 2]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(short[], short[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <method name="toArray" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Short&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Short} instances into a new array of
 primitive {@code short} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Short} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Short&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="short[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Short} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code short}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code short} primitives, that are not
 already found in either {@link Short} or {@link Arrays}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Shorts -->
  <!-- start class com.google.common.primitives.SignedBytes -->
  <class name="SignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code byte} type
 @return the {@code byte} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Byte#MAX_VALUE} or less than {@link Byte#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code byte} if it is in the range of the
     {@code byte} type, {@link Byte#MAX_VALUE} if it is too large,
     or {@link Byte#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values. The sign of the value
 returned is the same as that of {@code ((Byte) a).compareTo(b)}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated
 by {@code separator}. For example, {@code join(":", 0x01, 0x02, -0x01)}
 returns the string {@code "1:2:-1"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code byte} arrays
 lexicographically. That is, it compares, using {@link
 #compare(byte, byte)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter
 array as the lesser. For example, {@code [] < [0x01] < [0x01, 0x80] <
 [0x01, 0x7F] < [0x02]}. Values are treated as signed.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link java.util.Arrays#equals(byte[], byte[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that
 interpret values as signed. The corresponding methods that treat the values
 as unsigned are found in {@link UnsignedBytes}, and the methods for which
 signedness is not an issue are in {@link Bytes}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.SignedBytes -->
  <!-- start class com.google.common.primitives.UnsignedBytes -->
  <class name="UnsignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Returns the value of the given byte as an integer, when treated as
 unsigned. That is, returns {@code value + 256} if {@code value} is
 negative; {@code value} itself otherwise.

 @since 6]]>
      </doc>
    </method>
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is equal to
 {@code value}, if possible.

 @param value a value between 0 and 255 inclusive
 @return the {@code byte} value that, when treated as unsigned, equals
     {@code value}
 @throws IllegalArgumentException if {@code value} is negative or greater
     than 255]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is nearest
 in value to {@code value}.

 @param value any {@code long} value
 @return {@code (byte) 255} if {@code value >= 255}, {@code (byte) 0} if
     {@code value <= 0}, and {@code value} cast to {@code byte} otherwise]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values, treating them as unsigned
 values between 0 and 255 inclusive. For example, {@code (byte) -127} is
 considered greater than {@code (byte) 127} because it is seen as having
 the value of positive {@code 129}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal
     to every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated by
 {@code separator}. For example, {@code join(":", (byte) 1, (byte) 2,
 (byte) 255)} returns the string {@code "1:2:255"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code byte} arrays
 lexicographically. That is, it compares, using {@link
 #compare(byte, byte)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter
 array as the lesser. For example, {@code [] < [0x01] < [0x01, 0x7F] <
 [0x01, 0x80] < [0x02]}. Values are treated as unsigned.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link java.util.Arrays#equals(byte[], byte[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order</a> article at Wikipedia
 @since 2]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that interpret
 values as <i>unsigned</i> (that is, any negative value {@code b} is treated
 as the positive value {@code 256 + b}). The corresponding methods that treat
 the values as signed are found in {@link SignedBytes}, and the methods for
 which signedness is not an issue are in {@link Bytes}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedBytes -->
</package>
<package name="com.google.common.util.concurrent">
  <!-- start class com.google.common.util.concurrent.AbstractCheckedFuture -->
  <class name="AbstractCheckedFuture" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.CheckedFuture&lt;V, E&gt;"/>
    <constructor name="AbstractCheckedFuture" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an {@code AbstractCheckedFuture} that wraps a delegate.]]>
      </doc>
    </constructor>
    <method name="mapException" return="E extends java.lang.Exception"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Translate from an {@link InterruptedException},
 {@link CancellationException} or {@link ExecutionException} to an exception
 of type {@code E}.  Subclasses must implement the mapping themselves.
 
 The {@code e} parameter can be an instance of {@link InterruptedException},
 {@link CancellationException}, or {@link ExecutionException}.]]>
      </doc>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <field name="delegate" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The delegate, used to pass along all our methods.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A delegating wrapper around a {@link ListenableFuture} that adds support for
 the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.
 
 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractCheckedFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <class name="AbstractExecutionThreadService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="AbstractExecutionThreadService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service. This method is invoked on the execution thread.]]>
      </doc>
    </method>
    <method name="run"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run the service. This method is invoked on the execution thread.
 Implementations must respond to stop requests. You could poll for lifecycle
 changes in a work loop:
 <pre>
   public void run() {
     while ({@link #isRunning()}) {
       // perform a unit of work
     }
   }
 </pre>
 ...or you could respond to stop requests by implementing {@link
 #triggerShutdown()}, which should cause {@link #run()} to return.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service. This method is invoked on the execution thread.]]>
      </doc>
    </method>
    <method name="triggerShutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoked to request the service to stop.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service.
 Subclasses may override this method to use a custom {@link Executor}, which
 may configure its worker thread with a specific name, thread group or
 priority. The returned executor's {@link Executor#execute(Runnable)
 execute()} method is called when this service is started, and should return
 promptly.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for services that can implement {@link #startUp}, {@link #run} and
 {@link #shutDown} methods. This class uses a single thread to execute the
 service; consider {@link AbstractService} if you would like to manage any
 threading manually.

 @author Jesse Wilson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <!-- start class com.google.common.util.concurrent.AbstractFuture -->
  <class name="AbstractFuture" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <constructor name="AbstractFuture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Subclasses should invoke this method to set the result of the computation
 to {@code value}.  This will set the state of the future to
 {@link AbstractFuture.Sync#COMPLETED} and call {@link #done()} if the
 state was successfully changed.

 @param value the value that was the result of the task.
 @return true if the state was successfully changed.]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Subclasses should invoke this method to set the result of the computation
 to an error, {@code throwable}.  This will set the state of the future to
 {@link AbstractFuture.Sync#COMPLETED} and call {@link #done()} if the
 state was successfully changed.

 @param throwable the exception that the task failed with.
 @return true if the state was successfully changed.
 @throws Error if the throwable was an {@link Error}.]]>
      </doc>
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Subclasses should invoke this method to mark the future as cancelled.
 This will set the state of the future to {@link
 AbstractFuture.Sync#CANCELLED} and call {@link #done()} if the state was
 successfully changed.

 @return true if the state was successfully changed.]]>
      </doc>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>An abstract implementation of the {@link Future} interface.  This class
 is an abstraction of {@link java.util.concurrent.FutureTask} to support use
 for tasks other than {@link Runnable}s.  It uses an
 {@link AbstractQueuedSynchronizer} to deal with concurrency issues and
 guarantee thread safety.  It could be used as a base class to
 {@code FutureTask}, or any other implementor of the {@code Future} interface.

 <p>This class implements all methods in {@code Future}.  Subclasses should
 provide a way to set the result of the computation through the protected
 methods {@link #set(Object)}, {@link #setException(Throwable)}, or
 {@link #cancel()}.  If subclasses want to implement cancellation they can
 override the {@link #cancel(boolean)} method with a real implementation, the
 default implementation doesn't support cancellation.

 <p>The state changing methods all return a boolean indicating success or
 failure in changing the future's state.  Valid states are running,
 completed, failed, or cancelled.  Because this class does not implement
 cancellation it is left to the subclass to distinguish between created
 and running tasks.

 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractIdleService -->
  <class name="AbstractIdleService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="AbstractIdleService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startUp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="state" type="com.google.common.base.Service.State"/>
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service.
 Subclasses may override this method to use a custom {@link Executor}, which
 may configure its worker thread with a specific name, thread group or
 priority. The returned executor's {@link Executor#execute(Runnable)
 execute()} method is called when this service is started and stopped,
 and should return promptly.

 @param state {@link com.google.common.base.Service.State#STARTING} or
     {@link com.google.common.base.Service.State#STOPPING}, used by the
     default implementation for naming the thread]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for services that do not need a thread while "running"
 but may need one during startup and shutdown. Subclasses can
 implement {@link #startUp} and {@link #shutDown} methods, each
 which run in a executor which by default uses a separate thread
 for each method.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractIdleService -->
  <!-- start class com.google.common.util.concurrent.AbstractListenableFuture -->
  <class name="AbstractListenableFuture" extends="com.google.common.util.concurrent.AbstractFuture&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="AbstractListenableFuture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>An abstract base implementation of the listener support provided by
 {@link ListenableFuture}. This class uses an {@link ExecutionList} to
 guarantee that all registered listeners will be executed. Listener/Executor
 pairs are stored in the execution list and executed in the order in which
 they were added, but because of thread scheduling issues there is no
 guarantee that the JVM will execute them in order. In addition, listeners
 added after the task is complete will be executed immediately, even if some
 previously added listeners have not yet been executed.
 
 <p>This class uses the {@link AbstractFuture} class to implement the
 {@code ListenableFuture} interface and simply delegates the
 {@link #addListener(Runnable, Executor)} and {@link #done()} methods to it.
 
 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractListenableFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractService -->
  <class name="AbstractService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="AbstractService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doStart"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method is called by {@link #start} to initiate service startup. The
 invocation of this method should cause a call to {@link #notifyStarted()},
 either during this method's run, or after it has returned. If startup
 fails, the invocation should cause a call to {@link
 #notifyFailed(Throwable)} instead.

 <p>This method should return promptly; prefer to do work on a different
 thread where it is convenient. It is invoked exactly once on service
 startup, even when {@link #start} is called multiple times.]]>
      </doc>
    </method>
    <method name="doStop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method should be used to initiate service shutdown. The invocation
 of this method should cause a call to {@link #notifyStopped()}, either
 during this method's run, or after it has returned. If shutdown fails, the
 invocation should cause a call to {@link #notifyFailed(Throwable)} instead.

 <p>This method should return promptly; prefer to do work on a different
 thread where it is convenient. It is invoked exactly once on service
 shutdown, even when {@link #stop} is called multiple times.]]>
      </doc>
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="notifyStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has
 started. It will cause the service to transition from {@link
 State#STARTING} to {@link State#RUNNING}.

 @throws IllegalStateException if the service is not
     {@link State#STARTING}.]]>
      </doc>
    </method>
    <method name="notifyStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has
 stopped. It will cause the service to transition from {@link
 State#STOPPING} to {@link State#TERMINATED}.

 @throws IllegalStateException if the service is neither {@link
     State#STOPPING} nor {@link State#RUNNING}.]]>
      </doc>
    </method>
    <method name="notifyFailed"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Invoke this method to transition the service to the
 {@link State#FAILED}. The service will <b>not be stopped</b> if it
 is running. Invoke this method when a service has failed critically or
 otherwise cannot be started nor stopped.]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for implementing services that can handle {@link #doStart} and
 {@link #doStop} requests, responding to them with {@link #notifyStarted()}
 and {@link #notifyStopped()} callbacks. Its subclasses must manage threads
 manually; consider {@link AbstractExecutionThreadService} if you need only a
 single execution thread.

 @author Jesse Wilson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractService -->
  <!-- start class com.google.common.util.concurrent.Callables -->
  <class name="Callables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="returning" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Creates a {@code Callable} which immediately returns a preset value each
 time it is called.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Callable} interface.

 @author Isaac Shum
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Callables -->
  <!-- start interface com.google.common.util.concurrent.CheckedFuture -->
  <interface name="CheckedFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Exception checking version of {@link Future#get()} that will translate
 {@link InterruptedException}, {@link CancellationException} and
 {@link ExecutionException} into application-specific exceptions.
 
 @return the result of executing the future.
 @throws E on interruption, cancellation or execution exceptions.]]>
      </doc>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Exception checking version of {@link Future#get(long, TimeUnit)} that will
 translate {@link InterruptedException}, {@link CancellationException} and
 {@link ExecutionException} into application-specific exceptions.  On
 timeout this method throws a normal {@link TimeoutException}.
 
 @return the result of executing the future.
 @throws TimeoutException if retrieving the result timed out.
 @throws E on interruption, cancellation or execution exceptions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code CheckedFuture} is an extension of {@link Future} that includes
 versions of the {@code get} methods that can throw a checked exception and
 allows listeners to be attached to the future.  This makes it easier to
 create a future that executes logic which can throw an exception.
 
 <p>Implementations of this interface must adapt the exceptions thrown by
 {@code Future#get()}: {@link CancellationException},
 {@link ExecutionException} and {@link InterruptedException} into the type
 specified by the {@code E} type parameter.
 
 <p>This interface also extends the ListenableFuture interface to allow
 listeners to be added. This allows the future to be used as a normal
 {@link Future} or as an asynchronous callback mechanism as needed. This
 allows multiple callbacks to be registered for a particular task, and the
 future will guarantee execution of all listeners when the task completes.
 
 @author Sven Mawson
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.CheckedFuture -->
  <!-- start class com.google.common.util.concurrent.ExecutionList -->
  <class name="ExecutionList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Runnable"/>
    <constructor name="ExecutionList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Add the runnable/executor pair to the list of pairs to execute.  Executes
 the pair immediately if we've already started execution.]]>
      </doc>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Runs this execution list, executing all pairs in the order they were
 added.  Pairs added after this method has started executing the list will
 be executed immediately.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>A list of ({@code Runnable}, {@code Executor}) pairs that guarantees
 that every {@code Runnable} that is added using the add method will be
 executed in its associated {@code Executor} after {@link #run()} is called.
 {@code Runnable}s added after {@code run} is called are still guaranteed to
 execute.
 
 @author Nishant Thakkar
 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ExecutionList -->
  <!-- start class com.google.common.util.concurrent.FakeTimeLimiter -->
  <class name="FakeTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <constructor name="FakeTimeLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="amInterruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter implementation which actually does not attempt to limit time
 at all.  This may be desirable to use in some unit tests.  More importantly,
 attempting to debug a call which is time-limited would be extremely annoying,
 so this gives you a time-limiter you can easily swap in for your real
 time-limiter while you're debugging.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.FakeTimeLimiter -->
  <!-- start class com.google.common.util.concurrent.ForwardingBlockingQueue -->
  <class name="ForwardingBlockingQueue" extends="com.google.common.collect.ForwardingQueue&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
    <constructor name="ForwardingBlockingQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.BlockingQueue&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="maxElements" type="int"/>
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="remainingCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="take" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[A {@link BlockingQueue} which forwards all its method calls to another
 {@link BlockingQueue}. Subclasses should override one or more methods to
 modify the behavior of the backing collection as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Raimundo Mirisola

 @param <E> the type of elements held in this collection
 @since 4]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingBlockingQueue -->
  <!-- start class com.google.common.util.concurrent.ForwardingFuture -->
  <class name="ForwardingFuture" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <constructor name="ForwardingFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.Future&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[A {@link Future} which forwards all its method calls to another future.
 Subclasses should override one or more methods to modify the behavior of
 the backing collection as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingListenableFuture -->
  <class name="ForwardingListenableFuture" extends="com.google.common.util.concurrent.ForwardingFuture&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="ForwardingListenableFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <doc>
    <![CDATA[A {@link ForwardingFuture} that also implements {@link ListenableFuture}.
 Subclasses will have to provide a delegate {@link ListenableFuture} through
 the {@link #delegate()} method.

 @param <V> The result type returned by this Future's <tt>get</tt> method

 @author Shardul Deo
 @since 4]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingService -->
  <class name="ForwardingService" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Service"/>
    <constructor name="ForwardingService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.base.Service"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="start" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="java.util.concurrent.Future&lt;com.google.common.base.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.base.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link Service} that forwards all method calls to another service.

 @author Chris Nokleberg
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingService -->
  <!-- start class com.google.common.util.concurrent.Futures -->
  <class name="Futures" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="makeUninterruptible" return="com.google.common.util.concurrent.UninterruptibleFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns an uninterruptible view of a {@code Future}. If a thread is
 interrupted during an attempt to {@code get()} from the returned future, it
 continues to wait on the result until it is available or the timeout
 elapses, and only then re-interrupts the thread.]]>
      </doc>
    </method>
    <method name="makeListenable" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a {@link ListenableFuture} out of a normal {@link Future}. The
 returned future will create a thread to wait for the source future to
 complete before executing the listeners.

 <p>Callers who have a future that subclasses
 {@link java.util.concurrent.FutureTask} may want to instead subclass
 {@link ListenableFutureTask}, which adds the {@link ListenableFuture}
 functionality to the standard {@code FutureTask} implementation.]]>
      </doc>
    </method>
    <method name="makeChecked" return="com.google.common.util.concurrent.CheckedFuture&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;T&gt;"/>
      <param name="mapper" type="com.google.common.base.Function&lt;java.lang.Exception, E&gt;"/>
      <doc>
      <![CDATA[Creates a {@link CheckedFuture} out of a normal {@link Future} and a
 {@link Function} that maps from {@link Exception} instances into the
 appropriate checked type.

 <p>The given mapping function will be applied to an
 {@link InterruptedException}, a {@link CancellationException}, or an
 {@link ExecutionException} with the actual cause of the exception.
 See {@link Future#get()} for details on the exceptions thrown.]]>
      </doc>
    </method>
    <method name="immediateFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFuture} which has its value set immediately upon
 construction. The getters just return the value. This {@code Future} can't
 be canceled or timed out and its {@code isDone()} method always returns
 {@code true}. It's useful for returning something that implements the
 {@code ListenableFuture} interface but already has the result.]]>
      </doc>
    </method>
    <method name="immediateCheckedFuture" return="com.google.common.util.concurrent.CheckedFuture&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Creates a {@code CheckedFuture} which has its value set immediately upon
 construction. The getters just return the value. This {@code Future} can't
 be canceled or timed out and its {@code isDone()} method always returns
 {@code true}. It's useful for returning something that implements the
 {@code CheckedFuture} interface but already has the result.]]>
      </doc>
    </method>
    <method name="immediateFailedFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFuture} which has an exception set immediately
 upon construction. The getters just return the value. This {@code Future}
 can't be canceled or timed out and its {@code isDone()} method always
 returns {@code true}. It's useful for returning something that implements
 the {@code ListenableFuture} interface but already has a failed
 result. Calling {@code get()} will throw the provided {@code Throwable}
 (wrapped in an {@code ExecutionException}).

 @throws Error if the throwable was an {@link Error}.]]>
      </doc>
    </method>
    <method name="immediateFailedCheckedFuture" return="com.google.common.util.concurrent.CheckedFuture&lt;T, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="E extends java.lang.Exception"/>
      <doc>
      <![CDATA[Creates a {@code CheckedFuture} which has an exception set immediately
 upon construction. The getters just return the value. This {@code Future}
 can't be canceled or timed out and its {@code isDone()} method always
 returns {@code true}. It's useful for returning something that implements
 the {@code CheckedFuture} interface but already has a failed result.
 Calling {@code get()} will throw the provided {@code Throwable} (wrapped in
 an {@code ExecutionException}) and calling {@code checkedGet()} will throw
 the provided exception itself.

 @throws Error if the throwable was an {@link Error}.]]>
      </doc>
    </method>
    <method name="chain" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends O&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} that wraps another
 {@code ListenableFuture}.  The result of the new future is the result of
 the provided function called on the result of the provided future.
 The resulting future doesn't interrupt when aborted.

 <p>TODO: Add a version that accepts a normal {@code Future}

 <p>The typical use for this method would be when a RPC call is dependent on
 the results of another RPC.  One would call the first RPC (input), create a
 function that calls another RPC based on input's result, and then call
 chain on input and that function to get a {@code ListenableFuture} of
 the result.

 @param input The future to chain
 @param function A function to chain the results of the provided future
     to the results of the returned future.  This will be run in the thread
     that notifies input it is complete.
 @return A future that holds result of the chain.]]>
      </doc>
    </method>
    <method name="chain" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends O&gt;&gt;"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} that wraps another
 {@code ListenableFuture}.  The result of the new future is the result of
 the provided function called on the result of the provided future.
 The resulting future doesn't interrupt when aborted.

 <p>This version allows an arbitrary executor to be passed in for running
 the chained Function. When using {@link MoreExecutors#sameThreadExecutor},
 the thread chained Function executes in will be whichever thread set the
 result of the input Future, which may be the network thread in the case of
 RPC-based Futures.

 @param input The future to chain
 @param function A function to chain the results of the provided future
     to the results of the returned future.
 @param exec Executor to run the function in.
 @return A future that holds result of the chain.]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} that wraps another
 {@code ListenableFuture}.  The result of the new future is the result of
 the provided function called on the result of the provided future.
 The resulting future doesn't interrupt when aborted.

 <p>An example use of this method is to convert a serializable object
 returned from an RPC into a POJO.

 @param future The future to compose
 @param function A Function to compose the results of the provided future
     to the results of the returned future.  This will be run in the thread
     that notifies input it is complete.
 @return A future that holds result of the composition.]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} that wraps another
 {@code ListenableFuture}.  The result of the new future is the result of
 the provided function called on the result of the provided future.
 The resulting future doesn't interrupt when aborted.

 <p>An example use of this method is to convert a serializable object
 returned from an RPC into a POJO.

 <p>This version allows an arbitrary executor to be passed in for running
 the chained Function. When using {@link MoreExecutors#sameThreadExecutor},
 the thread chained Function executes in will be whichever thread set the
 result of the input Future, which may be the network thread in the case of
 RPC-based Futures.

 @param future The future to compose
 @param function A Function to compose the results of the provided future
     to the results of the returned future.
 @param exec Executor to run the function in.
 @return A future that holds result of the composition.
 @since 2]]>
      </doc>
    </method>
    <method name="compose" return="java.util.concurrent.Future&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code Future} that wraps another {@code Future}.
 The result of the new future is the result of the provided function called
 on the result of the provided future.

 <p>An example use of this method is to convert a Future that produces a
 handle to an object to a future that produces the object itself.

 <p>Each call to {@code Future<O>.get(*)} results in a call to
 {@code Future<I>.get(*)}, but {@code function} is only applied once, so it
 is assumed that {@code Future<I>.get(*)} is idempotent.

 <p>When calling {@link Future#get(long, TimeUnit)} on the returned
 future, the timeout only applies to the future passed in to this method.
 Any additional time taken by applying {@code function} is not considered.

 @param future The future to compose
 @param function A Function to compose the results of the provided future
     to the results of the returned future.  This will be run in the thread
     that calls one of the varieties of {@code get()}.
 @return A future that computes result of the composition.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Future} interface.

 @author Kevin Bourrillion
 @author Nishant Thakkar
 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Futures -->
  <!-- start interface com.google.common.util.concurrent.ListenableFuture -->
  <interface name="ListenableFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[<p>Adds a listener and executor to the ListenableFuture.
 The listener will be {@linkplain Executor#execute(Runnable) passed
 to the executor} for execution when the {@code Future}'s computation is
 {@linkplain Future#isDone() complete}.

 <p>There is no guaranteed ordering of execution of listeners, they may get
 called in the order they were added and they may get called out of order,
 but any listener added through this method is guaranteed to be called once
 the computation is complete.

 @param listener the listener to run when the computation is complete.
 @param exec the executor to run the listener in.
 @throws NullPointerException if the executor or listener was null.
 @throws RejectedExecutionException if we tried to execute the listener
 immediately but the executor rejected it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>This interface defines a future that has listeners attached to it, which
 is useful for asynchronous workflows.  Each listener has an associated
 executor, and is invoked using this executor once the {@code Future}'s
 computation is {@linkplain Future#isDone() complete}.  The listener will be
 executed even if it is added after the computation is complete.

 <p>Usage:
 <pre>   {@code
   final ListenableFuture<?> future = myService.async(myRequest);
   future.addListener(new Runnable() {
     public void run() {
       System.out.println("Operation Complete.");
       try {
         System.out.println("Result: " + future.get());
       } catch (Exception e) {
         System.out.println("Error: " + e.message());
       }
     }
   }, exec);}</pre>

 @author Sven Mawson
 @author Nishant Thakkar
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ListenableFutureTask -->
  <class name="ListenableFutureTask" extends="java.util.concurrent.FutureTask&lt;V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="ListenableFutureTask" type="java.util.concurrent.Callable&lt;V&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the
 given {@code Callable}.

 @param  callable the callable task
 @throws NullPointerException if callable is null]]>
      </doc>
    </constructor>
    <constructor name="ListenableFutureTask" type="java.lang.Runnable, V"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the
 given {@code Runnable}, and arrange that {@code get} will return the
 given result on successful completion.

 @param  runnable the runnable task
 @param result the result to return on successful completion. If
 you don't need a particular result, consider using
 constructions of the form:
 {@code ListenableFuture<?> f =
     new ListenableFutureTask<Object>(runnable, null)}
 @throws NullPointerException if runnable is null]]>
      </doc>
    </constructor>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link FutureTask} that also implements the {@link ListenableFuture}
 interface.  Subclasses must make sure to call {@code super.done()} if they
 also override the {@link #done()} method, otherwise the listeners will not
 be called.
 
 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ListenableFutureTask -->
  <!-- start class com.google.common.util.concurrent.MoreExecutors -->
  <class name="MoreExecutors" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits
 when the application is complete.  It does so by using daemon threads and
 adding a shutdown hook to wait for their completion.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @param terminationTimeout how long to wait for the executor to
        finish before terminating the JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ScheduledThreadPoolExecutor into a
 ScheduledExecutorService that exits when the application is complete.  It
 does so by using daemon threads and adding a shutdown hook to wait for
 their completion.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @param terminationTimeout how long to wait for the executor to
        finish before terminating the JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="addDelayedShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Add a shutdown hook to wait for thread completion in the given
 {@link ExecutorService service}.  This is useful if the given service uses
 daemon threads, and we want to keep the JVM from exiting immediately on
 shutdown, instead giving these daemon threads a chance to terminate
 normally.
 @param service ExecutorService which uses daemon threads
 @param terminationTimeout how long to wait for the executor to finish
        before terminating the JVM
 @param timeUnit unit of time for the time parameter]]>
      </doc>
    </method>
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits
 when the application is complete.  It does so by using daemon threads and
 adding a shutdown hook to wait for their completion.

 <p>This method waits 120 seconds before continuing with JVM termination,
 even if the executor has not finished its work.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into a ScheduledExecutorService that
 exits when the application is complete.  It does so by using daemon threads
 and adding a shutdown hook to wait for their completion.

 <p>This method waits 120 seconds before continuing with JVM termination,
 even if the executor has not finished its work.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="sameThreadExecutor" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an executor service that runs each task in the thread
 that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This
 applies both to individually submitted tasks and to collections of tasks
 submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,
 tasks will run serially on the calling thread.  Tasks are run to
 completion before a {@code Future} is returned to the caller (unless the
 executor has been shutdown).

 <p>Although all tasks are immediately executed in the thread that
 submitted the task, this {@code ExecutorService} imposes a small
 locking overhead on each task submission in order to implement shutdown
 and termination behavior.

 <p>The implementation deviates from the {@code ExecutorService}
 specification with regards to the {@code shutdownNow} method.  First,
 "best-effort" with regards to canceling running tasks is implemented
 as "no-effort".  No interrupts or other attempts are made to stop
 threads executing tasks.  Second, the returned list will always be empty,
 as any submitted task is considered to have started execution.
 This applies also to tasks given to {@code invokeAll} or {@code invokeAny}
 which are pending serial execution, even the subset of the tasks that
 have not yet started execution.  It is unclear from the
 {@code ExecutorService} specification if these should be included, and
 it's much easier to implement the interpretation that they not be.
 Finally, a call to {@code shutdown} or {@code shutdownNow} may result
 in concurrent calls to {@code invokeAll/invokeAny} throwing
 RejectedExecutionException, although a subset of the tasks may already
 have been executed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory and utility methods for {@link java.util.concurrent.Executor}, {@link
 ExecutorService}, and {@link ThreadFactory}.

 @author Eric Fellheimer
 @author Kyle Littlefield
 @author Justin Mahoney
 @since 3]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.MoreExecutors -->
  <!-- start class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <class name="SimpleTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <constructor name="SimpleTimeLimiter" type="java.util.concurrent.ExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TimeLimiter instance using the given executor service to
 execute proxied method calls.
 <p>
 <b>Warning:</b> using a bounded executor
 may be counterproductive!  If the thread pool fills up, any time callers
 spend waiting for a thread may count toward their time limit, and in
 this case the call may even time out before the target method is ever
 invoked.

 @param executor the ExecutorService that will execute the method calls on
     the target objects; for example, a {@link
     java.util.concurrent.Executors#newCachedThreadPool()}.]]>
      </doc>
    </constructor>
    <constructor name="SimpleTimeLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TimeLimiter instance using a {@link
 java.util.concurrent.Executors#newCachedThreadPool()} to execute proxied
 method calls.

 <p><b>Warning:</b> using a bounded executor may be counterproductive! If
 the thread pool fills up, any time callers spend waiting for a thread may
 count toward their time limit, and in this case the call may even time out
 before the target method is ever invoked.]]>
      </doc>
    </constructor>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="amInterruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter that runs method calls in the background using an
 {@link ExecutorService}.  If the time limit expires for a given method call,
 the thread running the call will be interrupted.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <!-- start class com.google.common.util.concurrent.ThreadFactoryBuilder -->
  <class name="ThreadFactoryBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThreadFactoryBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link ThreadFactory} builder.]]>
      </doc>
    </constructor>
    <method name="setNameFormat" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nameFormat" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the naming format to use when naming threads ({@link Thread#setName})
 which are created with this ThreadFactory.

 @param nameFormat a {@link String#format(String, Object...)}-compatible
     format String, to which a unique integer (0, 1, etc.) will be supplied
     as the single parameter. This integer will be unique to the built
     instance of the ThreadFactory and will be assigned sequentially.
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setDaemon" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemon" type="boolean"/>
      <doc>
      <![CDATA[Sets daemon or not for new threads created with this ThreadFactory.

 @param daemon whether or not new Threads created with this ThreadFactory
     will be daemon threads
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setPriority" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="int"/>
      <doc>
      <![CDATA[Sets the priority for new threads created with this ThreadFactory.

 @param priority the priority for new Threads created with this
     ThreadFactory
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setUncaughtExceptionHandler" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uncaughtExceptionHandler" type="java.lang.Thread.UncaughtExceptionHandler"/>
      <doc>
      <![CDATA[Sets the {@link UncaughtExceptionHandler} for new threads created with this
 ThreadFactory.

 @param uncaughtExceptionHandler the uncaught exception handler for new
     Threads created with this ThreadFactory
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setThreadFactory" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingThreadFactory" type="java.util.concurrent.ThreadFactory"/>
      <doc>
      <![CDATA[Sets the backing {@link ThreadFactory} for new threads created with this
 ThreadFactory. Threads will be created by invoking #newThread(Runnable) on
 this backing {@link ThreadFactory}.

 @param backingThreadFactory the backing {@link ThreadFactory} which will
     be delegated to during thread creation.
 @return this for the builder pattern

 @see MoreExecutors]]>
      </doc>
    </method>
    <method name="build" return="java.util.concurrent.ThreadFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread factory using the options supplied during the building
 process. After building, it is still possible to change the options used to
 build the ThreadFactory and/or build again. State is not shared amongst
 built instances.

 @return the fully constructed {@link ThreadFactory}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A ThreadFactory builder, providing any combination of these features:
 <ul>
 <li> whether threads should be marked as {@linkplain Thread#setDaemon daemon}
 threads
 <li> a {@linkplain ThreadFactoryBuilder#setNameFormat naming format}
 <li> a {@linkplain Thread#setPriority thread priority}
 <li> an {@linkplain Thread#setUncaughtExceptionHandler uncaught exception
 handler}
 <li> a {@linkplain ThreadFactory#newThread backing thread factory}
 </ul>
 If no backing thread factory is provided, new threads are created using
 {@link Thread#Thread(Runnable)}.

 @author Kurt Alfred Kluever
 @since 4]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ThreadFactoryBuilder -->
  <!-- start interface com.google.common.util.concurrent.TimeLimiter -->
  <interface name="TimeLimiter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns an instance of {@code interfaceType} that delegates all method
 calls to the {@code target} object, enforcing the specified time limit on
 each call.  This time-limited delegation is also performed for calls to
 {@link Object#equals}, {@link Object#hashCode}, and
 {@link Object#toString}.
 <p>
 If the target method call finishes before the limit is reached, the return
 value or exception is propagated to the caller exactly as-is. If, on the
 other hand, the time limit is reached, the proxy will attempt to abort the
 call to the target, and will throw an {@link UncheckedTimeoutException} to
 the caller.
 <p>
 It is important to note that the primary purpose of the proxy object is to
 return control to the caller when the timeout elapses; aborting the target
 method call is of secondary concern.  The particular nature and strength
 of the guarantees made by the proxy is implementation-dependent.  However,
 it is important that each of the methods on the target object behaves
 appropriately when its thread is interrupted.

 @param target the object to proxy
 @param interfaceType the interface you wish the returned proxy to
     implement
 @param timeoutDuration with timeoutUnit, the maximum length of time that
     callers are willing to wait on each method call to the proxy
 @param timeoutUnit with timeoutDuration, the maximum length of time that
     callers are willing to wait on each method call to the proxy
 @return a time-limiting proxy
 @throws IllegalArgumentException if {@code interfaceType} is a regular
     class, enum, or annotation type, rather than an interface]]>
      </doc>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="interruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Invokes a specified Callable, timing out after the specified time limit.
 If the target method call finished before the limit is reached, the return
 value or exception is propagated to the caller exactly as-is.  If, on the
 other hand, the time limit is reached, we attempt to abort the call to the
 target, and throw an {@link UncheckedTimeoutException} to the caller.
 <p>
 <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or
 changed significantly.

 @param callable the Callable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @param interruptible whether to respond to thread interruption by aborting
     the operation and throwing InterruptedException; if false, the
     operation is allowed to complete or time out, and the current thread's
     interrupt status is re-asserted.
 @return the result returned by the Callable
 @throws InterruptedException if {@code interruptible} is true and our
     thread is interrupted during execution
 @throws UncheckedTimeoutException if the time limit is reached
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Produces proxies that impose a time limit on method
 calls to the proxied object.  For example, to return the value of
 {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this
 method call takes over 50 ms, you can use this code:
 <pre>
   TimeLimiter limiter = . . .;
   TargetType proxy = limiter.newProxy(
       target, TargetType.class, 50, TimeUnit.MILLISECONDS);
   try {
     return proxy.someMethod();
   } catch (UncheckedTimeoutException e) {
     return DEFAULT_VALUE;
   }
 </pre>
 Please see {@code SimpleTimeLimiterTest} for more usage examples.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.TimeLimiter -->
  <!-- start class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <class name="UncheckedTimeoutException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedTimeoutException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Unchecked version of {@link java.util.concurrent.TimeoutException}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <!-- start interface com.google.common.util.concurrent.UninterruptibleFuture -->
  <interface name="UninterruptibleFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[A {@code Future} whose {@code get} calls cannot be interrupted. If a thread
 is interrupted during such a call, the call continues to block until the
 result is available or the timeout elapses, and only then re-interrupts the
 thread. Obtain an instance of this type using {@link
 Futures#makeUninterruptible(Future)}.

 @author Kevin Bourrillion
 @since 1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.UninterruptibleFuture -->
  <!-- start class com.google.common.util.concurrent.ValueFuture -->
  <class name="ValueFuture" extends="com.google.common.util.concurrent.AbstractListenableFuture&lt;V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.ValueFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code ValueFuture} in the default state.]]>
      </doc>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="V"/>
      <doc>
      <![CDATA[Sets the value of this future.  This method will return {@code true} if
 the value was successfully set, or {@code false} if the future has already
 been set or cancelled.

 @param newValue the value the future should hold.
 @return true if the value was successfully set.]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Sets the future to having failed with the given exception.  This exception
 will be wrapped in an ExecutionException and thrown from the get methods.
 This method will return {@code true} if the exception was successfully set,
 or {@code false} if the future has already been set or cancelled.

 @param t the exception the future should hold.
 @return true if the exception was successfully set.]]>
      </doc>
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>A ValueFuture is never considered in the running state, so the
 {@code mayInterruptIfRunning} argument is ignored.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A simple ListenableFuture that holds a value or an exception.

 @author Sven Mawson
 @since 1]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ValueFuture -->
</package>

</api>
