<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/*</a>
<span class="sourceLineNo">002</span><a id="line.2"> * Copyright (C) 2012 The Guava Authors</a>
<span class="sourceLineNo">003</span><a id="line.3"> *</a>
<span class="sourceLineNo">004</span><a id="line.4"> * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except</a>
<span class="sourceLineNo">005</span><a id="line.5"> * in compliance with the License. You may obtain a copy of the License at</a>
<span class="sourceLineNo">006</span><a id="line.6"> *</a>
<span class="sourceLineNo">007</span><a id="line.7"> * http://www.apache.org/licenses/LICENSE-2.0</a>
<span class="sourceLineNo">008</span><a id="line.8"> *</a>
<span class="sourceLineNo">009</span><a id="line.9"> * Unless required by applicable law or agreed to in writing, software distributed under the License</a>
<span class="sourceLineNo">010</span><a id="line.10"> * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</a>
<span class="sourceLineNo">011</span><a id="line.11"> * or implied. See the License for the specific language governing permissions and limitations under</a>
<span class="sourceLineNo">012</span><a id="line.12"> * the License.</a>
<span class="sourceLineNo">013</span><a id="line.13"> */</a>
<span class="sourceLineNo">014</span><a id="line.14"></a>
<span class="sourceLineNo">015</span><a id="line.15">package com.google.common.math;</a>
<span class="sourceLineNo">016</span><a id="line.16"></a>
<span class="sourceLineNo">017</span><a id="line.17">import static com.google.common.base.Preconditions.checkState;</a>
<span class="sourceLineNo">018</span><a id="line.18">import static com.google.common.primitives.Doubles.isFinite;</a>
<span class="sourceLineNo">019</span><a id="line.19">import static java.lang.Double.NaN;</a>
<span class="sourceLineNo">020</span><a id="line.20">import static java.lang.Double.isNaN;</a>
<span class="sourceLineNo">021</span><a id="line.21"></a>
<span class="sourceLineNo">022</span><a id="line.22">import com.google.common.annotations.GwtIncompatible;</a>
<span class="sourceLineNo">023</span><a id="line.23">import com.google.common.annotations.J2ktIncompatible;</a>
<span class="sourceLineNo">024</span><a id="line.24">import com.google.common.primitives.Doubles;</a>
<span class="sourceLineNo">025</span><a id="line.25"></a>
<span class="sourceLineNo">026</span><a id="line.26">/**</a>
<span class="sourceLineNo">027</span><a id="line.27"> * A mutable object which accumulates paired double values (e.g. points on a plane) and tracks some</a>
<span class="sourceLineNo">028</span><a id="line.28"> * basic statistics over all the values added so far. This class is not thread safe.</a>
<span class="sourceLineNo">029</span><a id="line.29"> *</a>
<span class="sourceLineNo">030</span><a id="line.30"> * @author Pete Gillin</a>
<span class="sourceLineNo">031</span><a id="line.31"> * @since 20.0</a>
<span class="sourceLineNo">032</span><a id="line.32"> */</a>
<span class="sourceLineNo">033</span><a id="line.33">@J2ktIncompatible</a>
<span class="sourceLineNo">034</span><a id="line.34">@GwtIncompatible</a>
<span class="sourceLineNo">035</span><a id="line.35">@ElementTypesAreNonnullByDefault</a>
<span class="sourceLineNo">036</span><a id="line.36">public final class PairedStatsAccumulator {</a>
<span class="sourceLineNo">037</span><a id="line.37"></a>
<span class="sourceLineNo">038</span><a id="line.38">  // These fields must satisfy the requirements of PairedStats' constructor as well as those of the</a>
<span class="sourceLineNo">039</span><a id="line.39">  // stat methods of this class.</a>
<span class="sourceLineNo">040</span><a id="line.40">  private final StatsAccumulator xStats = new StatsAccumulator();</a>
<span class="sourceLineNo">041</span><a id="line.41">  private final StatsAccumulator yStats = new StatsAccumulator();</a>
<span class="sourceLineNo">042</span><a id="line.42">  private double sumOfProductsOfDeltas = 0.0;</a>
<span class="sourceLineNo">043</span><a id="line.43"></a>
<span class="sourceLineNo">044</span><a id="line.44">  /** Adds the given pair of values to the dataset. */</a>
<span class="sourceLineNo">045</span><a id="line.45">  public void add(double x, double y) {</a>
<span class="sourceLineNo">046</span><a id="line.46">    // We extend the recursive expression for the one-variable case at Art of Computer Programming</a>
<span class="sourceLineNo">047</span><a id="line.47">    // vol. 2, Knuth, 4.2.2, (16) to the two-variable case. We have two value series x_i and y_i.</a>
<span class="sourceLineNo">048</span><a id="line.48">    // We define the arithmetic means X_n = 1/n \sum_{i=1}^n x_i, and Y_n = 1/n \sum_{i=1}^n y_i.</a>
<span class="sourceLineNo">049</span><a id="line.49">    // We also define the sum of the products of the differences from the means</a>
<span class="sourceLineNo">050</span><a id="line.50">    //           C_n = \sum_{i=1}^n x_i y_i - n X_n Y_n</a>
<span class="sourceLineNo">051</span><a id="line.51">    // for all n &gt;= 1. Then for all n &gt; 1:</a>
<span class="sourceLineNo">052</span><a id="line.52">    //       C_{n-1} = \sum_{i=1}^{n-1} x_i y_i - (n-1) X_{n-1} Y_{n-1}</a>
<span class="sourceLineNo">053</span><a id="line.53">    // C_n - C_{n-1} = x_n y_n - n X_n Y_n + (n-1) X_{n-1} Y_{n-1}</a>
<span class="sourceLineNo">054</span><a id="line.54">    //               = x_n y_n - X_n [ y_n + (n-1) Y_{n-1} ] + [ n X_n - x_n ] Y_{n-1}</a>
<span class="sourceLineNo">055</span><a id="line.55">    //               = x_n y_n - X_n y_n - x_n Y_{n-1} + X_n Y_{n-1}</a>
<span class="sourceLineNo">056</span><a id="line.56">    //               = (x_n - X_n) (y_n - Y_{n-1})</a>
<span class="sourceLineNo">057</span><a id="line.57">    xStats.add(x);</a>
<span class="sourceLineNo">058</span><a id="line.58">    if (isFinite(x) &amp;&amp; isFinite(y)) {</a>
<span class="sourceLineNo">059</span><a id="line.59">      if (xStats.count() &gt; 1) {</a>
<span class="sourceLineNo">060</span><a id="line.60">        sumOfProductsOfDeltas += (x - xStats.mean()) * (y - yStats.mean());</a>
<span class="sourceLineNo">061</span><a id="line.61">      }</a>
<span class="sourceLineNo">062</span><a id="line.62">    } else {</a>
<span class="sourceLineNo">063</span><a id="line.63">      sumOfProductsOfDeltas = NaN;</a>
<span class="sourceLineNo">064</span><a id="line.64">    }</a>
<span class="sourceLineNo">065</span><a id="line.65">    yStats.add(y);</a>
<span class="sourceLineNo">066</span><a id="line.66">  }</a>
<span class="sourceLineNo">067</span><a id="line.67"></a>
<span class="sourceLineNo">068</span><a id="line.68">  /**</a>
<span class="sourceLineNo">069</span><a id="line.69">   * Adds the given statistics to the dataset, as if the individual values used to compute the</a>
<span class="sourceLineNo">070</span><a id="line.70">   * statistics had been added directly.</a>
<span class="sourceLineNo">071</span><a id="line.71">   */</a>
<span class="sourceLineNo">072</span><a id="line.72">  public void addAll(PairedStats values) {</a>
<span class="sourceLineNo">073</span><a id="line.73">    if (values.count() == 0) {</a>
<span class="sourceLineNo">074</span><a id="line.74">      return;</a>
<span class="sourceLineNo">075</span><a id="line.75">    }</a>
<span class="sourceLineNo">076</span><a id="line.76"></a>
<span class="sourceLineNo">077</span><a id="line.77">    xStats.addAll(values.xStats());</a>
<span class="sourceLineNo">078</span><a id="line.78">    if (yStats.count() == 0) {</a>
<span class="sourceLineNo">079</span><a id="line.79">      sumOfProductsOfDeltas = values.sumOfProductsOfDeltas();</a>
<span class="sourceLineNo">080</span><a id="line.80">    } else {</a>
<span class="sourceLineNo">081</span><a id="line.81">      // This is a generalized version of the calculation in add(double, double) above. Note that</a>
<span class="sourceLineNo">082</span><a id="line.82">      // non-finite inputs will have sumOfProductsOfDeltas = NaN, so non-finite values will result</a>
<span class="sourceLineNo">083</span><a id="line.83">      // in NaN naturally.</a>
<span class="sourceLineNo">084</span><a id="line.84">      sumOfProductsOfDeltas +=</a>
<span class="sourceLineNo">085</span><a id="line.85">          values.sumOfProductsOfDeltas()</a>
<span class="sourceLineNo">086</span><a id="line.86">              + (values.xStats().mean() - xStats.mean())</a>
<span class="sourceLineNo">087</span><a id="line.87">                  * (values.yStats().mean() - yStats.mean())</a>
<span class="sourceLineNo">088</span><a id="line.88">                  * values.count();</a>
<span class="sourceLineNo">089</span><a id="line.89">    }</a>
<span class="sourceLineNo">090</span><a id="line.90">    yStats.addAll(values.yStats());</a>
<span class="sourceLineNo">091</span><a id="line.91">  }</a>
<span class="sourceLineNo">092</span><a id="line.92"></a>
<span class="sourceLineNo">093</span><a id="line.93">  /** Returns an immutable snapshot of the current statistics. */</a>
<span class="sourceLineNo">094</span><a id="line.94">  public PairedStats snapshot() {</a>
<span class="sourceLineNo">095</span><a id="line.95">    return new PairedStats(xStats.snapshot(), yStats.snapshot(), sumOfProductsOfDeltas);</a>
<span class="sourceLineNo">096</span><a id="line.96">  }</a>
<span class="sourceLineNo">097</span><a id="line.97"></a>
<span class="sourceLineNo">098</span><a id="line.98">  /** Returns the number of pairs in the dataset. */</a>
<span class="sourceLineNo">099</span><a id="line.99">  public long count() {</a>
<span class="sourceLineNo">100</span><a id="line.100">    return xStats.count();</a>
<span class="sourceLineNo">101</span><a id="line.101">  }</a>
<span class="sourceLineNo">102</span><a id="line.102"></a>
<span class="sourceLineNo">103</span><a id="line.103">  /** Returns an immutable snapshot of the statistics on the {@code x} values alone. */</a>
<span class="sourceLineNo">104</span><a id="line.104">  public Stats xStats() {</a>
<span class="sourceLineNo">105</span><a id="line.105">    return xStats.snapshot();</a>
<span class="sourceLineNo">106</span><a id="line.106">  }</a>
<span class="sourceLineNo">107</span><a id="line.107"></a>
<span class="sourceLineNo">108</span><a id="line.108">  /** Returns an immutable snapshot of the statistics on the {@code y} values alone. */</a>
<span class="sourceLineNo">109</span><a id="line.109">  public Stats yStats() {</a>
<span class="sourceLineNo">110</span><a id="line.110">    return yStats.snapshot();</a>
<span class="sourceLineNo">111</span><a id="line.111">  }</a>
<span class="sourceLineNo">112</span><a id="line.112"></a>
<span class="sourceLineNo">113</span><a id="line.113">  /**</a>
<span class="sourceLineNo">114</span><a id="line.114">   * Returns the population covariance of the values. The count must be non-zero.</a>
<span class="sourceLineNo">115</span><a id="line.115">   *</a>
<span class="sourceLineNo">116</span><a id="line.116">   * &lt;p&gt;This is guaranteed to return zero if the dataset contains a single pair of finite values. It</a>
<span class="sourceLineNo">117</span><a id="line.117">   * is not guaranteed to return zero when the dataset consists of the same pair of values multiple</a>
<span class="sourceLineNo">118</span><a id="line.118">   * times, due to numerical errors.</a>
<span class="sourceLineNo">119</span><a id="line.119">   *</a>
<span class="sourceLineNo">120</span><a id="line.120">   * &lt;h3&gt;Non-finite values&lt;/h3&gt;</a>
<span class="sourceLineNo">121</span><a id="line.121">   *</a>
<span class="sourceLineNo">122</span><a id="line.122">   * &lt;p&gt;If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link</a>
<span class="sourceLineNo">123</span><a id="line.123">   * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.</a>
<span class="sourceLineNo">124</span><a id="line.124">   *</a>
<span class="sourceLineNo">125</span><a id="line.125">   * @throws IllegalStateException if the dataset is empty</a>
<span class="sourceLineNo">126</span><a id="line.126">   */</a>
<span class="sourceLineNo">127</span><a id="line.127">  public double populationCovariance() {</a>
<span class="sourceLineNo">128</span><a id="line.128">    checkState(count() != 0);</a>
<span class="sourceLineNo">129</span><a id="line.129">    return sumOfProductsOfDeltas / count();</a>
<span class="sourceLineNo">130</span><a id="line.130">  }</a>
<span class="sourceLineNo">131</span><a id="line.131"></a>
<span class="sourceLineNo">132</span><a id="line.132">  /**</a>
<span class="sourceLineNo">133</span><a id="line.133">   * Returns the sample covariance of the values. The count must be greater than one.</a>
<span class="sourceLineNo">134</span><a id="line.134">   *</a>
<span class="sourceLineNo">135</span><a id="line.135">   * &lt;p&gt;This is not guaranteed to return zero when the dataset consists of the same pair of values</a>
<span class="sourceLineNo">136</span><a id="line.136">   * multiple times, due to numerical errors.</a>
<span class="sourceLineNo">137</span><a id="line.137">   *</a>
<span class="sourceLineNo">138</span><a id="line.138">   * &lt;h3&gt;Non-finite values&lt;/h3&gt;</a>
<span class="sourceLineNo">139</span><a id="line.139">   *</a>
<span class="sourceLineNo">140</span><a id="line.140">   * &lt;p&gt;If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link</a>
<span class="sourceLineNo">141</span><a id="line.141">   * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.</a>
<span class="sourceLineNo">142</span><a id="line.142">   *</a>
<span class="sourceLineNo">143</span><a id="line.143">   * @throws IllegalStateException if the dataset is empty or contains a single pair of values</a>
<span class="sourceLineNo">144</span><a id="line.144">   */</a>
<span class="sourceLineNo">145</span><a id="line.145">  public final double sampleCovariance() {</a>
<span class="sourceLineNo">146</span><a id="line.146">    checkState(count() &gt; 1);</a>
<span class="sourceLineNo">147</span><a id="line.147">    return sumOfProductsOfDeltas / (count() - 1);</a>
<span class="sourceLineNo">148</span><a id="line.148">  }</a>
<span class="sourceLineNo">149</span><a id="line.149"></a>
<span class="sourceLineNo">150</span><a id="line.150">  /**</a>
<span class="sourceLineNo">151</span><a id="line.151">   * Returns the &lt;a href="http://mathworld.wolfram.com/CorrelationCoefficient.html"&gt;Pearson's or</a>
<span class="sourceLineNo">152</span><a id="line.152">   * product-moment correlation coefficient&lt;/a&gt; of the values. The count must greater than one, and</a>
<span class="sourceLineNo">153</span><a id="line.153">   * the {@code x} and {@code y} values must both have non-zero population variance (i.e. {@code</a>
<span class="sourceLineNo">154</span><a id="line.154">   * xStats().populationVariance() &gt; 0.0 &amp;&amp; yStats().populationVariance() &gt; 0.0}). The result is not</a>
<span class="sourceLineNo">155</span><a id="line.155">   * guaranteed to be exactly +/-1 even when the data are perfectly (anti-)correlated, due to</a>
<span class="sourceLineNo">156</span><a id="line.156">   * numerical errors. However, it is guaranteed to be in the inclusive range [-1, +1].</a>
<span class="sourceLineNo">157</span><a id="line.157">   *</a>
<span class="sourceLineNo">158</span><a id="line.158">   * &lt;h3&gt;Non-finite values&lt;/h3&gt;</a>
<span class="sourceLineNo">159</span><a id="line.159">   *</a>
<span class="sourceLineNo">160</span><a id="line.160">   * &lt;p&gt;If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link</a>
<span class="sourceLineNo">161</span><a id="line.161">   * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.</a>
<span class="sourceLineNo">162</span><a id="line.162">   *</a>
<span class="sourceLineNo">163</span><a id="line.163">   * @throws IllegalStateException if the dataset is empty or contains a single pair of values, or</a>
<span class="sourceLineNo">164</span><a id="line.164">   *     either the {@code x} and {@code y} dataset has zero population variance</a>
<span class="sourceLineNo">165</span><a id="line.165">   */</a>
<span class="sourceLineNo">166</span><a id="line.166">  public final double pearsonsCorrelationCoefficient() {</a>
<span class="sourceLineNo">167</span><a id="line.167">    checkState(count() &gt; 1);</a>
<span class="sourceLineNo">168</span><a id="line.168">    if (isNaN(sumOfProductsOfDeltas)) {</a>
<span class="sourceLineNo">169</span><a id="line.169">      return NaN;</a>
<span class="sourceLineNo">170</span><a id="line.170">    }</a>
<span class="sourceLineNo">171</span><a id="line.171">    double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();</a>
<span class="sourceLineNo">172</span><a id="line.172">    double ySumOfSquaresOfDeltas = yStats.sumOfSquaresOfDeltas();</a>
<span class="sourceLineNo">173</span><a id="line.173">    checkState(xSumOfSquaresOfDeltas &gt; 0.0);</a>
<span class="sourceLineNo">174</span><a id="line.174">    checkState(ySumOfSquaresOfDeltas &gt; 0.0);</a>
<span class="sourceLineNo">175</span><a id="line.175">    // The product of two positive numbers can be zero if the multiplication underflowed. We</a>
<span class="sourceLineNo">176</span><a id="line.176">    // force a positive value by effectively rounding up to MIN_VALUE.</a>
<span class="sourceLineNo">177</span><a id="line.177">    double productOfSumsOfSquaresOfDeltas =</a>
<span class="sourceLineNo">178</span><a id="line.178">        ensurePositive(xSumOfSquaresOfDeltas * ySumOfSquaresOfDeltas);</a>
<span class="sourceLineNo">179</span><a id="line.179">    return ensureInUnitRange(sumOfProductsOfDeltas / Math.sqrt(productOfSumsOfSquaresOfDeltas));</a>
<span class="sourceLineNo">180</span><a id="line.180">  }</a>
<span class="sourceLineNo">181</span><a id="line.181"></a>
<span class="sourceLineNo">182</span><a id="line.182">  /**</a>
<span class="sourceLineNo">183</span><a id="line.183">   * Returns a linear transformation giving the best fit to the data according to &lt;a</a>
<span class="sourceLineNo">184</span><a id="line.184">   * href="http://mathworld.wolfram.com/LeastSquaresFitting.html"&gt;Ordinary Least Squares linear</a>
<span class="sourceLineNo">185</span><a id="line.185">   * regression&lt;/a&gt; of {@code y} as a function of {@code x}. The count must be greater than one, and</a>
<span class="sourceLineNo">186</span><a id="line.186">   * either the {@code x} or {@code y} data must have a non-zero population variance (i.e. {@code</a>
<span class="sourceLineNo">187</span><a id="line.187">   * xStats().populationVariance() &gt; 0.0 || yStats().populationVariance() &gt; 0.0}). The result is</a>
<span class="sourceLineNo">188</span><a id="line.188">   * guaranteed to be horizontal if there is variance in the {@code x} data but not the {@code y}</a>
<span class="sourceLineNo">189</span><a id="line.189">   * data, and vertical if there is variance in the {@code y} data but not the {@code x} data.</a>
<span class="sourceLineNo">190</span><a id="line.190">   *</a>
<span class="sourceLineNo">191</span><a id="line.191">   * &lt;p&gt;This fit minimizes the root-mean-square error in {@code y} as a function of {@code x}. This</a>
<span class="sourceLineNo">192</span><a id="line.192">   * error is defined as the square root of the mean of the squares of the differences between the</a>
<span class="sourceLineNo">193</span><a id="line.193">   * actual {@code y} values of the data and the values predicted by the fit for the {@code x}</a>
<span class="sourceLineNo">194</span><a id="line.194">   * values (i.e. it is the square root of the mean of the squares of the vertical distances between</a>
<span class="sourceLineNo">195</span><a id="line.195">   * the data points and the best fit line). For this fit, this error is a fraction {@code sqrt(1 -</a>
<span class="sourceLineNo">196</span><a id="line.196">   * R*R)} of the population standard deviation of {@code y}, where {@code R} is the Pearson's</a>
<span class="sourceLineNo">197</span><a id="line.197">   * correlation coefficient (as given by {@link #pearsonsCorrelationCoefficient()}).</a>
<span class="sourceLineNo">198</span><a id="line.198">   *</a>
<span class="sourceLineNo">199</span><a id="line.199">   * &lt;p&gt;The corresponding root-mean-square error in {@code x} as a function of {@code y} is a</a>
<span class="sourceLineNo">200</span><a id="line.200">   * fraction {@code sqrt(1/(R*R) - 1)} of the population standard deviation of {@code x}. This fit</a>
<span class="sourceLineNo">201</span><a id="line.201">   * does not normally minimize that error: to do that, you should swap the roles of {@code x} and</a>
<span class="sourceLineNo">202</span><a id="line.202">   * {@code y}.</a>
<span class="sourceLineNo">203</span><a id="line.203">   *</a>
<span class="sourceLineNo">204</span><a id="line.204">   * &lt;h3&gt;Non-finite values&lt;/h3&gt;</a>
<span class="sourceLineNo">205</span><a id="line.205">   *</a>
<span class="sourceLineNo">206</span><a id="line.206">   * &lt;p&gt;If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link</a>
<span class="sourceLineNo">207</span><a id="line.207">   * Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link</a>
<span class="sourceLineNo">208</span><a id="line.208">   * LinearTransformation#forNaN()}.</a>
<span class="sourceLineNo">209</span><a id="line.209">   *</a>
<span class="sourceLineNo">210</span><a id="line.210">   * @throws IllegalStateException if the dataset is empty or contains a single pair of values, or</a>
<span class="sourceLineNo">211</span><a id="line.211">   *     both the {@code x} and {@code y} dataset have zero population variance</a>
<span class="sourceLineNo">212</span><a id="line.212">   */</a>
<span class="sourceLineNo">213</span><a id="line.213">  public final LinearTransformation leastSquaresFit() {</a>
<span class="sourceLineNo">214</span><a id="line.214">    checkState(count() &gt; 1);</a>
<span class="sourceLineNo">215</span><a id="line.215">    if (isNaN(sumOfProductsOfDeltas)) {</a>
<span class="sourceLineNo">216</span><a id="line.216">      return LinearTransformation.forNaN();</a>
<span class="sourceLineNo">217</span><a id="line.217">    }</a>
<span class="sourceLineNo">218</span><a id="line.218">    double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();</a>
<span class="sourceLineNo">219</span><a id="line.219">    if (xSumOfSquaresOfDeltas &gt; 0.0) {</a>
<span class="sourceLineNo">220</span><a id="line.220">      if (yStats.sumOfSquaresOfDeltas() &gt; 0.0) {</a>
<span class="sourceLineNo">221</span><a id="line.221">        return LinearTransformation.mapping(xStats.mean(), yStats.mean())</a>
<span class="sourceLineNo">222</span><a id="line.222">            .withSlope(sumOfProductsOfDeltas / xSumOfSquaresOfDeltas);</a>
<span class="sourceLineNo">223</span><a id="line.223">      } else {</a>
<span class="sourceLineNo">224</span><a id="line.224">        return LinearTransformation.horizontal(yStats.mean());</a>
<span class="sourceLineNo">225</span><a id="line.225">      }</a>
<span class="sourceLineNo">226</span><a id="line.226">    } else {</a>
<span class="sourceLineNo">227</span><a id="line.227">      checkState(yStats.sumOfSquaresOfDeltas() &gt; 0.0);</a>
<span class="sourceLineNo">228</span><a id="line.228">      return LinearTransformation.vertical(xStats.mean());</a>
<span class="sourceLineNo">229</span><a id="line.229">    }</a>
<span class="sourceLineNo">230</span><a id="line.230">  }</a>
<span class="sourceLineNo">231</span><a id="line.231"></a>
<span class="sourceLineNo">232</span><a id="line.232">  private double ensurePositive(double value) {</a>
<span class="sourceLineNo">233</span><a id="line.233">    if (value &gt; 0.0) {</a>
<span class="sourceLineNo">234</span><a id="line.234">      return value;</a>
<span class="sourceLineNo">235</span><a id="line.235">    } else {</a>
<span class="sourceLineNo">236</span><a id="line.236">      return Double.MIN_VALUE;</a>
<span class="sourceLineNo">237</span><a id="line.237">    }</a>
<span class="sourceLineNo">238</span><a id="line.238">  }</a>
<span class="sourceLineNo">239</span><a id="line.239"></a>
<span class="sourceLineNo">240</span><a id="line.240">  private static double ensureInUnitRange(double value) {</a>
<span class="sourceLineNo">241</span><a id="line.241">    return Doubles.constrainToRange(value, -1.0, 1.0);</a>
<span class="sourceLineNo">242</span><a id="line.242">  }</a>
<span class="sourceLineNo">243</span><a id="line.243">}</a>




























































</pre>
</div>
</main>
</body>
</html>
