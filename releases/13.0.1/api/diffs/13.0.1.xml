<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Jun 09 17:08:35 CDT 2015 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Guava 13.0.1"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath _lib/jdiff.jar:_lib/xerces-for-jdiff.jar -sourcepath /var/folders/xl/3_nkmzlj5256gs3rkyzg905m0051x0/T/guava-13.0.1-src.2ywokUvP -classpath /var/folders/xl/3_nkmzlj5256gs3rkyzg905m0051x0/T/guava-13.0.1-classes.NAcdbP7Y:/Users/cgdecker/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar -subpackages com.google.common -encoding UTF-8 -apiname Guava 13.0.1 -apidir releases/13.0.1/api/diffs/ -exclude com.google.common.base.internal -protected -->
<package name="com.google.common.annotations">
  <!-- start class com.google.common.annotations.Beta -->
  <class name="Beta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Signifies that a public API (public class, method or field) is subject to
 incompatible changes, or even removal, in a future release. An API bearing
 this annotation is exempt from any compatibility guarantees made by its
 containing library. Note that the presence of this annotation implies nothing
 about the quality or performance of the API in question, only the fact that
 it is not "API-frozen."

 <p>It is generally safe for <i>applications</i> to depend on beta APIs, at
 the cost of some extra work during upgrades. However it is generally
 inadvisable for <i>libraries</i> (which get included on users' CLASSPATHs,
 outside the library developers' control) to do so.


 @author Kevin Bourrillion]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.Beta -->
  <!-- start class com.google.common.annotations.GwtCompatible -->
  <class name="GwtCompatible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[The presence of this annotation on a type indicates that the type may be
 used with the
 <a href="http://code.google.com/webtoolkit/">Google Web Toolkit</a> (GWT).
 When applied to a method, the return type of the method is GWT compatible.
 It's useful to indicate that an instance created by factory methods has a GWT
 serializable type.  In the following example,

 <pre style="code">
 {@literal @}GwtCompatible
 class Lists {
   ...
   {@literal @}GwtCompatible(serializable = true)
   static &lt;E> List&lt;E> newArrayList(E... elements) {
     ...
   }
 }
 </pre>
 The return value of {@code Lists.newArrayList(E[])} has GWT
 serializable type.  It is also useful in specifying contracts of interface
 methods.  In the following example,

 <pre style="code">
 {@literal @}GwtCompatible
 interface ListFactory {
   ...
   {@literal @}GwtCompatible(serializable = true)
   &lt;E> List&lt;E> newArrayList(E... elements);
 }
 </pre>
 The {@code newArrayList(E[])} method of all implementations of {@code
 ListFactory} is expected to return a value with a GWT serializable type.

 <p>Note that a {@code GwtCompatible} type may have some {@link
 GwtIncompatible} methods.

 @author Charles Fry
 @author Hayward Chan]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.GwtCompatible -->
  <!-- start class com.google.common.annotations.GwtIncompatible -->
  <class name="GwtIncompatible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[The presence of this annotation on a method indicates that the method may
 <em>not</em> be used with the
 <a href="http://code.google.com/webtoolkit/">Google Web Toolkit</a> (GWT),
 even though its type is annotated as {@link GwtCompatible} and accessible in
 GWT.  They can cause GWT compilation errors or simply unexpected exceptions
 when used in GWT.

 <p>Note that this annotation should only be applied to methods, fields, or
 inner classes of types which are annotated as {@link GwtCompatible}.

 @author Charles Fry]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.GwtIncompatible -->
  <!-- start class com.google.common.annotations.VisibleForTesting -->
  <class name="VisibleForTesting"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates a program element that exists, or is more widely visible than
 otherwise necessary, only for use in test code.

 @author Johannes Henkel]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.VisibleForTesting -->
</package>
<package name="com.google.common.base">
  <!-- start class com.google.common.base.Ascii -->
  <class name="Ascii" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toLowerCase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a copy of the input string in which all {@linkplain #isUpperCase(char) uppercase ASCII
 characters} have been converted to lowercase. All other characters are copied without
 modification.]]>
      </doc>
    </method>
    <method name="toLowerCase" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[If the argument is an {@linkplain #isUpperCase(char) uppercase ASCII character} returns the
 lowercase equivalent. Otherwise returns the argument.]]>
      </doc>
    </method>
    <method name="toUpperCase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a copy of the input string in which all {@linkplain #isLowerCase(char) lowercase ASCII
 characters} have been converted to uppercase. All other characters are copied without
 modification.]]>
      </doc>
    </method>
    <method name="toUpperCase" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[If the argument is a {@linkplain #isLowerCase(char) lowercase ASCII character} returns the
 uppercase equivalent. Otherwise returns the argument.]]>
      </doc>
    </method>
    <method name="isLowerCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Indicates whether {@code c} is one of the twenty-six lowercase ASCII alphabetic characters
 between {@code 'a'} and {@code 'z'} inclusive. All others (including non-ASCII characters)
 return {@code false}.]]>
      </doc>
    </method>
    <method name="isUpperCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Indicates whether {@code c} is one of the twenty-six uppercase ASCII alphabetic characters
 between {@code 'A'} and {@code 'Z'} inclusive. All others (including non-ASCII characters)
 return {@code false}.]]>
      </doc>
    </method>
    <field name="NUL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Null ('\0'): The all-zeros character which may serve to accomplish
 time fill and media fill.  Normally used as a C string terminator.
 <p>Although RFC 20 names this as "Null", note that it is distinct
 from the C/C++ "NULL" pointer.

 @since 8.0]]>
      </doc>
    </field>
    <field name="SOH" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start of Heading: A communication control character used at
 the beginning of a sequence of characters which constitute a
 machine-sensible address or routing information.  Such a sequence is
 referred to as the "heading."  An STX character has the effect of
 terminating a heading.

 @since 8.0]]>
      </doc>
    </field>
    <field name="STX" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start of Text: A communication control character which
 precedes a sequence of characters that is to be treated as an entity
 and entirely transmitted through to the ultimate destination.  Such a
 sequence is referred to as "text."  STX may be used to terminate a
 sequence of characters started by SOH.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ETX" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Text: A communication control character used to
 terminate a sequence of characters started with STX and transmitted
 as an entity.

 @since 8.0]]>
      </doc>
    </field>
    <field name="EOT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Transmission: A communication control character used
 to indicate the conclusion of a transmission, which may have
 contained one or more texts and any associated headings.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ENQ" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enquiry: A communication control character used in data
 communication systems as a request for a response from a remote
 station.  It may be used as a "Who Are You" (WRU) to obtain
 identification, or may be used to obtain station status, or both.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ACK" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Acknowledge: A communication control character transmitted
 by a receiver as an affirmative response to a sender.

 @since 8.0]]>
      </doc>
    </field>
    <field name="BEL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bell ('\a'): A character for use when there is a need to call for
 human attention.  It may control alarm or attention devices.

 @since 8.0]]>
      </doc>
    </field>
    <field name="BS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Backspace ('\b'): A format effector which controls the movement of
 the printing position one printing space backward on the same
 printing line.  (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="HT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Horizontal Tabulation ('\t'): A format effector which controls the
 movement of the printing position to the next in a series of
 predetermined positions along the printing line.  (Applicable also to
 display devices and the skip function on punched cards.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="LF" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Line Feed ('\n'): A format effector which controls the movement of
 the printing position to the next printing line.  (Applicable also to
 display devices.) Where appropriate, this character may have the
 meaning "New Line" (NL), a format effector which controls the
 movement of the printing point to the first printing position on the
 next printing line.  Use of this convention requires agreement
 between sender and recipient of data.

 @since 8.0]]>
      </doc>
    </field>
    <field name="NL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Alternate name for {@link #LF}.  ({@code LF} is preferred.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="VT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vertical Tabulation ('\v'): A format effector which controls the
 movement of the printing position to the next in a series of
 predetermined printing lines.  (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="FF" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Form Feed ('\f'): A format effector which controls the movement of
 the printing position to the first pre-determined printing line on
 the next form or page.  (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="CR" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Carriage Return ('\r'): A format effector which controls the
 movement of the printing position to the first printing position on
 the same printing line.  (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SO" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shift Out: A control character indicating that the code
 combinations which follow shall be interpreted as outside of the
 character set of the standard code table until a Shift In character
 is reached.

 @since 8.0]]>
      </doc>
    </field>
    <field name="SI" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shift In: A control character indicating that the code
 combinations which follow shall be interpreted according to the
 standard code table.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DLE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Data Link Escape: A communication control character which
 will change the meaning of a limited number of contiguously following
 characters.  It is used exclusively to provide supplementary controls
 in data communication networks.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC1" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 1. Characters for the control
 of ancillary devices associated with data processing or
 telecommunication systems, more especially switching devices "on" or
 "off."  (If a single "stop" control is required to interrupt or turn
 off ancillary devices, DC4 is the preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="XON" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Transmission On: Although originally defined as DC1, this ASCII
 control character is now better known as the XON code used for software
 flow control in serial communications.  The main use is restarting
 the transmission after the communication has been stopped by the XOFF
 control code.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC2" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 2. Characters for the control
 of ancillary devices associated with data processing or
 telecommunication systems, more especially switching devices "on" or
 "off."  (If a single "stop" control is required to interrupt or turn
 off ancillary devices, DC4 is the preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC3" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 3. Characters for the control
 of ancillary devices associated with data processing or
 telecommunication systems, more especially switching devices "on" or
 "off."  (If a single "stop" control is required to interrupt or turn
 off ancillary devices, DC4 is the preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="XOFF" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Transmission off. See {@link #XON} for explanation.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC4" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 4. Characters for the control
 of ancillary devices associated with data processing or
 telecommunication systems, more especially switching devices "on" or
 "off."  (If a single "stop" control is required to interrupt or turn
 off ancillary devices, DC4 is the preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="NAK" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Negative Acknowledge: A communication control character
 transmitted by a receiver as a negative response to the sender.

 @since 8.0]]>
      </doc>
    </field>
    <field name="SYN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Synchronous Idle: A communication control character used by
 a synchronous transmission system in the absence of any other
 character to provide a signal from which synchronism may be achieved
 or retained.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ETB" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Transmission Block: A communication control character
 used to indicate the end of a block of data for communication
 purposes.  ETB is used for blocking data where the block structure is
 not necessarily related to the processing format.

 @since 8.0]]>
      </doc>
    </field>
    <field name="CAN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Cancel: A control character used to indicate that the data
 with which it is sent is in error or is to be disregarded.

 @since 8.0]]>
      </doc>
    </field>
    <field name="EM" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Medium: A control character associated with the sent
 data which may be used to identify the physical end of the medium, or
 the end of the used, or wanted, portion of information recorded on a
 medium.  (The position of this character does not necessarily
 correspond to the physical end of the medium.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SUB" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Substitute: A character that may be substituted for a
 character which is determined to be invalid or in error.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ESC" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Escape: A control character intended to provide code
 extension (supplementary characters) in general information
 interchange.  The Escape character itself is a prefix affecting the
 interpretation of a limited number of contiguously following
 characters.

 @since 8.0]]>
      </doc>
    </field>
    <field name="FS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[File Separator: These four information separators may be
 used within data in optional fashion, except that their hierarchical
 relationship shall be: FS is the most inclusive, then GS, then RS,
 and US is least inclusive.  (The content and length of a File, Group,
 Record, or Unit are not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="GS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Group Separator: These four information separators may be
 used within data in optional fashion, except that their hierarchical
 relationship shall be: FS is the most inclusive, then GS, then RS,
 and US is least inclusive.  (The content and length of a File, Group,
 Record, or Unit are not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="RS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Record Separator: These four information separators may be
 used within data in optional fashion, except that their hierarchical
 relationship shall be: FS is the most inclusive, then GS, then RS,
 and US is least inclusive.  (The content and length of a File, Group,
 Record, or Unit are not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="US" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unit Separator: These four information separators may be
 used within data in optional fashion, except that their hierarchical
 relationship shall be: FS is the most inclusive, then GS, then RS,
 and US is least inclusive.  (The content and length of a File, Group,
 Record, or Unit are not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SP" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Space: A normally non-printing graphic character used to
 separate words.  It is also a format effector which controls the
 movement of the printing position, one printing position forward.
 (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SPACE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Alternate name for {@link #SP}.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DEL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Delete: This character is used primarily to "erase" or
 "obliterate" erroneous or unwanted characters in perforated tape.

 @since 8.0]]>
      </doc>
    </field>
    <field name="MIN" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The minimum value of an ASCII character.

 @since 9.0 (was type {@code int} before 12.0)]]>
      </doc>
    </field>
    <field name="MAX" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The maximum value of an ASCII character.

 @since 9.0 (was type {@code int} before 12.0)]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static methods pertaining to ASCII characters (those in the range of values
 {@code 0x00} through {@code 0x7F}), and to strings containing such
 characters.

 <p>ASCII utilities also exist in other classes of this package:
 <ul>
 <!-- TODO(kevinb): how can we make this not produce a warning when building gwt javadoc? -->
 <li>{@link Charsets#US_ASCII} specifies the {@code Charset} of ASCII characters.
 <li>{@link CharMatcher#ASCII} matches ASCII characters and provides text processing methods
     which operate only on the ASCII characters of a string.
 </ul>

 @author Craig Berry
 @author Gregory Kick
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Ascii -->
  <!-- start class com.google.common.base.CaseFormat -->
  <class name="CaseFormat" extends="java.lang.Enum&lt;com.google.common.base.CaseFormat&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.base.CaseFormat[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.base.CaseFormat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="to" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="com.google.common.base.CaseFormat"/>
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Converts the specified {@code String s} from this format to the specified {@code format}. A
 "best effort" approach is taken; if {@code s} does not conform to the assumed format, then the
 behavior of this method is undefined but we make a reasonable effort at converting anyway.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class for converting between various ASCII case formats.

 @author Mike Bostock
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CaseFormat -->
  <!-- start class com.google.common.base.CharMatcher -->
  <class name="CharMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Predicate&lt;java.lang.Character&gt;"/>
    <constructor name="CharMatcher"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses. When subclassing, you may want to override
 {@code toString()} to provide a useful description.]]>
      </doc>
    </constructor>
    <method name="is" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches only one specified character.]]>
      </doc>
    </method>
    <method name="isNot" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character except the one specified.

 <p>To negate another {@code CharMatcher}, use {@link #negate()}.]]>
      </doc>
    </method>
    <method name="anyOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character present in the given character
 sequence.]]>
      </doc>
    </method>
    <method name="noneOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character not present in the given character
 sequence.]]>
      </doc>
    </method>
    <method name="inRange" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startInclusive" type="char"/>
      <param name="endInclusive" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character in a given range (both endpoints are
 inclusive). For example, to match any lowercase letter of the English alphabet, use {@code
 CharMatcher.inRange('a', 'z')}.

 @throws IllegalArgumentException if {@code endInclusive < startInclusive}]]>
      </doc>
    </method>
    <method name="forPredicate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super java.lang.Character&gt;"/>
      <doc>
      <![CDATA[Returns a matcher with identical behavior to the given {@link Character}-based predicate, but
 which operates on primitive {@code char} instances instead.]]>
      </doc>
    </method>
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Determines a true or false value for the given character.]]>
      </doc>
    </method>
    <method name="negate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher that matches any character not matched by this matcher.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by both this matcher and {@code other}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by either this matcher or {@code other}.]]>
      </doc>
    </method>
    <method name="precomputed" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to
 query than the original; your mileage may vary. Precomputation takes time and is likely to be
 worthwhile only if the precomputed matcher is queried many thousands of times.

 <p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a
 precomputed matcher is faster, but it certainly consumes more memory, which doesn't seem like a
 worthwhile tradeoff in a browser.]]>
      </doc>
    </method>
    <method name="matchesAnyOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains at least one matching character.
 Equivalent to {@code !matchesNoneOf(sequence)}.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code true} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches at least one character in the sequence
 @since 8.0]]>
      </doc>
    </method>
    <method name="matchesAllOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains only matching characters.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code false} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches every character in the sequence, including when
         the sequence is empty]]>
      </doc>
    </method>
    <method name="matchesNoneOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains no matching characters. Equivalent to
 {@code !matchesAnyOf(sequence)}.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code false} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches every character in the sequence, including when
         the sequence is empty]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the first matching character in a character sequence, or {@code -1} if no
 matching character is present.

 <p>The default implementation iterates over the sequence in forward order calling {@link
 #matches} for each character.

 @param sequence the character sequence to examine from the beginning
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first matching character in a character sequence, starting from a
 given position, or {@code -1} if no character matches after that position.

 <p>The default implementation iterates over the sequence in forward order, beginning at {@code
 start}, calling {@link #matches} for each character.

 @param sequence the character sequence to examine
 @param start the first index to examine; must be nonnegative and no greater than {@code
        sequence.length()}
 @return the index of the first matching character, guaranteed to be no less than {@code start},
         or {@code -1} if no character matches
 @throws IndexOutOfBoundsException if start is negative or greater than {@code
         sequence.length()}]]>
      </doc>
    </method>
    <method name="lastIndexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the last matching character in a character sequence, or {@code -1} if no
 matching character is present.

 <p>The default implementation iterates over the sequence in reverse order calling {@link
 #matches} for each character.

 @param sequence the character sequence to examine from the end
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="countIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the number of matching characters found in a character sequence.]]>
      </doc>
    </method>
    <method name="removeFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all non-matching characters of a character sequence, in order. For
 example: <pre>   {@code

   CharMatcher.is('a').removeFrom("bazaar")}</pre>

 ... returns {@code "bzr"}.]]>
      </doc>
    </method>
    <method name="retainFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all matching characters of a character sequence, in order. For
 example: <pre>   {@code

   CharMatcher.is('a').retainFrom("bazaar")}</pre>

 ... returns {@code "aaa"}.]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each character that matches this
 matcher replaced by a given replacement character. For example: <pre>   {@code

   CharMatcher.is('a').replaceFrom("radar", 'o')}</pre>

 ... returns {@code "rodor"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching
 character, then iterates the remainder of the sequence calling {@link #matches(char)} for each
 character.

 @param sequence the character sequence to replace matching characters in
 @param replacement the character to append to the result string in place of each matching
        character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each character that matches this
 matcher replaced by a given replacement sequence. For example: <pre>   {@code

   CharMatcher.is('a').replaceFrom("yaha", "oo")}</pre>

 ... returns {@code "yoohoo"}.

 <p><b>Note:</b> If the replacement is a fixed string with only one character, you are better
 off calling {@link #replaceFrom(CharSequence, char)} directly.

 @param sequence the character sequence to replace matching characters in
 @param replacement the characters to append to the result string in place of each matching
        character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all characters this matcher
 matches from the beginning and from the end of the string. For example: <pre>   {@code

   CharMatcher.anyOf("ab").trimFrom("abacatbab")}</pre>

 ... returns {@code "cat"}.

 <p>Note that: <pre>   {@code

   CharMatcher.inRange('\0', ' ').trimFrom(str)}</pre>

 ... is equivalent to {@link String#trim()}.]]>
      </doc>
    </method>
    <method name="trimLeadingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all characters this matcher
 matches from the beginning of the string. For example: <pre> {@code

   CharMatcher.anyOf("ab").trimLeadingFrom("abacatbab")}</pre>

 ... returns {@code "catbab"}.]]>
      </doc>
    </method>
    <method name="trimTrailingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all characters this matcher
 matches from the end of the string. For example: <pre> {@code

   CharMatcher.anyOf("ab").trimTrailingFrom("abacatbab")}</pre>

 ... returns {@code "abacat"}.]]>
      </doc>
    </method>
    <method name="collapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each group of consecutive
 characters that match this matcher replaced by a single replacement character. For example:
 <pre>   {@code

   CharMatcher.anyOf("eko").collapseFrom("bookkeeper", '-')}</pre>

 ... returns {@code "b-p-r"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching
 character, then iterates the remainder of the sequence calling {@link #matches(char)} for each
 character.

 @param sequence the character sequence to replace matching groups of characters in
 @param replacement the character to append to the result string in place of each group of
        matching characters in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimAndCollapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that
 groups of matching characters at the start or end of the sequence are removed without
 replacement.]]>
      </doc>
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="character" type="java.lang.Character"/>
      <doc>
      <![CDATA[Returns {@code true} if this matcher matches the given character.

 @throws NullPointerException if {@code character} is null]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this {@code CharMatcher}, such as
 {@code CharMatcher.or(WHITESPACE, JAVA_DIGIT)}.]]>
      </doc>
    </method>
    <field name="BREAKING_WHITESPACE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a breaking whitespace (that is, a whitespace which can be
 interpreted as a break between words for formatting purposes). See {@link #WHITESPACE} for a
 discussion of that term.

 @since 2.0]]>
      </doc>
    </field>
    <field name="ASCII" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is ASCII, meaning that its code point is less than 128.]]>
      </doc>
    </field>
    <field name="DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a digit according to
 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">Unicode</a>.]]>
      </doc>
    </field>
    <field name="JAVA_DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a digit according to {@link Character#isDigit(char) Java's
 definition}. If you only care to match ASCII digits, you can use {@code inRange('0', '9')}.]]>
      </doc>
    </field>
    <field name="JAVA_LETTER" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a letter according to {@link Character#isLetter(char) Java's
 definition}. If you only care to match letters of the Latin alphabet, you can use {@code
 inRange('a', 'z').or(inRange('A', 'Z'))}.]]>
      </doc>
    </field>
    <field name="JAVA_LETTER_OR_DIGIT" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a letter or digit according to {@link
 Character#isLetterOrDigit(char) Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_UPPER_CASE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is upper case according to {@link Character#isUpperCase(char)
 Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_LOWER_CASE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is lower case according to {@link Character#isLowerCase(char)
 Java's definition}.]]>
      </doc>
    </field>
    <field name="JAVA_ISO_CONTROL" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is an ISO control character as specified by {@link
 Character#isISOControl(char)}.]]>
      </doc>
    </field>
    <field name="INVISIBLE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is invisible; that is, if its Unicode category is any of
 SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and
 PRIVATE_USE according to ICU4J.]]>
      </doc>
    </field>
    <field name="SINGLE_WIDTH" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is single-width (not double-width). When in doubt, this matcher
 errs on the side of returning {@code false} (that is, it tends to assume a character is
 double-width).

 <p><b>Note:</b> as the reference file evolves, we will modify this constant to keep it up to
 date.]]>
      </doc>
    </field>
    <field name="ANY" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches any character.]]>
      </doc>
    </field>
    <field name="NONE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches no characters.]]>
      </doc>
    </field>
    <field name="WHITESPACE" type="com.google.common.base.CharMatcher"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is whitespace according to the latest Unicode standard, as
 illustrated
 <a href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.
 This is not the same definition used by other Java APIs. (See a
 <a href="http://spreadsheets.google.com/pub?key=pd8dAQyHbdewRsnE5x5GzKQ">comparison of several
 definitions of "whitespace"</a>.)

 <p><b>Note:</b> as the Unicode definition evolves, we will modify this constant to keep it up
 to date.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does
 for any {@link Object}. Also offers basic text processing methods based on this function.
 Implementations are strongly encouraged to be side-effect-free and immutable.

 <p>Throughout the documentation of this class, the phrase "matching character" is used to mean
 "any character {@code c} for which {@code this.matches(c)} returns {@code true}".

 <p><b>Note:</b> This class deals only with {@code char} values; it does not understand
 supplementary Unicode code points in the range {@code 0x10000} to {@code 0x10FFFF}. Such logical
 characters are encoded into a {@code String} using surrogate pairs, and a {@code CharMatcher}
 treats these just as two separate characters.

 <p>Example usages: <pre>
   String trimmed = {@link #WHITESPACE WHITESPACE}.{@link #trimFrom trimFrom}(userInput);
   if ({@link #ASCII ASCII}.{@link #matchesAllOf matchesAllOf}(s)) { ... }</pre>

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/StringsExplained#CharMatcher">
 {@code CharMatcher}</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CharMatcher -->
  <!-- start class com.google.common.base.Charsets -->
  <class name="Charsets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="US_ASCII" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[US-ASCII: seven-bit ASCII, the Basic Latin block of the Unicode character set (ISO646-US).]]>
      </doc>
    </field>
    <field name="ISO_8859_1" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[ISO-8859-1: ISO Latin Alphabet Number 1 (ISO-LATIN-1).]]>
      </doc>
    </field>
    <field name="UTF_8" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-8: eight-bit UCS Transformation Format.]]>
      </doc>
    </field>
    <field name="UTF_16BE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16BE: sixteen-bit UCS Transformation Format, big-endian byte order.]]>
      </doc>
    </field>
    <field name="UTF_16LE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16LE: sixteen-bit UCS Transformation Format, little-endian byte order.]]>
      </doc>
    </field>
    <field name="UTF_16" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-16: sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order
 mark.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Contains constant definitions for the six standard {@link Charset} instances, which are
 guaranteed to be supported by all Java platform implementations.

 <p>Assuming you're free to choose, note that <b>{@link #UTF_8} is widely preferred</b>.

 <p>See the Guava User Guide article on <a
 href="http://code.google.com/p/guava-libraries/wiki/StringsExplained#Charsets">
 {@code Charsets}</a>.

 @author Mike Bostock
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Charsets -->
  <!-- start class com.google.common.base.Defaults -->
  <class name="Defaults" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="defaultValue" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the default value of {@code type} as defined by JLS --- {@code 0} for numbers, {@code
 false} for {@code boolean} and {@code '\0'} for {@code char}. For non-primitive types and
 {@code void}, null is returned.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides default values for all Java types, as defined by the JLS.

 @author Ben Yu
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Defaults -->
  <!-- start class com.google.common.base.Enums -->
  <class name="Enums" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumValue" type="java.lang.Enum&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the {@link Field} in which {@code enumValue} is defined.
 For example, to get the {@code Description} annotation on the {@code GOLF}
 constant of enum {@code Sport}, use
 {@code Enums.getField(Sport.GOLF).getAnnotation(Description.class)}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="valueOfFunction" return="com.google.common.base.Function&lt;java.lang.String, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumClass" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Function} that maps an {@link Enum} name to the associated
 {@code Enum} constant. The {@code Function} will return {@code null} if the
 {@code Enum} constant does not exist.

 @param enumClass the {@link Class} of the {@code Enum} declaring the
     constant values.]]>
      </doc>
    </method>
    <method name="getIfPresent" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an optional enum constant for the given type, using {@link Enum#valueOf}. If the
 constant does not exist, {@link Optional#absent} is returned. A common use case is for parsing
 user input or falling back to a default enum constant. For example,
 {@code Enums.getIfPresent(Country.class, countryInput).or(Country.DEFAULT);}

 @since 12.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Enum} instances.

 @author Steve McKay

 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Enums -->
  <!-- start class com.google.common.base.Equivalence -->
  <class name="Equivalence" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Equivalence"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="equivalent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="T"/>
      <param name="b" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if the given objects are considered equivalent.

 <p>The {@code equivalent} method implements an equivalence relation on object references:

 <ul>
 <li>It is <i>reflexive</i>: for any reference {@code x}, including null, {@code
     equivalent(x, x)} returns {@code true}.
 <li>It is <i>symmetric</i>: for any references {@code x} and {@code y}, {@code
     equivalent(x, y) == equivalent(y, x)}.
 <li>It is <i>transitive</i>: for any references {@code x}, {@code y}, and {@code z}, if
     {@code equivalent(x, y)} returns {@code true} and {@code equivalent(y, z)} returns {@code
     true}, then {@code equivalent(x, z)} returns {@code true}.
 <li>It is <i>consistent</i>: for any references {@code x} and {@code y}, multiple invocations
     of {@code equivalent(x, y)} consistently return {@code true} or consistently return {@code
     false} (provided that neither {@code x} nor {@code y} is modified).
 </ul>]]>
      </doc>
    </method>
    <method name="doEquivalent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="a" type="T"/>
      <param name="b" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code a} and {@code b} are considered equivalent.

 <p>Called by {@link #equivalent}. {@code a} and {@code b} are not the same
 object and are not nulls.

 @since 10.0 (previously, subclasses would override equivalent())]]>
      </doc>
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns a hash code for {@code t}.

 <p>The {@code hash} has the following properties:
 <ul>
 <li>It is <i>consistent</i>: for any reference {@code x}, multiple invocations of
     {@code hash(x}} consistently return the same value provided {@code x} remains unchanged
     according to the definition of the equivalence. The hash need not remain consistent from
     one execution of an application to another execution of the same application.
 <li>It is <i>distributable accross equivalence</i>: for any references {@code x} and {@code y},
     if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i> necessary
     that the hash be distributable accorss <i>inequivalence</i>. If {@code equivalence(x, y)}
     is false, {@code hash(x) == hash(y)} may still be true.
 <li>{@code hash(null)} is {@code 0}.
 </ul>]]>
      </doc>
    </method>
    <method name="doHash" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns a hash code for non-null object {@code t}.

 <p>Called by {@link #hash}.

 @since 10.0 (previously, subclasses would override hash())]]>
      </doc>
    </method>
    <method name="onResultOf" return="com.google.common.base.Equivalence&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a new equivalence relation for {@code F} which evaluates equivalence by first applying
 {@code function} to the argument, then evaluating using {@code this}. That is, for any pair of
 non-null objects {@code x} and {@code y}, {@code
 equivalence.onResultOf(function).equivalent(a, b)} is true if and only if {@code
 equivalence.equivalent(function.apply(a), function.apply(b))} is true.

 <p>For example: <pre>   {@code

    Equivalence<Person> SAME_AGE = Equivalences.equals().onResultOf(GET_PERSON_AGE);
 }</pre>
 
 <p>{@code function} will never be invoked with a null value.
 
 <p>Note that {@code function} must be consistent according to {@code this} equivalence
 relation. That is, invoking {@link Function#apply} multiple times for a given value must return
 equivalent results.
 For example, {@code Equivalences.identity().onResultOf(Functions.toStringFunction())} is broken
 because it's not guaranteed that {@link Object#toString}) always returns the same string
 instance.
 
 @since 10.0]]>
      </doc>
    </method>
    <method name="wrap" return="com.google.common.base.Equivalence.Wrapper&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="S extends T"/>
      <doc>
      <![CDATA[Returns a wrapper of {@code reference} that implements
 {@link Wrapper#equals(Object) Object.equals()} such that
 {@code wrap(this, a).equals(wrap(this, b))} if and only if {@code this.equivalent(a, b)}.
 
 @since 10.0]]>
      </doc>
    </method>
    <method name="pairwise" return="com.google.common.base.Equivalence&lt;java.lang.Iterable&lt;S&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence over iterables based on the equivalence of their elements.  More
 specifically, two iterables are considered equivalent if they both contain the same number of
 elements, and each pair of corresponding elements is equivalent according to
 {@code this}.  Null iterables are equivalent to one another.
 
 <p>Note that this method performs a similar function for equivalences as {@link
 com.google.common.collect.Ordering#lexicographical} does for orderings.

 @since 10.0]]>
      </doc>
    </method>
    <method name="equivalentTo" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to true if and only if the input is
 equivalent to {@code target} according to this equivalence relation.
 
 @since 10.0]]>
      </doc>
    </method>
    <method name="equals" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence that delegates to {@link Object#equals} and {@link Object#hashCode}.
 {@link Equivalence#equivalent} returns {@code true} if both values are null, or if neither
 value is null and {@link Object#equals} returns {@code true}. {@link Equivalence#hash} returns
 {@code 0} if passed a null value.

 @since 13.0
 @since 8.0 (in Equivalences with null-friendly behavior)
 @since 4.0 (in Equivalences)]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence that uses {@code ==} to compare values and {@link
 System#identityHashCode(Object)} to compute the hash code.  {@link Equivalence#equivalent}
 returns {@code true} if {@code a == b}, including in the case that a and b are both null.

 @since 13.0
 @since 4.0 (in Equivalences)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A strategy for determining whether two instances are considered equivalent. Examples of
 equivalences are the {@link Equivalences#identity() identity equivalence} and {@link
 Equivalences#equals equals equivalence}.

 @author Bob Lee
 @author Ben Yu
 @author Gregory Kick
 @since 10.0 (<a href="http://code.google.com/p/guava-libraries/wiki/Compatibility"
        >mostly source-compatible</a> since 4.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Equivalence -->
  <!-- start class com.google.common.base.Equivalence.Wrapper -->
  <class name="Equivalence.Wrapper" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the (possibly null) reference wrapped by this instance.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@link Equivalence#equivalent(Object, Object)} applied to the wrapped
 references is {@code true} and both wrappers use the {@link Object#equals(Object) same}
 equivalence.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the result of {@link Equivalence#hash(Object)} applied to the the wrapped reference.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this equivalence wrapper. The form of this string
 representation is not specified.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an
 {@link Equivalence}.

 <p>For example, given an {@link Equivalence} for {@link String strings} named {@code equiv}
 that tests equivalence using their lengths:

 <pre>   {@code
   equiv.wrap("a").equals(equiv.wrap("b")) // true
   equiv.wrap("a").equals(equiv.wrap("hello")) // false
 }</pre>

 <p>Note in particular that an equivalence wrapper is never equal to the object it wraps.

 <pre>   {@code
   equiv.wrap(obj).equals(obj) // always false
 }</pre>

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Equivalence.Wrapper -->
  <!-- start class com.google.common.base.Equivalences -->
  <class name="Equivalences" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="equals" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This method has been moved to {@link Equivalence#equals}. This method is scheduled
     to be removed in Guava release 14.0.">
      <doc>
      <![CDATA[Returns an equivalence that delegates to {@link Object#equals} and {@link Object#hashCode}.
 {@link Equivalence#equivalent} returns {@code true} if both values are null, or if neither
 value is null and {@link Object#equals} returns {@code true}. {@link Equivalence#hash} returns
 {@code 0} if passed a null value.

 @since 8.0 (present null-friendly behavior)
 @since 4.0 (otherwise)
 @deprecated This method has been moved to {@link Equivalence#equals}. This method is scheduled
     to be removed in Guava release 14.0.]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This method has been moved to {@link Equivalence#identity}. This method is schedule
     to be removed in Guava release 14.0.">
      <doc>
      <![CDATA[Returns an equivalence that uses {@code ==} to compare values and {@link
 System#identityHashCode(Object)} to compute the hash code.  {@link Equivalence#equivalent}
 returns {@code true} if {@code a == b}, including in the case that a and b are both null.

 @deprecated This method has been moved to {@link Equivalence#identity}. This method is schedule
     to be removed in Guava release 14.0.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static factory methods for creating {@code Equivalence} instances.

 <p>All methods return serializable instances.

 @author Bob Lee
 @author Kurt Alfred Kluever
 @author Gregory Kick
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Equivalences -->
  <!-- start class com.google.common.base.FinalizablePhantomReference -->
  <class name="FinalizablePhantomReference" extends="java.lang.ref.PhantomReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizablePhantomReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable phantom reference.

 @param referent to phantom reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Phantom reference with a {@code finalizeReferent()} method which a background thread invokes
 after the garbage collector reclaims the referent. This is a simpler alternative to using a
 {@link ReferenceQueue}.

 <p>Unlike a normal phantom reference, this reference will be cleared automatically.

 @author Bob Lee
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizablePhantomReference -->
  <!-- start interface com.google.common.base.FinalizableReference -->
  <interface name="FinalizableReference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="finalizeReferent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoked on a background thread after the referent has been garbage collected unless security
 restrictions prevented starting a background thread, in which case this method is invoked when
 new references are created.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implemented by references that have code to run after garbage collection of their referents.

 @see FinalizableReferenceQueue
 @author Bob Lee
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.FinalizableReference -->
  <!-- start class com.google.common.base.FinalizableReferenceQueue -->
  <class name="FinalizableReferenceQueue" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FinalizableReferenceQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new queue.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A reference queue with an associated background thread that dequeues references and invokes
 {@link FinalizableReference#finalizeReferent()} on them.

 <p>Keep a strong reference to this object until all of the associated referents have been
 finalized. If this object is garbage collected earlier, the backing thread will not invoke {@code
 finalizeReferent()} on the remaining references.

 @author Bob Lee
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableReferenceQueue -->
  <!-- start class com.google.common.base.FinalizableSoftReference -->
  <class name="FinalizableSoftReference" extends="java.lang.ref.SoftReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizableSoftReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable soft reference.

 @param referent to softly reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Soft reference with a {@code finalizeReferent()} method which a background thread invokes after
 the garbage collector reclaims the referent. This is a simpler alternative to using a {@link
 ReferenceQueue}.

 @author Bob Lee
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableSoftReference -->
  <!-- start class com.google.common.base.FinalizableWeakReference -->
  <class name="FinalizableWeakReference" extends="java.lang.ref.WeakReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizableWeakReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable weak reference.

 @param referent to weakly reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Weak reference with a {@code finalizeReferent()} method which a background thread invokes after
 the garbage collector reclaims the referent. This is a simpler alternative to using a {@link
 ReferenceQueue}.

 @author Bob Lee
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableWeakReference -->
  <!-- start interface com.google.common.base.Function -->
  <interface name="Function"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="F"/>
      <doc>
      <![CDATA[Returns the result of applying this function to {@code input}. This method is <i>generally
 expected</i>, but not absolutely required, to have the following properties:

 <ul>
 <li>Its execution does not cause any observable side effects.
 <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equal
     Objects.equal}{@code (a, b)} implies that {@code Objects.equal(function.apply(a),
     function.apply(b))}.
 </ul>

 @throws NullPointerException if {@code input} is null and this function does not accept null
     arguments]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Indicates whether another object is equal to this function.

 <p>Most implementations will have no reason to override the behavior of {@link Object#equals}.
 However, an implementation may also choose to return {@code true} whenever {@code object} is a
 {@link Function} that it considers <i>interchangeable</i> with this one. "Interchangeable"
 <i>typically</i> means that {@code Objects.equal(this.apply(f), that.apply(f))} is true for all
 {@code f} of type {@code F}. Note that a {@code false} result from this method does not imply
 that the functions are known <i>not</i> to be interchangeable.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Determines an output value based on an input value.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/FunctionalExplained">the use of {@code
 Function}</a>.
 
 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Function -->
  <!-- start class com.google.common.base.Functions -->
  <class name="Functions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toStringFunction" return="com.google.common.base.Function&lt;java.lang.Object, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a function that calls {@code toString()} on its argument. The function does not accept
 nulls; it will throw a {@link NullPointerException} when applied to {@code null}.

 <p><b>Warning:</b> The returned function may not be <i>consistent with equals</i> (as
 documented at {@link Function#apply}). For example, this function yields different results for
 the two equal instances {@code ImmutableSet.of(1, 2)} and {@code ImmutableSet.of(2, 1)}.]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Function&lt;E, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the identity function.]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.base.Function&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a function which performs a map lookup. The returned function throws an {@link
 IllegalArgumentException} if given a key that does not exist in the map.]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.base.Function&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <param name="defaultValue" type="V"/>
      <doc>
      <![CDATA[Returns a function which performs a map lookup with a default value. The function created by
 this method returns {@code defaultValue} for all inputs that do not belong to the map's key
 set.

 @param map source map that determines the function behavior
 @param defaultValue the value to return for inputs that aren't map keys
 @return function that returns {@code map.get(a)} when {@code a} is a key, or {@code
         defaultValue} otherwise]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.base.Function&lt;A, C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="g" type="com.google.common.base.Function&lt;B, C&gt;"/>
      <param name="f" type="com.google.common.base.Function&lt;A, ? extends B&gt;"/>
      <doc>
      <![CDATA[Returns the composition of two functions. For {@code f: A->B} and {@code g: B->C}, composition
 is defined as the function h such that {@code h(a) == g(f(a))} for each {@code a}.

 @param g the second function to apply
 @param f the first function to apply
 @return the composition of {@code f} and {@code g}
 @see <a href="//en.wikipedia.org/wiki/Function_composition">function composition</a>]]>
      </doc>
    </method>
    <method name="forPredicate" return="com.google.common.base.Function&lt;T, java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a function that returns the same boolean output as the given predicate for all inputs.

 <p>The returned function is <i>consistent with equals</i> (as documented at {@link
 Function#apply}) if and only if {@code predicate} is itself consistent with equals.]]>
      </doc>
    </method>
    <method name="constant" return="com.google.common.base.Function&lt;java.lang.Object, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="E"/>
      <doc>
      <![CDATA[Creates a function that returns {@code value} for any input.

 @param value the constant value for the function to return
 @return a function that always returns {@code value}]]>
      </doc>
    </method>
    <method name="forSupplier" return="com.google.common.base.Function&lt;java.lang.Object, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a function that always returns the result of invoking {@link Supplier#get} on {@code
 supplier}, regardless of its input.
 
 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code Function} instances.

 <p>All methods return serializable functions as long as they're given serializable parameters.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/FunctionalExplained">the use of {@code
 Function}</a>.

 @author Mike Bostock
 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Functions -->
  <!-- start class com.google.common.base.Joiner -->
  <class name="Joiner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="on" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a joiner which automatically places {@code separator} between consecutive elements.]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a joiner which automatically places {@code separator} between consecutive elements.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="use {@link #appendTo(Appendable, Iterator)} by casting {@code parts} to
     {@code IteratorlEsS_tHaN?>}, or better yet, by implementing only {@code Iterator} and not
     {@code Iterable}. lEsS_tHaNb>This method is scheduled for deletion in June 2013.lEsS_tHaN/b>">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="I extends java.lang.Object &amp; java.lang.Iterable&lt;?&gt; &amp; java.util.Iterator&lt;?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<b>Deprecated.</b>

 @since 11.0
 @deprecated use {@link #appendTo(Appendable, Iterator)} by casting {@code parts} to
     {@code Iterator<?>}, or better yet, by implementing only {@code Iterator} and not
     {@code Iterable}. <b>This method is scheduled for deletion in June 2013.</b>]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.util.Iterator&lt;?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends to {@code appendable} the string representation of each of the remaining arguments.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="use {@link #appendTo(StringBuilder, Iterator)} by casting {@code parts} to
     {@code IteratorlEsS_tHaN?>}, or better yet, by implementing only {@code Iterator} and not
     {@code Iterable}. lEsS_tHaNb>This method is scheduled for deletion in June 2013.lEsS_tHaN/b>">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="I extends java.lang.Object &amp; java.lang.Iterable&lt;?&gt; &amp; java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[<b>Deprecated.</b>

 @since 11.0
 @deprecated use {@link #appendTo(StringBuilder, Iterator)} by casting {@code parts} to
     {@code Iterator<?>}, or better yet, by implementing only {@code Iterator} and not
     {@code Iterable}. <b>This method is scheduled for deletion in June 2013.</b>]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Appends to {@code builder} the string representation of each of the remaining arguments.
 Identical to {@link #appendTo(Appendable, Object, Object, Object...)}, except that it does not
 throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="use {@link #join(Iterator)} by casting {@code parts} to
     {@code IteratorlEsS_tHaN?>}, or better yet, by implementing only {@code Iterator} and not
     {@code Iterable}. lEsS_tHaNb>This method is scheduled for deletion in June 2013.lEsS_tHaN/b>">
      <param name="parts" type="I extends java.lang.Object &amp; java.lang.Iterable&lt;?&gt; &amp; java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[<b>Deprecated.</b>

 @since 11.0
 @deprecated use {@link #join(Iterator)} by casting {@code parts} to
     {@code Iterator<?>}, or better yet, by implementing only {@code Iterator} and not
     {@code Iterable}. <b>This method is scheduled for deletion in June 2013.</b>]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.

 @since 11.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each argument, using the previously
 configured separator between each.]]>
      </doc>
    </method>
    <method name="useForNull" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullText" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a joiner with the same behavior as this one, except automatically substituting {@code
 nullText} for any provided null elements.]]>
      </doc>
    </method>
    <method name="skipNulls" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a joiner with the same behavior as this joiner, except automatically skipping over any
 provided null elements.]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Joiner.MapJoiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValueSeparator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as
 this {@code Joiner} otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object which joins pieces of text (specified as an array, {@link Iterable}, varargs or even a
 {@link Map}) with a separator. It either appends the results to an {@link Appendable} or returns
 them as a {@link String}. Example: <pre>   {@code

   Joiner joiner = Joiner.on("; ").skipNulls();
    . . .
   return joiner.join("Harry", null, "Ron", "Hermione");}</pre>

 This returns the string {@code "Harry; Ron; Hermione"}. Note that all input elements are
 converted to strings using {@link Object#toString()} before being appended.

 <p>If neither {@link #skipNulls()} nor {@link #useForNull(String)} is specified, the joining
 methods will throw {@link NullPointerException} if any given element is null.

 <p><b>Warning: joiner instances are always immutable</b>; a configuration method such as {@code
 useForNull} has no effect on the instance it is invoked on! You must store and use the new joiner
 instance returned by the method. This makes joiners thread-safe, and safe to store as {@code
 static final} constants. <pre>   {@code

   // Bad! Do not do this!
   Joiner joiner = Joiner.on(',');
   joiner.skipNulls(); // does nothing!
   return joiner.join("wrong", null, "wrong");}</pre>

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/StringsExplained#Joiner">{@code Joiner}</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Joiner -->
  <!-- start class com.google.common.base.Joiner.MapJoiner -->
  <class name="Joiner.MapJoiner" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each entry of {@code map}, using the previously
 configured separator and key-value separator, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each entry of {@code map}, using the previously
 configured separator and key-value separator, to {@code builder}. Identical to {@link
 #appendTo(Appendable, Map)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each entry of {@code map}, using the
 previously configured separator and key-value separator.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #appendTo(Appendable, Iterator)} by casting {@code entries} to
     {@code IteratorlEsS_tHaN? extends EntrylEsS_tHaN?, ?>>}, or better yet, by implementing only
     {@code Iterator} and not {@code Iterable}. lEsS_tHaNb>This method is scheduled for deletion
     in June 2013.lEsS_tHaN/b>">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="entries" type="I extends java.lang.Object &amp; java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt; &amp; java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<b>Deprecated.</b>

 @since 11.0
 @deprecated use {@link #appendTo(Appendable, Iterator)} by casting {@code entries} to
     {@code Iterator<? extends Entry<?, ?>>}, or better yet, by implementing only
     {@code Iterator} and not {@code Iterable}. <b>This method is scheduled for deletion
     in June 2013.</b>]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code appendable}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code appendable}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #appendTo(StringBuilder, Iterator)} by casting {@code entries} to
     {@code IteratorlEsS_tHaN? extends EntrylEsS_tHaN?, ?>>}, or better yet, by implementing only
     {@code Iterator} and not {@code Iterable}. lEsS_tHaNb>This method is scheduled for deletion
     in June 2013.lEsS_tHaN/b>">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="entries" type="I extends java.lang.Object &amp; java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt; &amp; java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<b>Deprecated.</b>

 @since 11.0
 @deprecated use {@link #appendTo(StringBuilder, Iterator)} by casting {@code entries} to
     {@code Iterator<? extends Entry<?, ?>>}, or better yet, by implementing only
     {@code Iterator} and not {@code Iterable}. <b>This method is scheduled for deletion
     in June 2013.</b>]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code builder}. Identical to {@link
 #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="entries" type="java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code builder}. Identical to {@link
 #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #join(Iterator)} by casting {@code entries} to
     {@code IteratorlEsS_tHaN? extends EntrylEsS_tHaN?, ?>>}, or better yet, by implementing only
     {@code Iterator} and not {@code Iterable}. lEsS_tHaNb>This method is scheduled for deletion
     in June 2013.lEsS_tHaN/b>">
      <param name="entries" type="I extends java.lang.Object &amp; java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt; &amp; java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<b>Deprecated.</b>

 @since 11.0
 @deprecated use {@link #join(Iterator)} by casting {@code entries} to
     {@code Iterator<? extends Entry<?, ?>>}, or better yet, by implementing only
     {@code Iterator} and not {@code Iterable}. <b>This method is scheduled for deletion
     in June 2013.</b>]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each entry in {@code entries}, using
 the previously configured separator and key-value separator.

 @since 10.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each entry in {@code entries}, using
 the previously configured separator and key-value separator.

 @since 11.0]]>
      </doc>
    </method>
    <method name="useForNull" return="com.google.common.base.Joiner.MapJoiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullText" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a map joiner with the same behavior as this one, except automatically substituting
 {@code nullText} for any provided null keys or values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that joins map entries in the same manner as {@code Joiner} joins iterables and
 arrays. Like {@code Joiner}, it is thread-safe and immutable.

 <p>In addition to operating on {@code Map} instances, {@code MapJoiner} can operate on {@code
 Multimap} entries in two distinct modes:

 <ul>
 <li>To output a separate entry for each key-value pair, pass {@code multimap.entries()} to a
     {@code MapJoiner} method that accepts entries as input, and receive output of the form
     {@code key1=A&key1=B&key2=C}.
 <li>To output a single entry for each key, pass {@code multimap.asMap()} to a {@code MapJoiner}
     method that accepts a map as input, and receive output of the form {@code
     key1=[A, B]&key2=C}.
 </ul>

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Joiner.MapJoiner -->
  <!-- start class com.google.common.base.Objects -->
  <class name="Objects" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
      <param name="b" type="java.lang.Object"/>
      <doc>
      <![CDATA[Determines whether two possibly-null objects are equal. Returns:

 <ul>
 <li>{@code true} if {@code a} and {@code b} are both null.
 <li>{@code true} if {@code a} and {@code b} are both non-null and they are
     equal according to {@link Object#equals(Object)}.
 <li>{@code false} in all other situations.
 </ul>

 <p>This assumes that any non-null objects passed to this function conform
 to the {@code equals()} contract.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Generates a hash code for multiple values. The hash code is generated by
 calling {@link Arrays#hashCode(Object[])}.

 <p>This is useful for implementing {@link Object#hashCode()}. For example,
 in an object that has three properties, {@code x}, {@code y}, and
 {@code z}, one could write:
 <pre>
 public int hashCode() {
   return Objects.hashCode(getX(), getY(), getZ());
 }</pre>

 <b>Warning</b>: When a single object is supplied, the returned hash code
 does not equal the hash code of that object.]]>
      </doc>
    </method>
    <method name="toStringHelper" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="self" type="java.lang.Object"/>
      <doc>
      <![CDATA[Creates an instance of {@link ToStringHelper}.

 <p>This is helpful for implementing {@link Object#toString()}.
 Specification by example: <pre>   {@code
   // Returns "ClassName{}"
   Objects.toStringHelper(this)
       .toString();

   // Returns "ClassName{x=1}"
   Objects.toStringHelper(this)
       .add("x", 1)
       .toString();

   // Returns "MyObject{x=1}"
   Objects.toStringHelper("MyObject")
       .add("x", 1)
       .toString();

   // Returns "ClassName{x=1, y=foo}"
   Objects.toStringHelper(this)
       .add("x", 1)
       .add("y", "foo")
       .toString();
   }}

   // Returns "ClassName{x=1}"
   Objects.toStringHelper(this)
       .omitNullValues()
       .add("x", 1)
       .add("y", null)
       .toString();
   }}</pre>

 <p>Note that in GWT, class names are often obfuscated.

 @param self the object to generate the string for (typically {@code this}),
        used only for its class name
 @since 2.0]]>
      </doc>
    </method>
    <method name="toStringHelper" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Creates an instance of {@link ToStringHelper} in the same manner as
 {@link Objects#toStringHelper(Object)}, but using the name of {@code clazz}
 instead of using an instance's {@link Object#getClass()}.

 <p>Note that in GWT, class names are often obfuscated.

 @param clazz the {@link Class} of the instance
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="toStringHelper" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates an instance of {@link ToStringHelper} in the same manner as
 {@link Objects#toStringHelper(Object)}, but using {@code className} instead
 of using an instance's {@link Object#getClass()}.

 @param className the name of the instance type
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="firstNonNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="T"/>
      <param name="second" type="T"/>
      <doc>
      <![CDATA[Returns the first of two given parameters that is not {@code null}, if
 either is, or otherwise throws a {@link NullPointerException}.

 <p><b>Note:</b> if {@code first} is represented as an {@code Optional<T>},
 this can be accomplished with {@code first.or(second)}. That approach also
 allows for lazy evaluation of the fallback instance, using
 {@code first.or(Supplier)}.

 @return {@code first} if {@code first} is not {@code null}, or
     {@code second} if {@code first} is {@code null} and {@code second} is
     not {@code null}
 @throws NullPointerException if both {@code first} and {@code second} were
     {@code null}
 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper functions that can operate on any {@code Object}.

 <p>See the Guava User Guide on <a
 href="http://code.google.com/p/guava-libraries/wiki/CommonObjectUtilitiesExplained">writing
 {@code Object} methods with {@code Objects}</a>.

 @author Laurence Gonsalves
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Objects -->
  <!-- start class com.google.common.base.Objects.ToStringHelper -->
  <class name="Objects.ToStringHelper" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="omitNullValues" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When called, the formatted output returned by {@link #toString()} will
 ignore {@code null} values.

 @since 12.0]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format. If {@code value} is {@code null}, the string {@code "null"}
 is used, unless {@link #omitNullValues()} is called, in which case this
 name/value pair will not be added.]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value}
 format.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, Object)} instead
 and give value a readable name.]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, boolean)} instead
 and give value a readable name.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, char)} instead
 and give value a readable name.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, double)} instead
 and give value a readable name.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, float)} instead
 and give value a readable name.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, int)} instead
 and give value a readable name.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.Objects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, long)} instead
 and give value a readable name.

 @since 11.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string in the format specified by {@link
 Objects#toStringHelper(Object)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Support class for {@link Objects#toStringHelper}.

 @author Jason Lee
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Objects.ToStringHelper -->
  <!-- start class com.google.common.base.Optional -->
  <class name="Optional" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="absent" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code Optional} instance with no contained reference.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <doc>
      <![CDATA[Returns an {@code Optional} instance containing the given non-null reference.]]>
      </doc>
    </method>
    <method name="fromNullable" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullableReference" type="T"/>
      <doc>
      <![CDATA[If {@code nullableReference} is non-null, returns an {@code Optional} instance containing that
 reference; otherwise returns {@link Optional#absent}.]]>
      </doc>
    </method>
    <method name="isPresent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this holder contains a (non-null) instance.]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contained instance, which must be present. If the instance might be
 absent, use {@link #or(Object)} or {@link #orNull} instead.

 @throws IllegalStateException if the instance is absent ({@link #isPresent} returns
     {@code false})]]>
      </doc>
    </method>
    <method name="or" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the contained instance if it is present; {@code defaultValue} otherwise. If
 no default value should be required because the instance is known to be present, use
 {@link #get()} instead. For a default value of {@code null}, use {@link #orNull}.

 <p>Note about generics: The signature {@code public T or(T defaultValue)} is overly
 restrictive. However, the ideal signature, {@code public <S super T> S or(S)}, is not legal
 Java. As a result, some sensible operations involving subtypes are compile errors:
 <pre>   {@code

   Optional<Integer> optionalInt = getSomeOptionalInt();
   Number value = optionalInt.or(0.5); // error

   FluentIterable<? extends Number> numbers = getSomeNumbers();
   Optional<? extends Number> first = numbers.first();
   Number value = first.or(0.5); // error}</pre>

 As a workaround, it is always safe to cast an {@code Optional<? extends T>} to {@code
 Optional<T>}. Casting either of the above example {@code Optional} instances to {@code
 Optional<Number>} (where {@code Number} is the desired output type) solves the problem:
 <pre>   {@code

   Optional<Number> optionalInt = (Optional) getSomeOptionalInt();
   Number value = optionalInt.or(0.5); // fine

   FluentIterable<? extends Number> numbers = getSomeNumbers();
   Optional<Number> first = (Optional) numbers.first();
   Number value = first.or(0.5); // fine}</pre>]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="secondChoice" type="com.google.common.base.Optional&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns this {@code Optional} if it has a value present; {@code secondChoice}
 otherwise.]]>
      </doc>
    </method>
    <method name="or" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.base.Supplier&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns the contained instance if it is present; {@code supplier.get()} otherwise. If the
 supplier returns {@code null}, a {@link NullPointerException} is thrown.

 @throws NullPointerException if the supplier returns {@code null}]]>
      </doc>
    </method>
    <method name="orNull" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contained instance if it is present; {@code null} otherwise. If the
 instance is known to be present, use {@link #get()} instead.]]>
      </doc>
    </method>
    <method name="asSet" return="java.util.Set&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable singleton {@link Set} whose only element is the contained instance
 if it is present; an empty immutable {@link Set} otherwise.

 @since 11.0]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.base.Optional&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super T, V&gt;"/>
      <doc>
      <![CDATA[If the instance is present, it is transformed with the given {@link Function}; otherwise,
 {@link Optional#absent} is returned. If the function returns {@code null}, a
 {@link NullPointerException} is thrown.

 @throws NullPointerException if the function returns {@code null}

 @since 12.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is an {@code Optional} instance, and either
 the contained references are {@linkplain Object#equals equal} to each other or both
 are absent. Note that {@code Optional} instances of differing parameterized types can
 be equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code for this instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this instance. The form of this string
 representation is unspecified.]]>
      </doc>
    </method>
    <method name="presentInstances" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optionals" type="java.lang.Iterable&lt;? extends com.google.common.base.Optional&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns the value of each present instance from the supplied {@code optionals}, in order,
 skipping over occurrences of {@link Optional#absent}. Iterators are unmodifiable and are
 evaluated lazily.

 @since 11.0 (generics widened in 13.0)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable object that may contain a non-null reference to another object. Each
 instance of this type either contains a non-null reference, or contains nothing (in
 which case we say that the reference is "absent"); it is never said to "contain {@code
 null}".

 <p>A non-null {@code Optional<T>} reference can be used as a replacement for a nullable
 {@code T} reference. It allows you to represent "a {@code T} that must be present" and
 a "a {@code T} that might be absent" as two distinct types in your program, which can
 aid clarity.

 <p>Some uses of this class include

 <ul>
 <li>As a method return type, as an alternative to returning {@code null} to indicate
     that no value was available
 <li>To distinguish between "unknown" (for example, not present in a map) and "known to
     have no value" (present in the map, with value {@code Optional.absent()})
 <li>To wrap nullable references for storage in a collection that does not support
     {@code null} (though there are
     <a href="http://code.google.com/p/guava-libraries/wiki/LivingWithNullHostileCollections">
     several other approaches to this</a> that should be considered first)
 </ul>

 <p>A common alternative to using this class is to find or create a suitable
 <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">null object</a> for the
 type in question.

 <p>This class is not intended as a direct analogue of any existing "option" or "maybe"
 construct from other programming environments, though it may bear some similarities.

 <p>See the Guava User Guide article on <a
 href="http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained#Optional">
 using {@code Optional}</a>.

 @param <T> the type of instance that can be contained. {@code Optional} is naturally
     covariant on this type, so it is safe to cast an {@code Optional<T>} to {@code
     Optional<S>} for any supertype {@code S} of {@code T}.
 @author Kurt Alfred Kluever
 @author Kevin Bourrillion
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Optional -->
  <!-- start class com.google.common.base.Preconditions -->
  <class name="Preconditions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @throws IllegalArgumentException if {@code expression} is false
 @throws NullPointerException if the check fails and either {@code
     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
     this happen)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @throws IllegalStateException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @throws IllegalStateException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @throws IllegalStateException if {@code expression} is false
 @throws NullPointerException if the check fails and either {@code
     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
     this happen)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array,
 list or string of size {@code size}. An element index may range from zero,
 inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list
     or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not
     less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array,
 list or string of size {@code size}. An element index may range from zero,
 inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list
     or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not
     less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array,
 list or string of size {@code size}. A position index may range from zero
 to {@code size}, inclusive.

 @param index a user-supplied index identifying a position in an array, list
     or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is
     greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array,
 list or string of size {@code size}. A position index may range from zero
 to {@code size}, inclusive.

 @param index a user-supplied index identifying a position in an array, list
     or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is
     greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndexes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code start} and {@code end} specify a valid <i>positions</i>
 in an array, list or string of size {@code size}, and are in order. A
 position index may range from zero to {@code size}, inclusive.

 @param start a user-supplied index identifying a starting position in an
     array, list or string
 @param end a user-supplied index identifying a ending position in an array,
     list or string
 @param size the size of that array, list or string
 @throws IndexOutOfBoundsException if either index is negative or is
     greater than {@code size}, or if {@code end} is less than {@code start}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple static methods to be called at the start of your own methods to verify
 correct arguments and state. This allows constructs such as
 <pre>
     if (count <= 0) {
       throw new IllegalArgumentException("must be positive: " + count);
     }</pre>

 to be replaced with the more compact
 <pre>
     checkArgument(count > 0, "must be positive: %s", count);</pre>

 Note that the sense of the expression is inverted; with {@code Preconditions}
 you declare what you expect to be <i>true</i>, just as you do with an
 <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/assert.html">
 {@code assert}</a> or a JUnit {@code assertTrue} call.

 <p><b>Warning:</b> only the {@code "%s"} specifier is recognized as a
 placeholder in these messages, not the full range of {@link
 String#format(String, Object[])} specifiers.

 <p>Take care not to confuse precondition checking with other similar types
 of checks! Precondition exceptions -- including those provided here, but also
 {@link IndexOutOfBoundsException}, {@link NoSuchElementException}, {@link
 UnsupportedOperationException} and others -- are used to signal that the
 <i>calling method</i> has made an error. This tells the caller that it should
 not have invoked the method when it did, with the arguments it did, or
 perhaps ever. Postcondition or other invariant failures should not throw
 these types of exceptions.

 <p>See the Guava User Guide on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PreconditionsExplained">
 using {@code Preconditions}</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Preconditions -->
  <!-- start interface com.google.common.base.Predicate -->
  <interface name="Predicate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="T"/>
      <doc>
      <![CDATA[Returns the result of applying this predicate to {@code input}. This method is <i>generally
 expected</i>, but not absolutely required, to have the following properties:

 <ul>
 <li>Its execution does not cause any observable side effects.
 <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equal
     Objects.equal}{@code (a, b)} implies that {@code predicate.apply(a) ==
     predicate.apply(b))}.
 </ul>

 @throws NullPointerException if {@code input} is null and this predicate does not accept null
     arguments]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Indicates whether another object is equal to this predicate.

 <p>Most implementations will have no reason to override the behavior of {@link Object#equals}.
 However, an implementation may also choose to return {@code true} whenever {@code object} is a
 {@link Predicate} that it considers <i>interchangeable</i> with this one. "Interchangeable"
 <i>typically</i> means that {@code this.apply(t) == that.apply(t)} for all {@code t} of type
 {@code T}). Note that a {@code false} result from this method does not imply that the
 predicates are known <i>not</i> to be interchangeable.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Determines a true or false value for a given input.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/FunctionalExplained">the use of {@code
 Predicate}</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Predicate -->
  <!-- start class com.google.common.base.Predicates -->
  <class name="Predicates" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="alwaysTrue" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that always evaluates to {@code true}.]]>
      </doc>
    </method>
    <method name="alwaysFalse" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that always evaluates to {@code false}.]]>
      </doc>
    </method>
    <method name="isNull" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference
 being tested is null.]]>
      </doc>
    </method>
    <method name="notNull" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference
 being tested is not null.]]>
      </doc>
    </method>
    <method name="not" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the given predicate
 evaluates to {@code false}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="java.lang.Iterable&lt;? extends com.google.common.base.Predicate&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if each of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a false
 predicate is found. It defensively copies the iterable passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 true}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="com.google.common.base.Predicate[]"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if each of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a false
 predicate is found. It defensively copies the array passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 true}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="second" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if both of its
 components evaluate to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a false
 predicate is found.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="java.lang.Iterable&lt;? extends com.google.common.base.Predicate&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if any one of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a
 true predicate is found. It defensively copies the iterable passed in, so
 future changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 false}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="com.google.common.base.Predicate[]"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if any one of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a
 true predicate is found. It defensively copies the array passed in, so
 future changes to it won't alter the behavior of this predicate. If {@code
 components} is empty, the returned predicate will always evaluate to {@code
 false}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="second" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if either of its
 components evaluates to {@code true}. The components are evaluated in
 order, and evaluation will be "short-circuited" as soon as a
 true predicate is found.]]>
      </doc>
    </method>
    <method name="equalTo" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object being
 tested {@code equals()} the given target or both are null.]]>
      </doc>
    </method>
    <method name="instanceOf" return="com.google.common.base.Predicate&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object being
 tested is an instance of the given class. If the object being tested
 is {@code null} this predicate evaluates to {@code false}.

 <p>If you want to filter an {@code Iterable} to narrow its type, consider
 using {@link com.google.common.collect.Iterables#filter(Iterable, Class)}
 in preference.

 <p><b>Warning:</b> contrary to the typical assumptions about predicates (as
 documented at {@link Predicate#apply}), the returned predicate may not be
 <i>consistent with equals</i>. For example, {@code
 instanceOf(ArrayList.class)} will yield different results for the two equal
 instances {@code Lists.newArrayList(1)} and {@code Arrays.asList(1)}.]]>
      </doc>
    </method>
    <method name="assignableFrom" return="com.google.common.base.Predicate&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the class being
 tested is assignable from the given class.  The returned predicate
 does not allow null inputs.

 @since 10.0]]>
      </doc>
    </method>
    <method name="in" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.util.Collection&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference
 being tested is a member of the given collection. It does not defensively
 copy the collection passed in, so future changes to it will alter the
 behavior of the predicate.

 <p>This method can technically accept any {@code Collection<?>}, but using
 a typed collection helps prevent bugs. This approach doesn't block any
 potential users since it is always possible to use {@code
 Predicates.<Object>in()}.

 @param target the collection that may contain the function input]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.base.Predicate&lt;A&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;B&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;A, ? extends B&gt;"/>
      <doc>
      <![CDATA[Returns the composition of a function and a predicate. For every {@code x},
 the generated predicate returns {@code predicate(function(x))}.

 @return the composition of the provided function and predicate]]>
      </doc>
    </method>
    <method name="containsPattern" return="com.google.common.base.Predicate&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the
 {@code CharSequence} being tested contains any match for the given
 regular expression pattern. The test used is equivalent to
 {@code Pattern.compile(pattern).matcher(arg).find()}

 @throws java.util.regex.PatternSyntaxException if the pattern is invalid
 @since 3.0]]>
      </doc>
    </method>
    <method name="contains" return="com.google.common.base.Predicate&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the
 {@code CharSequence} being tested contains any match for the given
 regular expression pattern. The test used is equivalent to
 {@code pattern.matcher(arg).find()}

 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code Predicate} instances.

 <p>All methods returns serializable predicates as long as they're given
 serializable parameters.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/FunctionalExplained">the
 use of {@code Predicate}</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Predicates -->
  <!-- start class com.google.common.base.Splitter -->
  <class name="Splitter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given single-character separator. For
 example, {@code Splitter.on(',').split("foo,,bar")} returns an iterable
 containing {@code ["foo", "", "bar"]}.

 @param separator the character to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorMatcher" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that considers any single character matched by the
 given {@code CharMatcher} to be a separator. For example, {@code
 Splitter.on(CharMatcher.anyOf(";,")).split("foo,;bar,quux")} returns an
 iterable containing {@code ["foo", "", "bar", "quux"]}.

 @param separatorMatcher a {@link CharMatcher} that determines whether a
     character is a separator
 @return a splitter, with default settings, that uses this matcher]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given fixed string as a separator. For
 example, {@code Splitter.on(", ").split("foo, bar, baz,qux")} returns an
 iterable containing {@code ["foo", "bar", "baz,qux"]}.

 @param separator the literal, nonempty string to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching {@code
 pattern} to be a separator. For example, {@code
 Splitter.on(Pattern.compile("\r?\n")).split(entireFile)} splits a string
 into lines whether it uses DOS-style or UNIX-style line terminators.

 @param separatorPattern the pattern that determines whether a subsequence
     is a separator. This pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws IllegalArgumentException if {@code separatorPattern} matches the
     empty string]]>
      </doc>
    </method>
    <method name="onPattern" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching a given
 pattern (regular expression) to be a separator. For example, {@code
 Splitter.onPattern("\r?\n").split(entireFile)} splits a string into lines
 whether it uses DOS-style or UNIX-style line terminators. This is
 equivalent to {@code Splitter.on(Pattern.compile(pattern))}.

 @param separatorPattern the pattern that determines whether a subsequence
     is a separator. This pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws java.util.regex.PatternSyntaxException if {@code separatorPattern}
     is a malformed expression
 @throws IllegalArgumentException if {@code separatorPattern} matches the
     empty string]]>
      </doc>
    </method>
    <method name="fixedLength" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a splitter that divides strings into pieces of the given length.
 For example, {@code Splitter.fixedLength(2).split("abcde")} returns an
 iterable containing {@code ["ab", "cd", "e"]}. The last piece can be
 smaller than {@code length} but will never be empty.

 @param length the desired length of pieces after splitting
 @return a splitter, with default settings, that can split into fixed sized
     pieces]]>
      </doc>
    </method>
    <method name="omitEmptyStrings" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 automatically omits empty strings from the results. For example, {@code
 Splitter.on(',').omitEmptyStrings().split(",a,,,b,c,,")} returns an
 iterable containing only {@code ["a", "b", "c"]}.

 <p>If either {@code trimResults} option is also specified when creating a
 splitter, that splitter always trims results first before checking for
 emptiness. So, for example, {@code
 Splitter.on(':').omitEmptyStrings().trimResults().split(": : : ")} returns
 an empty iterable.

 <p>Note that it is ordinarily not possible for {@link #split(CharSequence)}
 to return an empty iterable, but when using this option, it can (if the
 input sequence consists of nothing but separators).

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="limit" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="int"/>
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter but
 stops splitting after it reaches the limit.
 The limit defines the maximum number of items returned by the iterator.

 <p>For example,
 {@code Splitter.on(',').limit(3).split("a,b,c,d")} returns an iterable
 containing {@code ["a", "b", "c,d"]}.  When omitting empty strings, the
 omitted strings do no count.  Hence,
 {@code Splitter.on(',').limit(3).omitEmptyStrings().split("a,,,b,,,c,d")}
 returns an iterable containing {@code ["a", "b", "c,d"}.
 When trim is requested, all entries, including the last are trimmed.  Hence
 {@code Splitter.on(',').limit(3).trimResults().split(" a , b , c , d ")}
 results in @{code ["a", "b", "c , d"]}.

 @param limit the maximum number of items returns
 @return a splitter with the desired configuration
 @since 9.0]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 automatically removes leading and trailing {@linkplain
 CharMatcher#WHITESPACE whitespace} from each returned substring; equivalent
 to {@code trimResults(CharMatcher.WHITESPACE)}. For example, {@code
 Splitter.on(',').trimResults().split(" a, b ,c ")} returns an iterable
 containing {@code ["a", "b", "c"]}.

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trimmer" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but
 removes all leading or trailing characters matching the given {@code
 CharMatcher} from each returned substring. For example, {@code
 Splitter.on(',').trimResults(CharMatcher.is('_')).split("_a ,_b_ ,c__")}
 returns an iterable containing {@code ["a ", "b_ ", "c"]}.

 @param trimmer a {@link CharMatcher} that determines whether a character
     should be removed from the beginning/end of a subsequence
 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="split" return="java.lang.Iterable&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits {@code sequence} into string components and makes them available
 through an {@link Iterator}, which may be lazily evaluated.

 @param sequence the sequence of characters to split
 @return an iteration over the segments split from the parameter.]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Splitter.MapSplitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code MapSplitter} which splits entries based on this splitter,
 and splits entries into keys and values using the specified separator.

 @since 10.0]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Splitter.MapSplitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValueSplitter" type="com.google.common.base.Splitter"/>
      <doc>
      <![CDATA[Returns a {@code MapSplitter} which splits entries based on this splitter,
 and splits entries into keys and values using the specified key-value
 splitter.

 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that divides strings (or other instances of {@code CharSequence})
 into substrings, by recognizing a <i>separator</i> (a.k.a. "delimiter")
 which can be expressed as a single character, literal string, regular
 expression, {@code CharMatcher}, or by using a fixed substring length. This
 class provides the complementary functionality to {@link Joiner}.

 <p>Here is the most basic example of {@code Splitter} usage: <pre>   {@code

   Splitter.on(',').split("foo,bar")}</pre>

 This invocation returns an {@code Iterable<String>} containing {@code "foo"}
 and {@code "bar"}, in that order.

 <p>By default {@code Splitter}'s behavior is very simplistic: <pre>   {@code

   Splitter.on(',').split("foo,,bar, quux")}</pre>

 This returns an iterable containing {@code ["foo", "", "bar", " quux"]}.
 Notice that the splitter does not assume that you want empty strings removed,
 or that you wish to trim whitespace. If you want features like these, simply
 ask for them: <pre> {@code

   private static final Splitter MY_SPLITTER = Splitter.on(',')
       .trimResults()
       .omitEmptyStrings();}</pre>

 Now {@code MY_SPLITTER.split("foo, ,bar, quux,")} returns an iterable
 containing just {@code ["foo", "bar", "quux"]}. Note that the order in which
 the configuration methods are called is never significant; for instance,
 trimming is always applied first before checking for an empty result,
 regardless of the order in which the {@link #trimResults()} and
 {@link #omitEmptyStrings()} methods were invoked.

 <p><b>Warning: splitter instances are always immutable</b>; a configuration
 method such as {@code omitEmptyStrings} has no effect on the instance it
 is invoked on! You must store and use the new splitter instance returned by
 the method. This makes splitters thread-safe, and safe to store as {@code
 static final} constants (as illustrated above). <pre>   {@code

   // Bad! Do not do this!
   Splitter splitter = Splitter.on('/');
   splitter.trimResults(); // does nothing!
   return splitter.split("wrong / wrong / wrong");}</pre>

 The separator recognized by the splitter does not have to be a single
 literal character as in the examples above. See the methods {@link
 #on(String)}, {@link #on(Pattern)} and {@link #on(CharMatcher)} for examples
 of other ways to specify separators.

 <p><b>Note:</b> this class does not mimic any of the quirky behaviors of
 similar JDK methods; for instance, it does not silently discard trailing
 separators, as does {@link String#split(String)}, nor does it have a default
 behavior of using five particular whitespace characters as separators, like
 {@link java.util.StringTokenizer}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/StringsExplained#Splitter">
 {@code Splitter}</a>.

 @author Julien Silland
 @author Jesse Wilson
 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Splitter -->
  <!-- start class com.google.common.base.Splitter.MapSplitter -->
  <class name="Splitter.MapSplitter" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="split" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits {@code sequence} into substrings, splits each substring into
 an entry, and returns an unmodifiable map with each of the entries. For
 example, <code>
 Splitter.on(';').trimResults().withKeyValueSeparator("=>")
 .split("a=>b ; c=>b")
 </code> will return a mapping from {@code "a"} to {@code "b"} and
 {@code "c"} to {@code b}.

 <p>The returned map preserves the order of the entries from
 {@code sequence}.

 @throws IllegalArgumentException if the specified sequence does not split
         into valid map entries, or if there are duplicate keys]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that splits strings into maps as {@code Splitter} splits
 iterables and lists. Like {@code Splitter}, it is thread-safe and
 immutable.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Splitter.MapSplitter -->
  <!-- start class com.google.common.base.Stopwatch -->
  <class name="Stopwatch" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Stopwatch"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates (but does not start) a new stopwatch using {@link System#nanoTime}
 as its time source.]]>
      </doc>
    </constructor>
    <constructor name="Stopwatch" type="com.google.common.base.Ticker"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates (but does not start) a new stopwatch, using the specified time
 source.]]>
      </doc>
    </constructor>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if {@link #start()} has been called on this stopwatch,
 and {@link #stop()} has not been called since the last call to {@code
 start()}.]]>
      </doc>
    </method>
    <method name="start" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts the stopwatch.

 @return this {@code Stopwatch} instance
 @throws IllegalStateException if the stopwatch is already running.]]>
      </doc>
    </method>
    <method name="stop" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the stopwatch. Future reads will return the fixed duration that had
 elapsed up to this point.

 @return this {@code Stopwatch} instance
 @throws IllegalStateException if the stopwatch is already stopped.]]>
      </doc>
    </method>
    <method name="reset" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the elapsed time for this stopwatch to zero,
 and places it in a stopped state.

 @return this {@code Stopwatch} instance]]>
      </doc>
    </method>
    <method name="elapsedTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desiredUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns the current elapsed time shown on this stopwatch, expressed
 in the desired time unit, with any fraction rounded down.

 <p>Note that the overhead of measurement can be more than a microsecond, so
 it is generally not useful to specify {@link TimeUnit#NANOSECONDS}
 precision here.]]>
      </doc>
    </method>
    <method name="elapsedMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current elapsed time shown on this stopwatch, expressed
 in milliseconds, with any fraction rounded down. This is identical to
 {@code elapsedTime(TimeUnit.MILLISECONDS}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the current elapsed time.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #toString()} instead. This method is scheduled
     to be removed in Guava release 15.0.">
      <param name="significantDigits" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of the current elapsed time, choosing an
 appropriate unit and using the specified number of significant figures.
 For example, at the instant when {@code elapsedTime(NANOSECONDS)} would
 return {1234567}, {@code toString(4)} returns {@code "1.235 ms"}.

 @deprecated Use {@link #toString()} instead. This method is scheduled
     to be removed in Guava release 15.0.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that measures elapsed time in nanoseconds. It is useful to measure
 elapsed time using this class instead of direct calls to {@link
 System#nanoTime} for a few reasons:

 <ul>
 <li>An alternate time source can be substituted, for testing or performance
     reasons.
 <li>As documented by {@code nanoTime}, the value returned has no absolute
     meaning, and can only be interpreted as relative to another timestamp
     returned by {@code nanoTime} at a different time. {@code Stopwatch} is a
     more effective abstraction because it exposes only these relative values,
     not the absolute ones.
 </ul>

 <p>Basic usage:
 <pre>
   Stopwatch stopwatch = new Stopwatch().{@link #start start}();
   doSomething();
   stopwatch.{@link #stop stop}(); // optional

   long millis = stopwatch.{@link #elapsedMillis elapsedMillis}();

   log.info("that took: " + stopwatch); // formatted string like "12.3 ms"
 </pre>

 <p>Stopwatch methods are not idempotent; it is an error to start or stop a
 stopwatch that is already in the desired state.

 <p>When testing code that uses this class, use the {@linkplain
 #Stopwatch(Ticker) alternate constructor} to supply a fake or mock ticker.
 <!-- TODO(kevinb): restore the "such as" --> This allows you to
 simulate any valid behavior of the stopwatch.

 <p><b>Note:</b> This class is not thread-safe.

 @author Kevin Bourrillion
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Stopwatch -->
  <!-- start class com.google.common.base.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nullToEmpty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the given string if it is non-null; the empty string otherwise.

 @param string the string to test and possibly return
 @return {@code string} itself if it is non-null; {@code ""} if it is null]]>
      </doc>
    </method>
    <method name="emptyToNull" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the given string if it is nonempty; {@code null} otherwise.

 @param string the string to test and possibly return
 @return {@code string} itself if it is nonempty; {@code null} if it is
     empty or null]]>
      </doc>
    </method>
    <method name="isNullOrEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the given string is null or is the empty string.

 <p>Consider normalizing your string references with {@link #nullToEmpty}.
 If you do, you can use {@link String#isEmpty()} instead of this
 method, and you won't need special null-safe forms of methods like {@link
 String#toUpperCase} either. Or, if you'd like to normalize "in the other
 direction," converting empty strings to {@code null}, you can use {@link
 #emptyToNull}.

 @param string a string reference to check
 @return {@code true} if the string is null or is the empty string]]>
      </doc>
    </method>
    <method name="padStart" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="minLength" type="int"/>
      <param name="padChar" type="char"/>
      <doc>
      <![CDATA[Returns a string, of length at least {@code minLength}, consisting of
 {@code string} prepended with as many copies of {@code padChar} as are
 necessary to reach that length. For example,

 <ul>
 <li>{@code padStart("7", 3, '0')} returns {@code "007"}
 <li>{@code padStart("2010", 3, '0')} returns {@code "2010"}
 </ul>

 <p>See {@link Formatter} for a richer set of formatting capabilities.

 @param string the string which should appear at the end of the result
 @param minLength the minimum length the resulting string must have. Can be
     zero or negative, in which case the input string is always returned.
 @param padChar the character to insert at the beginning of the result until
     the minimum length is reached
 @return the padded string]]>
      </doc>
    </method>
    <method name="padEnd" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="minLength" type="int"/>
      <param name="padChar" type="char"/>
      <doc>
      <![CDATA[Returns a string, of length at least {@code minLength}, consisting of
 {@code string} appended with as many copies of {@code padChar} as are
 necessary to reach that length. For example,

 <ul>
 <li>{@code padEnd("4.", 5, '0')} returns {@code "4.000"}
 <li>{@code padEnd("2010", 3, '!')} returns {@code "2010"}
 </ul>

 <p>See {@link Formatter} for a richer set of formatting capabilities.

 @param string the string which should appear at the beginning of the result
 @param minLength the minimum length the resulting string must have. Can be
     zero or negative, in which case the input string is always returned.
 @param padChar the character to append to the end of the result until the
     minimum length is reached
 @return the padded string]]>
      </doc>
    </method>
    <method name="repeat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Returns a string consisting of a specific number of concatenated copies of
 an input string. For example, {@code repeat("hey", 3)} returns the string
 {@code "heyheyhey"}.

 @param string any non-null string
 @param count the number of times to repeat it; a nonnegative integer
 @return a string containing {@code string} repeated {@code count} times
     (the empty string if {@code count} is zero)
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="commonPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.CharSequence"/>
      <param name="b" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the longest string {@code prefix} such that
 {@code a.toString().startsWith(prefix) && b.toString().startsWith(prefix)},
 taking care not to split surrogate pairs. If {@code a} and {@code b} have
 no common prefix, returns the empty string.

 @since 11.0]]>
      </doc>
    </method>
    <method name="commonSuffix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.CharSequence"/>
      <param name="b" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the longest string {@code suffix} such that
 {@code a.toString().endsWith(suffix) && b.toString().endsWith(suffix)},
 taking care not to split surrogate pairs. If {@code a} and {@code b} have
 no common suffix, returns the empty string.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code String} or {@code CharSequence}
 instances.

 @author Kevin Bourrillion
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Strings -->
  <!-- start interface com.google.common.base.Supplier -->
  <interface name="Supplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves an instance of the appropriate type. The returned object may or
 may not be a new instance, depending on the implementation.

 @return an instance of the appropriate type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that can supply objects of a single type.  Semantically, this could
 be a factory, generator, builder, closure, or something else entirely. No
 guarantees are implied by this interface.

 @author Harry Heymann
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Supplier -->
  <!-- start class com.google.common.base.Suppliers -->
  <class name="Suppliers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compose" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super F, T&gt;"/>
      <param name="supplier" type="com.google.common.base.Supplier&lt;F&gt;"/>
      <doc>
      <![CDATA[Returns a new supplier which is the composition of the provided function
 and supplier. In other words, the new supplier's value will be computed by
 retrieving the value from {@code supplier}, and then applying
 {@code function} to that value. Note that the resulting supplier will not
 call {@code supplier} or invoke {@code function} until it is called.]]>
      </doc>
    </method>
    <method name="memoize" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a supplier which caches the instance retrieved during the first
 call to {@code get()} and returns that value on subsequent calls to
 {@code get()}. See:
 <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>

 <p>The returned supplier is thread-safe. The supplier's serialized form
 does not contain the cached value, which will be recalculated when {@code
 get()} is called on the reserialized instance.

 <p>If {@code delegate} is an instance created by an earlier call to {@code
 memoize}, it is returned directly.]]>
      </doc>
    </method>
    <method name="memoizeWithExpiration" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns a supplier that caches the instance supplied by the delegate and
 removes the cached value after the specified time has passed. Subsequent
 calls to {@code get()} return the cached value if the expiration time has
 not passed. After the expiration time, a new value is retrieved, cached,
 and returned. See:
 <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>

 <p>The returned supplier is thread-safe. The supplier's serialized form
 does not contain the cached value, which will be recalculated when {@code
 get()} is called on the reserialized instance.

 @param duration the length of time after a value is created that it
     should stop being returned by subsequent {@code get()} calls
 @param unit the unit that {@code duration} is expressed in
 @throws IllegalArgumentException if {@code duration} is not positive
 @since 2.0]]>
      </doc>
    </method>
    <method name="ofInstance" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Returns a supplier that always supplies {@code instance}.]]>
      </doc>
    </method>
    <method name="synchronizedSupplier" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a supplier whose {@code get()} method synchronizes on
 {@code delegate} before calling it, making it thread-safe.]]>
      </doc>
    </method>
    <method name="supplierFunction" return="com.google.common.base.Function&lt;com.google.common.base.Supplier&lt;T&gt;, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a function that accepts a supplier and returns the result of
 invoking {@link Supplier#get} on that supplier.

 @since 8.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Useful suppliers.

 <p>All methods return serializable suppliers as long as they're given
 serializable parameters.

 @author Laurence Gonsalves
 @author Harry Heymann
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Suppliers -->
  <!-- start class com.google.common.base.Throwables -->
  <class name="Throwables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="propagateIfInstanceOf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@code declaredType}.  Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfInstanceOf(t, IOException.class);
     Throwables.propagateIfInstanceOf(t, SQLException.class);
     throw Throwables.propagate(t);
   }
 </pre>]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException} or {@link Error}.  Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfPossible(t);
     throw new RuntimeException("unexpected", t);
   }
 </pre>]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException}, {@link Error}, or
 {@code declaredType}. Example usage:
 <pre>
   try {
     someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     handle(e);
   } catch (Throwable t) {
     Throwables.propagateIfPossible(t, OtherException.class);
     throw new RuntimeException("unexpected", t);
   }
 </pre>

 @param throwable the Throwable to possibly propagate
 @param declaredType the single checked exception type declared by the
     calling method]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType1" type="java.lang.Class&lt;X1&gt;"/>
      <param name="declaredType2" type="java.lang.Class&lt;X2&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an
 instance of {@link RuntimeException}, {@link Error}, {@code declaredType1},
 or {@code declaredType2}.  In the unlikely case that you have three or more
 declared checked exception types, you can handle them all by invoking these
 methods repeatedly. See usage example in {@link
 #propagateIfPossible(Throwable, Class)}.

 @param throwable the Throwable to possibly propagate
 @param declaredType1 any checked exception type declared by the calling
     method
 @param declaredType2 any other checked exception type declared by the
     calling method]]>
      </doc>
    </method>
    <method name="propagate" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} as-is if it is an instance of
 {@link RuntimeException} or {@link Error}, or else as a last resort, wraps
 it in a {@code RuntimeException} then propagates.
 <p>
 This method always throws an exception. The {@code RuntimeException} return
 type is only for client code to make Java type system happy in case a
 return value is required by the enclosing method. Example usage:
 <pre>
   T doSomething() {
     try {
       return someMethodThatCouldThrowAnything();
     } catch (IKnowWhatToDoWithThisException e) {
       return handle(e);
     } catch (Throwable t) {
       throw Throwables.propagate(t);
     }
   }
 </pre>

 @param throwable the Throwable to propagate
 @return nothing will ever be returned; this return type is only for your
     convenience, as illustrated in the example above]]>
      </doc>
    </method>
    <method name="getRootCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns the innermost cause of {@code throwable}. The first throwable in a
 chain provides context from when the error or exception was initially
 detected. Example usage:
 <pre>
   assertEquals("Unable to assign a customer id",
       Throwables.getRootCause(e).getMessage());
 </pre>]]>
      </doc>
    </method>
    <method name="getCausalChain" return="java.util.List&lt;java.lang.Throwable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Gets a {@code Throwable} cause chain as a list.  The first entry in the
 list will be {@code throwable} followed by its cause hierarchy.  Note
 that this is a snapshot of the cause chain and will not reflect
 any subsequent changes to the cause chain.

 <p>Here's an example of how it can be used to find specific types
 of exceptions in the cause chain:

 <pre>
 Iterables.filter(Throwables.getCausalChain(e), IOException.class));
 </pre>

 @param throwable the non-null {@code Throwable} to extract causes from
 @return an unmodifiable list containing the cause chain starting with
     {@code throwable}]]>
      </doc>
    </method>
    <method name="getStackTraceAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns a string containing the result of
 {@link Throwable#toString() toString()}, followed by the full, recursive
 stack trace of {@code throwable}. Note that you probably should not be
 parsing the resulting string; if you need programmatic access to the stack
 frames, you can call {@link Throwable#getStackTrace()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to instances of {@link Throwable}.

 <p>See the Guava User Guide entry on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ThrowablesExplained">
 Throwables</a>.

 @author Kevin Bourrillion
 @author Ben Yu
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Throwables -->
  <!-- start class com.google.common.base.Ticker -->
  <class name="Ticker" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Ticker"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="read" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of nanoseconds elapsed since this ticker's fixed
 point of reference.]]>
      </doc>
    </method>
    <method name="systemTicker" return="com.google.common.base.Ticker"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A ticker that reads the current time using {@link System#nanoTime}.

 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A time source; returns a time value representing the number of nanoseconds elapsed since some
 fixed but arbitrary point in time. Note that most users should use {@link Stopwatch} instead of
 interacting with this class directly.

 <p><b>Warning:</b> this interface can only be used to measure elapsed time, not wall time.

 @author Kevin Bourrillion
 @since 10.0
     (<a href="http://code.google.com/p/guava-libraries/wiki/Compatibility"
     >mostly source-compatible</a> since 9.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Ticker -->
</package>
<package name="com.google.common.cache">
  <!-- start class com.google.common.cache.AbstractCache -->
  <class name="AbstractCache" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.Cache&lt;K, V&gt;"/>
    <constructor name="AbstractCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="valueLoader" type="java.util.concurrent.Callable&lt;? extends V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[This implementation of {@code getAllPresent} lacks any insight into the internal cache data
 structure, and is thus forced to return the query keys instead of the cached keys. This is only
 possible with an unsafe cast which requires {@code keys} to actually be of type {@code K}.

 {@inheritDoc}

 @since 11.0]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Cache} interface to minimize the
 effort required to implement this interface.

 <p>To implement a cache, the programmer needs only to extend this class and provide an
 implementation for the {@link #put} and {@link #getIfPresent} methods. {@link #getAllPresent} is
 implemented in terms of {@link #getIfPresent}; {@link #putAll} is implemented in terms of
 {@link #put}, {@link #invalidateAll(Iterable)} is implemented in terms of {@link #invalidate}.
 The method {@link #cleanUp} is a no-op. All other methods throw an
 {@link UnsupportedOperationException}.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.AbstractCache -->
  <!-- start class com.google.common.cache.AbstractCache.SimpleStatsCounter -->
  <class name="AbstractCache.SimpleStatsCounter" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.AbstractCache.StatsCounter"/>
    <constructor name="AbstractCache.SimpleStatsCounter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an instance with all counts initialized to zero.]]>
      </doc>
    </constructor>
    <method name="recordHits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="recordMisses"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="recordLoadSuccess"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
    </method>
    <method name="recordLoadException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
    </method>
    <method name="recordEviction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="snapshot" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incrementBy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.cache.AbstractCache.StatsCounter"/>
      <doc>
      <![CDATA[Increments all counters by the values in {@code other}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A thread-safe {@link StatsCounter} implementation for use by {@link Cache} implementors.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.AbstractCache.SimpleStatsCounter -->
  <!-- start interface com.google.common.cache.AbstractCache.StatsCounter -->
  <interface name="AbstractCache.StatsCounter"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="recordHits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Records cache hits. This should be called when a cache request returns a cached value.

 @param count the number of hits to record
 @since 11.0]]>
      </doc>
    </method>
    <method name="recordMisses"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Records cache misses. This should be called when a cache request returns a value that was
 not found in the cache. This method should be called by the loading thread, as well as by
 threads blocking on the load. Multiple concurrent calls to {@link Cache} lookup methods with
 the same key on an absent value should result in a single call to either
 {@code recordLoadSuccess} or {@code recordLoadException} and multiple calls to this method,
 despite all being served by the results of a single load operation.

 @param count the number of misses to record
 @since 11.0]]>
      </doc>
    </method>
    <method name="recordLoadSuccess"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
      <doc>
      <![CDATA[Records the successful load of a new entry. This should be called when a cache request
 causes an entry to be loaded, and the loading completes successfully. In contrast to
 {@link #recordMisses}, this method should only be called by the loading thread.

 @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
     value]]>
      </doc>
    </method>
    <method name="recordLoadException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
      <doc>
      <![CDATA[Records the failed load of a new entry. This should be called when a cache request causes
 an entry to be loaded, but an exception is thrown while loading the entry. In contrast to
 {@link #recordMisses}, this method should only be called by the loading thread.

 @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
     value prior to an exception being thrown]]>
      </doc>
    </method>
    <method name="recordEviction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Records the eviction of an entry from the cache. This should only been called when an entry
 is evicted due to the cache's eviction strategy, and not as a result of manual {@linkplain
 Cache#invalidate invalidations}.]]>
      </doc>
    </method>
    <method name="snapshot" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a snapshot of this counter's values. Note that this may be an inconsistent view, as
 it may be interleaved with update operations.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Accumulates statistics during the operation of a {@link Cache} for presentation by {@link
 Cache#stats}. This is solely intended for consumption by {@code Cache} implementors.

 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.AbstractCache.StatsCounter -->
  <!-- start class com.google.common.cache.AbstractLoadingCache -->
  <class name="AbstractLoadingCache" extends="com.google.common.cache.AbstractCache&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache&lt;K, V&gt;"/>
    <constructor name="AbstractLoadingCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="getUnchecked" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Cache} interface to minimize the
 effort required to implement this interface.

 <p>To implement a cache, the programmer needs only to extend this class and provide an
 implementation for the {@link #get(Object)} and {@link #getIfPresent} methods.
 {@link #getUnchecked}, {@link #get(Object, Callable)}, and {@link #getAll} are implemented in
 terms of {@code get}; {@link #getAllPresent} is implemented in terms of {@code getIfPresent};
 {@link #putAll} is implemented in terms of {@link #put}, {@link #invalidateAll(Iterable)} is
 implemented in terms of {@link #invalidate}. The method {@link #cleanUp} is a no-op. All other
 methods throw an {@link UnsupportedOperationException}.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.AbstractLoadingCache -->
  <!-- start interface com.google.common.cache.Cache -->
  <interface name="Cache"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getIfPresent" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, or {@code null} if there is no
 cached value for {@code key}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="valueLoader" type="java.util.concurrent.Callable&lt;? extends V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, obtaining that value from
 {@code valueLoader} if necessary. No observable state associated with this cache is modified
 until loading completes. This method provides a simple substitute for the conventional
 "if cached, return; otherwise create, cache and return" pattern.

 <p><b>Warning:</b> as with {@link CacheLoader#load}, {@code valueLoader} <b>must not</b> return
 {@code null}; it may either return a non-null value or throw an exception.

 @throws ExecutionException if a checked exception was thrown while loading the value
 @throws UncheckedExecutionException if an unchecked exception was thrown while loading the
     value
 @throws ExecutionError if an error was thrown while loading the value

 @since 11.0]]>
      </doc>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a map of the values associated with {@code keys} in this cache. The returned map will
 only contain entries which are already present in the cache.

 @since 11.0]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code value} with {@code key} in this cache. If the cache previously contained a
 value associated with {@code key}, the old value is replaced by {@code value}.

 <p>Prefer {@link #get(Object, Callable)} when using the conventional "if cached, return;
 otherwise create, cache and return" pattern.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Copies all of the mappings from the specified map to the cache. The effect of this call is
 equivalent to that of calling {@code put(k, v)} on this map once for each mapping from key
 {@code k} to value {@code v} in the specified map. The behavior of this operation is undefined
 if the specified map is modified while the operation is in progress.

 @since 12.0]]>
      </doc>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Discards any cached value for key {@code key}.]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Discards any cached values for keys {@code keys}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Discards all entries in the cache.]]>
      </doc>
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the approximate number of entries in this cache.]]>
      </doc>
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a current snapshot of this cache's cumulative statistics. All stats are initialized
 to zero, and are monotonically increasing over the lifetime of the cache.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to
 the map directly affect the cache.]]>
      </doc>
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Performs any pending maintenance operations needed by the cache. Exactly which activities are
 performed -- if any -- is implementation-dependent.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A semi-persistent mapping from keys to values. Cache entries are manually added using
 {@link #get(Object, Callable)} or {@link #put(Object, Object)}, and are stored in the cache until
 either evicted or manually invalidated.

 <p>Implementations of this interface are expected to be thread-safe, and can be safely accessed
 by multiple concurrent threads.

 <p>Note that while this class is still annotated as {@link Beta}, the API is frozen from a
 consumer's standpoint. In other words existing methods are all considered {@code non-Beta} and
 won't be changed without going through an 18 month deprecation cycle; however new methods may be
 added at any time.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.Cache -->
  <!-- start class com.google.common.cache.CacheBuilder -->
  <class name="CacheBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="com.google.common.cache.CacheBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,
 strong values, and no automatic eviction of any kind.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spec" type="com.google.common.cache.CacheBuilderSpec"/>
      <doc>
      <![CDATA[Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spec" type="java.lang.String"/>
      <doc>
      <![CDATA[Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.
 This is especially useful for command-line configuration of a {@code CacheBuilder}.

 @param spec a String in the format specified by {@link CacheBuilderSpec}
 @since 12.0]]>
      </doc>
    </method>
    <method name="initialCapacity" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Sets the minimum total size for the internal hash tables. For example, if the initial capacity
 is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each
 having a hash table of size eight. Providing a large enough estimate at construction time
 avoids the need for expensive resizing operations later, but setting this value unnecessarily
 high wastes memory.

 @throws IllegalArgumentException if {@code initialCapacity} is negative
 @throws IllegalStateException if an initial capacity was already set]]>
      </doc>
    </method>
    <method name="concurrencyLevel" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="concurrencyLevel" type="int"/>
      <doc>
      <![CDATA[Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The
 table is internally partitioned to try to permit the indicated number of concurrent updates
 without contention. Because assignment of entries to these partitions is not necessarily
 uniform, the actual concurrency observed may vary. Ideally, you should choose a value to
 accommodate as many threads as will ever concurrently modify the table. Using a significantly
 higher value than you need can waste space and time, and a significantly lower value can lead
 to thread contention. But overestimates and underestimates within an order of magnitude do not
 usually have much noticeable impact. A value of one permits only one thread to modify the cache
 at a time, but since read operations and cache loading computations can proceed concurrently,
 this still yields higher concurrency than full synchronization.

 <p> Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this
 value, you should always choose it explicitly.

 <p>The current implementation uses the concurrency level to create a fixed number of hashtable
 segments, each governed by its own write lock. The segment lock is taken once for each explicit
 write, and twice for each cache loading computation (once prior to loading the new value,
 and once after loading completes). Much internal cache management is performed at the segment
 granularity. For example, access queues and write queues are kept per segment when they are
 required by the selected eviction algorithm. As such, when writing unit tests it is not
 uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction
 behavior.

 <p>Note that future implementations may abandon segment locking in favor of more advanced
 concurrency controls.

 @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive
 @throws IllegalStateException if a concurrency level was already set]]>
      </doc>
    </method>
    <method name="maximumSize" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
      <doc>
      <![CDATA[Specifies the maximum number of entries the cache may contain. Note that the cache <b>may evict
 an entry before this limit is exceeded</b>. As the cache size grows close to the maximum, the
 cache evicts entries that are less likely to be used again. For example, the cache may evict an
 entry because it hasn't been used recently or very often.

 <p>When {@code size} is zero, elements will be evicted immediately after being loaded into the
 cache. This can be useful in testing, or to disable caching temporarily without a code change.

 <p>This feature cannot be used in conjunction with {@link #maximumWeight}.

 @param size the maximum size of the cache
 @throws IllegalArgumentException if {@code size} is negative
 @throws IllegalStateException if a maximum size or weight was already set]]>
      </doc>
    </method>
    <method name="maximumWeight" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="weight" type="long"/>
      <doc>
      <![CDATA[Specifies the maximum weight of entries the cache may contain. Weight is determined using the
 {@link Weigher} specified with {@link #weigher}, and use of this method requires a
 corresponding call to {@link #weigher} prior to calling {@link #build}.

 <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. As the cache
 size grows close to the maximum, the cache evicts entries that are less likely to be used
 again. For example, the cache may evict an entry because it hasn't been used recently or very
 often.

 <p>When {@code weight} is zero, elements will be evicted immediately after being loaded into
 cache. This can be useful in testing, or to disable caching temporarily without a code
 change.

 <p>Note that weight is only used to determine whether the cache is over capacity; it has no
 effect on selecting which entry should be evicted next.

 <p>This feature cannot be used in conjunction with {@link #maximumSize}.

 @param weight the maximum total weight of entries the cache may contain
 @throws IllegalArgumentException if {@code weight} is negative
 @throws IllegalStateException if a maximum weight or size was already set
 @since 11.0]]>
      </doc>
    </method>
    <method name="weigher" return="com.google.common.cache.CacheBuilder&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="weigher" type="com.google.common.cache.Weigher&lt;? super K1, ? super V1&gt;"/>
      <doc>
      <![CDATA[Specifies the weigher to use in determining the weight of entries. Entry weight is taken
 into consideration by {@link #maximumWeight(long)} when determining which entries to evict, and
 use of this method requires a corresponding call to {@link #maximumWeight(long)} prior to
 calling {@link #build}. Weights are measured and recorded when entries are inserted into the
 cache, and are thus effectively static during the lifetime of a cache entry.

 <p>When the weight of an entry is zero it will not be considered for size-based eviction
 (though it still may be evicted by other means).

 <p><b>Important note:</b> Instead of returning <em>this</em> as a {@code CacheBuilder}
 instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the
 original reference or the returned reference may be used to complete configuration and build
 the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from
 building caches whose key or value types are incompatible with the types accepted by the
 weigher already provided; the {@code CacheBuilder} type cannot do this. For best results,
 simply use the standard method-chaining idiom, as illustrated in the documentation at top,
 configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.

 <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build
 a cache whose key or value type is incompatible with the weigher, you will likely experience
 a {@link ClassCastException} at some <i>undefined</i> point in the future.

 @param weigher the weigher to use in calculating the weight of cache entries
 @throws IllegalArgumentException if {@code size} is negative
 @throws IllegalStateException if a maximum size was already set
 @since 11.0]]>
      </doc>
    </method>
    <method name="weakKeys" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each key (not value) stored in the cache should be wrapped in a {@link
 WeakReference} (by default, strong references are used).

 <p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})
 comparison to determine equality of keys.

 <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size},
 but will never be visible to read or write operations; such entries are cleaned up as part of
 the routine maintenance described in the class javadoc.

 @throws IllegalStateException if the key strength was already set]]>
      </doc>
    </method>
    <method name="weakValues" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the cache should be wrapped in a
 {@link WeakReference} (by default, strong references are used).

 <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor
 candidate for caching; consider {@link #softValues} instead.

 <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})
 comparison to determine equality of values.

 <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},
 but will never be visible to read or write operations; such entries are cleaned up as part of
 the routine maintenance described in the class javadoc.

 @throws IllegalStateException if the value strength was already set]]>
      </doc>
    </method>
    <method name="softValues" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the cache should be wrapped in a
 {@link SoftReference} (by default, strong references are used). Softly-referenced objects will
 be garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory
 demand.

 <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain
 #maximumSize(long) maximum size} instead of using soft references. You should only use this
 method if you are well familiar with the practical consequences of soft references.

 <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})
 comparison to determine equality of values.

 <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},
 but will never be visible to read or write operations; such entries are cleaned up as part of
 the routine maintenance described in the class javadoc.

 @throws IllegalStateException if the value strength was already set]]>
      </doc>
    </method>
    <method name="expireAfterWrite" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Specifies that each entry should be automatically removed from the cache once a fixed duration
 has elapsed after the entry's creation, or the most recent replacement of its value.

 <p>When {@code duration} is zero, this method hands off to
 {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum
 size or weight. This can be useful in testing, or to disable caching temporarily without a code
 change.

 <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or
 write operations. Expired entries are cleaned up as part of the routine maintenance described
 in the class javadoc.

 @param duration the length of time after an entry is created that it should be automatically
     removed
 @param unit the unit that {@code duration} is expressed in
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if the time to live or time to idle was already set]]>
      </doc>
    </method>
    <method name="expireAfterAccess" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Specifies that each entry should be automatically removed from the cache once a fixed duration
 has elapsed after the entry's creation, the most recent replacement of its value, or its last
 access. Access time is reset by all cache read and write operations (including
 {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations
 on the collection-views of {@link Cache#asMap}.

 <p>When {@code duration} is zero, this method hands off to
 {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum
 size or weight. This can be useful in testing, or to disable caching temporarily without a code
 change.

 <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or
 write operations. Expired entries are cleaned up as part of the routine maintenance described
 in the class javadoc.

 @param duration the length of time after an entry is last accessed that it should be
     automatically removed
 @param unit the unit that {@code duration} is expressed in
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if the time to idle or time to live was already set]]>
      </doc>
    </method>
    <method name="refreshAfterWrite" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Specifies that active entries are eligible for automatic refresh once a fixed duration has
 elapsed after the entry's creation, or the most recent replacement of its value. The semantics
 of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling
 {@link CacheLoader#reload}.

 <p>As the default implementation of {@link CacheLoader#reload} is synchronous, it is
 recommended that users of this method override {@link CacheLoader#reload} with an asynchronous
 implementation; otherwise refreshes will be performed during unrelated cache read and write
 operations.

 <p>Currently automatic refreshes are performed when the first stale request for an entry
 occurs. The request triggering refresh will make a blocking call to {@link CacheLoader#reload}
 and immediately return the new value if the returned future is complete, and the old value
 otherwise.

 <p><b>Note:</b> <i>all exceptions thrown during refresh will be logged and then swallowed</i>.

 @param duration the length of time after an entry is created that it should be considered
     stale, and thus eligible for refresh
 @param unit the unit that {@code duration} is expressed in
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if the refresh interval was already set
 @since 11.0]]>
      </doc>
    </method>
    <method name="ticker" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticker" type="com.google.common.base.Ticker"/>
      <doc>
      <![CDATA[Specifies a nanosecond-precision time source for use in determining when entries should be
 expired. By default, {@link System#nanoTime} is used.

 <p>The primary intent of this method is to facilitate testing of caches which have been
 configured with {@link #expireAfterWrite} or {@link #expireAfterAccess}.

 @throws IllegalStateException if a ticker was already set]]>
      </doc>
    </method>
    <method name="removalListener" return="com.google.common.cache.CacheBuilder&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.cache.RemovalListener&lt;? super K1, ? super V1&gt;"/>
      <doc>
      <![CDATA[Specifies a listener instance, which all caches built using this {@code CacheBuilder} will
 notify each time an entry is removed from the cache by any means.

 <p>Each cache built by this {@code CacheBuilder} after this method is called invokes the
 supplied listener after removing an element for any reason (see removal causes in {@link
 RemovalCause}). It will invoke the listener as part of the routine maintenance described
 in the class javadoc.

 <p><b>Note:</b> <i>all exceptions thrown by {@code listener} will be logged (using
 {@link java.util.logging.Logger})and then swallowed</i>.

 <p><b>Important note:</b> Instead of returning <em>this</em> as a {@code CacheBuilder}
 instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the
 original reference or the returned reference may be used to complete configuration and build
 the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from
 building caches whose key or value types are incompatible with the types accepted by the
 listener already provided; the {@code CacheBuilder} type cannot do this. For best results,
 simply use the standard method-chaining idiom, as illustrated in the documentation at top,
 configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.

 <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build
 a cache whose key or value type is incompatible with the listener, you will likely experience
 a {@link ClassCastException} at some <i>undefined</i> point in the future.

 @throws IllegalStateException if a removal listener was already set]]>
      </doc>
    </method>
    <method name="recordStats" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this
 {@link Cache#stats} will return zero for all statistics. Note that recording stats requires
 bookkeeping to be performed with each operation, and thus imposes a performance penalty on
 cache operation.

 @since 12.0 (previously, stats collection was automatic)]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.cache.LoadingCache&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="com.google.common.cache.CacheLoader&lt;? super K1, V1&gt;"/>
      <doc>
      <![CDATA[Builds a cache, which either returns an already-loaded value for a given key or atomically
 computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently
 loading the value for this key, simply waits for that thread to finish and returns its
 loaded value. Note that multiple threads can concurrently load values for distinct keys.

 <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be
 invoked again to create multiple independent caches.

 @param loader the cache loader used to obtain new values
 @return a cache having the requested features]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.cache.Cache&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a cache which does not automatically load values when keys are requested.

 <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a
 {@code CacheLoader}.

 <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be
 invoked again to create multiple independent caches.

 @return a cache having the requested features
 @since 11.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this CacheBuilder instance. The exact form of the returned
 string is not specified.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>A builder of {@link LoadingCache} and {@link Cache} instances having any combination of the
 following features:

 <ul>
 <li>automatic loading of entries into the cache
 <li>least-recently-used eviction when a maximum size is exceeded
 <li>time-based expiration of entries, measured since last access or last write
 <li>keys automatically wrapped in {@linkplain WeakReference weak} references
 <li>values automatically wrapped in {@linkplain WeakReference weak} or
     {@linkplain SoftReference soft} references
 <li>notification of evicted (or otherwise removed) entries
 <li>accumulation of cache access statistics
 </ul>

 These features are all optional; caches can be created using all or none of them. By default
 cache instances created by {@code CacheBuilder} will not perform any type of eviction.

 <p>Usage example: <pre>   {@code

   LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()
       .maximumSize(10000)
       .expireAfterWrite(10, TimeUnit.MINUTES)
       .removalListener(MY_LISTENER)
       .build(
           new CacheLoader<Key, Graph>() {
             public Graph load(Key key) throws AnyException {
               return createExpensiveGraph(key);
             }
           });}</pre>

 Or equivalently, <pre>   {@code

   // In real life this would come from a command-line flag or config file
   String spec = "maximumSize=10000,expireAfterWrite=10m";

   LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)
       .removalListener(MY_LISTENER)
       .build(
           new CacheLoader<Key, Graph>() {
             public Graph load(Key key) throws AnyException {
               return createExpensiveGraph(key);
             }
           });}</pre>

 <p>The returned cache is implemented as a hash table with similar performance characteristics to
 {@link ConcurrentHashMap}. It implements all optional operations of the {@link LoadingCache} and
 {@link Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly
 consistent iterators</i>. This means that they are safe for concurrent use, but if other threads
 modify the cache after the iterator is created, it is undefined which of these changes, if any,
 are reflected in that iterator. These iterators never throw {@link
 ConcurrentModificationException}.

 <p><b>Note:</b> by default, the returned cache uses equality comparisons (the
 {@link Object#equals equals} method) to determine equality for keys or values. However, if
 {@link #weakKeys} was specified, the cache uses identity ({@code ==})
 comparisons instead for keys. Likewise, if {@link #weakValues} or {@link #softValues} was
 specified, the cache uses identity comparisons for values.

 <p>Entries are automatically evicted from the cache when any of
 {@linkplain #maximumSize(long) maximumSize}, {@linkplain #maximumWeight(long) maximumWeight},
 {@linkplain #expireAfterWrite expireAfterWrite},
 {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},
 {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} are requested.

 <p>If {@linkplain #maximumSize(long) maximumSize} or
 {@linkplain #maximumWeight(long) maximumWeight} is requested entries may be evicted on each cache
 modification.

 <p>If {@linkplain #expireAfterWrite expireAfterWrite} or
 {@linkplain #expireAfterAccess expireAfterAccess} is requested entries may be evicted on each
 cache modification, on occasional cache accesses, or on calls to {@link Cache#cleanUp}. Expired
 entries may be counted in {@link Cache#size}, but will never be visible to read or write
 operations.

 <p>If {@linkplain #weakKeys weakKeys}, {@linkplain #weakValues weakValues}, or
 {@linkplain #softValues softValues} are requested, it is possible for a key or value present in
 the cache to be reclaimed by the garbage collector. Entries with reclaimed keys or values may be
 removed from the cache on each cache modification, on occasional cache accesses, or on calls to
 {@link Cache#cleanUp}; such entries may be counted in {@link Cache#size}, but will never be
 visible to read or write operations.

 <p>Certain cache configurations will result in the accrual of periodic maintenance tasks which
 will be performed during write operations, or during occasional read operations in the absense of
 writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but
 calling it should not be necessary with a high throughput cache. Only caches built with
 {@linkplain #removalListener removalListener}, {@linkplain #expireAfterWrite expireAfterWrite},
 {@linkplain #expireAfterAccess expireAfterAccess}, {@linkplain #weakKeys weakKeys},
 {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic
 maintenance.

 <p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches
 retain all the configuration properties of the original cache. Note that the serialized form does
 <i>not</i> include cache contents, but only configuration.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CachesExplained">caching</a> for a higher-level
 explanation.

 @param <K> the base key type for all caches created by this builder
 @param <V> the base value type for all caches created by this builder
 @author Charles Fry
 @author Kevin Bourrillion
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheBuilder -->
  <!-- start class com.google.common.cache.CacheBuilderSpec -->
  <class name="CacheBuilderSpec" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="parse" return="com.google.common.cache.CacheBuilderSpec"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cacheBuilderSpecification" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a CacheBuilderSpec from a string.

 @param cacheBuilderSpecification the string form]]>
      </doc>
    </method>
    <method name="disableCaching" return="com.google.common.cache.CacheBuilderSpec"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a CacheBuilderSpec that will prevent caching.]]>
      </doc>
    </method>
    <method name="toParsableString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string that can be used to parse an equivalent
 {@code CacheBuilderSpec}.  The order and form of this representation is
 not guaranteed, except that reparsing its output will produce
 a {@code CacheBuilderSpec} equal to this instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this CacheBuilderSpec instance.
 The form of this representation is not guaranteed.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A specification of a {@link CacheBuilder} configuration.

 <p>{@code CacheBuilderSpec} supports parsing configuration off of a string, which
 makes it especially useful for command-line configuration of a {@code CacheBuilder}.

 <p>The string syntax is a series of comma-separated keys or key-value pairs,
 each corresponding to a {@code CacheBuilder} method.
 <ul>
 <li>{@code concurrencyLevel=[integer]}: sets {@link CacheBuilder#concurrencyLevel}.
 <li>{@code initialCapacity=[integer]}: sets {@link CacheBuilder#initialCapacity}.
 <li>{@code maximumSize=[long]}: sets {@link CacheBuilder#maximumSize}.
 <li>{@code maximumWeight=[long]}: sets {@link CacheBuilder#maximumWeight}.
 <li>{@code expireAfterAccess=[duration]}: sets {@link CacheBuilder#expireAfterAccess}.
 <li>{@code expireAfterWrite=[duration]}: sets {@link CacheBuilder#expireAfterWrite}.
 <li>{@code refreshAfterWrite=[duration]}: sets {@link CacheBuilder#refreshAfterWrite}.
 <li>{@code weakKeys}: sets {@link CacheBuilder#weakKeys}.
 <li>{@code softValues}: sets {@link CacheBuilder#softValues}.
 <li>{@code weakValues}: sets {@link CacheBuilder#weakValues}.
 </ul>

 The set of supported keys will grow as {@code CacheBuilder} evolves, but existing keys
 will never be removed.

 <p>Durations are represented by an integer, followed by one of "d", "h", "m",
 or "s", representing days, hours, minutes, or seconds respectively.  (There
 is currently no syntax to request expiration in milliseconds, microseconds,
 or nanoseconds.)

 <p>Whitespace before and after commas and equal signs is ignored.  Keys may
 not be repeated;  it is also illegal to use the following pairs of keys in
 a single value:
 <ul>
 <li>{@code maximumSize} and {@code maximumWeight}
 <li>{@code softValues} and {@code weakValues}
 </ul>

 <p>{@code CacheBuilderSpec} does not support configuring {@code CacheBuilder} methods
 with non-value parameters.  These must be configured in code.

 <p>A new {@code CacheBuilder} can be instantiated from a {@code CacheBuilderSpec} using
 {@link CacheBuilder#from(CacheBuilderSpec)} or {@link CacheBuilder#from(String)}.

 @author Adam Winer
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheBuilderSpec -->
  <!-- start class com.google.common.cache.CacheLoader -->
  <class name="CacheLoader" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CacheLoader"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="load" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes or retrieves the value corresponding to {@code key}.

 @param key the non-null key whose value should be loaded
 @return the value associated with {@code key}; <b>must not be null</b>
 @throws Exception if unable to load the result
 @throws InterruptedException if this method is interrupted. {@code InterruptedException} is
     treated like any other {@code Exception} in all respects except that, when it is caught,
     the thread's interrupt status is set]]>
      </doc>
    </method>
    <method name="reload" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="oldValue" type="V"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes or retrieves a replacement value corresponding to an already-cached {@code key}. This
 method is called when an existing cache entry is refreshed by
 {@link CacheBuilder#refreshAfterWrite}, or through a call to {@link LoadingCache#refresh}.

 <p>This implementation synchronously delegates to {@link #load}. It is recommended that it be
 overridden with an asynchronous implementation when using
 {@link CacheBuilder#refreshAfterWrite}.

 <p><b>Note:</b> <i>all exceptions thrown by this method will be logged and then swallowed</i>.

 @param key the non-null key whose value should be loaded
 @param oldValue the non-null old value corresponding to {@code key}
 @return the future new value associated with {@code key};
     <b>must not be null, must not return null</b>
 @throws Exception if unable to reload the result
 @throws InterruptedException if this method is interrupted. {@code InterruptedException} is
     treated like any other {@code Exception} in all respects except that, when it is caught,
     the thread's interrupt status is set
 @since 11.0]]>
      </doc>
    </method>
    <method name="loadAll" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes or retrieves the values corresponding to {@code keys}. This method is called by
 {@link LoadingCache#getAll}.

 <p>If the returned map doesn't contain all requested {@code keys} then the entries it does
 contain will be cached, but {@code getAll} will throw an exception. If the returned map
 contains extra keys not present in {@code keys} then all returned entries will be cached,
 but only the entries for {@code keys} will be returned from {@code getAll}.

 <p>This method should be overriden when bulk retrieval is significantly more efficient than
 many individual lookups. Note that {@link LoadingCache#getAll} will defer to individual calls
 to {@link LoadingCache#get} if this method is not overriden.

 @param keys the unique, non-null keys whose values should be loaded
 @return a map from each key in {@code keys} to the value associated with that key;
     <b>may not contain null values</b>
 @throws Exception if unable to load the result
 @throws InterruptedException if this method is interrupted. {@code InterruptedException} is
     treated like any other {@code Exception} in all respects except that, when it is caught,
     the thread's interrupt status is set
 @since 11.0]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheLoader&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a cache loader based on an <i>existing</i> function instance. Note that there's no need
 to create a <i>new</i> function just to pass it in here; just subclass {@code CacheLoader} and
 implement {@link #load load} instead.

 @param function the function to be used for loading values; must never return {@code null}
 @return a cache loader that loads values by passing each key to {@code function}]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheLoader&lt;java.lang.Object, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.base.Supplier&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a cache loader based on an <i>existing</i> supplier instance. Note that there's no need
 to create a <i>new</i> supplier just to pass it in here; just subclass {@code CacheLoader} and
 implement {@link #load load} instead.

 @param supplier the supplier to be used for loading values; must never return {@code null}
 @return a cache loader that loads values by calling {@link Supplier#get}, irrespective of the
     key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Computes or retrieves values, based on a key, for use in populating a {@link LoadingCache}.

 <p>Most implementations will only need to implement {@link #load}. Other methods may be
 overridden as desired.

 <p>Usage example: <pre>   {@code

   CacheLoader<Key, Graph> loader = new CacheLoader<Key, Graph>() {
     public Graph load(Key key) throws AnyException {
       return createExpensiveGraph(key);
     }
   };
   LoadingCache<Key, Graph> cache = CacheBuilder.newBuilder().build(loader);}</pre>

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheLoader -->
  <!-- start class com.google.common.cache.CacheLoader.InvalidCacheLoadException -->
  <class name="CacheLoader.InvalidCacheLoadException" extends="java.lang.RuntimeException"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CacheLoader.InvalidCacheLoadException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown to indicate that an invalid response was returned from a call to {@link CacheLoader}.

 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheLoader.InvalidCacheLoadException -->
  <!-- start class com.google.common.cache.CacheStats -->
  <class name="CacheStats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CacheStats" type="long, long, long, long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@code CacheStats} instance.

 <p>Five parameters of the same type in a row is a bad thing, but this class is not constructed
 by end users and is too fine-grained for a builder.]]>
      </doc>
    </constructor>
    <method name="requestCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have returned either a cached or
 uncached value. This is defined as {@code hitCount + missCount}.]]>
      </doc>
    </method>
    <method name="hitCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have returned a cached value.]]>
      </doc>
    </method>
    <method name="hitRate" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ratio of cache requests which were hits. This is defined as
 {@code hitCount / requestCount}, or {@code 1.0} when {@code requestCount == 0}.
 Note that {@code hitRate + missRate =~ 1.0}.]]>
      </doc>
    </method>
    <method name="missCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have returned an uncached (newly
 loaded) value, or null. Multiple concurrent calls to {@link Cache} lookup methods on an absent
 value can result in multiple misses, all returning the results of a single cache load
 operation.]]>
      </doc>
    </method>
    <method name="missRate" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ratio of cache requests which were misses. This is defined as
 {@code missCount / requestCount}, or {@code 0.0} when {@code requestCount == 0}.
 Note that {@code hitRate + missRate =~ 1.0}. Cache misses include all requests which
 weren't cache hits, including requests which resulted in either successful or failed loading
 attempts, and requests which waited for other threads to finish loading. It is thus the case
 that {@code missCount &gt;= loadSuccessCount + loadExceptionCount}. Multiple
 concurrent misses for the same key will result in a single load operation.]]>
      </doc>
    </method>
    <method name="loadCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of times that {@link Cache} lookup methods attempted to load new
 values. This includes both successful load operations, as well as those that threw
 exceptions. This is defined as {@code loadSuccessCount + loadExceptionCount}.]]>
      </doc>
    </method>
    <method name="loadSuccessCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have successfully loaded a new value.
 This is always incremented in conjunction with {@link #missCount}, though {@code missCount}
 is also incremented when an exception is encountered during cache loading (see
 {@link #loadExceptionCount}). Multiple concurrent misses for the same key will result in a
 single load operation.]]>
      </doc>
    </method>
    <method name="loadExceptionCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods threw an exception while loading a
 new value. This is always incremented in conjunction with {@code missCount}, though
 {@code missCount} is also incremented when cache loading completes successfully (see
 {@link #loadSuccessCount}). Multiple concurrent misses for the same key will result in a
 single load operation.]]>
      </doc>
    </method>
    <method name="loadExceptionRate" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ratio of cache loading attempts which threw exceptions. This is defined as
 {@code loadExceptionCount / (loadSuccessCount + loadExceptionCount)}, or
 {@code 0.0} when {@code loadSuccessCount + loadExceptionCount == 0}.]]>
      </doc>
    </method>
    <method name="totalLoadTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of nanoseconds the cache has spent loading new values. This can be
 used to calculate the miss penalty. This value is increased every time
 {@code loadSuccessCount} or {@code loadExceptionCount} is incremented.]]>
      </doc>
    </method>
    <method name="averageLoadPenalty" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the average time spent loading new values. This is defined as
 {@code totalLoadTime / (loadSuccessCount + loadExceptionCount)}.]]>
      </doc>
    </method>
    <method name="evictionCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times an entry has been evicted. This count does not include manual
 {@linkplain Cache#invalidate invalidations}.]]>
      </doc>
    </method>
    <method name="minus" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.cache.CacheStats"/>
      <doc>
      <![CDATA[Returns a new {@code CacheStats} representing the difference between this {@code CacheStats}
 and {@code other}. Negative values, which aren't supported by {@code CacheStats} will be
 rounded up to zero.]]>
      </doc>
    </method>
    <method name="plus" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.cache.CacheStats"/>
      <doc>
      <![CDATA[Returns a new {@code CacheStats} representing the sum of this {@code CacheStats}
 and {@code other}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Statistics about the performance of a {@link Cache}. Instances of this class are immutable.

 <p>Cache statistics are incremented according to the following rules:

 <ul>
 <li>When a cache lookup encounters an existing cache entry {@code hitCount} is incremented.
 <li>When a cache lookup first encounters a missing cache entry, a new entry is loaded.
 <ul>
 <li>After successfully loading an entry {@code missCount} and {@code loadSuccessCount} are
     incremented, and the total loading time, in nanoseconds, is added to
     {@code totalLoadTime}.
 <li>When an exception is thrown while loading an entry, {@code missCount} and {@code
     loadExceptionCount} are incremented, and the total loading time, in nanoseconds, is
     added to {@code totalLoadTime}.
 <li>Cache lookups that encounter a missing cache entry that is still loading will wait
     for loading to complete (whether successful or not) and then increment {@code missCount}.
 </ul>
 <li>When an entry is evicted from the cache, {@code evictionCount} is incremented.
 <li>No stats are modified when a cache entry is invalidated or manually removed.
 <li>No stats are modified by operations invoked on the {@linkplain Cache#asMap asMap} view of
     the cache.
 </ul>

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheStats -->
  <!-- start class com.google.common.cache.ForwardingCache -->
  <class name="ForwardingCache" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.Cache&lt;K, V&gt;"/>
    <constructor name="ForwardingCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.cache.Cache&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="valueLoader" type="java.util.concurrent.Callable&lt;? extends V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A cache which forwards all its method calls to another cache. Subclasses should override one or
 more methods to modify the behavior of the backing cache as desired per the
 <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingCache -->
  <!-- start class com.google.common.cache.ForwardingCache.SimpleForwardingCache -->
  <class name="ForwardingCache.SimpleForwardingCache" extends="com.google.common.cache.ForwardingCache&lt;K, V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingCache.SimpleForwardingCache" type="com.google.common.cache.Cache&lt;K, V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.cache.Cache&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingCache} where subclasses can pass in an already
 constructed {@link Cache} as the delegete.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingCache.SimpleForwardingCache -->
  <!-- start class com.google.common.cache.ForwardingLoadingCache -->
  <class name="ForwardingLoadingCache" extends="com.google.common.cache.ForwardingCache&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache&lt;K, V&gt;"/>
    <constructor name="ForwardingLoadingCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.cache.LoadingCache&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <doc>
    <![CDATA[A cache which forwards all its method calls to another cache. Subclasses should override one or
 more methods to modify the behavior of the backing cache as desired per the
 <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>Note that {@link #get}, {@link #getUnchecked}, and {@link #apply} all expose the same
 underlying functionality, so should probably be overridden as a group.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingLoadingCache -->
  <!-- start class com.google.common.cache.ForwardingLoadingCache.SimpleForwardingLoadingCache -->
  <class name="ForwardingLoadingCache.SimpleForwardingLoadingCache" extends="com.google.common.cache.ForwardingLoadingCache&lt;K, V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingLoadingCache.SimpleForwardingLoadingCache" type="com.google.common.cache.LoadingCache&lt;K, V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.cache.LoadingCache&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingLoadingCache} where subclasses can pass in an already
 constructed {@link LoadingCache} as the delegete.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingLoadingCache.SimpleForwardingLoadingCache -->
  <!-- start interface com.google.common.cache.LoadingCache -->
  <interface name="LoadingCache"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.Cache&lt;K, V&gt;"/>
    <implements name="com.google.common.base.Function&lt;K, V&gt;"/>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, first loading that value if
 necessary. No observable state associated with this cache is modified until loading completes.

 <p>If another call to {@link #get} or {@link #getUnchecked} is currently loading the value for
 {@code key}, simply waits for that thread to finish and returns its loaded value. Note that
 multiple threads can concurrently load values for distinct keys.

 <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#load} to load new values
 into the cache. Newly loaded values are added to the cache using
 {@code Cache.asMap().putIfAbsent} after loading has completed; if another value was associated
 with {@code key} while the new value was loading then a removal notification will be sent for
 the new value.

 <p>If the cache loader associated with this cache is known not to throw checked
 exceptions, then prefer {@link #getUnchecked} over this method.

 @throws ExecutionException if a checked exception was thrown while loading the value
 @throws UncheckedExecutionException if an unchecked exception was thrown while loading the
     value
 @throws ExecutionError if an error was thrown while loading the value]]>
      </doc>
    </method>
    <method name="getUnchecked" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, first loading that value if
 necessary. No observable state associated with this cache is modified until loading
 completes. Unlike {@link #get}, this method does not throw a checked exception, and thus should
 only be used in situations where checked exceptions are not thrown by the cache loader.

 <p>If another call to {@link #get} or {@link #getUnchecked} is currently loading the value for
 {@code key}, simply waits for that thread to finish and returns its loaded value. Note that
 multiple threads can concurrently load values for distinct keys.

 <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#load} to load new values
 into the cache. Newly loaded values are added to the cache using
 {@code Cache.asMap().putIfAbsent} after loading has completed; if another value was associated
 with {@code key} while the new value was loading then a removal notification will be sent for
 the new value.

 <p><b>Warning:</b> this method silently converts checked exceptions to unchecked exceptions,
 and should not be used with cache loaders which throw checked exceptions. In such cases use
 {@link #get} instead.

 @throws UncheckedExecutionException if an exception was thrown while loading the value,
     regardless of whether the exception was checked or unchecked
 @throws ExecutionError if an error was thrown while loading the value]]>
      </doc>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns a map of the values associated with {@code keys}, creating or retrieving those values
 if necessary. The returned map contains entries that were already cached, combined with newly
 loaded entries; it will never contain null keys or values.

 <p>Caches loaded by a {@link CacheLoader} will issue a single request to
 {@link CacheLoader#loadAll} for all keys which are not already present in the cache. All
 entries returned by {@link CacheLoader#loadAll} will be stored in the cache, over-writing
 any previously cached values. This method will throw an exception if
 {@link CacheLoader#loadAll} returns {@code null}, returns a map containing null keys or values,
 or fails to return an entry for each requested key.

 <p>Note that duplicate elements in {@code keys}, as determined by {@link Object#equals}, will
 be ignored.

 @throws ExecutionException if a checked exception was thrown while loading the values
 @throws UncheckedExecutionException if an unchecked exception was thrown while loading the
     values
 @throws ExecutionError if an error was thrown while loading the values
 @since 11.0]]>
      </doc>
    </method>
    <method name="apply" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Discouraged. Provided to satisfy the {@code Function} interface; use {@link #get} or
 {@link #getUnchecked} instead.

 @throws UncheckedExecutionException if an exception was thrown while loading the value,
     regardless of whether the exception was checked or unchecked
 @throws ExecutionError if an error was thrown while loading the value]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Loads a new value for key {@code key}, possibly asynchronously. While the new value is loading
 the previous value (if any) will continue to be returned by {@code get(key)} unless it is
 evicted. If the new value is loaded successfully it will replace the previous value in the
 cache; if an exception is thrown while refreshing the previous value will remain, <i>and the
 exception will be logged (using {@link java.util.logging.Logger}) and swallowed</i>.

 <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#reload} if the
 cache currently contains a value for {@code key}, and {@link CacheLoader#load} otherwise.
 Loading is asynchronous only if {@link CacheLoader#reload} was overridden with an
 asynchronous implementation.

 <p>Returns without doing anything if another thread is currently loading the value for
 {@code key}. If the cache loader associated with this cache performs refresh asynchronously
 then this method may return before refresh completes.

 @since 11.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note that although the view <i>is</i> modifiable, no method on the returned map will ever
 cause entries to be automatically loaded.</b>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A semi-persistent mapping from keys to values. Values are automatically loaded by the cache,
 and are stored in the cache until either evicted or manually invalidated.

 <p>Implementations of this interface are expected to be thread-safe, and can be safely accessed
 by multiple concurrent threads.

 <p>When evaluated as a {@link Function}, a cache yields the same result as invoking
 {@link #getUnchecked}.

 <p>Note that while this class is still annotated as {@link Beta}, the API is frozen from a
 consumer's standpoint. In other words existing methods are all considered {@code non-Beta} and
 won't be changed without going through an 18 month deprecation cycle; however new methods may be
 added at any time.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.LoadingCache -->
  <!-- start class com.google.common.cache.RemovalCause -->
  <class name="RemovalCause" extends="java.lang.Enum&lt;com.google.common.cache.RemovalCause&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.cache.RemovalCause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.cache.RemovalCause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The reason why a cached entry was removed.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.RemovalCause -->
  <!-- start interface com.google.common.cache.RemovalListener -->
  <interface name="RemovalListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onRemoval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="com.google.common.cache.RemovalNotification&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Notifies the listener that a removal occurred at some point in the past.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that can receive a notification when an entry is removed from a cache. The removal
 resulting in notification could have occured to an entry being manually removed or replaced, or
 due to eviction resulting from timed expiration, exceeding a maximum size, or garbage
 collection.

 <p>An instance may be called concurrently by multiple threads to process different entries.
 Implementations of this interface should avoid performing blocking calls or synchronizing on
 shared resources.

 @param <K> the most general type of keys this listener can listen for; for
     example {@code Object} if any key is acceptable
 @param <V> the most general type of values this listener can listen for; for
     example {@code Object} if any key is acceptable
 @author Charles Fry
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.RemovalListener -->
  <!-- start class com.google.common.cache.RemovalListeners -->
  <class name="RemovalListeners" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="asynchronous" return="com.google.common.cache.RemovalListener&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.cache.RemovalListener&lt;K, V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a {@code RemovalListener} which processes all eviction
 notifications using {@code executor}.

 @param listener the backing listener
 @param executor the executor with which removal notifications are
     asynchronously executed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection of common removal listeners.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.RemovalListeners -->
  <!-- start class com.google.common.cache.RemovalNotification -->
  <class name="RemovalNotification" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map.Entry&lt;K, V&gt;"/>
    <method name="getCause" return="com.google.common.cache.RemovalCause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the cause for which the entry was removed.]]>
      </doc>
    </method>
    <method name="wasEvicted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there was an automatic removal due to eviction (the cause is neither
 {@link RemovalCause#EXPLICIT} nor {@link RemovalCause#REPLACED}).]]>
      </doc>
    </method>
    <method name="getKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the form <code>{key}={value}</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A notification of the removal of a single entry. The key and/or value may be null if they were
 already garbage collected.

 <p>Like other {@code Map.Entry} instances associated with {@code CacheBuilder}, this class holds
 strong references to the key and value, regardless of the type of references the cache may be
 using.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.RemovalNotification -->
  <!-- start interface com.google.common.cache.Weigher -->
  <interface name="Weigher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="weigh" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns the weight of a cache entry. There is no unit for entry weights; rather they are simply
 relative to each other.

 @return the weight of the entry; must be non-negative]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Calculates the weights of cache entries.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.Weigher -->
</package>
<package name="com.google.common.collect">
  <!-- start class com.google.common.collect.AbstractIterator -->
  <class name="AbstractIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="computeNext" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element. <b>Note:</b> the implementation must call {@link
 #endOfData()} when there are no elements left in the iteration. Failure to
 do so could result in an infinite loop.

 <p>The initial invocation of {@link #hasNext()} or {@link #next()} calls
 this method, as does the first invocation of {@code hasNext} or {@code
 next} following each successful call to {@code next}. Once the
 implementation either invokes {@code endOfData} or throws an exception,
 {@code computeNext} is guaranteed to never be called again.

 <p>If this method throws an exception, it will propagate outward to the
 {@code hasNext} or {@code next} invocation that invoked this method. Any
 further attempts to use the iterator will result in an {@link
 IllegalStateException}.

 <p>The implementation of this method may not invoke the {@code hasNext},
 {@code next}, or {@link #peek()} methods on this instance; if it does, an
 {@code IllegalStateException} will result.

 @return the next element if there was one. If {@code endOfData} was called
     during execution, the return value will be ignored.
 @throws RuntimeException if any unrecoverable error happens. This exception
     will propagate outward to the {@code hasNext()}, {@code next()}, or
     {@code peek()} invocation that invoked this method. Any further
     attempts to use the iterator will result in an
     {@link IllegalStateException}.]]>
      </doc>
    </method>
    <method name="endOfData" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementations of {@link #computeNext} <b>must</b> invoke this method when
 there are no elements left in the iteration.

 @return {@code null}; a convenience so your {@code computeNext}
     implementation can use the simple statement {@code return endOfData();}]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element in the iteration without advancing the iteration,
 according to the contract of {@link PeekingIterator#peek()}.

 <p>Implementations of {@code AbstractIterator} that wish to expose this
 functionality should implement {@code PeekingIterator}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Iterator}
 interface, to make this interface easier to implement for certain types of
 data sources.

 <p>{@code Iterator} requires its implementations to support querying the
 end-of-data status without changing the iterator's state, using the {@link
 #hasNext} method. But many data sources, such as {@link
 java.io.Reader#read()}, do not expose this information; the only way to
 discover whether there is any data left is by trying to retrieve it. These
 types of data sources are ordinarily difficult to write iterators for. But
 using this class, one must implement only the {@link #computeNext} method,
 and invoke the {@link #endOfData} method when appropriate.

 <p>Another example is an iterator that skips over null elements in a backing
 iterator. This could be implemented as: <pre>   {@code

   public static Iterator<String> skipNulls(final Iterator<String> in) {
     return new AbstractIterator<String>() {
       protected String computeNext() {
         while (in.hasNext()) {
           String s = in.next();
           if (s != null) {
             return s;
           }
         }
         return endOfData();
       }
     };
   }}</pre>

 This class supports iterators that include null elements.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AbstractIterator -->
  <!-- start class com.google.common.collect.AbstractLinkedIterator -->
  <class name="AbstractLinkedIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="This class has been renamed {@link AbstractSequentialIterator}.
     This class is scheduled to be removed in Guava release 13.0.">
    <constructor name="AbstractLinkedIterator" type="T"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new iterator with the given first element, or, if {@code
 firstOrNull} is null, creates a new empty iterator.]]>
      </doc>
    </constructor>
    <method name="computeNext" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="previous" type="T"/>
      <doc>
      <![CDATA[Returns the element that follows {@code previous}, or returns {@code null}
 if no elements remain. This method is invoked during each call to
 {@link #next()} in order to compute the result of a <i>future</i> call to
 {@code next()}.]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Iterator}
 interface for sequences whose next element can always be derived from the
 previous element. Null elements are not supported, nor is the
 {@link #remove()} method.

 <p>Example: <pre>   {@code

   Iterator<Integer> powersOfTwo = new AbstractLinkedIterator<Integer>(1) {
     protected Integer computeNext(Integer previous) {
       return (previous == 1 << 30) ? null : previous * 2;
     }
   };}</pre>

 @author Chris Povirk
 @since 8.0
 @deprecated This class has been renamed {@link AbstractSequentialIterator}.
     This class is scheduled to be removed in Guava release 13.0.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AbstractLinkedIterator -->
  <!-- start class com.google.common.collect.AbstractSequentialIterator -->
  <class name="AbstractSequentialIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractSequentialIterator" type="T"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new iterator with the given first element, or, if {@code
 firstOrNull} is null, creates a new empty iterator.]]>
      </doc>
    </constructor>
    <method name="computeNext" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="previous" type="T"/>
      <doc>
      <![CDATA[Returns the element that follows {@code previous}, or returns {@code null}
 if no elements remain. This method is invoked during each call to
 {@link #next()} in order to compute the result of a <i>future</i> call to
 {@code next()}.]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Iterator}
 interface for sequences whose next element can always be derived from the
 previous element. Null elements are not supported, nor is the
 {@link #remove()} method.

 <p>Example: <pre>   {@code

   Iterator<Integer> powersOfTwo = 
       new AbstractSequentialIterator<Integer>(1) {
         protected Integer computeNext(Integer previous) {
           return (previous == 1 << 30) ? null : previous * 2;
         }
       };}</pre>

 @author Chris Povirk
 @since 12.0 (in Guava as {@code AbstractLinkedIterator} since 8.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AbstractSequentialIterator -->
  <!-- start class com.google.common.collect.ArrayListMultimap -->
  <class name="ArrayListMultimap" extends="com.google.common.collect.AbstractListMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code ArrayListMultimap} with the default initial
 capacities.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code ArrayListMultimap} with enough capacity to hold
 the specified numbers of keys and values without resizing.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code
      expectedValuesPerKey} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs an {@code ArrayListMultimap} with the same mappings as the
 specified multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="trimToSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reduces the memory used by this {@code ArrayListMultimap}, if feasible.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} that uses an {@code ArrayList} to store
 the values for a given key. A {@link HashMap} associates each key with an
 {@link ArrayList} of values.

 <p>When iterating through the collections supplied by this class, the
 ordering of values for a given key agrees with the order in which the values
 were added.

 <p>This multimap allows duplicate key-value pairs. After adding a new
 key-value pair equal to an existing key-value pair, the {@code
 ArrayListMultimap} will contain entries for both the new value and the old
 value.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>The lists returned by {@link #get}, {@link #removeAll}, and {@link
 #replaceValues} all implement {@link java.util.RandomAccess}.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedListMultimap}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ArrayListMultimap -->
  <!-- start class com.google.common.collect.ArrayTable -->
  <class name="ArrayTable" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Table&lt;R, C, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.ArrayTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKeys" type="java.lang.Iterable&lt;? extends R&gt;"/>
      <param name="columnKeys" type="java.lang.Iterable&lt;? extends C&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code ArrayTable}.

 @param rowKeys row keys that may be stored in the generated table
 @param columnKeys column keys that may be stored in the generated table
 @throws NullPointerException if any of the provided keys is null
 @throws IllegalArgumentException if {@code rowKeys} or {@code columnKeys}
     contains duplicates or is empty]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;R, C, V&gt;"/>
      <doc>
      <![CDATA[Creates an {@code ArrayTable} with the mappings in the provided table.

 <p>If {@code table} includes a mapping with row key {@code r} and a
 separate mapping with column key {@code c}, the returned table contains a
 mapping with row key {@code r} and column key {@code c}. If that row key /
 column key pair in not in {@code table}, the pair maps to {@code null} in
 the generated table.

 <p>The returned table allows subsequent {@code put} calls with the row keys
 in {@code table.rowKeySet()} and the column keys in {@code
 table.columnKeySet()}. Calling {@link #put} with other keys leads to an
 {@code IllegalArgumentException}.

 <p>The ordering of {@code table.rowKeySet()} and {@code
 table.columnKeySet()} determines the row and column iteration ordering of
 the returned table.

 @throws NullPointerException if {@code table} has a null key
 @throws IllegalArgumentException if the provided table is empty]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.ArrayTable&lt;R, C, V&gt;"/>
      <doc>
      <![CDATA[Creates an {@code ArrayTable} with the same mappings, allowed keys, and
 iteration ordering as the provided {@code ArrayTable}.]]>
      </doc>
    </method>
    <method name="rowKeyList" return="com.google.common.collect.ImmutableList&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns, as an immutable list, the row keys provided when the table was
 constructed, including those that are mapped to null values only.]]>
      </doc>
    </method>
    <method name="columnKeyList" return="com.google.common.collect.ImmutableList&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns, as an immutable list, the column keys provided when the table was
 constructed, including those that are mapped to null values only.]]>
      </doc>
    </method>
    <method name="at" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowIndex" type="int"/>
      <param name="columnIndex" type="int"/>
      <doc>
      <![CDATA[Returns the value corresponding to the specified row and column indices.
 The same value is returned by {@code
 get(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex))}, but
 this method runs more quickly.

 @param rowIndex position of the row key in {@link #rowKeyList()}
 @param columnIndex position of the row key in {@link #columnKeyList()}
 @return the value with the specified row and column
 @throws IndexOutOfBoundsException if either index is negative, {@code
     rowIndex} is greater then or equal to the number of allowed row keys,
     or {@code columnIndex} is greater then or equal to the number of
     allowed column keys]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowIndex" type="int"/>
      <param name="columnIndex" type="int"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code value} with the specified row and column indices. The
 logic {@code
 put(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex), value)}
 has the same behavior, but this method runs more quickly.

 @param rowIndex position of the row key in {@link #rowKeyList()}
 @param columnIndex position of the row key in {@link #columnKeyList()}
 @param value value to store in the table
 @return the previous value with the specified row and column
 @throws IndexOutOfBoundsException if either index is negative, {@code
     rowIndex} is greater then or equal to the number of allowed row keys,
     or {@code columnIndex} is greater then or equal to the number of
     allowed column keys]]>
      </doc>
    </method>
    <method name="toArray" return="V[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueClass" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a two-dimensional array with the table contents. The row and column
 indices correspond to the positions of the row and column in the iterables
 provided during table construction. If the table lacks a mapping for a
 given row and column, the corresponding array element is null.

 <p>Subsequent table changes will not modify the array, and vice versa.

 @param valueClass class of values stored in the returned array]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #eraseAll}">
      <doc>
      <![CDATA[Not supported. Use {@link #eraseAll} instead.

 @throws UnsupportedOperationException always
 @deprecated Use {@link #eraseAll}]]>
      </doc>
    </method>
    <method name="eraseAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Associates the value {@code null} with every pair of allowed row and column
 keys.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the provided keys are among the keys provided when
 the table was constructed.]]>
      </doc>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the provided column key is among the column keys
 provided when the table was constructed.]]>
      </doc>
    </method>
    <method name="containsRow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the provided row key is among the row keys
 provided when the table was constructed.]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Always returns {@code false}.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws IllegalArgumentException if {@code rowKey} is not in {@link
     #rowKeySet()} or {@code columnKey} is not in {@link #columnKeySet()}.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If {@code table} is an {@code ArrayTable}, its null values will be
 stored in this table, possibly replacing values that were previously
 non-null.

 @throws NullPointerException if {@code table} has a null key
 @throws IllegalArgumentException if any of the provided table's row keys or
     column keys is not in {@link #rowKeySet()} or {@link #columnKeySet()}]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #erase}">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Not supported. Use {@link #erase} instead.

 @throws UnsupportedOperationException always
 @deprecated Use {@link #erase}]]>
      </doc>
    </method>
    <method name="erase" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Associates the value {@code null} with the specified keys, assuming both
 keys are valid. If either key is null or isn't among the keys provided
 during construction, this method has no effect.

 <p>This method is equivalent to {@code put(rowKey, columnKey, null)} when
 both provided keys are valid.

 @param rowKey row key of mapping to be erased
 @param columnKey column key of mapping to be erased
 @return the value previously associated with the keys, or {@code null} if
     no mapping existed for the keys]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the string representation {@code rowMap().toString()}.]]>
      </doc>
    </method>
    <method name="cellSet" return="java.util.Set&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable set of all row key / column key / value
 triplets. Changes to the table will update the returned set.

 <p>The returned set's iterator traverses the mappings with the first row
 key, the mappings with the second row key, and so on.

 <p>The value in the returned cells may change if the table subsequently
 changes.

 @return set of table cells consisting of row key / column key / value
     triplets]]>
      </doc>
    </method>
    <method name="column" return="java.util.Map&lt;R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given column key. If the
 column key isn't in {@link #columnKeySet()}, an empty immutable map is
 returned.

 <p>Otherwise, for each row key in {@link #rowKeySet()}, the returned map
 associates the row key with the corresponding value in the table. Changes
 to the returned map will update the underlying table, and vice versa.

 @param columnKey key of column to search for in the table
 @return the corresponding map from row keys to values]]>
      </doc>
    </method>
    <method name="columnKeySet" return="com.google.common.collect.ImmutableSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the valid column keys, including those that
 are associated with null values only.

 @return immutable set of column keys]]>
      </doc>
    </method>
    <method name="columnMap" return="java.util.Map&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="row" return="java.util.Map&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given row key. If the
 row key isn't in {@link #rowKeySet()}, an empty immutable map is
 returned.

 <p>Otherwise, for each column key in {@link #columnKeySet()}, the returned
 map associates the column key with the corresponding value in the
 table. Changes to the returned map will update the underlying table, and
 vice versa.

 @param rowKey key of row to search for in the table
 @return the corresponding map from column keys to values]]>
      </doc>
    </method>
    <method name="rowKeySet" return="com.google.common.collect.ImmutableSet&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the valid row keys, including those that are
 associated with null values only.

 @return immutable set of row keys]]>
      </doc>
    </method>
    <method name="rowMap" return="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable collection of all values, which may contain
 duplicates. Changes to the table will update the returned collection.

 <p>The returned collection's iterator traverses the values of the first row
 key, the values of the second row key, and so on.

 @return collection of values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fixed-size {@link Table} implementation backed by a two-dimensional array.

 <p>The allowed row and column keys must be supplied when the table is
 created. The table always contains a mapping for every row key / column pair.
 The value corresponding to a given row and column is null unless another
 value is provided.

 <p>The table's size is constant: the product of the number of supplied row
 keys and the number of supplied column keys. The {@code remove} and {@code
 clear} methods are not supported by the table or its views. The {@link
 #erase} and {@link #eraseAll} methods may be used instead.

 <p>The ordering of the row and column keys provided when the table is
 constructed determines the iteration ordering across rows and columns in the
 table's views. None of the view iterators support {@link Iterator#remove}.
 If the table is modified after an iterator is created, the iterator remains
 valid.

 <p>This class requires less memory than the {@link HashBasedTable} and {@link
 TreeBasedTable} implementations, except when the table is sparse.

 <p>Null row keys or column keys are not permitted.

 <p>This class provides methods involving the underlying array structure,
 where the array indices correspond to the position of a row or column in the
 lists of allowed keys and values. See the {@link #at}, {@link #set}, {@link
 #toArray}, {@link #rowKeyList}, and {@link #columnKeyList} methods for more
 details.

 <p>Note that this implementation is not synchronized. If multiple threads
 access the same cell of an {@code ArrayTable} concurrently and one of the
 threads modifies its value, there is no guarantee that the new value will be
 fully visible to the other threads. To guarantee that modifications are
 visible, synchronize access to the table. Unlike other {@code Table}
 implementations, synchronization is unnecessary between a thread that writes
 to one cell and a thread that reads from another.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Table">
 {@code Table}</a>.

 @author Jared Levy
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ArrayTable -->
  <!-- start class com.google.common.collect.AsynchronousComputationException -->
  <class name="AsynchronousComputationException" extends="com.google.common.collect.ComputationException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="this class is unused by com.google.common.collect. lEsS_tHaNb>This class
     is scheduled for deletion in November 2012.lEsS_tHaN/b>">
    <constructor name="AsynchronousComputationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Wraps an exception that occurred during a computation in a different thread.

 @author Bob Lee
 @since 2.0 (imported from Google Collections Library)
 @deprecated this class is unused by com.google.common.collect. <b>This class
     is scheduled for deletion in November 2012.</b>]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AsynchronousComputationException -->
  <!-- start interface com.google.common.collect.BiMap -->
  <interface name="BiMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws IllegalArgumentException if the given value is already bound to a
     different key in this bimap. The bimap will remain unmodified in this
     event. To avoid this exception, call {@link #forcePut} instead.]]>
      </doc>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[An alternate form of {@code put} that silently removes any existing entry
 with the value {@code value} before proceeding with the {@link #put}
 operation. If the bimap previously contained the provided key-value
 mapping, this method has no effect.

 <p>Note that a successful call to this method could cause the size of the
 bimap to increase by one, stay the same, or even decrease by one.

 <p><b>Warning:</b> If an existing entry with this value is removed, the key
 for that entry is discarded and not returned.

 @param key the key with which the specified value is to be associated
 @param value the value to be associated with the specified key
 @return the value which was previously associated with the key, which may
     be {@code null}, or {@code null} if there was no previous entry]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Warning:</b> the results of calling this method may vary depending on
 the iteration order of {@code map}.

 @throws IllegalArgumentException if an attempt to {@code put} any
     entry fails. Note that some map entries may have been added to the
     bimap before the exception was thrown.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a bimap has unique values, this method returns a {@link Set},
 instead of the {@link java.util.Collection} specified in the {@link Map}
 interface.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.BiMap&lt;V, K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the inverse view of this bimap, which maps each of this bimap's
 values to its associated key. The two bimaps are backed by the same data;
 any changes to one will appear in the other.

 <p><b>Note:</b>There is no guaranteed correspondence between the iteration
 order of a bimap and that of its inverse.

 @return the inverse view of this bimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A bimap (or "bidirectional map") is a map that preserves the uniqueness of
 its values as well as that of its keys. This constraint enables bimaps to
 support an "inverse view", which is another bimap containing the same entries
 as this bimap but with reversed keys and values.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#BiMap">
 {@code BiMap}</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.BiMap -->
  <!-- start class com.google.common.collect.BoundType -->
  <class name="BoundType" extends="java.lang.Enum&lt;com.google.common.collect.BoundType&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.collect.BoundType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.collect.BoundType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Indicates whether an endpoint of some range is contained in the range itself ("closed") or not
 ("open"). If a range is unbounded on a side, it is neither open nor closed on that side; the
 bound simply does not exist.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.BoundType -->
  <!-- start interface com.google.common.collect.ClassToInstanceMap -->
  <interface name="ClassToInstanceMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"/>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value the specified class is mapped to, or {@code null} if no
 entry for this class is present. This will only return a value that was
 bound to this specific class, not a value that may have been bound to a
 subtype.]]>
      </doc>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Maps the specified class to the specified value. Does <i>not</i> associate
 this value with any of the class's supertypes.

 @return the value previously associated with this class (possibly {@code
     null}), or {@code null} if there was no previous entry.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map, each entry of which maps a Java
 <a href="http://tinyurl.com/2cmwkz">raw type</a> to an instance of that type.
 In addition to implementing {@code Map}, the additional type-safe operations
 {@link #putInstance} and {@link #getInstance} are available.

 <p>Like any other {@code Map<Class, Object>}, this map may contain entries
 for primitive types, and a primitive type and its corresponding wrapper type
 may map to different values.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#ClassToInstanceMap">
 {@code ClassToInstanceMap}</a>.

 <p>To map a generic type to an instance of that type, use {@link
 com.google.common.reflect.TypeToInstanceMap} instead.

 @param <B> the common supertype that all entries must share; often this is
     simply {@link Object}

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.ClassToInstanceMap -->
  <!-- start class com.google.common.collect.Collections2 -->
  <class name="Collections2" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="filter" return="java.util.Collection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Collection&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The
 returned collection is a live view of {@code unfiltered}; changes to one
 affect the other.

 <p>The resulting collection's iterator does not support {@code remove()},
 but all other collection methods are supported. When given an element that
 doesn't satisfy the predicate, the collection's {@code add()} and {@code
 addAll()} methods throw an {@link IllegalArgumentException}. When methods
 such as {@code removeAll()} and {@code clear()} are called on the filtered
 collection, only elements that satisfy the filter will be removed from the
 underlying collection.

 <p>The returned collection isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered collection's methods, such as {@code size()},
 iterate across every element in the underlying collection and determine
 which elements satisfy the filter. When a live view is <i>not</i> needed,
 it may be faster to copy {@code Iterables.filter(unfiltered, predicate)}
 and use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,
 as documented at {@link Predicate#apply}. Do not provide a predicate such
 as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent
 with equals. (See {@link Iterables#filter(Iterable, Class)} for related
 functionality.)]]>
      </doc>
    </method>
    <method name="transform" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromCollection" type="java.util.Collection&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, T&gt;"/>
      <doc>
      <![CDATA[Returns a collection that applies {@code function} to each element of
 {@code fromCollection}. The returned collection is a live view of {@code
 fromCollection}; changes to one affect the other.

 <p>The returned collection's {@code add()} and {@code addAll()} methods
 throw an {@link UnsupportedOperationException}. All other collection
 methods are supported, as long as {@code fromCollection} supports them.

 <p>The returned collection isn't threadsafe or serializable, even if
 {@code fromCollection} is.

 <p>When a live view is <i>not</i> needed, it may be faster to copy the
 transformed collection and use the copy.

 <p>If the input {@code Collection} is known to be a {@code List}, consider
 {@link Lists#transform}. If only an {@code Iterable} is available, use
 {@link Iterables#transform}.]]>
      </doc>
    </method>
    <method name="orderedPermutations" return="java.util.Collection&lt;java.util.List&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collection} of all the permutations of the specified
 {@link Iterable}.

 <p><i>Notes:</i> This is an implementation of the algorithm for
 Lexicographical Permutations Generation, described in Knuth's "The Art of
 Computer Programming", Volume 4, Chapter 7, Section 7.2.1.2. The
 iteration order follows the lexicographical order. This means that
 the first permutation will be in ascending order, and the last will be in
 descending order.

 <p>Duplicate elements are considered equal. For example, the list [1, 1]
 will have only one permutation, instead of two. This is why the elements
 have to implement {@link Comparable}.

 <p>An empty iterable has only one permutation, which is an empty list.

 <p>This method is equivalent to
 {@code Collections2.orderedPermutations(list, Ordering.natural())}.

 @param elements the original iterable whose elements have to be permuted.
 @return an immutable {@link Collection} containing all the different
     permutations of the original iterable.
 @throws NullPointerException if the specified iterable is null or has any
     null elements.
 @since 12.0]]>
      </doc>
    </method>
    <method name="orderedPermutations" return="java.util.Collection&lt;java.util.List&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collection} of all the permutations of the specified
 {@link Iterable} using the specified {@link Comparator} for establishing
 the lexicographical ordering.

 <p>Examples: <pre>   {@code

   for (List<String> perm : orderedPermutations(asList("b", "c", "a"))) {
     println(perm);
   }
   // -> ["a", "b", "c"]
   // -> ["a", "c", "b"]
   // -> ["b", "a", "c"]
   // -> ["b", "c", "a"]
   // -> ["c", "a", "b"]
   // -> ["c", "b", "a"]

   for (List<Integer> perm : orderedPermutations(asList(1, 2, 2, 1))) {
     println(perm);
   }
   // -> [1, 1, 2, 2]
   // -> [1, 2, 1, 2]
   // -> [1, 2, 2, 1]
   // -> [2, 1, 1, 2]
   // -> [2, 1, 2, 1]
   // -> [2, 2, 1, 1]}</pre>

 <p><i>Notes:</i> This is an implementation of the algorithm for
 Lexicographical Permutations Generation, described in Knuth's "The Art of
 Computer Programming", Volume 4, Chapter 7, Section 7.2.1.2. The
 iteration order follows the lexicographical order. This means that
 the first permutation will be in ascending order, and the last will be in
 descending order.

 <p>Elements that compare equal are considered equal and no new permutations
 are created by swapping them.

 <p>An empty iterable has only one permutation, which is an empty list.

 @param elements the original iterable whose elements have to be permuted.
 @param comparator a comparator for the iterable's elements.
 @return an immutable {@link Collection} containing all the different
     permutations of the original iterable.
 @throws NullPointerException If the specified iterable is null, has any
     null elements, or if the specified comparator is null.
 @since 12.0]]>
      </doc>
    </method>
    <method name="permutations" return="java.util.Collection&lt;java.util.List&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collection} of all the permutations of the specified
 {@link Collection}.

 <p><i>Notes:</i> This is an implementation of the Plain Changes algorithm
 for permutations generation, described in Knuth's "The Art of Computer
 Programming", Volume 4, Chapter 7, Section 7.2.1.2.

 <p>If the input list contains equal elements, some of the generated
 permutations will be equal.

 <p>An empty collection has only one permutation, which is an empty list.

 @param elements the original collection whose elements have to be permuted.
 @return an immutable {@link Collection} containing all the different
     permutations of the original collection.
 @throws NullPointerException if the specified collection is null or has any
     null elements.
 @since 12.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods for working with {@code Collection} instances.

 @author Chris Povirk
 @author Mike Bostock
 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Collections2 -->
  <!-- start class com.google.common.collect.ComparisonChain -->
  <class name="ComparisonChain" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start" return="com.google.common.collect.ComparisonChain"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Begins a new chained comparison statement. See example in the class
 documentation.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.lang.Comparable&lt;?&gt;"/>
      <param name="right" type="java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Compares two comparable objects as specified by {@link
 Comparable#compareTo}, <i>if</i> the result of this comparison chain
 has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="T"/>
      <param name="right" type="T"/>
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Compares two objects using a comparator, <i>if</i> the result of this
 comparison chain has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="int"/>
      <param name="right" type="int"/>
      <doc>
      <![CDATA[Compares two {@code int} values as specified by {@link Ints#compare},
 <i>if</i> the result of this comparison chain has not already been
 determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="long"/>
      <param name="right" type="long"/>
      <doc>
      <![CDATA[Compares two {@code long} values as specified by {@link Longs#compare},
 <i>if</i> the result of this comparison chain has not already been
 determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="float"/>
      <param name="right" type="float"/>
      <doc>
      <![CDATA[Compares two {@code float} values as specified by {@link
 Float#compare}, <i>if</i> the result of this comparison chain has not
 already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="double"/>
      <param name="right" type="double"/>
      <doc>
      <![CDATA[Compares two {@code double} values as specified by {@link
 Double#compare}, <i>if</i> the result of this comparison chain has not
 already been determined.]]>
      </doc>
    </method>
    <method name="compareTrueFirst" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="boolean"/>
      <param name="right" type="boolean"/>
      <doc>
      <![CDATA[Compares two {@code boolean} values, considering {@code true} to be less
 than {@code false}, <i>if</i> the result of this comparison chain has not
 already been determined.

 @since 12.0]]>
      </doc>
    </method>
    <method name="compareFalseFirst" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="boolean"/>
      <param name="right" type="boolean"/>
      <doc>
      <![CDATA[Compares two {@code boolean} values, considering {@code false} to be less
 than {@code true}, <i>if</i> the result of this comparison chain has not
 already been determined.

 @since 12.0 (present as {@code compare} since 2.0)]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Use {@link #compareFalseFirst}; or, if the parameters passed
     are being either negated or reversed, undo the negation or reversal and
     use {@link #compareTrueFirst}. lEsS_tHaNb>This method is scheduled for deletion
     in September 2013.lEsS_tHaN/b>">
      <param name="left" type="boolean"/>
      <param name="right" type="boolean"/>
      <doc>
      <![CDATA[Old name of {@link #compareFalseFirst}.

 @deprecated Use {@link #compareFalseFirst}; or, if the parameters passed
     are being either negated or reversed, undo the negation or reversal and
     use {@link #compareTrueFirst}. <b>This method is scheduled for deletion
     in September 2013.</b>]]>
      </doc>
    </method>
    <method name="result" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ends this comparison chain and returns its result: a value having the
 same sign as the first nonzero comparison result in the chain, or zero if
 every result was zero.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A utility for performing a "lazy" chained comparison statement, which 
 performs comparisons only until it finds a nonzero result. For example:
 <pre>   {@code

   public int compareTo(Foo that) {
     return ComparisonChain.start()
         .compare(this.aString, that.aString)
         .compare(this.anInt, that.anInt)
         .compare(this.anEnum, that.anEnum, Ordering.natural().nullsLast())
         .result();
   }}</pre>

 The value of this expression will have the same sign as the <i>first
 nonzero</i> comparison result in the chain, or will be zero if every
 comparison result was zero.

 <p>Once any comparison returns a nonzero value, remaining comparisons are
 "short-circuited".
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CommonObjectUtilitiesExplained#compare/compareTo">
 {@code ComparisonChain}</a>.

 @author Mark Davis
 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ComparisonChain -->
  <!-- start class com.google.common.collect.ComputationException -->
  <class name="ComputationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ComputationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Wraps an exception that occurred during a computation.

 @author Bob Lee
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ComputationException -->
  <!-- start class com.google.common.collect.ConcurrentHashMultiset -->
  <class name="ConcurrentHashMultiset" extends="com.google.common.collect.AbstractMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code ConcurrentHashMultiset} using the default
 initial capacity, load factor, and concurrency settings.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ConcurrentHashMultiset} containing the specified elements, using
 the default initial capacity, load factor, and concurrency settings.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapMaker" type="com.google.common.collect.GenericMapMaker&lt;? super E, ? super java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Creates a new, empty {@code ConcurrentHashMultiset} using {@code mapMaker}
 to construct the internal backing map.

 <p>If this {@link MapMaker} is configured to use entry eviction of any kind, this eviction
 applies to all occurrences of a given element as a single unit. However, most updates to the
 multiset do not count as map updates at all, since we're usually just mutating the value
 stored in the map, so {@link MapMaker#expireAfterAccess} makes sense (evict the entry that
 was queried or updated longest ago), but {@link MapMaker#expireAfterWrite} doesn't, because
 the eviction time is measured from when we saw the first occurrence of the object.

 <p>The returned multiset is serializable but any serialization caveats
 given in {@code MapMaker} apply.

 <p>Finally, soft/weak values can be used but are not very useful: the values are created
 internally and not exposed externally, so no one else will have a strong reference to the
 values. Weak keys on the other hand can be useful in some scenarios.

 @since 7.0]]>
      </doc>
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of occurrences of {@code element} in this multiset.

 @param element the element to look for
 @return the nonnegative number of occurrences of the element]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If the data in the multiset is modified by any other threads during this method,
 it is undefined which (if any) of these modifications will be reflected in the result.]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of the specified element to this multiset.

 @param element the element to add
 @param occurrences the number of occurrences to add
 @return the previous count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative, or if
     the resulting amount would exceed {@link Integer#MAX_VALUE}]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes a number of occurrences of the specified element from this multiset. If the multiset
 contains fewer than this number of occurrences to begin with, all occurrences will be removed.

 @param element the element whose occurrences should be removed
 @param occurrences the number of occurrences of the element to remove
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative]]>
      </doc>
    </method>
    <method name="removeExactly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes exactly the specified number of occurrences of {@code element}, or makes no
 change if this is not possible.

 <p>This method, in contrast to {@link #remove(Object, int)}, has no effect when the
 element count is smaller than {@code occurrences}.

 @param element the element to remove
 @param occurrences the number of occurrences of {@code element} to remove
 @return {@code true} if the removal was possible (including if {@code occurrences} is zero)]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes occurrences of {@code element} such that the {@link #count} of the
 element becomes {@code count}.

 @return the count of {@code element} in the multiset before this call
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="expectedOldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Sets the number of occurrences of {@code element} to {@code newCount}, but only if
 the count is currently {@code expectedOldCount}. If {@code element} does not appear
 in the multiset exactly {@code expectedOldCount} times, no changes will be made.

 @return {@code true} if the change was successful. This usually indicates
     that the multiset has been modified, but not always: in the case that
     {@code expectedOldCount == newCount}, the method will return {@code true} if
     the condition was met.
 @throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A multiset that supports concurrent modifications and that provides atomic versions of most
 {@code Multiset} operations (exceptions where noted). Null elements are not supported.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset">
 {@code Multiset}</a>.

 @author Cliff L. Biffle
 @author mike nonemacher
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ConcurrentHashMultiset -->
  <!-- start interface com.google.common.collect.Constraint -->
  <interface name="Constraint"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="checkElement" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Throws a suitable {@code RuntimeException} if the specified element is
 illegal. Typically this is either a {@link NullPointerException}, an
 {@link IllegalArgumentException}, or a {@link ClassCastException}, though
 an application-specific exception class may be used if appropriate.

 @param element the element to check
 @return the provided element]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a brief human readable description of this constraint, such as
 "Not null" or "Positive number".]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constraint that an element must satisfy in order to be added to a
 collection. For example, {@link Constraints#notNull()}, which prevents a
 collection from including any null elements, could be implemented like this:
 <pre>   {@code

   public Object checkElement(Object element) {
     if (element == null) {
       throw new NullPointerException();
     }
     return element;
   }}</pre>

 In order to be effective, constraints should be deterministic; that is,
 they should not depend on state that can change (such as external state,
 random variables, and time) and should only depend on the value of the
 passed-in element. A non-deterministic constraint cannot reliably enforce
 that all the collection's elements meet the constraint, since the constraint
 is only enforced when elements are added.

 @see Constraints
 @see MapConstraint
 @author Mike Bostock
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Constraint -->
  <!-- start class com.google.common.collect.Constraints -->
  <class name="Constraints" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="notNull" return="com.google.common.collect.Constraint&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a constraint that verifies that the element is not null. If the
 element is null, a {@link NullPointerException} is thrown.]]>
      </doc>
    </method>
    <method name="constrainedCollection" return="java.util.Collection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified collection, using the specified
 constraint. Any operations that add new elements to the collection will
 call the provided constraint. However, this method does not verify that
 existing elements satisfy the constraint.

 <p>The returned collection is not serializable.

 @param collection the collection to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the collection]]>
      </doc>
    </method>
    <method name="constrainedSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified set, using the specified
 constraint. Any operations that add new elements to the set will call the
 provided constraint. However, this method does not verify that existing
 elements satisfy the constraint.

 <p>The returned set is not serializable.

 @param set the set to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the set]]>
      </doc>
    </method>
    <method name="constrainedSortedSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedSet" type="java.util.SortedSet&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified sorted set, using the specified
 constraint. Any operations that add new elements to the sorted set will
 call the provided constraint. However, this method does not verify that
 existing elements satisfy the constraint.

 <p>The returned set is not serializable.

 @param sortedSet the sorted set to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the sorted set]]>
      </doc>
    </method>
    <method name="constrainedList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified list, using the specified
 constraint. Any operations that add new elements to the list will call the
 provided constraint. However, this method does not verify that existing
 elements satisfy the constraint.

 <p>If {@code list} implements {@link RandomAccess}, so will the returned
 list. The returned list is not serializable.

 @param list the list to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the list]]>
      </doc>
    </method>
    <method name="constrainedMultiset" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <param name="constraint" type="com.google.common.collect.Constraint&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified multiset, using the specified
 constraint. Any operations that add new elements to the multiset will call
 the provided constraint. However, this method does not verify that
 existing elements satisfy the constraint.

 <p>The returned multiset is not serializable.

 @param multiset the multiset to constrain
 @param constraint the constraint that validates added elements
 @return a constrained view of the multiset]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories and utilities pertaining to the {@link Constraint} interface.

 @see MapConstraints
 @author Mike Bostock
 @author Jared Levy
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Constraints -->
  <!-- start class com.google.common.collect.ContiguousSet -->
  <class name="ContiguousSet" extends="com.google.common.collect.ImmutableSortedSet&lt;C&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <param name="domain" type="com.google.common.collect.DiscreteDomain&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a {@code ContiguousSet} containing the same values in the given domain
 {@linkplain Range#contains contained} by the range.

 @throws IllegalArgumentException if neither range nor the domain has a lower bound, or if
     neither has an upper bound

 @since 13.0]]>
      </doc>
    </method>
    <method name="headSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="C extends java.lang.Comparable"/>
    </method>
    <method name="headSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="C extends java.lang.Comparable"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="subSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
      <param name="toElement" type="C extends java.lang.Comparable"/>
    </method>
    <method name="subSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="C extends java.lang.Comparable"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="tailSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
    </method>
    <method name="tailSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.ContiguousSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the set of values that are contained in both this set and the other.

 <p>This method should always be used instead of
 {@link Sets#intersection} for {@link ContiguousSet} instances.]]>
      </doc>
    </method>
    <method name="range" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a range, closed on both ends, whose endpoints are the minimum and maximum values
 contained in this set.  This is equivalent to {@code range(CLOSED, CLOSED)}.

 @throws NoSuchElementException if this set is empty]]>
      </doc>
    </method>
    <method name="range" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns the minimal range with the given boundary types for which all values in this set are
 {@linkplain Range#contains(Comparable) contained} within the range.

 <p>Note that this method will return ranges with unbounded endpoints if {@link BoundType#OPEN}
 is requested for a domain minimum or maximum.  For example, if {@code set} was created from the
 range {@code [1..Integer.MAX_VALUE]} then {@code set.range(CLOSED, OPEN)} must return
 {@code [1..#)}.

 @throws NoSuchElementException if this set is empty]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a short-hand representation of the contents such as {@code "[1..100]"}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A sorted set of contiguous values in a given {@link DiscreteDomain}.

 <p><b>Warning:</b> Be extremely careful what you do with conceptually large instances (such as
 {@code ContiguousSet.create(Ranges.greaterThan(0), DiscreteDomains.integers()}). Certain
 operations on such a set can be performed efficiently, but others (such as {@link Set#hashCode}
 or {@link Collections#frequency}) can cause major performance problems.

 @author Gregory Kick
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ContiguousSet -->
  <!-- start class com.google.common.collect.DiscreteDomain -->
  <class name="DiscreteDomain" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiscreteDomain"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="next" return="C extends java.lang.Comparable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns the unique least value of type {@code C} that is greater than
 {@code value}, or {@code null} if none exists. Inverse operation to {@link
 #previous}.

 @param value any value of type {@code C}
 @return the least value greater than {@code value}, or {@code null} if
     {@code value} is {@code maxValue()}]]>
      </doc>
    </method>
    <method name="previous" return="C extends java.lang.Comparable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns the unique greatest value of type {@code C} that is less than
 {@code value}, or {@code null} if none exists. Inverse operation to {@link
 #next}.

 @param value any value of type {@code C}
 @return the greatest value less than {@code value}, or {@code null} if
     {@code value} is {@code minValue()}]]>
      </doc>
    </method>
    <method name="distance" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="C extends java.lang.Comparable"/>
      <param name="end" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns a signed value indicating how many nested invocations of {@link
 #next} (if positive) or {@link #previous} (if negative) are needed to reach
 {@code end} starting from {@code start}. For example, if {@code end =
 next(next(next(start)))}, then {@code distance(start, end) == 3} and {@code
 distance(end, start) == -3}. As well, {@code distance(a, a)} is always
 zero.

 <p>Note that this function is necessarily well-defined for any discrete
 type.

 @return the distance as described above, or {@link Long#MIN_VALUE} or
     {@link Long#MAX_VALUE} if the distance is too small or too large,
     respectively.]]>
      </doc>
    </method>
    <method name="minValue" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the minimum value of type {@code C}, if it has one. The minimum
 value is the unique value for which {@link Comparable#compareTo(Object)}
 never returns a positive value for any input of type {@code C}.

 <p>The default implementation throws {@code NoSuchElementException}.

 @return the minimum value of type {@code C}; never null
 @throws NoSuchElementException if the type has no (practical) minimum
     value; for example, {@link java.math.BigInteger}]]>
      </doc>
    </method>
    <method name="maxValue" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the maximum value of type {@code C}, if it has one. The maximum
 value is the unique value for which {@link Comparable#compareTo(Object)}
 never returns a negative value for any input of type {@code C}.

 <p>The default implementation throws {@code NoSuchElementException}.

 @return the maximum value of type {@code C}; never null
 @throws NoSuchElementException if the type has no (practical) maximum
     value; for example, {@link java.math.BigInteger}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A descriptor for a <i>discrete</i> {@code Comparable} domain such as all
 {@link Integer}s. A discrete domain is one that supports the three basic
 operations: {@link #next}, {@link #previous} and {@link #distance}, according
 to their specifications. The methods {@link #minValue} and {@link #maxValue}
 should also be overridden for bounded types.

 <p>A discrete domain always represents the <i>entire</i> set of values of its
 type; it cannot represent partial domains such as "prime integers" or
 "strings of length 5."

 <p>See the Guava User Guide section on <a href=
 "http://code.google.com/p/guava-libraries/wiki/RangesExplained#Discrete_Domains">
 {@code DiscreteDomain}</a>.

 @author Kevin Bourrillion
 @since 10.0
 @see DiscreteDomains]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.DiscreteDomain -->
  <!-- start class com.google.common.collect.DiscreteDomains -->
  <class name="DiscreteDomains" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="integers" return="com.google.common.collect.DiscreteDomain&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the discrete domain for values of type {@code Integer}.]]>
      </doc>
    </method>
    <method name="longs" return="com.google.common.collect.DiscreteDomain&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the discrete domain for values of type {@code Long}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories for common {@link DiscreteDomain} instances.
 
 <p>See the Guava User Guide section on <a href=
 "http://code.google.com/p/guava-libraries/wiki/RangesExplained#Discrete_Domains">
 {@code DiscreteDomain}</a>.

 @author Gregory Kick
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.DiscreteDomains -->
  <!-- start class com.google.common.collect.EnumBiMap -->
  <class name="EnumBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new, empty {@code EnumBiMap} using the specified key and value
 types.

 @param keyType the key type
 @param valueType the value type]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a new bimap with the same mappings as the specified map. If the
 specified map is an {@code EnumBiMap}, the new bimap has the same types as
 the provided map. Otherwise, the specified map must contain at least one
 mapping, in order to determine the key and value types.

 @param map the map whose mappings are to be placed in this map
 @throws IllegalArgumentException if map is not an {@code EnumBiMap}
     instance and contains no mappings]]>
      </doc>
    </method>
    <method name="keyType" return="java.lang.Class&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated key type.]]>
      </doc>
    </method>
    <method name="valueType" return="java.lang.Class&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated value type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code BiMap} backed by two {@code EnumMap} instances. Null keys and values
 are not permitted. An {@code EnumBiMap} and its inverse are both
 serializable.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#BiMap">
 {@code BiMap}</a>.

 @author Mike Bostock
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumBiMap -->
  <!-- start class com.google.common.collect.EnumHashBiMap -->
  <class name="EnumHashBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumHashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a new, empty {@code EnumHashBiMap} using the specified key type.

 @param keyType the key type]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumHashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a new bimap with the same mappings as the specified map. If the
 specified map is an {@code EnumHashBiMap} or an {@link EnumBiMap}, the new
 bimap has the same key type as the input bimap. Otherwise, the specified
 map must contain at least one mapping, in order to determine the key type.

 @param map the map whose mappings are to be placed in this map
 @throws IllegalArgumentException if map is not an {@code EnumBiMap} or an
     {@code EnumHashBiMap} instance and contains no mappings]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Enum&lt;K&gt;"/>
      <param name="value" type="V"/>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Enum&lt;K&gt;"/>
      <param name="value" type="V"/>
    </method>
    <method name="keyType" return="java.lang.Class&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated key type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code BiMap} backed by an {@code EnumMap} instance for keys-to-values, and
 a {@code HashMap} instance for values-to-keys. Null keys are not permitted,
 but null values are. An {@code EnumHashBiMap} and its inverse are both
 serializable.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#BiMap">
 {@code BiMap}</a>.

 @author Mike Bostock
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumHashBiMap -->
  <!-- start class com.google.common.collect.EnumMultiset -->
  <class name="EnumMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code EnumMultiset}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code EnumMultiset} containing the specified elements.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link
 Multiset}.

 @param elements the elements that the multiset should contain
 @throws IllegalArgumentException if {@code elements} is empty]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Multiset implementation backed by an {@link EnumMap}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset">
 {@code Multiset}</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumMultiset -->
  <!-- start class com.google.common.collect.FluentIterable -->
  <class name="FluentIterable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;E&gt;"/>
    <constructor name="FluentIterable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="from" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that wraps {@code iterable}, or {@code iterable} itself if it
 is already a {@code FluentIterable}.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="instances of {@code FluentIterable} don't need to be converted to
     {@code FluentIterable}">
      <param name="iterable" type="com.google.common.collect.FluentIterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Construct a fluent iterable from another fluent iterable. This is obviously never necessary,
 but is intended to help call out cases where one migration from {@code Iterable} to
 {@code FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.

 @deprecated instances of {@code FluentIterable} don't need to be converted to
     {@code FluentIterable}]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this fluent iterable, with the format
 {@code [e1, e2, ..., en]}.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of elements in this fluent iterable.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if this fluent iterable contains any object for which
 {@code equals(element)} is true.]]>
      </doc>
    </method>
    <method name="cycle" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a fluent iterable whose {@code Iterator} cycles indefinitely over the elements of
 this fluent iterable.

 <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After
 {@code remove()} is called, subsequent cycles omit the removed element, which is no longer in
 this fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until
 this fluent iterable is empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You
 should use an explicit {@code break} or be certain that you will eventually remove all the
 elements.]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements from this fluent iterable that satisfy a predicate. The
 resulting fluent iterable's iterator does not support {@code remove()}.]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the elements from this fluent iterable that are instances of class {@code type}.

 @param type the type of elements desired]]>
      </doc>
    </method>
    <method name="anyMatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if any element in this fluent iterable satisfies the predicate.]]>
      </doc>
    </method>
    <method name="allMatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element in this fluent iterable satisfies the predicate.
 If this fluent iterable is empty, {@code true} is returned.]]>
      </doc>
    </method>
    <method name="firstMatch" return="com.google.common.base.Optional&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in this fluent iterable that
 satisfies the given predicate, if such an element exists.

 <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}
 is matched in this fluent iterable, a {@link NullPointerException} will be thrown.]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super E, T&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that applies {@code function} to each element of this
 fluent iterable.

 <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's
 iterator does. After a successful {@code remove()} call, this fluent iterable no longer
 contains the corresponding element.]]>
      </doc>
    </method>
    <method name="transformAndConcat" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super E, ? extends java.lang.Iterable&lt;T&gt;&gt;"/>
      <doc>
      <![CDATA[Applies {@code function} to each element of this fluent iterable and returns
 a fluent iterable with the concatenated combination of results.  {@code function}
 returns an Iterable of results.

 <p>The returned fluent iterable's iterator supports {@code remove()} if this
 function-returned iterables' iterator does. After a successful {@code remove()} call,
 the returned fluent iterable no longer contains the corresponding element.

 @since 13.0]]>
      </doc>
    </method>
    <method name="first" return="com.google.common.base.Optional&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in this fluent iterable.
 If the iterable is empty, {@code Optional.absent()} is returned.

 @throws NullPointerException if the first element is null; if this is a possibility, use
     {@code iterator().next()} or {@link Iterables#getFirst} instead.]]>
      </doc>
    </method>
    <method name="last" return="com.google.common.base.Optional&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Optional} containing the last element in this fluent iterable.
 If the iterable is empty, {@code Optional.absent()} is returned.

 @throws NullPointerException if the last element is null; if this is a possibility, use
     {@link Iterables#getLast} instead.]]>
      </doc>
    </method>
    <method name="skip" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="numberToSkip" type="int"/>
      <doc>
      <![CDATA[Returns a view of this fluent iterable that skips its first {@code numberToSkip}
 elements. If this fluent iterable contains fewer than {@code numberToSkip} elements,
 the returned fluent iterable skips all of its elements.

 <p>Modifications to this fluent iterable before a call to {@code iterator()} are
 reflected in the returned fluent iterable. That is, the its iterator skips the first
 {@code numberToSkip} elements that exist when the iterator is created, not when {@code skip()}
 is called.

 <p>The returned fluent iterable's iterator supports {@code remove()} if the
 {@code Iterator} of this fluent iterable supports it. Note that it is <i>not</i>
 possible to delete the last skipped element by immediately calling {@code remove()} on the
 returned fluent iterable's iterator, as the {@code Iterator} contract states that a call
 to {@code * remove()} before a call to {@code next()} will throw an
 {@link IllegalStateException}.]]>
      </doc>
    </method>
    <method name="limit" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Creates a fluent iterable with the first {@code size} elements of this
 fluent iterable. If this fluent iterable does not contain that many elements,
 the returned fluent iterable will have the same behavior as this fluent iterable.
 The returned fluent iterable's iterator supports {@code remove()} if this
 fluent iterable's iterator does.

 @param size the maximum number of elements in the returned fluent iterable
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether this fluent iterable is empty.]]>
      </doc>
    </method>
    <method name="toImmutableList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableList} containing all of the elements from this
 fluent iterable in proper sequence.]]>
      </doc>
    </method>
    <method name="toSortedImmutableList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an {@code ImmutableList} containing all of the elements from this
 {@code FluentIterable} in the order specified by {@code comparator}.  To produce an
 {@code ImmutableList} sorted by its natural ordering, use
 {@code toSortedImmutableList(Ordering.natural())}.

 @param comparator the function by which to sort list elements
 @throws NullPointerException if any element is null
 @since 13.0]]>
      </doc>
    </method>
    <method name="toImmutableSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableSet} containing all of the elements from this
 fluent iterable with duplicates removed.]]>
      </doc>
    </method>
    <method name="toImmutableSortedSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an {@code ImmutableSortedSet} containing all of the elements from this
 {@code FluentIterable} in the order specified by {@code comparator}, with duplicates
 (determined by {@code comaprator.compare(x, y) == 0}) removed. To produce an
 {@code ImmutableSortedSet} sorted by its natural ordering, use
 {@code toImmutableSortedSet(Ordering.natural())}.

 @param comparator the function by which to sort set elements
 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="toArray" return="E[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an array containing all of the elements from this fluent iterable in iteration order.

 @param type the type of the elements
 @return a newly-allocated array into which all the elements of this fluent iterable have
     been copied]]>
      </doc>
    </method>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the element at the specified position in this fluent iterable.

 @param position position of the element to return
 @return the element at the specified position in this fluent iterable
 @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to
     the size of this fluent iterable]]>
      </doc>
    </method>
    <doc>
    <![CDATA[{@code FluentIterable} provides a rich interface for manipulating {@code Iterable}s in a chained
 fashion. A {@code FluentIterable} can be created from an {@code Iterable}, or from a set of
 elements. The following types of methods are provided on {@code FluentIterable}:
 <ul>
 <li>chained methods which return a new {@code FluentIterable} based in some way on the contents
 of the current one (for example {@link #transform})
 <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection or
 array (for example {@link #toImmutableList})
 <li>element extraction methods which facilitate the retrieval of certain elements (for example
 {@link #last})
 <li>query methods which answer questions about the {@code FluentIterable}'s contents (for example
 {@link #anyMatch})
 </ul>

 <p>Here is an example that merges the lists returned by two separate database calls, transforms
 it by invoking {@code toString()} on each element, and returns the first 10 elements as an
 {@code ImmutableList}: <pre>   {@code

   FluentIterable
       .from(database.getClientList())
       .filter(activeInLastMonth())
       .transform(Functions.toStringFunction())
       .limit(10)
       .toImmutableList();}</pre>

 Anything which can be done using {@code FluentIterable} could be done in a different fashion
 (often with {@link Iterables}), however the use of {@code FluentIterable} makes many sets of
 operations significantly more concise.

 @author Marcin Mikosik
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.FluentIterable -->
  <!-- start class com.google.common.collect.ForwardingCollection -->
  <class name="ForwardingCollection" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <constructor name="ForwardingCollection"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Collection&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
    </method>
    <method name="standardContains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #contains} in terms of {@link #iterator}.
 If you override {@link #iterator}, you may wish to override {@link
 #contains} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardContainsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #containsAll} in terms of {@link #contains}
 . If you override {@link #contains}, you may wish to override {@link
 #containsAll} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAddAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #addAll} in terms of {@link #add}. If you
 override {@link #add}, you may wish to override {@link #addAll} to forward
 to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #remove} in terms of {@link #iterator},
 using the iterator's {@code remove} method. If you override {@link
 #iterator}, you may wish to override {@link #remove} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemoveAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #removeAll} in terms of {@link #iterator},
 using the iterator's {@code remove} method. If you override {@link
 #iterator}, you may wish to override {@link #removeAll} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRetainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #retainAll} in terms of {@link #iterator},
 using the iterator's {@code remove} method. If you override {@link
 #iterator}, you may wish to override {@link #retainAll} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #clear} in terms of {@link #iterator},
 using the iterator's {@code remove} method. If you override {@link
 #iterator}, you may wish to override {@link #clear} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIsEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #isEmpty} as {@code !iterator().hasNext}.
 If you override {@link #isEmpty}, you may wish to override {@link #isEmpty}
 to forward to this implementation. Alternately, it may be more efficient to
 implement {@code isEmpty} as {@code size() == 0}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} in terms of {@link #iterator}.
 If you override {@link #iterator}, you may wish to override {@link
 #toString} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toArray()} in terms of {@link
 #toArray(Object[])}. If you override {@link #toArray(Object[])}, you may
 wish to override {@link #toArray} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[A sensible definition of {@link #toArray(Object[])} in terms of {@link
 #size} and {@link #iterator}. If you override either of these methods, you
 may wish to override {@link #toArray} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection which forwards all its method calls to another collection.
 Subclasses should override one or more methods to modify the behavior of the
 backing collection as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingCollection} forward
 <b>indiscriminately</b> to the methods of the delegate. For example,
 overriding {@link #add} alone <b>will not</b> change the behavior of {@link
 #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or
 delegating to the provided {@code standardAddAll} method.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even
 when all of the methods that they depend on are thread-safe.

 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingCollection -->
  <!-- start class com.google.common.collect.ForwardingConcurrentMap -->
  <class name="ForwardingConcurrentMap" extends="com.google.common.collect.ForwardingMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"/>
    <constructor name="ForwardingConcurrentMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="putIfAbsent" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="replace" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="replace" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="oldValue" type="V"/>
      <param name="newValue" type="V"/>
    </method>
    <doc>
    <![CDATA[A concurrent map which forwards all its method calls to another concurrent
 map. Subclasses should override one or more methods to modify the behavior of
 the backing map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Charles Fry
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingConcurrentMap -->
  <!-- start class com.google.common.collect.ForwardingDeque -->
  <class name="ForwardingDeque" extends="com.google.common.collect.ForwardingQueue&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Deque&lt;E&gt;"/>
    <constructor name="ForwardingDeque"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Deque&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="addFirst"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="addLast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="descendingIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="offerFirst" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="offerLast" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="peekFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peekLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pop" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="push"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="removeFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeFirstOccurrence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="removeLastOccurrence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A deque which forwards all its method calls to another deque. Subclasses
 should override one or more methods to modify the behavior of the backing
 deque as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingDeque} forward
 <b>indiscriminately</b> to the methods of the delegate. For example,
 overriding {@link #add} alone <b>will not</b> change the behavior of {@link
 #offer} which can lead to unexpected behavior. In this case, you should
 override {@code offer} as well, either providing your own implementation, or
 delegating to the provided {@code standardOffer} method.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even
 when all of the methods that they depend on are thread-safe.

 @author Kurt Alfred Kluever
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingDeque -->
  <!-- start class com.google.common.collect.ForwardingIterator -->
  <class name="ForwardingIterator" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;T&gt;"/>
    <constructor name="ForwardingIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Iterator&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An iterator which forwards all its method calls to another iterator.
 Subclasses should override one or more methods to modify the behavior of the
 backing iterator as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingIterator -->
  <!-- start class com.google.common.collect.ForwardingList -->
  <class name="ForwardingList" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.List&lt;E&gt;"/>
    <constructor name="ForwardingList"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.List&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="listIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="remove" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="set" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
    </method>
    <method name="subList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardAdd" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #add(Object)}, in terms of
 {@link #add(int, Object)}. If you override {@link #add(int, Object)}, you
 may wish to override {@link #add(Object)} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAddAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #addAll(int, Collection)}, in
 terms of the {@code add} method of {@link #listIterator(int)}. If you
 override {@link #listIterator(int)}, you may wish to override {@link
 #addAll(int, Collection)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #indexOf}, in terms of {@link
 #listIterator()}. If you override {@link #listIterator()}, you may wish to
 override {@link #indexOf} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardLastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #lastIndexOf}, in terms of
 {@link #listIterator(int)}. If you override {@link #listIterator(int)}, you
 may wish to override {@link #lastIndexOf} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible default implementation of {@link #iterator}, in terms of
 {@link #listIterator()}. If you override {@link #listIterator()}, you may
 wish to override {@link #iterator} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardListIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible default implementation of {@link #listIterator()}, in terms of
 {@link #listIterator(int)}. If you override {@link #listIterator(int)}, you
 may wish to override {@link #listIterator()} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardListIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="start" type="int"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #listIterator(int)}, in terms
 of {@link #size}, {@link #get(int)}, {@link #set(int, Object)}, {@link
 #add(int, Object)}, and {@link #remove(int)}. If you override any of these
 methods, you may wish to override {@link #listIterator(int)} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSubList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #subList(int, int)}. If you
 override any other methods, you may wish to override {@link #subList(int,
 int)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals(Object)} in terms of {@link #size}
 and {@link #iterator}. If you override either of those methods, you may
 wish to override {@link #equals(Object)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} in terms of {@link #iterator}.
 If you override {@link #iterator}, you may wish to override {@link
 #hashCode} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A list which forwards all its method calls to another list. Subclasses should
 override one or more methods to modify the behavior of the backing list as
 desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>This class does not implement {@link java.util.RandomAccess}. If the
 delegate supports random access, the {@code ForwardingList} subclass should
 implement the {@code RandomAccess} interface.

 <p><b>Warning:</b> The methods of {@code ForwardingList} forward
 <b>indiscriminately</b> to the methods of the delegate. For example,
 overriding {@link #add} alone <b>will not</b> change the behavior of {@link
 #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or
 delegating to the provided {@code standardAddAll} method.

 <p>The {@code standard} methods and any collection views they return are not
 guaranteed to be thread-safe, even when all of the methods that they depend
 on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingList -->
  <!-- start class com.google.common.collect.ForwardingListIterator -->
  <class name="ForwardingListIterator" extends="com.google.common.collect.ForwardingIterator&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.ListIterator&lt;E&gt;"/>
    <constructor name="ForwardingListIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.ListIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
    </method>
    <method name="hasPrevious" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="previous" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="previousIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
    </method>
    <doc>
    <![CDATA[A list iterator which forwards all its method calls to another list
 iterator. Subclasses should override one or more methods to modify the
 behavior of the backing iterator as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Mike Bostock
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingListIterator -->
  <!-- start class com.google.common.collect.ForwardingListMultimap -->
  <class name="ForwardingListMultimap" extends="com.google.common.collect.ForwardingMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingListMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A list multimap which forwards all its method calls to another list multimap.
 Subclasses should override one or more methods to modify the behavior of
 the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kurt Alfred Kluever
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingListMultimap -->
  <!-- start class com.google.common.collect.ForwardingMap -->
  <class name="ForwardingMap" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <constructor name="ForwardingMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Map&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPutAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #putAll(Map)} in terms of {@link
 #put(Object, Object)}. If you override {@link #put(Object, Object)}, you
 may wish to override {@link #putAll(Map)} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #remove} in terms of
 the {@code iterator} method of {@link #entrySet}. If you override {@link
 #entrySet}, you may wish to override {@link #remove} to forward to this
 implementation.

 <p>Alternately, you may wish to override {@link #remove} with {@code
 keySet().remove}, assuming that approach would not lead to an infinite
 loop.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #clear} in terms of the {@code iterator}
 method of {@link #entrySet}. In many cases, you may wish to override
 {@link #clear} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardContainsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #containsKey} in terms
 of the {@code iterator} method of {@link #entrySet}. If you override {@link
 #entrySet}, you may wish to override {@link #containsKey} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardContainsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #containsValue} in terms of the {@code
 iterator} method of {@link #entrySet}. If you override {@link #entrySet},
 you may wish to override {@link #containsValue} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIsEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #isEmpty} in terms of the {@code iterator}
 method of {@link #entrySet}. If you override {@link #entrySet}, you may
 wish to override {@link #isEmpty} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals} in terms of the {@code equals}
 method of {@link #entrySet}. If you override {@link #entrySet}, you may
 wish to override {@link #equals} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} in terms of the {@code iterator}
 method of {@link #entrySet}. If you override {@link #entrySet}, you may
 wish to override {@link #hashCode} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} in terms of the {@code iterator}
 method of {@link #entrySet}. If you override {@link #entrySet}, you may
 wish to override {@link #toString} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map which forwards all its method calls to another map. Subclasses should
 override one or more methods to modify the behavior of the backing map as
 desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><i>Warning:</i> The methods of {@code ForwardingMap} forward
 <i>indiscriminately</i> to the methods of the delegate. For example,
 overriding {@link #put} alone <i>will not</i> change the behavior of {@link
 #putAll}, which can lead to unexpected behavior. In this case, you should
 override {@code putAll} as well, either providing your own implementation, or
 delegating to the provided {@code standardPutAll} method.

 <p>Each of the {@code standard} methods, where appropriate, use {@link
 Objects#equal} to test equality for both keys and values. This may not be
 the desired behavior for map implementations that use non-standard notions of
 key equality, such as a {@code SortedMap} whose comparator is not consistent
 with {@code equals}.

 <p>The {@code standard} methods and the collection views they return are not
 guaranteed to be thread-safe, even when all of the methods that they depend
 on are thread-safe.

 @author Kevin Bourrillion
 @author Jared Levy
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap -->
  <!-- start class com.google.common.collect.ForwardingMap.StandardEntrySet -->
  <class name="ForwardingMap.StandardEntrySet" extends="com.google.common.collect.Maps.EntrySet&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ForwardingMap.StandardEntrySet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link Map#entrySet} in terms of the following
 methods: {@link ForwardingMap#clear}, {@link ForwardingMap#containsKey},
 {@link ForwardingMap#get}, {@link ForwardingMap#isEmpty}, {@link
 ForwardingMap#remove}, and {@link ForwardingMap#size}. In many cases, you
 may wish to override {@link #entrySet} to forward to this implementation
 or a subclass thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap.StandardEntrySet -->
  <!-- start class com.google.common.collect.ForwardingMap.StandardKeySet -->
  <class name="ForwardingMap.StandardKeySet" extends="com.google.common.collect.Maps.KeySet&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ForwardingMap.StandardKeySet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link Map#keySet} in terms of the following
 methods: {@link ForwardingMap#clear}, {@link ForwardingMap#containsKey},
 {@link ForwardingMap#isEmpty}, {@link ForwardingMap#remove}, {@link
 ForwardingMap#size}, and the {@link Set#iterator} method of {@link
 ForwardingMap#entrySet}. In many cases, you may wish to override {@link
 ForwardingMap#keySet} to forward to this implementation or a subclass
 thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap.StandardKeySet -->
  <!-- start class com.google.common.collect.ForwardingMap.StandardValues -->
  <class name="ForwardingMap.StandardValues" extends="com.google.common.collect.Maps.Values&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ForwardingMap.StandardValues"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link Map#values} in terms of the following
 methods: {@link ForwardingMap#clear}, {@link ForwardingMap#containsValue},
 {@link ForwardingMap#isEmpty}, {@link ForwardingMap#size}, and the {@link
 Set#iterator} method of {@link ForwardingMap#entrySet}. In many cases, you
 may wish to override {@link ForwardingMap#values} to forward to this
 implementation or a subclass thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap.StandardValues -->
  <!-- start class com.google.common.collect.ForwardingMapEntry -->
  <class name="ForwardingMapEntry" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map.Entry&lt;K, V&gt;"/>
    <constructor name="ForwardingMapEntry"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals(Object)} in terms of {@link
 #getKey()} and {@link #getValue()}. If you override either of these
 methods, you may wish to override {@link #equals(Object)} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode()} in terms of {@link #getKey()}
 and {@link #getValue()}. If you override either of these methods, you may
 wish to override {@link #hashCode()} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} in terms of {@link
 #getKey} and {@link #getValue}. If you override either of these
 methods, you may wish to override {@link #equals} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map entry which forwards all its method calls to another map entry.
 Subclasses should override one or more methods to modify the behavior of the
 backing map entry as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><i>Warning:</i> The methods of {@code ForwardingMapEntry} forward
 <i>indiscriminately</i> to the methods of the delegate. For example,
 overriding {@link #getValue} alone <i>will not</i> change the behavior of
 {@link #equals}, which can lead to unexpected behavior. In this case, you
 should override {@code equals} as well, either providing your own
 implementation, or delegating to the provided {@code standardEquals} method.

 <p>Each of the {@code standard} methods, where appropriate, use {@link
 Objects#equal} to test equality for both keys and values. This may not be
 the desired behavior for map implementations that use non-standard notions of
 key equality, such as the entry of a {@code SortedMap} whose comparator is
 not consistent with {@code equals}.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even
 when all of the methods that they depend on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMapEntry -->
  <!-- start class com.google.common.collect.ForwardingMultimap -->
  <class name="ForwardingMultimap" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <constructor name="ForwardingMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entries" return="java.util.Collection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="removeAll" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A multimap which forwards all its method calls to another multimap.
 Subclasses should override one or more methods to modify the behavior of
 the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Robert Konigsberg
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultimap -->
  <!-- start class com.google.common.collect.ForwardingMultiset -->
  <class name="ForwardingMultiset" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multiset&lt;E&gt;"/>
    <constructor name="ForwardingMultiset"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="elementSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
    </method>
    <method name="standardContains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #contains} in terms of {@link #count}. If
 you override {@link #count}, you may wish to override {@link #contains} to
 forward to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #clear} in terms of the {@code iterator}
 method of {@link #entrySet}. If you override {@link #entrySet}, you may
 wish to override {@link #clear} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #count} in terms of
 {@link #entrySet}. If you override {@link #entrySet}, you may wish to
 override {@link #count} to forward to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAdd" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #add(Object)} in terms of {@link
 #add(Object, int)}. If you override {@link #add(Object, int)}, you may
 wish to override {@link #add(Object)} to forward to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAddAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="elementsToAdd" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #addAll(Collection)} in terms of {@link
 #add(Object)} and {@link #add(Object, int)}. If you override either of
 these methods, you may wish to override {@link #addAll(Collection)} to
 forward to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #remove(Object)} in terms of {@link
 #remove(Object, int)}. If you override {@link #remove(Object, int)}, you
 may wish to override {@link #remove(Object)} to forward to this
 implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemoveAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #removeAll} in terms of the {@code
 removeAll} method of {@link #elementSet}. If you override {@link
 #elementSet}, you may wish to override {@link #removeAll} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRetainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #retainAll} in terms of the {@code
 retainAll} method of {@link #elementSet}. If you override {@link
 #elementSet}, you may wish to override {@link #retainAll} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSetCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[A sensible definition of {@link #setCount(Object, int)} in terms of {@link
 #count(Object)}, {@link #add(Object, int)}, and {@link #remove(Object,
 int)}. {@link #entrySet()}. If you override any of these methods, you may
 wish to override {@link #setCount(Object, int)} to forward to this
 implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSetCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[A sensible definition of {@link #setCount(Object, int, int)} in terms of
 {@link #count(Object)} and {@link #setCount(Object, int)}. If you override
 either of these methods, you may wish to override {@link #setCount(Object,
 int, int)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #iterator} in terms of {@link #entrySet}
 and {@link #remove(Object)}. If you override either of these methods, you
 may wish to override {@link #iterator} to forward to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #size} in terms of
 {@link #entrySet}. If you override {@link #entrySet}, you may wish to
 override {@link #size} to forward to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #size} in terms of
 {@code entrySet().size()} and {@link #count}. If you override either of
 these methods, you may wish to override {@link #size} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} as {@code entrySet().hashCode()}
 . If you override {@link #entrySet}, you may wish to override {@link
 #hashCode} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} as {@code entrySet().toString()}
 . If you override {@link #entrySet}, you may wish to override {@link
 #toString} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A multiset which forwards all its method calls to another multiset.
 Subclasses should override one or more methods to modify the behavior of the
 backing multiset as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingMultiset} forward
 <b>indiscriminately</b> to the methods of the delegate. For example,
 overriding {@link #add(Object, int)} alone <b>will not</b> change the
 behavior of {@link #add(Object)}, which can lead to unexpected behavior. In
 this case, you should override {@code add(Object)} as well, either providing
 your own implementation, or delegating to the provided {@code standardAdd}
 method.

 <p>The {@code standard} methods and any collection views they return are not
 guaranteed to be thread-safe, even when all of the methods that they depend
 on are thread-safe.

 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultiset -->
  <!-- start class com.google.common.collect.ForwardingMultiset.StandardElementSet -->
  <class name="ForwardingMultiset.StandardElementSet" extends="com.google.common.collect.Multisets.ElementSet&lt;E&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ForwardingMultiset.StandardElementSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link Multiset#elementSet} in terms of the
 following methods: {@link ForwardingMultiset#clear}, {@link
 ForwardingMultiset#contains}, {@link ForwardingMultiset#containsAll},
 {@link ForwardingMultiset#count}, {@link ForwardingMultiset#isEmpty}, the
 {@link Set#size} and {@link Set#iterator} methods of {@link
 ForwardingMultiset#entrySet}, and {@link ForwardingMultiset#remove(Object,
 int)}.  In many situations, you may wish to override {@link
 ForwardingMultiset#elementSet} to forward to this implementation or a
 subclass thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultiset.StandardElementSet -->
  <!-- start class com.google.common.collect.ForwardingNavigableMap -->
  <class name="ForwardingNavigableMap" extends="com.google.common.collect.ForwardingSortedMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableMap&lt;K, V&gt;"/>
    <constructor name="ForwardingNavigableMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="lowerEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardLowerEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #lowerEntry} in terms of the {@code lastEntry()} of
 {@link #headMap(Object, boolean)}. If you override {@code headMap}, you may wish to override
 {@code lowerEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="lowerKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardLowerKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #lowerKey} in terms of {@code lowerEntry}. If you override
 {@link #lowerEntry}, you may wish to override {@code lowerKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="floorEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardFloorEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #floorEntry} in terms of the {@code lastEntry()} of
 {@link #headMap(Object, boolean)}. If you override {@code headMap}, you may wish to override
 {@code floorEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="floorKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardFloorKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #floorKey} in terms of {@code floorEntry}. If you override
 {@code floorEntry}, you may wish to override {@code floorKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="ceilingEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardCeilingEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #ceilingEntry} in terms of the {@code firstEntry()} of
 {@link #tailMap(Object, boolean)}. If you override {@code tailMap}, you may wish to override
 {@code ceilingEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="ceilingKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardCeilingKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #ceilingKey} in terms of {@code ceilingEntry}. If you override
 {@code ceilingEntry}, you may wish to override {@code ceilingKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="higherEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardHigherEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #higherEntry} in terms of the {@code firstEntry()} of
 {@link #tailMap(Object, boolean)}. If you override {@code tailMap}, you may wish to override
 {@code higherEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="higherKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="standardHigherKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #higherKey} in terms of {@code higherEntry}. If you override
 {@code higherEntry}, you may wish to override {@code higherKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="firstEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardFirstEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #firstEntry} in terms of the {@code iterator()} of
 {@link #entrySet}. If you override {@code entrySet}, you may wish to override
 {@code firstEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardFirstKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #firstKey} in terms of {@code firstEntry}. If you override
 {@code firstEntry}, you may wish to override {@code firstKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="lastEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardLastEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #lastEntry} in terms of the {@code iterator()} of the
 {@link #entrySet} of {@link #descendingMap}. If you override {@code descendingMap}, you may
 wish to override {@code lastEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardLastKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #lastKey} in terms of {@code lastEntry}. If you override
 {@code lastEntry}, you may wish to override {@code lastKey} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollFirstEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollFirstEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollFirstEntry} in terms of the {@code iterator} of
 {@code entrySet}. If you override {@code entrySet}, you may wish to override
 {@code pollFirstEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollLastEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollFirstEntry} in terms of the {@code iterator} of the
 {@code entrySet} of {@code descendingMap}. If you override {@code descendingMap}, you may wish
 to override {@code pollFirstEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="descendingMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="navigableKeySet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingKeySet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardDescendingKeySet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #descendingKeySet} as the {@code navigableKeySet} of
 {@link #descendingMap}. (The {@link StandardDescendingMap} implementation implements
 {@code navigableKeySet} on its own, so as not to cause an infinite loop.) If you override
 {@code descendingMap}, you may wish to override {@code descendingKeySet} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="standardSubMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #subMap(Object, Object)} in terms of
 {@link #subMap(Object, boolean, Object, boolean)}. If you override
 {@code subMap(K, boolean, K, boolean)}, you may wish to override {@code subMap} to forward to
 this implementation.]]>
      </doc>
    </method>
    <method name="subMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toKey" type="K"/>
      <param name="toInclusive" type="boolean"/>
    </method>
    <method name="headMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="tailMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="standardHeadMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #headMap(Object)} in terms of
 {@link #headMap(Object, boolean)}. If you override {@code headMap(K, boolean)}, you may wish
 to override {@code headMap} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardTailMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <doc>
      <![CDATA[A sensible definition of {@link #tailMap(Object)} in terms of
 {@link #tailMap(Object, boolean)}. If you override {@code tailMap(K, boolean)}, you may wish
 to override {@code tailMap} to forward to this implementation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A navigable map which forwards all its method calls to another navigable map. Subclasses should
 override one or more methods to modify the behavior of the backing map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><i>Warning:</i> The methods of {@code ForwardingNavigableMap} forward <i>indiscriminately</i>
 to the methods of the delegate. For example, overriding {@link #put} alone <i>will not</i>
 change the behavior of {@link #putAll}, which can lead to unexpected behavior. In this case, you
 should override {@code putAll} as well, either providing your own implementation, or delegating
 to the provided {@code standardPutAll} method.

 <p>Each of the {@code standard} methods uses the map's comparator (or the natural ordering of
 the elements, if there is no comparator) to test element equality. As a result, if the comparator
 is not consistent with equals, some of the standard implementations may violate the {@code Map}
 contract.

 <p>The {@code standard} methods and the collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Louis Wasserman
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableMap -->
  <!-- start class com.google.common.collect.ForwardingNavigableMap.StandardDescendingMap -->
  <class name="ForwardingNavigableMap.StandardDescendingMap" extends="com.google.common.collect.Maps.DescendingMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ForwardingNavigableMap.StandardDescendingMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="entryIterator" return="java.util.Iterator&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A sensible implementation of {@link NavigableMap#descendingMap} in terms of the methods of
 this {@code NavigableMap}. In many cases, you may wish to override
 {@link ForwardingNavigableMap#descendingMap} to forward to this implementation or a subclass
 thereof.

 <p>In particular, this map iterates over entries with repeated calls to
 {@link NavigableMap#lowerEntry}. If a more efficient means of iteration is available, you may
 wish to override the {@code entryIterator()} method of this class.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableMap.StandardDescendingMap -->
  <!-- start class com.google.common.collect.ForwardingNavigableMap.StandardNavigableKeySet -->
  <class name="ForwardingNavigableMap.StandardNavigableKeySet" extends="com.google.common.collect.Maps.NavigableKeySet&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ForwardingNavigableMap.StandardNavigableKeySet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link NavigableMap#navigableKeySet} in terms of the methods of
 this {@code NavigableMap}. In many cases, you may wish to override
 {@link ForwardingNavigableMap#navigableKeySet} to forward to this implementation or a subclass
 thereof.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableMap.StandardNavigableKeySet -->
  <!-- start class com.google.common.collect.ForwardingNavigableSet -->
  <class name="ForwardingNavigableSet" extends="com.google.common.collect.ForwardingSortedSet&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableSet&lt;E&gt;"/>
    <constructor name="ForwardingNavigableSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.NavigableSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="lower" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="standardLower" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #lower} in terms of the {@code descendingIterator} method of
 {@link #headSet(Object, boolean)}. If you override {@link #headSet(Object, boolean)}, you may
 wish to override {@link #lower} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="floor" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="standardFloor" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #floor} in terms of the {@code descendingIterator} method of
 {@link #headSet(Object, boolean)}. If you override {@link #headSet(Object, boolean)}, you may
 wish to override {@link #floor} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="ceiling" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="standardCeiling" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #ceiling} in terms of the {@code iterator} method of
 {@link #tailSet(Object, boolean)}. If you override {@link #tailSet(Object, boolean)}, you may
 wish to override {@link #ceiling} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="higher" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="standardHigher" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #higher} in terms of the {@code iterator} method of
 {@link #tailSet(Object, boolean)}. If you override {@link #tailSet(Object, boolean)}, you may
 wish to override {@link #higher} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollFirst} in terms of the {@code iterator} method. If you
 override {@link #iterator} you may wish to override {@link #pollFirst} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollLast} in terms of the {@code descendingIterator} method.
 If you override {@link #descendingIterator} you may wish to override {@link #pollLast} to
 forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="standardLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="descendingSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="E"/>
      <param name="toInclusive" type="boolean"/>
    </method>
    <method name="standardSubSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="E"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[A sensible definition of {@link #subSet(Object, boolean, Object, boolean)} in terms of the
 {@code headSet} and {@code tailSet} methods. In many cases, you may wish to override
 {@link #subSet(Object, boolean, Object, boolean)} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardSubSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #subSet(Object, Object)} in terms of the
 {@link #subSet(Object, boolean, Object, boolean)} method. If you override
 {@link #subSet(Object, boolean, Object, boolean)}, you may wish to override
 {@link #subSet(Object, Object)} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="headSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="standardHeadSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #headSet(Object)} in terms of the
 {@link #headSet(Object, boolean)} method. If you override
 {@link #headSet(Object, boolean)}, you may wish to override
 {@link #headSet(Object)} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="tailSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="standardTailSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #tailSet(Object)} in terms of the
 {@link #tailSet(Object, boolean)} method. If you override
 {@link #tailSet(Object, boolean)}, you may wish to override
 {@link #tailSet(Object)} to forward to this implementation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A navigable set which forwards all its method calls to another navigable set. Subclasses should
 override one or more methods to modify the behavior of the backing set as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><i>Warning:</i> The methods of {@code ForwardingNavigableSet} forward <i>indiscriminately</i>
 to the methods of the delegate. For example, overriding {@link #add} alone <i>will not</i>
 change the behavior of {@link #addAll}, which can lead to unexpected behavior. In this case, you
 should override {@code addAll} as well, either providing your own implementation, or delegating
 to the provided {@code standardAddAll} method.

 <p>Each of the {@code standard} methods uses the set's comparator (or the natural ordering of
 the elements, if there is no comparator) to test element equality. As a result, if the
 comparator is not consistent with equals, some of the standard implementations may violate the
 {@code Set} contract.

 <p>The {@code standard} methods and the collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Louis Wasserman
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableSet -->
  <!-- start class com.google.common.collect.ForwardingNavigableSet.StandardDescendingSet -->
  <class name="ForwardingNavigableSet.StandardDescendingSet" extends="com.google.common.collect.Sets.DescendingSet&lt;E&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ForwardingNavigableSet.StandardDescendingSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link NavigableSet#descendingSet} in terms of the other methods
 of {@link NavigableSet}, notably including {@link NavigableSet#descendingIterator}.

 <p>In many cases, you may wish to override {@link ForwardingNavigableSet#descendingSet} to
 forward to this implementation or a subclass thereof.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableSet.StandardDescendingSet -->
  <!-- start class com.google.common.collect.ForwardingObject -->
  <class name="ForwardingObject" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingObject"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the backing delegate instance that methods are forwarded to.
 Abstract subclasses generally override this method with an abstract method
 that has a more specific return type, such as {@link
 ForwardingSet#delegate}. Concrete subclasses override this method to supply
 the instance being decorated.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the string representation generated by the delegate's
 {@code toString} method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract base class for implementing the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.
 The {@link #delegate()} method must be overridden to return the instance
 being decorated.

 <p>This class does <i>not</i> forward the {@code hashCode} and {@code equals}
 methods through to the backing object, but relies on {@code Object}'s
 implementation. This is necessary to preserve the symmetry of {@code equals}.
 Custom definitions of equality are usually based on an interface, such as
 {@code Set} or {@code List}, so that the implementation of {@code equals} can
 cast the object being tested for equality to the custom interface. {@code
 ForwardingObject} implements no such custom interfaces directly; they
 are implemented only in subclasses. Therefore, forwarding {@code equals}
 would break symmetry, as the forwarding object might consider itself equal to
 the object being tested, but the reverse could not be true. This behavior is
 consistent with the JDK's collection wrappers, such as
 {@link java.util.Collections#unmodifiableCollection}. Use an
 interface-specific subclass of {@code ForwardingObject}, such as {@link
 ForwardingList}, to preserve equality behavior, or override {@code equals}
 directly.

 <p>The {@code toString} method is forwarded to the delegate. Although this
 class does not implement {@link Serializable}, a serializable subclass may be
 created since this class has a parameter-less constructor.

 @author Mike Bostock
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingObject -->
  <!-- start class com.google.common.collect.ForwardingQueue -->
  <class name="ForwardingQueue" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Queue&lt;E&gt;"/>
    <constructor name="ForwardingQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Queue&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="E"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="element" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardOffer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[A sensible definition of {@link #offer} in terms of {@link #add}. If you
 override {@link #add}, you may wish to override {@link #offer} to forward
 to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardPeek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #peek} in terms of {@link #element}. If you
 override {@link #element}, you may wish to override {@link #peek} to
 forward to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <method name="standardPoll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #poll} in terms of {@link #remove}. If you
 override {@link #remove}, you may wish to override {@link #poll} to forward
 to this implementation.
 
 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A queue which forwards all its method calls to another queue. Subclasses
 should override one or more methods to modify the behavior of the backing
 queue as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingQueue} forward
 <b>indiscriminately</b> to the methods of the delegate. For example,
 overriding {@link #add} alone <b>will not</b> change the behavior of {@link
 #offer} which can lead to unexpected behavior. In this case, you should
 override {@code offer} as well, either providing your own implementation, or
 delegating to the provided {@code standardOffer} method.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even
 when all of the methods that they depend on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingQueue -->
  <!-- start class com.google.common.collect.ForwardingSet -->
  <class name="ForwardingSet" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set&lt;E&gt;"/>
    <constructor name="ForwardingSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardRemoveAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #removeAll} in terms of {@link #iterator}
 and {@link #remove}.  If you override {@code iterator} or {@code remove},
 you may wish to override {@link #removeAll} to forward to this
 implementation.

 @since 7.0 (this version overrides the {@code ForwardingCollection} version as of 12.0)]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals} in terms of {@link #size} and
 {@link #containsAll}. If you override either of those methods, you may wish
 to override {@link #equals} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} in terms of {@link #iterator}.
 If you override {@link #iterator}, you may wish to override {@link #equals}
 to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A set which forwards all its method calls to another set. Subclasses should
 override one or more methods to modify the behavior of the backing set as
 desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingSet} forward
 <b>indiscriminately</b> to the methods of the delegate. For example,
 overriding {@link #add} alone <b>will not</b> change the behavior of {@link
 #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or
 delegating to the provided {@code standardAddAll} method.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even
 when all of the methods that they depend on are thread-safe.

 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSet -->
  <!-- start class com.google.common.collect.ForwardingSetMultimap -->
  <class name="ForwardingSetMultimap" extends="com.google.common.collect.ForwardingMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingSetMultimap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="removeAll" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A set multimap which forwards all its method calls to another set multimap.
 Subclasses should override one or more methods to modify the behavior of
 the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kurt Alfred Kluever
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSetMultimap -->
  <!-- start class com.google.common.collect.ForwardingSortedMap -->
  <class name="ForwardingSortedMap" extends="com.google.common.collect.ForwardingMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedMap&lt;K, V&gt;"/>
    <constructor name="ForwardingSortedMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="firstKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
    </method>
    <method name="lastKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
    </method>
    <method name="tailMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
    </method>
    <method name="standardContainsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #containsKey} in terms of the {@code
 firstKey()} method of {@link #tailMap}. If you override {@link #tailMap},
 you may wish to override {@link #containsKey} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #remove} in terms of the {@code
 iterator()} of the {@code entrySet()} of {@link #tailMap}. If you override
 {@link #tailMap}, you may wish to override {@link #remove} to forward
 to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSubMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #subMap(Object, Object)} in
 terms of {@link #headMap(Object)} and {@link #tailMap(Object)}. In some
 situations, you may wish to override {@link #subMap(Object, Object)} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A sorted map which forwards all its method calls to another sorted map.
 Subclasses should override one or more methods to modify the behavior of
 the backing sorted map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><i>Warning:</i> The methods of {@code ForwardingSortedMap} forward
 <i>indiscriminately</i> to the methods of the delegate. For example,
 overriding {@link #put} alone <i>will not</i> change the behavior of {@link
 #putAll}, which can lead to unexpected behavior. In this case, you should
 override {@code putAll} as well, either providing your own implementation, or
 delegating to the provided {@code standardPutAll} method.

 <p>Each of the {@code standard} methods, where appropriate, use the
 comparator of the map to test equality for both keys and values, unlike
 {@code ForwardingMap}.

 <p>The {@code standard} methods and the collection views they return are not
 guaranteed to be thread-safe, even when all of the methods that they depend
 on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedMap -->
  <!-- start class com.google.common.collect.ForwardingSortedSet -->
  <class name="ForwardingSortedSet" extends="com.google.common.collect.ForwardingSet&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedSet&lt;E&gt;"/>
    <constructor name="ForwardingSortedSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.SortedSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="first" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
    </method>
    <method name="last" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="toElement" type="E"/>
    </method>
    <method name="tailSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
    </method>
    <method name="standardContains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #contains} in terms of the {@code first()}
 method of {@link #tailSet}. If you override {@link #tailSet}, you may wish
 to override {@link #contains} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #remove} in terms of the {@code iterator()}
 method of {@link #tailSet}. If you override {@link #tailSet}, you may wish
 to override {@link #remove} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSubSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #subSet(Object, Object)} in
 terms of {@link #headSet(Object)} and {@link #tailSet(Object)}. In some
 situations, you may wish to override {@link #subSet(Object, Object)} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A sorted set which forwards all its method calls to another sorted set.
 Subclasses should override one or more methods to modify the behavior of the
 backing sorted set as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><i>Warning:</i> The methods of {@code ForwardingSortedSet} forward
 <i>indiscriminately</i> to the methods of the delegate. For example,
 overriding {@link #add} alone <i>will not</i> change the behavior of {@link
 #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or
 delegating to the provided {@code standardAddAll} method.

 <p>Each of the {@code standard} methods, where appropriate, uses the set's
 comparator (or the natural ordering of the elements, if there is no
 comparator) to test element equality. As a result, if the comparator is not
 consistent with equals, some of the standard implementations may violate the
 {@code Set} contract.

 <p>The {@code standard} methods and the collection views they return are not
 guaranteed to be thread-safe, even when all of the methods that they depend
 on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedSet -->
  <!-- start class com.google.common.collect.ForwardingSortedSetMultimap -->
  <class name="ForwardingSortedSetMultimap" extends="com.google.common.collect.ForwardingSetMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingSortedSetMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="removeAll" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="replaceValues" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="valueComparator" return="java.util.Comparator&lt;? super V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A sorted set multimap which forwards all its method calls to another sorted
 set multimap. Subclasses should override one or more methods to modify the
 behavior of the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kurt Alfred Kluever
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedSetMultimap -->
  <!-- start class com.google.common.collect.ForwardingTable -->
  <class name="ForwardingTable" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Table&lt;R, C, V&gt;"/>
    <constructor name="ForwardingTable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Table&lt;R, C, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="cellSet" return="java.util.Set&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="column" return="java.util.Map&lt;R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C"/>
    </method>
    <method name="columnKeySet" return="java.util.Set&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="columnMap" return="java.util.Map&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="containsRow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="row" return="java.util.Map&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
    </method>
    <method name="rowKeySet" return="java.util.Set&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="rowMap" return="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A table which forwards all its method calls to another table. Subclasses
 should override one or more methods to modify the behavior of the backing
 map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Gregory Kick
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingTable -->
  <!-- start class com.google.common.collect.GenericMapMaker -->
  <class name="GenericMapMaker" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="initialCapacity" return="com.google.common.collect.GenericMapMaker&lt;K0, V0&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[See {@link MapMaker#initialCapacity}.]]>
      </doc>
    </method>
    <method name="concurrencyLevel" return="com.google.common.collect.GenericMapMaker&lt;K0, V0&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="concurrencyLevel" type="int"/>
      <doc>
      <![CDATA[See {@link MapMaker#concurrencyLevel}.]]>
      </doc>
    </method>
    <method name="weakKeys" return="com.google.common.collect.GenericMapMaker&lt;K0, V0&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link MapMaker#weakKeys}.]]>
      </doc>
    </method>
    <method name="softKeys" return="com.google.common.collect.GenericMapMaker&lt;K0, V0&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link MapMaker#softKeys}.]]>
      </doc>
    </method>
    <method name="weakValues" return="com.google.common.collect.GenericMapMaker&lt;K0, V0&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link MapMaker#weakValues}.]]>
      </doc>
    </method>
    <method name="softValues" return="com.google.common.collect.GenericMapMaker&lt;K0, V0&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link MapMaker#softValues}.]]>
      </doc>
    </method>
    <method name="makeMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link MapMaker#makeMap}.]]>
      </doc>
    </method>
    <method name="makeComputingMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="computingFunction" type="com.google.common.base.Function&lt;? super K, ? extends V&gt;"/>
      <doc>
      <![CDATA[See {@link MapMaker#makeComputingMap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class exactly like {@link MapMaker}, except restricted in the types of maps it can build.
 For the most part, you should probably just ignore the existence of this class.

 @param <K0> the base type for all key types of maps built by this map maker
 @param <V0> the base type for all value types of maps built by this map maker
 @author Kevin Bourrillion
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.GenericMapMaker -->
  <!-- start class com.google.common.collect.HashBasedTable -->
  <class name="HashBasedTable" extends="com.google.common.collect.StandardTable&lt;R, C, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code HashBasedTable}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedRows" type="int"/>
      <param name="expectedCellsPerRow" type="int"/>
      <doc>
      <![CDATA[Creates an empty {@code HashBasedTable} with the specified map sizes.

 @param expectedRows the expected number of distinct row keys
 @param expectedCellsPerRow the expected number of column key / value
     mappings in each row
 @throws IllegalArgumentException if {@code expectedRows} or {@code
     expectedCellsPerRow} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a {@code HashBasedTable} with the same mappings as the specified
 table.

 @param table the table to copy
 @throws NullPointerException if any of the row keys, column keys, or values
     in {@code table} is null]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="containsRow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Implementation of {@link Table} using hash tables.

 <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link
 #columnMap()} have iterators that don't support {@code remove()}. Otherwise,
 all optional operations are supported. Null row keys, columns keys, and
 values are not supported.

 <p>Lookups by row key are often faster than lookups by column key, because
 the data is stored in a {@code Map<R, Map<C, V>>}. A method call like {@code
 column(columnKey).get(rowKey)} still runs quickly, since the row key is
 provided. However, {@code column(columnKey).size()} takes longer, since an
 iteration across all row keys occurs.

 <p>Note that this implementation is not synchronized. If multiple threads
 access this table concurrently and one of the threads modifies the table, it
 must be synchronized externally.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Table">
 {@code Table}</a>.

 @author Jared Levy
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashBasedTable -->
  <!-- start class com.google.common.collect.HashBiMap -->
  <class name="HashBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty {@code HashBiMap} with the default initial capacity
 (16).]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Constructs a new, empty bimap with the specified expected size.

 @param expectedSize the expected number of entries
 @throws IllegalArgumentException if the specified expected size is
     negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a new bimap containing initial values from {@code map}. The
 bimap is created with an initial capacity sufficient to hold the mappings
 in the specified map.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <doc>
    <![CDATA[A {@link BiMap} backed by two {@link HashMap} instances. This implementation
 allows null keys and values. A {@code HashBiMap} and its inverse are both
 serializable.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#BiMap">
 {@code BiMap}</a>.

 @author Mike Bostock
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashBiMap -->
  <!-- start class com.google.common.collect.HashMultimap -->
  <class name="HashMultimap" extends="com.google.common.collect.AbstractSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultimap} with the default initial
 capacities.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code HashMultimap} with enough capacity to hold the
 specified numbers of keys and values without rehashing.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code
      expectedValuesPerKey} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code HashMultimap} with the same mappings as the specified
 multimap. If a key-value mapping appears multiple times in the input
 multimap, it only appears once in the constructed multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@link Multimap} using hash tables.

 <p>The multimap does not store duplicate key-value pairs. Adding a new
 key-value pair equal to an existing key-value pair has no effect.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedSetMultimap}.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashMultimap -->
  <!-- start class com.google.common.collect.HashMultiset -->
  <class name="HashMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultiset} using the default initial
 capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distinctElements" type="int"/>
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultiset} with the specified expected
 number of distinct elements.

 @param distinctElements the expected number of distinct elements
 @throws IllegalArgumentException if {@code distinctElements} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code HashMultiset} containing the specified elements.
 
 <p>This implementation is highly efficient when {@code elements} is itself
 a {@link Multiset}.
 
 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Multiset implementation backed by a {@link HashMap}.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashMultiset -->
  <!-- start class com.google.common.collect.ImmutableBiMap -->
  <class name="ImmutableBiMap" extends="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.BiMap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty bimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable bimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable bimap containing the same entries as {@code map}. If
 {@code map} somehow contains entries with duplicate keys (for example, if
 it is a {@code SortedMap} whose comparator is not <i>consistent with
 equals</i>), the results of this method are undefined.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws IllegalArgumentException if two keys have the same value
 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableBiMap&lt;V, K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The inverse of an {@code ImmutableBiMap} is another
 {@code ImmutableBiMap}.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the values in this map. The values are in the
 same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the bimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable {@link BiMap} with reliable user-specified iteration order. Does
 not permit null keys or values. An {@code ImmutableBiMap} and its inverse
 have the same iteration ordering.

 <p>An instance of {@code ImmutableBiMap} contains its own data and will
 <i>never</i> change. {@code ImmutableBiMap} is convenient for
 {@code public static final} maps ("constant maps") and also lets you easily
 make a "defensive copy" of a bimap provided to your class by a caller.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class are
 guaranteed to be immutable.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableBiMap -->
  <!-- start class com.google.common.collect.ImmutableBiMap.Builder -->
  <class name="ImmutableBiMap.Builder" extends="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableBiMap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableBiMap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built bimap. Duplicate
 keys or values are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built bimap.
 Duplicate keys or values are not allowed, and will cause {@link #build}
 to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable bimap.

 @throws IllegalArgumentException if duplicate keys or values were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable bimap instances, especially {@code public
 static final} bimaps ("constant bimaps"). Example: <pre>   {@code

   static final ImmutableBiMap<String, Integer> WORD_TO_INT =
       new ImmutableBiMap.Builder<String, Integer>()
           .put("one", 1)
           .put("two", 2)
           .put("three", 3)
           .build();}</pre>

 For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods
 are even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple bimaps in series. Each bimap is a superset
 of the bimaps created before it.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableBiMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableClassToInstanceMap -->
  <class name="ImmutableClassToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ClassToInstanceMap&lt;B&gt;"/>
    <method name="builder" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.Class&lt;? extends S&gt;, ? extends S&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}. If
 {@code map} somehow contains entries with duplicate keys (for example, if
 it is a {@code SortedMap} whose comparator is not <i>consistent with
 equals</i>), the results of this method are undefined.

 <p><b>Note:</b> Despite what the method name suggests, if {@code map} is
 an {@code ImmutableClassToInstanceMap}, no copy will actually be performed.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws ClassCastException if any value is not an instance of the type
     specified by its key]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class-to-instance map backed by an {@link ImmutableMap}. See also {@link
 MutableClassToInstanceMap}.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableClassToInstanceMap -->
  <!-- start class com.google.common.collect.ImmutableClassToInstanceMap.Builder -->
  <class name="ImmutableClassToInstanceMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableClassToInstanceMap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.Class&lt;? extends T&gt;, ? extends T&gt;"/>
      <doc>
      <![CDATA[Associates all of {@code map's} keys and values in the built map.
 Duplicate keys are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws ClassCastException if any value is not an instance of the type
     specified by its key]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable class-to-instance map containing the entries
 provided to this builder.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable class-to-instance maps. Example:
 <pre>   {@code

   static final ImmutableClassToInstanceMap<Handler> HANDLERS =
       new ImmutableClassToInstanceMap.Builder<Handler>()
           .put(FooHandler.class, new FooHandler())
           .put(BarHandler.class, new SubBarHandler())
           .put(Handler.class, new QuuxHandler())
           .build();}</pre>

 After invoking {@link #build()} it is still possible to add more entries
 and build again. Thus each map generated by this builder will be a superset
 of any map generated before it.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableClassToInstanceMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableCollection -->
  <class name="ImmutableCollection" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable iterator across the elements in this collection.]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="T[]"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targets" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="oldElements" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="elementsToKeep" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a list view of the collection.

 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable collection. Does not permit null elements.

 <p>In addition to the {@link Collection} methods, this class has an {@link
 #asList()} method, which returns a list view of the collection's elements.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed
 outside of this package as it has no public or protected constructors. Thus,
 instances of this type are guaranteed to be immutable.

 @author Jesse Wilson
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableCollection -->
  <!-- start class com.google.common.collect.ImmutableCollection.Builder -->
  <class name="ImmutableCollection.Builder" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="add" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableCollection} being built.

 <p>Note that each builder class covariantly returns its own type from
 this method.

 @param element the element to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableCollection}
 being built.

 <p>Note that each builder class overrides this method in order to
 covariantly return its own type.

 @param elements the elements to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableCollection}
 being built.

 <p>Note that each builder class overrides this method in order to
 covariantly return its own type.

 @param elements the elements to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableCollection}
 being built.

 <p>Note that each builder class overrides this method in order to
 covariantly return its own type.

 @param elements the elements to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableCollection&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableCollection} of the appropriate
 type, containing the elements provided to this builder.

 <p>Note that each builder class covariantly returns the appropriate type
 of {@code ImmutableCollection} from this method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract base class for builders of {@link ImmutableCollection} types.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableCollection.Builder -->
  <!-- start class com.google.common.collect.ImmutableList -->
  <class name="ImmutableList" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.List&lt;E&gt;"/>
    <implements name="java.util.RandomAccess"/>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable list. This set behaves and performs comparably
 to {@link Collections#emptyList}, and is preferable mainly for consistency
 and maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing a single element. This list behaves
 and performs comparably to {@link Collections#singleton}, but will not
 accept a null element. It is preferable mainly for consistency and
 maintainability of your code.

 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <param name="e11" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <param name="e11" type="E"/>
      <param name="e12" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 3.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order. If
 {@code elements} is a {@link Collection}, this method behaves exactly as
 {@link #copyOf(Collection)}; otherwise, it behaves exactly as {@code
 copyOf(elements.iterator()}.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 <p>Note that if {@code list} is a {@code List<String>}, then {@code
 ImmutableList.copyOf(list)} returns an {@code ImmutableList<String>}
 containing each of the strings in {@code list}, while
 ImmutableList.of(list)} returns an {@code ImmutableList<List<String>>}
 containing one element (the given list itself).

 <p>This method is safe to use even when {@code elements} is a synchronized
 or concurrent collection that is currently being modified by another
 thread.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any of {@code elements} is null
 @since 3.0]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listIterator" return="com.google.common.collect.UnmodifiableListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listIterator" return="com.google.common.collect.UnmodifiableListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="subList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Returns an immutable list of the elements between the specified {@code
 fromIndex}, inclusive, and {@code toIndex}, exclusive. (If {@code
 fromIndex} and {@code toIndex} are equal, the empty immutable list is
 returned.)]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="set" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this list instance.

 @since 2.0]]>
      </doc>
    </method>
    <method name="reverse" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of this immutable list in reverse order. For example, {@code
 ImmutableList.of(1, 2, 3).reverse()} is equivalent to {@code
 ImmutableList.of(3, 2, 1)}.

 @return a view of this immutable list in reverse order
 @since 7.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A high-performance, immutable, random-access {@code List} implementation.
 Does not permit null elements.

 <p>Unlike {@link Collections#unmodifiableList}, which is a <i>view</i> of a
 separate collection that can still change, an instance of {@code
 ImmutableList} contains its own private data and will <i>never</i> change.
 {@code ImmutableList} is convenient for {@code public static final} lists
 ("constant lists") and also lets you easily make a "defensive copy" of a list
 provided to your class by a caller.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this type are
 guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @see ImmutableMap
 @see ImmutableSet
 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableList -->
  <!-- start class com.google.common.collect.ImmutableList.Builder -->
  <class name="ImmutableList.Builder" extends="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableList.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableList#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableList}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableList} based on the contents of
 the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable list instances, especially {@code public
 static final} lists ("constant lists"). Example: <pre>   {@code

   public static final ImmutableList<Color> GOOGLE_COLORS
       = new ImmutableList.Builder<Color>()
           .addAll(WEBSAFE_COLORS)
           .add(new Color(0, 191, 255))
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple
 times to build multiple lists in series. Each new list contains all the
 elements of the ones created before it.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableList.Builder -->
  <!-- start class com.google.common.collect.ImmutableListMultimap -->
  <class name="ImmutableListMultimap" extends="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty multimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the same mappings as {@code
 multimap}. The generated multimap's key and value orderings correspond to
 the iteration ordering of the {@code multimap.asMap()} view.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code multimap} is
         null]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable list of the values for the given key.  If no mappings
 in the multimap have the provided key, an empty immutable list is
 returned. The values are in the same order as the parameters used to build
 this multimap.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableListMultimap&lt;V, K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because an inverse of a list multimap can contain multiple pairs with
 the same key and value, this method returns an {@code
 ImmutableListMultimap} rather than the {@code ImmutableMultimap} specified
 in the {@code ImmutableMultimap} class.

 @since 11]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@link ListMultimap} with reliable user-specified key and value
 iteration order. Does not permit null keys or values.

 <p>Unlike {@link Multimaps#unmodifiableListMultimap(ListMultimap)}, which is
 a <i>view</i> of a separate multimap which can still change, an instance of
 {@code ImmutableListMultimap} contains its own data and will <i>never</i>
 change. {@code ImmutableListMultimap} is convenient for
 {@code public static final} multimaps ("constant multimaps") and also lets
 you easily make a "defensive copy" of a multimap provided to your class by
 a caller.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class
 are guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableListMultimap -->
  <!-- start class com.google.common.collect.ImmutableListMultimap.Builder -->
  <class name="ImmutableListMultimap.Builder" extends="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableListMultimap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableListMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="orderKeysBy" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 8.0]]>
      </doc>
    </method>
    <method name="orderValuesBy" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 8.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable list multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable {@code ListMultimap} instances, especially
 {@code public static final} multimaps ("constant multimaps"). Example:
 <pre>   {@code

   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
       new ImmutableListMultimap.Builder<String, Integer>()
           .put("one", 1)
           .putAll("several", 1, 2, 3)
           .putAll("many", 1, 2, 3, 4, 5)
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple
 times to build multiple multimaps in series. Each multimap contains the
 key-value mappings in the previously created multimaps.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableListMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMap -->
  <class name="ImmutableMap" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty map. This map behaves and performs comparably to
 {@link Collections#emptyMap}, and is preferable mainly for consistency
 and maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing a single entry. This map behaves and
 performs comparably to {@link Collections#singletonMap} but will not accept
 a null key or value. It is preferable mainly for consistency and
 maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}. If
 {@code map} somehow contains entries with duplicate keys (for example, if
 it is a {@code SortedMap} whose comparator is not <i>consistent with
 equals</i>), the results of this method are undefined.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="K"/>
      <param name="v" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the mappings in this map. The entries are in
 the same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the keys in this map. These keys are in
 the same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this map. The values are
 in the same order as the parameters used to build this map.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable, hash-based {@link Map} with reliable user-specified iteration
 order. Does not permit null keys or values.

 <p>Unlike {@link Collections#unmodifiableMap}, which is a <i>view</i> of a
 separate map which can still change, an instance of {@code ImmutableMap}
 contains its own data and will <i>never</i> change. {@code ImmutableMap} is
 convenient for {@code public static final} maps ("constant maps") and also
 lets you easily make a "defensive copy" of a map provided to your class by a
 caller.

 <p><i>Performance notes:</i> unlike {@link HashMap}, {@code ImmutableMap} is
 not optimized for element types that have slow {@link Object#equals} or
 {@link Object#hashCode} implementations. You can get better performance by
 having your element type cache its own hash codes, and by making use of the
 cached values to short-circuit a slow {@code equals} algorithm.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMap -->
  <!-- start class com.google.common.collect.ImmutableMap.Builder -->
  <class name="ImmutableMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableMap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableMap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds the given {@code entry} to the map, making it immutable if
 necessary. Duplicate keys are not allowed, and will cause {@link #build}
 to fail.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built map.
 Duplicate keys are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable map.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable map instances, especially {@code public
 static final} maps ("constant maps"). Example: <pre>   {@code

   static final ImmutableMap<String, Integer> WORD_TO_INT =
       new ImmutableMap.Builder<String, Integer>()
           .put("one", 1)
           .put("two", 2)
           .put("three", 3)
           .build();}</pre>

 For <i>small</i> immutable maps, the {@code ImmutableMap.of()} methods are
 even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple maps in series. Each map is a superset of
 the maps created before it.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMultimap -->
  <class name="ImmutableMultimap" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty multimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the same mappings as {@code
 multimap}. The generated multimap's key and value orderings correspond to
 the iteration ordering of the {@code multimap.asMap()} view.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code multimap} is
         null]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable collection of the values for the given key.  If no
 mappings in the multimap have the provided key, an empty immutable
 collection is returned. The values are in the same order as the parameters
 used to build this multimap.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableMultimap&lt;V, K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable multimap which is the inverse of this one. For every
 key-value mapping in the original, the result will have a mapping with
 key and value reversed.

 @since 11.0]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the distinct keys in this multimap. These keys
 are ordered according to when they first appeared during the construction
 of this multimap.]]>
      </doc>
    </method>
    <method name="asMap" return="com.google.common.collect.ImmutableMap&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable map that associates each key with its corresponding
 values in the multimap.]]>
      </doc>
    </method>
    <method name="entries" return="com.google.common.collect.ImmutableCollection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of all key-value pairs in the multimap. Its
 iterator traverses the values for the first key, the values for the second
 key, and so on.]]>
      </doc>
    </method>
    <method name="keys" return="com.google.common.collect.ImmutableMultiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection, which may contain duplicates, of all keys. The number
 of times a key appears in the returned multiset equals the number of
 mappings the key has in the multimap. Duplicate keys appear consecutively
 in the multiset's iteration order.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this multimap. Its
 iterator traverses the values for the first key, the values for the second
 key, and so on.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@link Multimap}. Does not permit null keys or values.

 <p>Unlike {@link Multimaps#unmodifiableMultimap(Multimap)}, which is
 a <i>view</i> of a separate multimap which can still change, an instance of
 {@code ImmutableMultimap} contains its own data and will <i>never</i>
 change. {@code ImmutableMultimap} is convenient for
 {@code public static final} multimaps ("constant multimaps") and also lets
 you easily make a "defensive copy" of a multimap provided to your class by
 a caller.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class
 are guaranteed to be immutable.

 <p>In addition to methods defined by {@link Multimap}, an {@link #inverse}
 method is also supported.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultimap -->
  <!-- start class com.google.common.collect.ImmutableMultimap.Builder -->
  <class name="ImmutableMultimap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableMultimap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds a key-value mapping to the built multimap.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds an entry to the built multimap.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key in the built multimap.

 @throws NullPointerException if {@code key}, {@code values}, or any
     element in {@code values} is null. The builder is left in an invalid
     state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
      <doc>
      <![CDATA[Stores an array of values with the same key in the built multimap.

 @throws NullPointerException if the key or any value is null. The builder
     is left in an invalid state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Stores another multimap's entries in the built multimap. The generated
 multimap's key and value orderings correspond to the iteration ordering
 of the {@code multimap.asMap()} view, with new keys and values following
 any existing keys and values.

 @throws NullPointerException if any key or value in {@code multimap} is
     null. The builder is left in an invalid state.]]>
      </doc>
    </method>
    <method name="orderKeysBy" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated multimap's keys.

 @since 8.0]]>
      </doc>
    </method>
    <method name="orderValuesBy" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated multimap's values for each key.

 @since 8.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multimap instances, especially
 {@code public static final} multimaps ("constant multimaps"). Example:
 <pre>   {@code

   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
       new ImmutableMultimap.Builder<String, Integer>()
           .put("one", 1)
           .putAll("several", 1, 2, 3)
           .putAll("many", 1, 2, 3, 4, 5)
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple
 times to build multiple multimaps in series. Each multimap contains the
 key-value mappings in the previously created multimaps.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMultiset -->
  <class name="ImmutableMultiset" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multiset&lt;E&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable multiset.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing a single element.

 @throws NullPointerException if {@code element} is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements.

 <p>The multiset is ordered by the first occurrence of each element. For
 example, {@code ImmutableMultiset.copyOf([2, 3, 1, 3])} yields a multiset
 with elements in the order {@code 2, 3, 3, 1}.

 @throws NullPointerException if any of {@code elements} is null
 @since 6.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements.

 <p>The multiset is ordered by the first occurrence of each element. For
 example, {@code ImmutableMultiset.copyOf(Arrays.asList(2, 3, 1, 3))} yields
 a multiset with elements in the order {@code 2, 3, 3, 1}.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements}
 is an {@code ImmutableMultiset}, no copy will actually be performed, and
 the given multiset itself will be returned.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements.

 <p>The multiset is ordered by the first occurrence of each element. For
 example,
 {@code ImmutableMultiset.copyOf(Arrays.asList(2, 3, 1, 3).iterator())}
 yields a multiset with elements in the order {@code 2, 3, 3, 1}.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targets" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable hash-based multiset. Does not permit null elements.

 <p>Its iterator orders elements according to the first appearance of the
 element among the items passed to the factory method or builder. When the
 multiset contains multiple instances of an element, those instances are
 consecutive in the iteration order.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultiset -->
  <!-- start class com.google.common.collect.ImmutableMultiset.Builder -->
  <class name="ImmutableMultiset.Builder" extends="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableMultiset.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableMultiset#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableMultiset}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="addCopies" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this {@code
 ImmutableMultiset}.

 @param element the element to add
 @param occurrences the number of occurrences of the element to add. May
     be zero, in which case no change will be made.
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code occurrences} is negative, or
     if this operation would result in more than {@link Integer#MAX_VALUE}
     occurrences of the element]]>
      </doc>
    </method>
    <method name="setCount" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the
 element attains the desired count.

 @param element the element to add or remove occurrences of
 @param count the desired count of the element in this multiset
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the {@code Iterable} to add to the {@code
     ImmutableMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the elements to add to the {@code ImmutableMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableMultiset} based on the contents
 of the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multiset instances, especially {@code
 public static final} multisets ("constant multisets"). Example:
 <pre> {@code

   public static final ImmutableMultiset<Bean> BEANS =
       new ImmutableMultiset.Builder<Bean>()
           .addCopies(Bean.COCOA, 4)
           .addCopies(Bean.GARDEN, 6)
           .addCopies(Bean.RED, 8)
           .addCopies(Bean.BLACK_EYED, 10)
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple
 times to build multiple multisets in series.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultiset.Builder -->
  <!-- start class com.google.common.collect.ImmutableSet -->
  <class name="ImmutableSet" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set&lt;E&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable set. This set behaves and performs comparably
 to {@link Collections#emptySet}, and is preferable mainly for consistency
 and maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing a single element. This set behaves and
 performs comparably to {@link Collections#singleton}, but will not accept
 a null element. It is preferable mainly for consistency and
 maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any element is null
 @since 3.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any of {@code elements} is null
 @since 3.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored. This method iterates over {@code elements} at most once.

 <p>Note that if {@code s} is a {@code Set<String>}, then {@code
 ImmutableSet.copyOf(s)} returns an {@code ImmutableSet<String>} containing
 each of the strings in {@code s}, while {@code ImmutableSet.of(s)} returns
 a {@code ImmutableSet<Set<String>>} containing one element (the given set
 itself).

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, in order. Repeated
 occurrences of an element (according to {@link Object#equals}) after the
 first are ignored. This method iterates over {@code elements} at most
 once.

 <p>Note that if {@code s} is a {@code Set<String>}, then {@code
 ImmutableSet.copyOf(s)} returns an {@code ImmutableSet<String>} containing
 each of the strings in {@code s}, while {@code ImmutableSet.of(s)} returns
 a {@code ImmutableSet<Set<String>>} containing one element (the given set
 itself).

 <p><b>Note:</b> Despite what the method name suggests, {@code copyOf} will
 return constant-space views, rather than linear-space copies, of some
 inputs known to be immutable. For some other immutable inputs, such as key
 sets of an {@code ImmutableMap}, it still performs a copy in order to avoid
 holding references to the values of the map. The heuristics used in this
 decision are undocumented and subject to change except that:
 <ul>
 <li>A full copy will be done of any {@code ImmutableSortedSet}.</li>
 <li>{@code ImmutableSet.copyOf()} is idempotent with respect to pointer
 equality.</li>
 </ul>

 <p>This method is safe to use even when {@code elements} is a synchronized
 or concurrent collection that is currently being modified by another
 thread.

 @throws NullPointerException if any of {@code elements} is null
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder} constructor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A high-performance, immutable {@code Set} with reliable, user-specified
 iteration order. Does not permit null elements.

 <p>Unlike {@link Collections#unmodifiableSet}, which is a <i>view</i> of a
 separate collection that can still change, an instance of this class contains
 its own private data and will <i>never</i> change. This class is convenient
 for {@code public static final} sets ("constant sets") and also lets you
 easily make a "defensive copy" of a set provided to your class by a caller.

 <p><b>Warning:</b> Like most sets, an {@code ImmutableSet} will not function
 correctly if an element is modified after being placed in the set. For this
 reason, and to avoid general confusion, it is strongly recommended to place
 only immutable objects into this collection.

 <p>This class has been observed to perform significantly better than {@link
 HashSet} for objects with very fast {@link Object#hashCode} implementations
 (as a well-behaved immutable object should). While this class's factory
 methods create hash-based instances, the {@link ImmutableSortedSet} subclass
 performs binary searches instead.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed
 outside its package as it has no public or protected constructors. Thus,
 instances of this type are guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @see ImmutableList
 @see ImmutableMap
 @author Kevin Bourrillion
 @author Nick Kralevich
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSet -->
  <!-- start class com.google.common.collect.ImmutableSet.Builder -->
  <class name="ImmutableSet.Builder" extends="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSet.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSet#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSet}.  If the {@code
 ImmutableSet} already contains {@code element}, then {@code add} has no
 effect (only the previously added element is retained).

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the {@code Iterable} to add to the {@code ImmutableSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a
     null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSet} based on the contents of
 the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable set instances, especially {@code public
 static final} sets ("constant sets"). Example: <pre>   {@code

   public static final ImmutableSet<Color> GOOGLE_COLORS =
       new ImmutableSet.Builder<Color>()
           .addAll(WEBSAFE_COLORS)
           .add(new Color(0, 191, 255))
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple
 times to build multiple sets in series. Each set is a superset of the set
 created before it.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSet.Builder -->
  <!-- start class com.google.common.collect.ImmutableSetMultimap -->
  <class name="ImmutableSetMultimap" extends="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty multimap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.
 Repeated occurrences of an entry (according to {@link Object#equals}) after
 the first are ignored.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@link Builder}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set multimap containing the same mappings as
 {@code multimap}. The generated multimap's key and value orderings
 correspond to the iteration ordering of the {@code multimap.asMap()} view.
 Repeated occurrences of an entry in the multimap after the first are
 ignored.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code multimap} is
     null]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable set of the values for the given key.  If no mappings
 in the multimap have the provided key, an empty immutable set is returned.
 The values are in the same order as the parameters used to build this
 multimap.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableSetMultimap&lt;V, K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because an inverse of a set multimap cannot contain multiple pairs with
 the same key and value, this method returns an {@code ImmutableSetMultimap}
 rather than the {@code ImmutableMultimap} specified in the {@code
 ImmutableMultimap} class.

 @since 11.0]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="entries" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of all key-value pairs in the multimap.
 Its iterator traverses the values for the first key, the values for the
 second key, and so on.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@link SetMultimap} with reliable user-specified key and value
 iteration order. Does not permit null keys or values.

 <p>Unlike {@link Multimaps#unmodifiableSetMultimap(SetMultimap)}, which is
 a <i>view</i> of a separate multimap which can still change, an instance of
 {@code ImmutableSetMultimap} contains its own data and will <i>never</i>
 change. {@code ImmutableSetMultimap} is convenient for
 {@code public static final} multimaps ("constant multimaps") and also lets
 you easily make a "defensive copy" of a multimap provided to your class by
 a caller.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class
 are guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Mike Ward
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSetMultimap -->
  <!-- start class com.google.common.collect.ImmutableSetMultimap.Builder -->
  <class name="ImmutableSetMultimap.Builder" extends="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSetMultimap.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSetMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds a key-value mapping to the built multimap if it is not already
 present.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds an entry to the built multimap if it is not already present.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="orderKeysBy" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 8.0]]>
      </doc>
    </method>
    <method name="orderValuesBy" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated multimap's values for each key.

 <p>If this method is called, the sets returned by the {@code get()}
 method of the generated multimap and its {@link Multimap#asMap()} view
 are {@link ImmutableSortedSet} instances. However, serialization does not
 preserve that property, though it does maintain the key and value
 ordering.

 @since 8.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable set multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable {@code SetMultimap} instances, especially
 {@code public static final} multimaps ("constant multimaps"). Example:
 <pre>   {@code

   static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
       new ImmutableSetMultimap.Builder<String, Integer>()
           .put("one", 1)
           .putAll("several", 1, 2, 3)
           .putAll("many", 1, 2, 3, 4, 5)
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple
 times to build multiple multimaps in series. Each multimap contains the
 key-value mappings in the previously created multimaps.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSetMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedMap -->
  <class name="ImmutableSortedMap" extends="com.google.common.collect.ImmutableSortedMapFauxverideShim&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableMap&lt;K, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty sorted map.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if the two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if any two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if any two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the
 natural ordering of their keys.

 @throws IllegalArgumentException if any two keys are equal according to
     their natural ordering]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}, sorted
 by the natural ordering of the keys.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 <p>This method is not type-safe, as it may be called on a map with keys
 that are not mutually comparable.

 @throws ClassCastException if the keys in {@code map} are not mutually
         comparable
 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to
         their natural ordering]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}, with
 keys sorted by the provided comparator.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to the
         comparator]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as the provided sorted
 map, with the same ordering.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps whose keys are
 ordered by their natural ordering. The sorted maps use {@link
 Ordering#natural()} as the comparator.

 <p>Note: the type parameter {@code K} extends {@code Comparable<K>} rather
 than {@code Comparable<? super K>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps with an explicit
 comparator. If the comparator has a more general type than the map's keys,
 such as creating a {@code SortedMap<Integer, String>} with a {@code
 Comparator<Number>}, use the {@link Builder} constructor instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps whose keys are
 ordered by the reverse of their natural ordering.

 <p>Note: the type parameter {@code K} extends {@code Comparable<K>} rather
 than {@code Comparable<? super K>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the mappings in this map, sorted by the key
 ordering.]]>
      </doc>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSortedSet&lt;K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable sorted set of the keys in this map.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this map, sorted by the
 ordering of the corresponding keys.]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the keys, which is
 {@link Ordering#natural()} when the natural ordering of the keys is used.
 Note that its behavior is not consistent with {@link TreeMap#comparator()},
 which returns {@code null} to indicate natural ordering.]]>
      </doc>
    </method>
    <method name="firstKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lastKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys are less than {@code toKey}.

 <p>The {@link SortedMap#headMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code toKey}
 greater than an earlier {@code toKey}. However, this method doesn't throw
 an exception in that situation, but instead keeps the original {@code
 toKey}.]]>
      </doc>
    </method>
    <method name="headMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys are less than (or equal to, if {@code inclusive}) {@code toKey}.

 <p>The {@link SortedMap#headMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code toKey}
 greater than an earlier {@code toKey}. However, this method doesn't throw
 an exception in that situation, but instead keeps the original {@code
 toKey}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="subMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys ranges from {@code fromKey}, inclusive, to {@code toKey},
 exclusive.

 <p>The {@link SortedMap#subMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code
 fromKey} less than an earlier {@code fromKey}. However, this method doesn't
 throw an exception in that situation, but instead keeps the original {@code
 fromKey}. Similarly, this method keeps the original {@code toKey}, instead
 of throwing an exception, if passed a {@code toKey} greater than an earlier
 {@code toKey}.]]>
      </doc>
    </method>
    <method name="subMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toKey" type="K"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys ranges from {@code fromKey} to {@code toKey}, inclusive or
 exclusive as indicated by the boolean flags.

 <p>The {@link SortedMap#subMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code
 fromKey} less than an earlier {@code fromKey}. However, this method doesn't
 throw an exception in that situation, but instead keeps the original {@code
 fromKey}. Similarly, this method keeps the original {@code toKey}, instead
 of throwing an exception, if passed a {@code toKey} greater than an earlier
 {@code toKey}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="tailMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys are greater than or equals to {@code fromKey}.

 <p>The {@link SortedMap#tailMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code
 fromKey} less than an earlier {@code fromKey}. However, this method doesn't
 throw an exception in that situation, but instead keeps the original {@code
 fromKey}.]]>
      </doc>
    </method>
    <method name="tailMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries
 whose keys are greater than (or equal to, if {@code inclusive})
 {@code fromKey}.

 <p>The {@link SortedMap#tailMap} documentation states that a submap of a
 submap throws an {@link IllegalArgumentException} if passed a {@code
 fromKey} less than an earlier {@code fromKey}. However, this method doesn't
 throw an exception in that situation, but instead keeps the original {@code
 fromKey}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="lowerEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="lowerKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="floorEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="floorKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="ceilingEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="ceilingKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="higherEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="higherKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="firstEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lastEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirstEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="navigableKeySet" return="com.google.common.collect.ImmutableSortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingKeySet" return="com.google.common.collect.ImmutableSortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable {@link SortedMap}. Does not permit null keys or values.

 <p>Unlike {@link Collections#unmodifiableSortedMap}, which is a <i>view</i>
 of a separate map which can still change, an instance of {@code
 ImmutableSortedMap} contains its own data and will <i>never</i> change.
 {@code ImmutableSortedMap} is convenient for {@code public static final} maps
 ("constant maps") and also lets you easily make a "defensive copy" of a map
 provided to your class by a caller.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class are
 guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library; implements {@code
        NavigableMap} since 12.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMap -->
  <!-- start class com.google.common.collect.ImmutableSortedMap.Builder -->
  <class name="ImmutableSortedMap.Builder" extends="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSortedMap.Builder" type="java.util.Comparator&lt;? super K&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSortedMap#orderedBy}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys, according to the comparator (which might be the keys' natural
 order), are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds the given {@code entry} to the map, making it immutable if
 necessary. Duplicate keys, according to the comparator (which might be
 the keys' natural order), are not allowed, and will cause {@link #build}
 to fail.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built map.
 Duplicate keys, according to the comparator (which might be the keys'
 natural order), are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable sorted map.

 @throws IllegalArgumentException if any two keys are equal according to
     the comparator (which might be the keys' natural order)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable sorted map instances, especially {@code
 public static final} maps ("constant maps"). Example: <pre>   {@code

   static final ImmutableSortedMap<Integer, String> INT_TO_WORD =
       new ImmutableSortedMap.Builder<Integer, String>(Ordering.natural())
           .put(1, "one")
           .put(2, "two")
           .put(3, "three")
           .build();}</pre>

 For <i>small</i> immutable sorted maps, the {@code ImmutableSortedMap.of()}
 methods are even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple maps in series. Each map is a superset of
 the maps created before it.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedMultiset -->
  <class name="ImmutableSortedMultiset" extends="com.google.common.collect.ImmutableSortedMultisetFauxverideShim&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SortedMultiset&lt;E&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable sorted multiset.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing a single element.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e6" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="remaining" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering. To create a copy of a {@code SortedMultiset} that preserves the
 comparator, call {@link #copyOfSorted} instead. This method iterates over {@code elements} at
 most once.

 <p>Note that if {@code s} is a {@code multiset<String>}, then {@code
 ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset<String>}
 containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)}
 returns an {@code ImmutableSortedMultiset<multiset<String>>} containing one element (the given
 multiset itself).

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is not type-safe, as it may be called on elements that are not mutually
 comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 <p>This method is not type-safe, as it may be called on elements that are not mutually
 comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by the given {@code
 Comparator}.

 @throws NullPointerException if {@code comparator} or any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by the given {@code
 Comparator}. This method iterates over {@code elements} at most once.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if {@code comparator} or any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedMultiset" type="com.google.common.collect.SortedMultiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the elements of a sorted multiset, sorted by
 the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which
 always uses the natural ordering of the elements.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is safe to use even when {@code sortedMultiset} is a synchronized or concurrent
 collection that is currently being modified by another thread.

 @throws NullPointerException if {@code sortedMultiset} or any of its elements is null]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="elementSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirstEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="headMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="subMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E"/>
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBound" type="E"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="tailMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted multisets with an explicit comparator. If the
 comparator has a more general type than the set being generated, such as creating a {@code
 SortedMultiset<Integer>} with a {@code Comparator<Number>}, use the {@link Builder}
 constructor instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted multisets whose elements are ordered by the
 reverse of their natural ordering.

 <p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather than {@code
 Comparable<? super E>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug 6468354</a>.]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted multisets whose elements are ordered by their
 natural ordering. The sorted multisets use {@link Ordering#natural()} as the comparator. This
 method provides more type-safety than {@link #builder}, as it can be called only for classes
 that implement {@link Comparable}.

 <p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather than {@code
 Comparable<? super E>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug 6468354</a>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@code SortedMultiset} that stores its elements in a sorted array. Some instances
 are ordered by an explicit comparator, while others follow the natural sort ordering of their
 elements. Either way, null elements are not supported.

 <p>Unlike {@link Multisets#unmodifiableSortedMultiset}, which is a <i>view</i> of a separate
 collection that can still change, an instance of {@code ImmutableSortedMultiset} contains its
 own private data and will <i>never</i> change. This class is convenient for {@code public static
 final} multisets ("constant multisets") and also lets you easily make a "defensive copy" of a
 set provided to your class by a caller.

 <p>The multisets returned by the {@link #headMultiset}, {@link #tailMultiset}, and
 {@link #subMultiset} methods share the same array as the original multiset, preventing that
 array from being garbage collected. If this is a concern, the data may be copied into a
 correctly-sized array by calling {@link #copyOfSorted}.

 <p><b>Note on element equivalence:</b> The {@link #contains(Object)},
 {@link #containsAll(Collection)}, and {@link #equals(Object)} implementations must check whether
 a provided object is equivalent to an element in the collection. Unlike most collections, an
 {@code ImmutableSortedMultiset} doesn't use {@link Object#equals} to determine if two elements
 are equivalent. Instead, with an explicit comparator, the following relation determines whether
 elements {@code x} and {@code y} are equivalent:

 <pre>   {@code

   {(x, y) | comparator.compare(x, y) == 0}}</pre>

 With natural ordering of elements, the following relation determines whether two elements are
 equivalent:

 <pre>   {@code

   {(x, y) | x.compareTo(y) == 0}}</pre>

 <b>Warning:</b> Like most multisets, an {@code ImmutableSortedMultiset} will not function
 correctly if an element is modified after being placed in the multiset. For this reason, and to
 avoid general confusion, it is strongly recommended to place only immutable objects into this
 collection.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as it has no public or
 protected constructors. Thus, instances of this type are guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Louis Wasserman
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMultiset -->
  <!-- start class com.google.common.collect.ImmutableSortedMultiset.Builder -->
  <class name="ImmutableSortedMultiset.Builder" extends="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSortedMultiset.Builder" type="java.util.Comparator&lt;? super E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by
 {@link ImmutableSortedMultiset#orderedBy(Comparator)}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSortedMultiset}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="addCopies" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.

 @param element the element to add
 @param occurrences the number of occurrences of the element to add. May be zero, in which
        case no change will be made.
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation
         would result in more than {@link Integer#MAX_VALUE} occurrences of the element]]>
      </doc>
    </method>
    <method name="setCount" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the element attains the
 desired count.

 @param element the element to add or remove occurrences of
 @param count the desired count of the element in this multiset
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.

 @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.

 @param elements the elements to add to the {@code ImmutableSortedMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code
 Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multiset instances, especially {@code public static final}
 multisets ("constant multisets"). Example:

 <pre> {@code

   public static final ImmutableSortedMultiset<Bean> BEANS =
       new ImmutableSortedMultiset.Builder<Bean>()
           .addCopies(Bean.COCOA, 4)
           .addCopies(Bean.GARDEN, 6)
           .addCopies(Bean.RED, 8)
           .addCopies(Bean.BLACK_EYED, 10)
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple multisets in series.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMultiset.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedSet -->
  <class name="ImmutableSortedSet" extends="com.google.common.collect.ImmutableSortedSetFauxverideShim&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableSet&lt;E&gt;"/>
    <implements name="com.google.common.collect.SortedIterable&lt;E&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable sorted set.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing a single element.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e6" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="remaining" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any element is null
 @since 3.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@link Comparable#compareTo}, only the first one specified is included.

 @throws NullPointerException if any of {@code elements} is null
 @since 3.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@code compareTo()}, only the first one specified is included. To create a
 copy of a {@code SortedSet} that preserves the comparator, call {@link
 #copyOfSorted} instead. This method iterates over {@code elements} at most
 once.


 <p>Note that if {@code s} is a {@code Set<String>}, then {@code
 ImmutableSortedSet.copyOf(s)} returns an {@code ImmutableSortedSet<String>}
 containing each of the strings in {@code s}, while {@code
 ImmutableSortedSet.of(s)} returns an {@code
 ImmutableSortedSet<Set<String>>} containing one element (the given set
 itself).

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 <p>This method is not type-safe, as it may be called on elements that are
 not mutually comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@code compareTo()}, only the first one specified is included. To create a
 copy of a {@code SortedSet} that preserves the comparator, call
 {@link #copyOfSorted} instead. This method iterates over {@code elements}
 at most once.

 <p>Note that if {@code s} is a {@code Set<String>}, then
 {@code ImmutableSortedSet.copyOf(s)} returns an
 {@code ImmutableSortedSet<String>} containing each of the strings in
 {@code s}, while {@code ImmutableSortedSet.of(s)} returns an
 {@code ImmutableSortedSet<Set<String>>} containing one element (the given
 set itself).

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements}
 is an {@code ImmutableSortedSet}, it may be returned instead of a copy.

 <p>This method is not type-safe, as it may be called on elements that are
 not mutually comparable.

 <p>This method is safe to use even when {@code elements} is a synchronized
 or concurrent collection that is currently being modified by another
 thread.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 their natural ordering. When multiple elements are equivalent according to
 {@code compareTo()}, only the first one specified is included.

 <p>This method is not type-safe, as it may be called on elements that are
 not mutually comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 the given {@code Comparator}. When multiple elements are equivalent
 according to {@code compareTo()}, only the first one specified is
 included.

 @throws NullPointerException if {@code comparator} or any of
     {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 the given {@code Comparator}. When multiple elements are equivalent
 according to {@code compare()}, only the first one specified is
 included. This method iterates over {@code elements} at most once.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 @throws NullPointerException if {@code comparator} or any of {@code
         elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by
 the given {@code Comparator}. When multiple elements are equivalent
 according to {@code compareTo()}, only the first one specified is
 included.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 <p>This method is safe to use even when {@code elements} is a synchronized
 or concurrent collection that is currently being modified by another
 thread.

 @throws NullPointerException if {@code comparator} or any of
     {@code elements} is null
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedSet" type="java.util.SortedSet&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the elements of a sorted set,
 sorted by the same {@code Comparator}. That behavior differs from {@link
 #copyOf(Iterable)}, which always uses the natural ordering of the
 elements.

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.

 <p>This method is safe to use even when {@code sortedSet} is a synchronized
 or concurrent collection that is currently being modified by another
 thread.

 @throws NullPointerException if {@code sortedSet} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets with an explicit
 comparator. If the comparator has a more general type than the set being
 generated, such as creating a {@code SortedSet<Integer>} with a
 {@code Comparator<Number>}, use the {@link Builder} constructor instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets whose elements are
 ordered by the reverse of their natural ordering.

 <p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather
 than {@code Comparable<? super E>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets whose elements are
 ordered by their natural ordering. The sorted sets use {@link
 Ordering#natural()} as the comparator. This method provides more
 type-safety than {@link #builder}, as it can be called only for classes
 that implement {@link Comparable}.

 <p>Note: the type parameter {@code E} extends {@code Comparable<E>} rather
 than {@code Comparable<? super E>} as a workaround for javac <a
 href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6468354">bug
 6468354</a>.]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the elements, which is
 {@link Ordering#natural()} when the natural ordering of the
 elements is used. Note that its behavior is not consistent with
 {@link SortedSet#comparator()}, which returns {@code null} to indicate
 natural ordering.]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#headSet} documentation states that a subset of a
 subset throws an {@link IllegalArgumentException} if passed a
 {@code toElement} greater than an earlier {@code toElement}. However, this
 method doesn't throw an exception in that situation, but instead keeps the
 original {@code toElement}.]]>
      </doc>
    </method>
    <method name="headSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="subSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#subSet} documentation states that a subset of a
 subset throws an {@link IllegalArgumentException} if passed a
 {@code fromElement} smaller than an earlier {@code fromElement}. However,
 this method doesn't throw an exception in that situation, but instead keeps
 the original {@code fromElement}. Similarly, this method keeps the
 original {@code toElement}, instead of throwing an exception, if passed a
 {@code toElement} greater than an earlier {@code toElement}.]]>
      </doc>
    </method>
    <method name="subSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="E"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="tailSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#tailSet} documentation states that a subset of a
 subset throws an {@link IllegalArgumentException} if passed a
 {@code fromElement} smaller than an earlier {@code fromElement}. However,
 this method doesn't throw an exception in that situation, but instead keeps
 the original {@code fromElement}.]]>
      </doc>
    </method>
    <method name="tailSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="lower" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="floor" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="ceiling" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="higher" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="descendingSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="descendingIterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable {@code SortedSet} that stores its elements in a sorted array.
 Some instances are ordered by an explicit comparator, while others follow the
 natural sort ordering of their elements. Either way, null elements are not
 supported.

 <p>Unlike {@link Collections#unmodifiableSortedSet}, which is a <i>view</i>
 of a separate collection that can still change, an instance of {@code
 ImmutableSortedSet} contains its own private data and will <i>never</i>
 change. This class is convenient for {@code public static final} sets
 ("constant sets") and also lets you easily make a "defensive copy" of a set
 provided to your class by a caller.

 <p>The sets returned by the {@link #headSet}, {@link #tailSet}, and
 {@link #subSet} methods share the same array as the original set, preventing
 that array from being garbage collected. If this is a concern, the data may
 be copied into a correctly-sized array by calling {@link #copyOfSorted}.

 <p><b>Note on element equivalence:</b> The {@link #contains(Object)},
 {@link #containsAll(Collection)}, and {@link #equals(Object)}
 implementations must check whether a provided object is equivalent to an
 element in the collection. Unlike most collections, an
 {@code ImmutableSortedSet} doesn't use {@link Object#equals} to determine if
 two elements are equivalent. Instead, with an explicit comparator, the
 following relation determines whether elements {@code x} and {@code y} are
 equivalent: <pre>   {@code

   {(x, y) | comparator.compare(x, y) == 0}}</pre>

 With natural ordering of elements, the following relation determines whether
 two elements are equivalent: <pre>   {@code

   {(x, y) | x.compareTo(y) == 0}}</pre>

 <b>Warning:</b> Like most sets, an {@code ImmutableSortedSet} will not
 function correctly if an element is modified after being placed in the set.
 For this reason, and to avoid general confusion, it is strongly recommended
 to place only immutable objects into this collection.

 <p><b>Note:</b> Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this type are
 guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @see ImmutableSet
 @author Jared Levy
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library; implements {@code NavigableSet} since 12.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedSet -->
  <!-- start class com.google.common.collect.ImmutableSortedSet.Builder -->
  <class name="ImmutableSortedSet.Builder" extends="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableSortedSet.Builder" type="java.util.Comparator&lt;? super E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableSortedSet#orderedBy}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSortedSet}.  If the
 {@code ImmutableSortedSet} already contains {@code element}, then
 {@code add} has no effect. (only the previously added element
 is retained).

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSortedSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet},
 ignoring duplicate elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSortedSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSortedSet} based on the contents
 of the {@code Builder} and its comparator.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable sorted set instances, especially {@code
 public static final} sets ("constant sets"), with a given comparator.
 Example: <pre>   {@code

   public static final ImmutableSortedSet<Number> LUCKY_NUMBERS =
       new ImmutableSortedSet.Builder<Number>(ODDS_FIRST_COMPARATOR)
           .addAll(SINGLE_DIGIT_PRIMES)
           .add(42)
           .build();}</pre>

 Builder instances can be reused; it is safe to call {@link #build} multiple
 times to build multiple sets in series. Each set is a superset of the set
 created before it.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedSet.Builder -->
  <!-- start class com.google.common.collect.ImmutableTable -->
  <class name="ImmutableTable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Table&lt;R, C, V&gt;"/>
    <method name="of" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty immutable table.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns an immutable table containing a single cell.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable copy of the provided table.

 <p>The {@link Table#cellSet()} iteration order of the provided table
 determines the iteration ordering of all views in the returned table. Note
 that some views of the original table and the copied table may have
 different iteration orders. For more control over the ordering, create a
 {@link Builder} and call {@link Builder#orderRowsBy},
 {@link Builder#orderColumnsBy}, and {@link Builder#putAll}

 <p>Despite the method name, this method attempts to avoid actually copying
 the data when it is safe to do so. The exact circumstances under which a
 copy will or will not be performed are undocumented and subject to change.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder
 created by the {@link Builder#ImmutableTable.Builder()} constructor.]]>
      </doc>
    </method>
    <method name="cellSet" return="com.google.common.collect.ImmutableSet&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="column" return="com.google.common.collect.ImmutableMap&lt;R, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws NullPointerException if {@code columnKey} is {@code null}]]>
      </doc>
    </method>
    <method name="columnKeySet" return="com.google.common.collect.ImmutableSet&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="columnMap" return="com.google.common.collect.ImmutableMap&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The value {@code Map<R, V>}s in the returned map are
 {@link ImmutableMap}s as well.]]>
      </doc>
    </method>
    <method name="row" return="com.google.common.collect.ImmutableMap&lt;C, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws NullPointerException if {@code rowKey} is {@code null}]]>
      </doc>
    </method>
    <method name="rowKeySet" return="com.google.common.collect.ImmutableSet&lt;R&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="rowMap" return="com.google.common.collect.ImmutableMap&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The value {@code Map<C, V>}s in the returned map are
 {@link ImmutableMap}s as well.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable {@link Table} with reliable user-specified iteration order.
 Does not permit null keys or values.

 <p><b>Note</b>: Although this class is not final, it cannot be subclassed as
 it has no public or protected constructors. Thus, instances of this class are
 guaranteed to be immutable.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">
 immutable collections</a>.

 @author Gregory Kick
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableTable -->
  <!-- start class com.google.common.collect.ImmutableTable.Builder -->
  <class name="ImmutableTable.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ImmutableTable.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder
 generated by {@link ImmutableTable#builder}.]]>
      </doc>
    </constructor>
    <method name="orderRowsBy" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowComparator" type="java.util.Comparator&lt;? super R&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated table's rows.]]>
      </doc>
    </method>
    <method name="orderColumnsBy" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnComparator" type="java.util.Comparator&lt;? super C&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated table's columns.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates the ({@code rowKey}, {@code columnKey}) pair with {@code
 value} in the built table. Duplicate key pairs are not allowed and will
 cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cell" type="com.google.common.collect.Table.Cell&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds the given {@code cell} to the table, making it immutable if
 necessary. Duplicate key pairs are not allowed and will cause {@link
 #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given table's keys and values in the built table.
 Duplicate row key column key pairs are not allowed, and will cause
 {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code table} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable table.

 @throws IllegalArgumentException if duplicate key pairs were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable table instances, especially {@code public
 static final} tables ("constant tables"). Example: <pre>   {@code

   static final ImmutableTable<Integer, Character, String> SPREADSHEET =
       new ImmutableTable.Builder<Integer, Character, String>()
           .put(1, 'A', "foo")
           .put(1, 'B', "bar")
           .put(2, 'A', "baz")
           .build();}</pre>

 <p>By default, the order in which cells are added to the builder determines
 the iteration ordering of all views in the returned table, with {@link
 #putAll} following the {@link Table#cellSet()} iteration order. However, if
 {@link #orderRowsBy} or {@link #orderColumnsBy} is called, the views are
 sorted by the supplied comparators.

 For empty or single-cell immutable tables, {@link #of()} and
 {@link #of(Object, Object, Object)} are even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #build}
 multiple times to build multiple tables in series. Each table is a superset
 of the tables created before it.

 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableTable.Builder -->
  <!-- start interface com.google.common.collect.Interner -->
  <interface name="Interner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="intern" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="E"/>
      <doc>
      <![CDATA[Chooses and returns the representative instance for any of a collection of
 instances that are equal to each other. If two {@linkplain Object#equals
 equal} inputs are given to this method, both calls will return the same
 instance.  That is, {@code intern(a).equals(a)} always holds, and {@code
 intern(a) == intern(b)} if and only if {@code a.equals(b)}. Note that
 {@code intern(a)} is permitted to return one instance now and a different
 instance later if the original interned instance was garbage-collected.

 <p><b>Warning:</b> do not use with mutable objects.

 @throws NullPointerException if {@code sample} is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides equivalent behavior to {@link String#intern} for other immutable
 types.

 @author Kevin Bourrillion
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Interner -->
  <!-- start class com.google.common.collect.Interners -->
  <class name="Interners" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newStrongInterner" return="com.google.common.collect.Interner&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread-safe interner which retains a strong reference to each instance it has
 interned, thus preventing these instances from being garbage-collected. If this retention is
 acceptable, this implementation may perform better than {@link #newWeakInterner}. Note that
 unlike {@link String#intern}, using this interner does not consume memory in the permanent
 generation.]]>
      </doc>
    </method>
    <method name="newWeakInterner" return="com.google.common.collect.Interner&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread-safe interner which retains a weak reference to each instance it has
 interned, and so does not prevent these instances from being garbage-collected. This most
 likely does not perform as well as {@link #newStrongInterner}, but is the best alternative
 when the memory usage of that implementation is unacceptable. Note that unlike {@link
 String#intern}, using this interner does not consume memory in the permanent generation.]]>
      </doc>
    </method>
    <method name="asFunction" return="com.google.common.base.Function&lt;E, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interner" type="com.google.common.collect.Interner&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a function that delegates to the {@link Interner#intern} method of the given interner.

 @since 8.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static methods pertaining to instances of {@link Interner}.

 @author Kevin Bourrillion
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Interners -->
  <!-- start class com.google.common.collect.Iterables -->
  <class name="Iterables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="unmodifiableIterable" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of {@code iterable}.]]>
      </doc>
    </method>
    <method name="unmodifiableIterable" return="java.lang.Iterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="iterable" type="com.google.common.collect.ImmutableCollection&lt;E&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the number of elements in {@code iterable}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code iterable} contains any object for which {@code equals(element)}
 is true.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that belongs to the provided
 collection.

 <p>This method calls {@link Collection#removeAll} if {@code iterable} is a
 collection, and {@link Iterators#removeAll} otherwise.

 @param removeFrom the iterable to (potentially) remove elements from
 @param elementsToRemove the elements to remove
 @return {@code true} if any element was removed from {@code iterable}]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that does not belong to the
 provided collection.

 <p>This method calls {@link Collection#retainAll} if {@code iterable} is a
 collection, and {@link Iterators#retainAll} otherwise.

 @param removeFrom the iterable to (potentially) remove elements from
 @param elementsToRetain the elements to retain
 @return {@code true} if any element was removed from {@code iterable}]]>
      </doc>
    </method>
    <method name="removeIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that satisfies the provided
 predicate.

 @param removeFrom the iterable to (potentially) remove elements from
 @param predicate a predicate that determines whether an element should
     be removed
 @return {@code true} if any elements were removed from the iterable

 @throws UnsupportedOperationException if the iterable does not support
     {@code remove()}.
 @since 2.0]]>
      </doc>
    </method>
    <method name="elementsEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable1" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="iterable2" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines whether two iterables contain equal elements in the same order.
 More specifically, this method returns {@code true} if {@code iterable1}
 and {@code iterable2} contain the same number of elements and every element
 of {@code iterable1} is equal to the corresponding element of
 {@code iterable2}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string representation of {@code iterable}, with the format
 {@code [e1, e2, ..., en]}.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterable}.

 @throws NoSuchElementException if the iterable is empty
 @throws IllegalArgumentException if the iterable contains multiple
     elements]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterable}, or {@code
 defaultValue} if the iterable is empty.

 @throws IllegalArgumentException if the iterator contains multiple
     elements]]>
      </doc>
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Copies an iterable's elements into an array.

 @param iterable the iterable to copy
 @param type the type of the elements
 @return a newly-allocated array into which all the elements of the iterable
     have been copied]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addTo" type="java.util.Collection&lt;T&gt;"/>
      <param name="elementsToAdd" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Adds all elements in {@code iterable} to {@code collection}.

 @return {@code true} if {@code collection} was modified as a result of this
     operation.]]>
      </doc>
    </method>
    <method name="frequency" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of elements in the specified iterable that equal the
 specified object. This implementation avoids a full iteration when the
 iterable is a {@link Multiset} or {@link Set}.

 @see Collections#frequency]]>
      </doc>
    </method>
    <method name="cycle" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an iterable whose iterators cycle indefinitely over the elements of
 {@code iterable}.

 <p>That iterator supports {@code remove()} if {@code iterable.iterator()}
 does. After {@code remove()} is called, subsequent cycles omit the removed
 element, which is no longer in {@code iterable}. The iterator's
 {@code hasNext()} method returns {@code true} until {@code iterable} is
 empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.

 <p>To cycle over the iterable {@code n} times, use the following:
 {@code Iterables.concat(Collections.nCopies(n, iterable))}]]>
      </doc>
    </method>
    <method name="cycle" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterable whose iterators cycle indefinitely over the provided
 elements.

 <p>After {@code remove} is invoked on a generated iterator, the removed
 element will no longer appear in either that iterator or any other iterator
 created from the same source iterable. That is, this method behaves exactly
 as {@code Iterables.cycle(Lists.newArrayList(elements))}. The iterator's
 {@code hasNext} method returns {@code true} until all of the original
 elements have been removed.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.

 <p>To cycle over the elements {@code n} times, use the following:
 {@code Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines two iterables into a single iterable. The returned iterable has an
 iterator that traverses the elements in {@code a}, followed by the elements
 in {@code b}. The source iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines three iterables into a single iterable. The returned iterable has
 an iterator that traverses the elements in {@code a}, followed by the
 elements in {@code b}, followed by the elements in {@code c}. The source
 iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="d" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines four iterables into a single iterable. The returned iterable has
 an iterator that traverses the elements in {@code a}, followed by the
 elements in {@code b}, followed by the elements in {@code c}, followed by
 the elements in {@code d}. The source iterators are not polled until
 necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable[]"/>
      <doc>
      <![CDATA[Combines multiple iterables into a single iterable. The returned iterable
 has an iterator that traverses the elements of each iterable in
 {@code inputs}. The input iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it.

 @throws NullPointerException if any of the provided iterables is null]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable&lt;? extends java.lang.Iterable&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Combines multiple iterables into a single iterable. The returned iterable
 has an iterator that traverses the elements of each iterable in
 {@code inputs}. The input iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the
 corresponding input iterator supports it. The methods of the returned
 iterable may throw {@code NullPointerException} if any of the input
 iterators is null.]]>
      </doc>
    </method>
    <method name="partition" return="java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterable into unmodifiable sublists of the given size (the final
 iterable may be smaller). For example, partitioning an iterable containing
 {@code [a, b, c, d, e]} with a partition size of 3 yields {@code
 [[a, b, c], [d, e]]} -- an outer iterable containing two inner lists of
 three and two elements, all in the original order.

 <p>Iterators returned by the returned iterable do not support the {@link
 Iterator#remove()} method. The returned lists implement {@link
 RandomAccess}, whether or not the input list does.

 <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link
 Lists#partition(List, int)} instead.

 @param iterable the iterable to return a partitioned view of
 @param size the desired size of each partition (the last may be smaller)
 @return an iterable of unmodifiable lists containing the elements of {@code
     iterable} divided into partitions
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="paddedPartition" return="java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterable into unmodifiable sublists of the given size, padding
 the final iterable with null values if necessary. For example, partitioning
 an iterable containing {@code [a, b, c, d, e]} with a partition size of 3
 yields {@code [[a, b, c], [d, e, null]]} -- an outer iterable containing
 two inner lists of three elements each, all in the original order.

 <p>Iterators returned by the returned iterable do not support the {@link
 Iterator#remove()} method.

 @param iterable the iterable to return a partitioned view of
 @param size the desired size of each partition
 @return an iterable of unmodifiable lists containing the elements of {@code
     iterable} divided into partitions (the final iterable may have
     trailing null elements)
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="filter" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The
 resulting iterable's iterator does not support {@code remove()}.]]>
      </doc>
    </method>
    <method name="filter" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns all instances of class {@code type} in {@code unfiltered}. The
 returned iterable has elements whose class is {@code type} or a subclass of
 {@code type}. The returned iterable's iterator does not support
 {@code remove()}.

 @param unfiltered an iterable containing objects of any type
 @param type the type of elements desired
 @return an unmodifiable iterable containing all elements of the original
     iterable that were of the requested type]]>
      </doc>
    </method>
    <method name="any" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if any element in {@code iterable} satisfies the predicate.]]>
      </doc>
    </method>
    <method name="all" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element in {@code iterable} satisfies the
 predicate. If {@code iterable} is empty, {@code true} is returned.]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterable} that satisfies the given
 predicate; use this method only when such an element is known to exist. If
 it is possible that <i>no</i> element will match, use {@link #tryFind} or
 {@link #find(Iterable, Predicate, Object)} instead.

 @throws NoSuchElementException if no element in {@code iterable} matches
     the given predicate]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterable} that satisfies the given
 predicate, or {@code defaultValue} if none found. Note that this can
 usually be handled more naturally using {@code
 tryFind(iterable, predicate).or(defaultValue)}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="tryFind" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in {@code
 iterable} that satisfies the given predicate, if such an element exists.

 <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code
 null}. If {@code null} is matched in {@code iterable}, a
 NullPointerException will be thrown.

 @since 11.0]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the index in {@code iterable} of the first element that satisfies
 the provided {@code predicate}, or {@code -1} if the Iterable has no such
 elements.

 <p>More formally, returns the lowest index {@code i} such that
 {@code predicate.apply(Iterables.get(iterable, i))} returns {@code true},
 or {@code -1} if there is no such index.

 @since 2.0]]>
      </doc>
    </method>
    <method name="transform" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIterable" type="java.lang.Iterable&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns an iterable that applies {@code function} to each element of {@code
 fromIterable}.

 <p>The returned iterable's iterator supports {@code remove()} if the
 provided iterator does. After a successful {@code remove()} call,
 {@code fromIterable} no longer contains the corresponding element.

 <p>If the input {@code Iterable} is known to be a {@code List} or other
 {@code Collection}, consider {@link Lists#transform} and {@link
 Collections2#transform}.]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the element at the specified position in an iterable.

 @param position position of the element to return
 @return the element at the specified position in {@code iterable}
 @throws IndexOutOfBoundsException if {@code position} is negative or
     greater than or equal to the size of {@code iterable}]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="position" type="int"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the element at the specified position in an iterable or a default
 value otherwise.

 @param position position of the element to return
 @param defaultValue the default value to return if {@code position} is
     greater than or equal to the size of the iterable
 @return the element at the specified position in {@code iterable} or
     {@code defaultValue} if {@code iterable} contains fewer than
     {@code position + 1} elements.
 @throws IndexOutOfBoundsException if {@code position} is negative
 @since 4.0]]>
      </doc>
    </method>
    <method name="getFirst" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterable} or {@code defaultValue} if
 the iterable is empty.  The {@link Iterators} analog to this method is
 {@link Iterators#getNext}.

 @param defaultValue the default value to return if the iterable is empty
 @return the first element of {@code iterable} or the default value
 @since 7.0]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the last element of {@code iterable}.

 @return the last element of {@code iterable}
 @throws NoSuchElementException if the iterable is empty]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the last element of {@code iterable} or {@code defaultValue} if
 the iterable is empty.

 @param defaultValue the value to return if {@code iterable} is empty
 @return the last element of {@code iterable} or the default value
 @since 3.0]]>
      </doc>
    </method>
    <method name="skip" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="numberToSkip" type="int"/>
      <doc>
      <![CDATA[Returns a view of {@code iterable} that skips its first
 {@code numberToSkip} elements. If {@code iterable} contains fewer than
 {@code numberToSkip} elements, the returned iterable skips all of its
 elements.

 <p>Modifications to the underlying {@link Iterable} before a call to
 {@code iterator()} are reflected in the returned iterator. That is, the
 iterator skips the first {@code numberToSkip} elements that exist when the
 {@code Iterator} is created, not when {@code skip()} is called.

 <p>The returned iterable's iterator supports {@code remove()} if the
 iterator of the underlying iterable supports it. Note that it is
 <i>not</i> possible to delete the last skipped element by immediately
 calling {@code remove()} on that iterator, as the {@code Iterator}
 contract states that a call to {@code remove()} before a call to
 {@code next()} will throw an {@link IllegalStateException}.

 @since 3.0]]>
      </doc>
    </method>
    <method name="limit" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="limitSize" type="int"/>
      <doc>
      <![CDATA[Creates an iterable with the first {@code limitSize} elements of the given
 iterable. If the original iterable does not contain that many elements, the
 returned iterator will have the same behavior as the original iterable. The
 returned iterable's iterator supports {@code remove()} if the original
 iterator does.

 @param iterable the iterable to limit
 @param limitSize the maximum number of elements in the returned iterator
 @throws IllegalArgumentException if {@code limitSize} is negative
 @since 3.0]]>
      </doc>
    </method>
    <method name="consumingIterable" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of the supplied iterable that wraps each generated
 {@link Iterator} through {@link Iterators#consumingIterator(Iterator)}.

 <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will
 get entries from {@link Queue#remove()} since {@link Queue}'s iteration
 order is undefined.  Calling {@link Iterator#hasNext()} on a generated
 iterator from the returned iterable may cause an item to be immediately
 dequeued for return on a subsequent call to {@link Iterator#next()}.

 @param iterable the iterable to wrap
 @return a view of the supplied iterable that wraps each generated iterator
     through {@link Iterators#consumingIterator(Iterator)}; for queues,
     an iterable that generates iterators that return and consume the
     queue's elements in queue order

 @see Iterators#consumingIterator(Iterator)
 @since 2.0]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines if the given iterable contains no elements.

 <p>There is no precise {@link Iterator} equivalent to this method, since
 one can only ask an iterator whether it has any elements <i>remaining</i>
 (which one does using {@link Iterator#hasNext}).

 @return {@code true} if the iterable contains no elements]]>
      </doc>
    </method>
    <method name="mergeSorted" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterables" type="java.lang.Iterable&lt;? extends java.lang.Iterable&lt;? extends T&gt;&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an iterable over the merged contents of all given
 {@code iterables}. Equivalent entries will not be de-duplicated.

 <p>Callers must ensure that the source {@code iterables} are in
 non-descending order as this method does not sort its input.

 <p>For any equivalent elements across all {@code iterables}, it is
 undefined which element is returned first.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class contains static utility methods that operate on or return objects
 of type {@code Iterable}. Except as noted, each method has a corresponding
 {@link Iterator}-based method in the {@link Iterators} class.

 <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables
 produced in this class are <i>lazy</i>, which means that their iterators
 only advance the backing iteration when absolutely necessary.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Iterables">
 {@code Iterables}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Iterables -->
  <!-- start class com.google.common.collect.Iterators -->
  <class name="Iterators" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="emptyIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty iterator.

 <p>The {@link Iterable} equivalent of this method is {@link
 ImmutableSet#of()}.]]>
      </doc>
    </method>
    <method name="unmodifiableIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of {@code iterator}.]]>
      </doc>
    </method>
    <method name="unmodifiableIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="iterator" type="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the number of elements remaining in {@code iterator}. The iterator
 will be left exhausted: its {@code hasNext()} method will return
 {@code false}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code iterator} contains {@code element}.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;?&gt;"/>
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Traverses an iterator and removes every element that belongs to the
 provided collection. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param elementsToRemove the elements to remove
 @return {@code true} if any element was removed from {@code iterator}]]>
      </doc>
    </method>
    <method name="removeIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Removes every element that satisfies the provided predicate from the
 iterator. The iterator will be left exhausted: its {@code hasNext()}
 method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param predicate a predicate that determines whether an element should
     be removed
 @return {@code true} if any elements were removed from the iterator
 @since 2.0]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;?&gt;"/>
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Traverses an iterator and removes every element that does not belong to the
 provided collection. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param elementsToRetain the elements to retain
 @return {@code true} if any element was removed from {@code iterator}]]>
      </doc>
    </method>
    <method name="elementsEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator1" type="java.util.Iterator&lt;?&gt;"/>
      <param name="iterator2" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines whether two iterators contain equal elements in the same order.
 More specifically, this method returns {@code true} if {@code iterator1}
 and {@code iterator2} contain the same number of elements and every element
 of {@code iterator1} is equal to the corresponding element of
 {@code iterator2}.

 <p>Note that this will modify the supplied iterators, since they will have
 been advanced some number of elements forward.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string representation of {@code iterator}, with the format
 {@code [e1, e2, ..., en]}. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterator}.

 @throws NoSuchElementException if the iterator is empty
 @throws IllegalArgumentException if the iterator contains multiple
     elements.  The state of the iterator is unspecified.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterator}, or {@code
 defaultValue} if the iterator is empty.

 @throws IllegalArgumentException if the iterator contains multiple
     elements.  The state of the iterator is unspecified.]]>
      </doc>
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Copies an iterator's elements into an array. The iterator will be left
 exhausted: its {@code hasNext()} method will return {@code false}.

 @param iterator the iterator to copy
 @param type the type of the elements
 @return a newly-allocated array into which all the elements of the iterator
         have been copied]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addTo" type="java.util.Collection&lt;T&gt;"/>
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Adds all elements in {@code iterator} to {@code collection}. The iterator
 will be left exhausted: its {@code hasNext()} method will return
 {@code false}.

 @return {@code true} if {@code collection} was modified as a result of this
         operation]]>
      </doc>
    </method>
    <method name="frequency" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of elements in the specified iterator that equal the
 specified object. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.

 @see Collections#frequency]]>
      </doc>
    </method>
    <method name="cycle" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an iterator that cycles indefinitely over the elements of {@code
 iterable}.

 <p>The returned iterator supports {@code remove()} if the provided iterator
 does. After {@code remove()} is called, subsequent cycles omit the removed
 element, which is no longer in {@code iterable}. The iterator's
 {@code hasNext()} method returns {@code true} until {@code iterable} is
 empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.]]>
      </doc>
    </method>
    <method name="cycle" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterator that cycles indefinitely over the provided elements.

 <p>The returned iterator supports {@code remove()} if the provided iterator
 does. After {@code remove()} is called, subsequent cycles omit the removed
 element, but {@code elements} does not change. The iterator's
 {@code hasNext()} method returns {@code true} until all of the original
 elements have been removed.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an
 infinite loop. You should use an explicit {@code break} or be certain that
 you will eventually remove all the elements.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines two iterators into a single iterator. The returned iterator
 iterates across the elements in {@code a}, followed by the elements in
 {@code b}. The source iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.

 <p><b>Note:</b> the current implementation is not suitable for nested
 concatenated iterators, i.e. the following should be avoided when in a loop:
 {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the
 resulting iterator has a cubic complexity to the depth of the nesting.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="c" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines three iterators into a single iterator. The returned iterator
 iterates across the elements in {@code a}, followed by the elements in
 {@code b}, followed by the elements in {@code c}. The source iterators
 are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.

 <p><b>Note:</b> the current implementation is not suitable for nested
 concatenated iterators, i.e. the following should be avoided when in a loop:
 {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the
 resulting iterator has a cubic complexity to the depth of the nesting.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="c" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="d" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines four iterators into a single iterator. The returned iterator
 iterates across the elements in {@code a}, followed by the elements in
 {@code b}, followed by the elements in {@code c}, followed by the elements
 in {@code d}. The source iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.

 <p><b>Note:</b> the current implementation is not suitable for nested
 concatenated iterators, i.e. the following should be avoided when in a loop:
 {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the
 resulting iterator has a cubic complexity to the depth of the nesting.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.util.Iterator[]"/>
      <doc>
      <![CDATA[Combines multiple iterators into a single iterator. The returned iterator
 iterates across the elements of each iterator in {@code inputs}. The input
 iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it.

 <p><b>Note:</b> the current implementation is not suitable for nested
 concatenated iterators, i.e. the following should be avoided when in a loop:
 {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the
 resulting iterator has a cubic complexity to the depth of the nesting.

 @throws NullPointerException if any of the provided iterators is null]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.util.Iterator&lt;? extends java.util.Iterator&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Combines multiple iterators into a single iterator. The returned iterator
 iterates across the elements of each iterator in {@code inputs}. The input
 iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding
 input iterator supports it. The methods of the returned iterator may throw
 {@code NullPointerException} if any of the input iterators is null.

 <p><b>Note:</b> the current implementation is not suitable for nested
 concatenated iterators, i.e. the following should be avoided when in a loop:
 {@code iterator = Iterators.concat(iterator, suffix);}, since iteration over the
 resulting iterator has a cubic complexity to the depth of the nesting.]]>
      </doc>
    </method>
    <method name="partition" return="com.google.common.collect.UnmodifiableIterator&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterator into unmodifiable sublists of the given size (the final
 list may be smaller). For example, partitioning an iterator containing
 {@code [a, b, c, d, e]} with a partition size of 3 yields {@code
 [[a, b, c], [d, e]]} -- an outer iterator containing two inner lists of
 three and two elements, all in the original order.

 <p>The returned lists implement {@link java.util.RandomAccess}.

 @param iterator the iterator to return a partitioned view of
 @param size the desired size of each partition (the last may be smaller)
 @return an iterator of immutable lists containing the elements of {@code
     iterator} divided into partitions
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="paddedPartition" return="com.google.common.collect.UnmodifiableIterator&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterator into unmodifiable sublists of the given size, padding
 the final iterator with null values if necessary. For example, partitioning
 an iterator containing {@code [a, b, c, d, e]} with a partition size of 3
 yields {@code [[a, b, c], [d, e, null]]} -- an outer iterator containing
 two inner lists of three elements each, all in the original order.

 <p>The returned lists implement {@link java.util.RandomAccess}.

 @param iterator the iterator to return a partitioned view of
 @param size the desired size of each partition
 @return an iterator of immutable lists containing the elements of {@code
     iterator} divided into partitions (the final iterable may have
     trailing null elements)
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate.]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Iterator&lt;?&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns all instances of class {@code type} in {@code unfiltered}. The
 returned iterator has elements whose class is {@code type} or a subclass of
 {@code type}.

 @param unfiltered an iterator containing objects of any type
 @param type the type of elements desired
 @return an unmodifiable iterator containing all elements of the original
     iterator that were of the requested type]]>
      </doc>
    </method>
    <method name="any" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if one or more elements returned by {@code iterator}
 satisfy the given predicate.]]>
      </doc>
    </method>
    <method name="all" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element returned by {@code iterator}
 satisfies the given predicate. If {@code iterator} is empty, {@code true}
 is returned.]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterator} that satisfies the given
 predicate; use this method only when such an element is known to exist. If
 no such element is found, the iterator will be left exhausted: its {@code
 hasNext()} method will return {@code false}. If it is possible that
 <i>no</i> element will match, use {@link #tryFind} or {@link
 #find(Iterator, Predicate, Object)} instead.

 @throws NoSuchElementException if no element in {@code iterator} matches
     the given predicate]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterator} that satisfies the given
 predicate. If no such element is found, {@code defaultValue} will be
 returned from this method and the iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}. Note that this can
 usually be handled more naturally using {@code
 tryFind(iterator, predicate).or(defaultValue)}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="tryFind" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in {@code
 iterator} that satisfies the given predicate, if such an element exists. If
 no such element is found, an empty {@link Optional} will be returned from
 this method and the the iterator will be left exhausted: its {@code
 hasNext()} method will return {@code false}.

 <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code
 null}. If {@code null} is matched in {@code iterator}, a
 NullPointerException will be thrown.

 @since 11.0]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the index in {@code iterator} of the first element that satisfies
 the provided {@code predicate}, or {@code -1} if the Iterator has no such
 elements.

 <p>More formally, returns the lowest index {@code i} such that
 {@code predicate.apply(Iterators.get(iterator, i))} returns {@code true},
 or {@code -1} if there is no such index.

 <p>If -1 is returned, the iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.  Otherwise,
 the iterator will be set to the element which satisfies the
 {@code predicate}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="transform" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIterator" type="java.util.Iterator&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns an iterator that applies {@code function} to each element of {@code
 fromIterator}.

 <p>The returned iterator supports {@code remove()} if the provided iterator
 does. After a successful {@code remove()} call, {@code fromIterator} no
 longer contains the corresponding element.]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Advances {@code iterator} {@code position + 1} times, returning the
 element at the {@code position}th position.

 @param position position of the element to return
 @return the element at the specified position in {@code iterator}
 @throws IndexOutOfBoundsException if {@code position} is negative or
     greater than or equal to the number of elements remaining in
     {@code iterator}]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="position" type="int"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Advances {@code iterator} {@code position + 1} times, returning the
 element at the {@code position}th position or {@code defaultValue}
 otherwise.

 @param position position of the element to return
 @param defaultValue the default value to return if the iterator is empty
     or if {@code position} is greater than the number of elements
     remaining in {@code iterator}
 @return the element at the specified position in {@code iterator} or
     {@code defaultValue} if {@code iterator} produces fewer than
     {@code position + 1} elements.
 @throws IndexOutOfBoundsException if {@code position} is negative
 @since 4.0]]>
      </doc>
    </method>
    <method name="getNext" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the next element in {@code iterator} or {@code defaultValue} if
 the iterator is empty.  The {@link Iterables} analog to this method is
 {@link Iterables#getFirst}.

 @param defaultValue the default value to return if the iterator is empty
 @return the next element of {@code iterator} or the default value
 @since 7.0]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Advances {@code iterator} to the end, returning the last element.

 @return the last element of {@code iterator}
 @throws NoSuchElementException if the iterator is empty]]>
      </doc>
    </method>
    <method name="getLast" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Advances {@code iterator} to the end, returning the last element or
 {@code defaultValue} if the iterator is empty.

 @param defaultValue the default value to return if the iterator is empty
 @return the last element of {@code iterator}
 @since 3.0]]>
      </doc>
    </method>
    <method name="skip" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This method has been renamed to {@link #advance(java.util.Iterator, int) advance}.
     This method is scheduled to be deleted in Guava 14.0.">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="numberToSkip" type="int"/>
      <doc>
      <![CDATA[Calls {@code next()} on {@code iterator}, either {@code numberToSkip} times
 or until {@code hasNext()} returns {@code false}, whichever comes first.

 @return the number of elements skipped
 @since 3.0
 @deprecated This method has been renamed to {@link #advance(java.util.Iterator, int) advance}.
     This method is scheduled to be deleted in Guava 14.0.]]>
      </doc>
    </method>
    <method name="advance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="numberToAdvance" type="int"/>
      <doc>
      <![CDATA[Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times
 or until {@code hasNext()} returns {@code false}, whichever comes first.

 @return the number of elements the iterator was advanced
 @since 13.0 (since 3.0 as {@code Iterators.skip})]]>
      </doc>
    </method>
    <method name="limit" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="limitSize" type="int"/>
      <doc>
      <![CDATA[Creates an iterator returning the first {@code limitSize} elements of the
 given iterator. If the original iterator does not contain that many
 elements, the returned iterator will have the same behavior as the original
 iterator. The returned iterator supports {@code remove()} if the original
 iterator does.

 @param iterator the iterator to limit
 @param limitSize the maximum number of elements in the returned iterator
 @throws IllegalArgumentException if {@code limitSize} is negative
 @since 3.0]]>
      </doc>
    </method>
    <method name="consumingIterator" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of the supplied {@code iterator} that removes each element
 from the supplied {@code iterator} as it is returned.

 <p>The provided iterator must support {@link Iterator#remove()} or
 else the returned iterator will fail on the first call to {@code
 next}.

 @param iterator the iterator to remove and return elements from
 @return an iterator that removes and returns elements from the
     supplied iterator
 @since 2.0]]>
      </doc>
    </method>
    <method name="forArray" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterator containing the elements of {@code array} in order. The
 returned iterator is a view of the array; subsequent changes to the array
 will be reflected in the iterator.

 <p><b>Note:</b> It is often preferable to represent your data using a
 collection type, for example using {@link Arrays#asList(Object[])}, making
 this method unnecessary.

 <p>The {@code Iterable} equivalent of this method is either {@link
 Arrays#asList(Object[])}, {@link ImmutableList#copyOf(Object[])}},
 or {@link ImmutableList#of}.]]>
      </doc>
    </method>
    <method name="singletonIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Returns an iterator containing only {@code value}.

 <p>The {@link Iterable} equivalent of this method is {@link
 Collections#singleton}.]]>
      </doc>
    </method>
    <method name="forEnumeration" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumeration" type="java.util.Enumeration&lt;T&gt;"/>
      <doc>
      <![CDATA[Adapts an {@code Enumeration} to the {@code Iterator} interface.

 <p>This method has no equivalent in {@link Iterables} because viewing an
 {@code Enumeration} as an {@code Iterable} is impossible. However, the
 contents can be <i>copied</i> into a collection using {@link
 Collections#list}.]]>
      </doc>
    </method>
    <method name="asEnumeration" return="java.util.Enumeration&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Adapts an {@code Iterator} to the {@code Enumeration} interface.

 <p>The {@code Iterable} equivalent of this method is either {@link
 Collections#enumeration} (if you have a {@link Collection}), or
 {@code Iterators.asEnumeration(collection.iterator())}.]]>
      </doc>
    </method>
    <method name="peekingIterator" return="com.google.common.collect.PeekingIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a {@code PeekingIterator} backed by the given iterator.

 <p>Calls to the {@code peek} method with no intervening calls to {@code
 next} do not affect the iteration, and hence return the same object each
 time. A subsequent call to {@code next} is guaranteed to return the same
 object again. For example: <pre>   {@code

   PeekingIterator<String> peekingIterator =
       Iterators.peekingIterator(Iterators.forArray("a", "b"));
   String a1 = peekingIterator.peek(); // returns "a"
   String a2 = peekingIterator.peek(); // also returns "a"
   String a3 = peekingIterator.next(); // also returns "a"}</pre>

 Any structural changes to the underlying iteration (aside from those
 performed by the iterator's own {@link PeekingIterator#remove()} method)
 will leave the iterator in an undefined state.

 <p>The returned iterator does not support removal after peeking, as
 explained by {@link PeekingIterator#remove()}.

 <p>Note: If the given iterator is already a {@code PeekingIterator},
 it <i>might</i> be returned to the caller, although this is neither
 guaranteed to occur nor required to be consistent.  For example, this
 method <i>might</i> choose to pass through recognized implementations of
 {@code PeekingIterator} when the behavior of the implementation is
 known to meet the contract guaranteed by this method.

 <p>There is no {@link Iterable} equivalent to this method, so use this
 method to wrap each individual iterator as it is generated.

 @param iterator the backing iterator. The {@link PeekingIterator} assumes
     ownership of this iterator, so users should cease making direct calls
     to it after calling this method.
 @return a peeking iterator backed by that iterator. Apart from the
     additional {@link PeekingIterator#peek()} method, this iterator behaves
     exactly the same as {@code iterator}.]]>
      </doc>
    </method>
    <method name="peekingIterator" return="com.google.common.collect.PeekingIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="iterator" type="com.google.common.collect.PeekingIterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="mergeSorted" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterators" type="java.lang.Iterable&lt;? extends java.util.Iterator&lt;? extends T&gt;&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an iterator over the merged contents of all given
 {@code iterators}, traversing every element of the input iterators.
 Equivalent entries will not be de-duplicated.

 <p>Callers must ensure that the source {@code iterators} are in
 non-descending order as this method does not sort its input.

 <p>For any equivalent elements across all {@code iterators}, it is
 undefined which element is returned first.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class contains static utility methods that operate on or return objects
 of type {@link Iterator}. Except as noted, each method has a corresponding
 {@link Iterable}-based method in the {@link Iterables} class.

 <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators
 produced in this class are <i>lazy</i>, which means that they only advance
 the backing iteration when absolutely necessary.

 <p>See the Guava User Guide section on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Iterables">
 {@code Iterators}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Iterators -->
  <!-- start class com.google.common.collect.LinkedHashMultimap -->
  <class name="LinkedHashMultimap" extends="com.google.common.collect.AbstractSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultimap} with the default initial
 capacities.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code LinkedHashMultimap} with enough capacity to hold
 the specified numbers of keys and values without rehashing.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code
      expectedValuesPerKey} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code LinkedHashMultimap} with the same mappings as the
 specified multimap. If a key-value mapping appears multiple times in the
 input multimap, it only appears once in the constructed multimap. The new
 multimap has the same {@link Multimap#entries()} iteration order as the
 input multimap, except for excluding duplicate mappings.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If {@code values} is not empty and the multimap already contains a
 mapping for {@code key}, the {@code keySet()} ordering is unchanged.
 However, the provided values always come last in the {@link #entries()} and
 {@link #values()} iteration orderings.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of all key-value pairs. Changes to the returned set will
 update the underlying multimap, and vice versa. The entries set does not
 support the {@code add} or {@code addAll} operations.

 <p>The iterator generated by the returned set traverses the entries in the
 order they were added to the multimap.

 <p>Each entry is an immutable snapshot of a key-value mapping in the
 multimap, taken at the time the entry is returned by a method call to the
 collection or its iterator.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all values in the multimap. Changes to the returned
 collection will update the underlying multimap, and vice versa.

 <p>The iterator generated by the returned collection traverses the values
 in the order they were added to the multimap.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} that does not allow duplicate key-value
 entries and that returns collections whose iterators follow the ordering in
 which the data was added to the multimap.

 <p>The collections returned by {@code keySet}, {@code keys}, and {@code
 asMap} iterate through the keys in the order they were first added to the
 multimap. Similarly, {@code get}, {@code removeAll}, and {@code
 replaceValues} return collections that iterate through the values in the
 order they were added. The collections generated by {@code entries} and
 {@code values} iterate across the key-value mappings in the order they were
 added to the multimap.

 <p>The iteration ordering of the collections generated by {@code keySet},
 {@code keys}, and {@code asMap} has a few subtleties. As long as the set of
 keys remains unchanged, adding or removing mappings does not affect the key
 iteration order. However, if you remove all values associated with a key and
 then add the key back to the multimap, that key will come last in the key
 iteration order.

 <p>The multimap does not store duplicate key-value pairs. Adding a new
 key-value pair equal to an existing key-value pair has no effect.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedSetMultimap}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedHashMultimap -->
  <!-- start class com.google.common.collect.LinkedHashMultiset -->
  <class name="LinkedHashMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultiset} using the default initial
 capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distinctElements" type="int"/>
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultiset} with the specified expected
 number of distinct elements.

 @param distinctElements the expected number of distinct elements
 @throws IllegalArgumentException if {@code distinctElements} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code LinkedHashMultiset} containing the specified elements.

 <p>This implementation is highly efficient when {@code elements} is itself
 a {@link Multiset}.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multiset} implementation with predictable iteration order. Its
 iterator orders elements according to when the first occurrence of the
 element was added. When the multiset contains multiple instances of an
 element, those instances are consecutive in the iteration order. If all
 occurrences of an element are removed, after which that element is added to
 the multiset, the element will appear at the end of the iteration.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset">
 {@code Multiset}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedHashMultiset -->
  <!-- start class com.google.common.collect.LinkedListMultimap -->
  <class name="LinkedListMultimap" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedListMultimap} with the default initial
 capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code LinkedListMultimap} with enough capacity to hold
 the specified number of keys without rehashing.

 @param expectedKeys the expected number of distinct keys
 @throws IllegalArgumentException if {@code expectedKeys} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code LinkedListMultimap} with the same mappings as the
 specified {@code Multimap}. The new multimap has the same
 {@link Multimap#entries()} iteration order as the input multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Stores a key-value pair in the multimap.

 @param key key to store in the multimap
 @param value value to store in the multimap
 @return {@code true} always]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If any entries for the specified {@code key} already exist in the
 multimap, their values are changed in-place without affecting the iteration
 order.

 <p>The returned list is immutable and implements
 {@link java.util.RandomAccess}.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The returned list is immutable and implements
 {@link java.util.RandomAccess}.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If the multimap is modified while an iteration over the list is in
 progress (except through the iterator's own {@code add}, {@code set} or
 {@code remove} operations) the results of the iteration are undefined.

 <p>The returned list is not serializable and does not have random access.]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator generated by the returned collection traverses the values
 in the order they were added to the multimap. Because the values may have
 duplicates and follow the insertion ordering, this method returns a {@link
 List}, instead of the {@link Collection} specified in the {@link
 ListMultimap} interface.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.List&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator generated by the returned collection traverses the entries
 in the order they were added to the multimap. Because the entries may have
 duplicates and follow the insertion ordering, this method returns a {@link
 List}, instead of the {@link Collection} specified in the {@link
 ListMultimap} interface.

 <p>An entry's {@link Entry#getKey} method always returns the same key,
 regardless of what happens subsequently. As long as the corresponding
 key-value mapping is not removed from the multimap, {@link Entry#getValue}
 returns the value from the multimap, which may change over time, and {@link
 Entry#setValue} modifies that value. Removing the mapping from the
 multimap does not alter the value returned by {@code getValue()}, though a
 subsequent {@code setValue()} call won't update the multimap but will lead
 to a revised value being returned by {@code getValue()}.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code ListMultimap} instances are equal if, for each key, they
 contain the same values in the same order. If the value orderings disagree,
 the multimaps will not be considered equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multimap.

 <p>The hash code of a multimap is defined as the hash code of the map view,
 as returned by {@link Multimap#asMap}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the multimap, generated by calling
 {@code toString} on the map returned by {@link Multimap#asMap}.

 @return a string representation of the multimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of {@code ListMultimap} that supports deterministic
 iteration order for both keys and values. The iteration order is preserved
 across non-distinct key values. For example, for the following multimap
 definition: <pre>   {@code

   Multimap<K, V> multimap = LinkedListMultimap.create();
   multimap.put(key1, foo);
   multimap.put(key2, bar);
   multimap.put(key1, baz);}</pre>

 ... the iteration order for {@link #keys()} is {@code [key1, key2, key1]},
 and similarly for {@link #entries()}. Unlike {@link LinkedHashMultimap}, the
 iteration order is kept consistent between keys, entries and values. For
 example, calling: <pre>   {@code

   map.remove(key1, foo);}</pre>

 changes the entries iteration order to {@code [key2=bar, key1=baz]} and the
 key iteration order to {@code [key2, key1]}. The {@link #entries()} iterator
 returns mutable map entries, and {@link #replaceValues} attempts to preserve
 iteration order as much as possible.

 <p>The collections returned by {@link #keySet()} and {@link #asMap} iterate
 through the keys in the order they were first added to the multimap.
 Similarly, {@link #get}, {@link #removeAll}, and {@link #replaceValues}
 return collections that iterate through the values in the order they were
 added. The collections generated by {@link #entries()}, {@link #keys()}, and
 {@link #values} iterate across the key-value mappings in the order they were
 added to the multimap.

 <p>The {@link #values()} and {@link #entries()} methods both return a
 {@code List}, instead of the {@code Collection} specified by the {@link
 ListMultimap} interface.

 <p>The methods {@link #get}, {@link #keySet()}, {@link #keys()},
 {@link #values}, {@link #entries()}, and {@link #asMap} return collections
 that are views of the multimap. If the multimap is modified while an
 iteration over any of those collections is in progress, except through the
 iterator's methods, the results of the iteration are undefined.

 <p>Keys and values may be null. All optional multimap methods are supported,
 and all returned views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedListMultimap}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Mike Bostock
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedListMultimap -->
  <!-- start interface com.google.common.collect.ListMultimap -->
  <interface name="ListMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the
 insertion ordering, this method returns a {@link List}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the
 insertion ordering, this method returns a {@link List}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the
 insertion ordering, this method returns a {@link List}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Though the method signature doesn't say so explicitly, the returned map
 has {@link List} values.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code ListMultimap} instances are equal if, for each key, they
 contain the same values in the same order. If the value orderings disagree,
 the multimaps will not be considered equal.

 <p>An empty {@code ListMultimap} is equal to any other empty {@code
 Multimap}, including an empty {@code SetMultimap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multimap} that can hold duplicate key-value pairs and that maintains
 the insertion ordering of values for a given key. See the {@link Multimap}
 documentation for information common to all multimaps.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods
 each return a {@link List} of values. Though the method signature doesn't say
 so explicitly, the map returned by {@link #asMap} has {@code List} values.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.ListMultimap -->
  <!-- start class com.google.common.collect.Lists -->
  <class name="Lists" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code ArrayList} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableList#of()} instead.

 @return a new, empty {@code ArrayList}]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given
 elements.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use an overload of {@link ImmutableList#of()} (for varargs) or
 {@link ImmutableList#copyOf(Object[])} (for an array) instead.

 @param elements the elements that the list should contain, in order
 @return a new {@code ArrayList} containing those elements]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given
 elements.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableList#copyOf(Iterator)} instead.

 @param elements the elements that the list should contain, in order
 @return a new {@code ArrayList} containing those elements]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given
 elements.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableList#copyOf(Iterator)} instead.

 @param elements the elements that the list should contain, in order
 @return a new {@code ArrayList} containing those elements]]>
      </doc>
    </method>
    <method name="newArrayListWithCapacity" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialArraySize" type="int"/>
      <doc>
      <![CDATA[Creates an {@code ArrayList} instance backed by an array of the
 <i>exact</i> size specified; equivalent to
 {@link ArrayList#ArrayList(int)}.

 <p><b>Note:</b> if you know the exact size your list will be, consider
 using a fixed-size list ({@link Arrays#asList(Object[])}) or an {@link
 ImmutableList} instead of a growable {@link ArrayList}.

 <p><b>Note:</b> If you have only an <i>estimate</i> of the eventual size of
 the list, consider padding this estimate by a suitable amount, or simply
 use {@link #newArrayListWithExpectedSize(int)} instead.

 @param initialArraySize the exact size of the initial backing array for
     the returned array list ({@code ArrayList} documentation calls this
     value the "capacity")
 @return a new, empty {@code ArrayList} which is guaranteed not to resize
     itself unless its size reaches {@code initialArraySize + 1}
 @throws IllegalArgumentException if {@code initialArraySize} is negative]]>
      </doc>
    </method>
    <method name="newArrayListWithExpectedSize" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="estimatedSize" type="int"/>
      <doc>
      <![CDATA[Creates an {@code ArrayList} instance sized appropriately to hold an
 <i>estimated</i> number of elements without resizing. A small amount of
 padding is added in case the estimate is low.

 <p><b>Note:</b> If you know the <i>exact</i> number of elements the list
 will hold, or prefer to calculate your own amount of padding, refer to
 {@link #newArrayListWithCapacity(int)}.

 @param estimatedSize an estimate of the eventual {@link List#size()} of
     the new list
 @return a new, empty {@code ArrayList}, sized appropriately to hold the
     estimated number of elements
 @throws IllegalArgumentException if {@code estimatedSize} is negative]]>
      </doc>
    </method>
    <method name="newLinkedList" return="java.util.LinkedList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code LinkedList} instance.

 <p><b>Note:</b> if you need an immutable empty {@link List}, use
 {@link ImmutableList#of()} instead.

 @return a new, empty {@code LinkedList}]]>
      </doc>
    </method>
    <method name="newLinkedList" return="java.util.LinkedList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code LinkedList} instance containing the given elements.

 @param elements the elements that the list should contain, in order
 @return a new {@code LinkedList} containing those elements]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArrayList" return="java.util.concurrent.CopyOnWriteArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code CopyOnWriteArrayList} instance.

 <p><b>Note:</b> if you need an immutable empty {@link List}, use
 {@link Collections#emptyList} instead.

 @return a new, empty {@code CopyOnWriteArrayList}
 @since 12.0]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArrayList" return="java.util.concurrent.CopyOnWriteArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code CopyOnWriteArrayList} instance containing the given elements.

 @param elements the elements that the list should contain, in order
 @return a new {@code CopyOnWriteArrayList} containing those elements
 @since 12.0]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="E"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns an unmodifiable list containing the specified first element and
 backed by the specified array of additional elements. Changes to the {@code
 rest} array will be reflected in the returned list. Unlike {@link
 Arrays#asList}, the returned list is unmodifiable.

 <p>This is useful when a varargs method needs to use a signature such as
 {@code (Foo firstFoo, Foo... moreFoos)}, in order to avoid overload
 ambiguity or to enforce a minimum argument count.

 <p>The returned list is serializable and implements {@link RandomAccess}.

 @param first the first element
 @param rest an array of additional elements, possibly empty
 @return an unmodifiable list containing the specified elements]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="E"/>
      <param name="second" type="E"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns an unmodifiable list containing the specified first and second
 element, and backed by the specified array of additional elements. Changes
 to the {@code rest} array will be reflected in the returned list. Unlike
 {@link Arrays#asList}, the returned list is unmodifiable.

 <p>This is useful when a varargs method needs to use a signature such as
 {@code (Foo firstFoo, Foo secondFoo, Foo... moreFoos)}, in order to avoid
 overload ambiguity or to enforce a minimum argument count.

 <p>The returned list is serializable and implements {@link RandomAccess}.

 @param first the first element
 @param second the second element
 @param rest an array of additional elements, possibly empty
 @return an unmodifiable list containing the specified elements]]>
      </doc>
    </method>
    <method name="transform" return="java.util.List&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromList" type="java.util.List&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a list that applies {@code function} to each element of {@code
 fromList}. The returned list is a transformed view of {@code fromList};
 changes to {@code fromList} will be reflected in the returned list and vice
 versa.

 <p>Since functions are not reversible, the transform is one-way and new
 items cannot be stored in the returned list. The {@code add},
 {@code addAll} and {@code set} methods are unsupported in the returned
 list.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned list to be a view, but it means that the function will be
 applied many times for bulk operations like {@link List#contains} and
 {@link List#hashCode}. For this to perform well, {@code function} should be
 fast. To avoid lazy evaluation when the returned list doesn't need to be a
 view, copy the returned list into a new list of your choosing.

 <p>If {@code fromList} implements {@link RandomAccess}, so will the
 returned list. The returned list is threadsafe if the supplied list and
 function are.

 <p>If only a {@code Collection} or {@code Iterable} input is available, use
 {@link Collections2#transform} or {@link Iterables#transform}.

 <p><b>Note:</b> serializing the returned list is implemented by serializing
 {@code fromList}, its contents, and {@code function} -- <i>not</i> by
 serializing the transformed values. This can lead to surprising behavior,
 so serializing the returned list is <b>not recommended</b>. Instead,
 copy the list using {@link ImmutableList#copyOf(Collection)} (for example),
 then serialize the copy. Other methods similar to this do not implement
 serialization at all for this reason.]]>
      </doc>
    </method>
    <method name="partition" return="java.util.List&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns consecutive {@linkplain List#subList(int, int) sublists} of a list,
 each of the same size (the final list may be smaller). For example,
 partitioning a list containing {@code [a, b, c, d, e]} with a partition
 size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing
 two inner lists of three and two elements, all in the original order.

 <p>The outer list is unmodifiable, but reflects the latest state of the
 source list. The inner lists are sublist views of the original list,
 produced on demand using {@link List#subList(int, int)}, and are subject
 to all the usual caveats about modification as explained in that API.

 @param list the list to return consecutive sublists of
 @param size the desired size of each sublist (the last may be
     smaller)
 @return a list of consecutive sublists
 @throws IllegalArgumentException if {@code partitionSize} is nonpositive]]>
      </doc>
    </method>
    <method name="charactersOf" return="com.google.common.collect.ImmutableList&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a view of the specified string as an immutable list of {@code
 Character} values.

 @since 7.0]]>
      </doc>
    </method>
    <method name="charactersOf" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a view of the specified {@code CharSequence} as a {@code
 List<Character>}, viewing {@code sequence} as a sequence of Unicode code
 units. The view does not support any modification operations, but reflects
 any changes to the underlying character sequence.

 @param sequence the character sequence to view as a {@code List} of
        characters
 @return an {@code List<Character>} view of the character sequence
 @since 7.0]]>
      </doc>
    </method>
    <method name="reverse" return="java.util.List&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a reversed view of the specified list. For example, {@code
 Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3,
 2, 1}. The returned list is backed by this list, so changes in the returned
 list are reflected in this list, and vice-versa. The returned list supports
 all of the optional list operations supported by this list.

 <p>The returned list is random-access if the specified list is random
 access.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link List} instances. Also see this
 class's counterparts {@link Sets} and {@link Maps}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Lists">
 {@code Lists}</a>.

 @author Kevin Bourrillion
 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Lists -->
  <!-- start interface com.google.common.collect.MapConstraint -->
  <interface name="MapConstraint"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="checkKeyValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Throws a suitable {@code RuntimeException} if the specified key or value is
 illegal. Typically this is either a {@link NullPointerException}, an
 {@link IllegalArgumentException}, or a {@link ClassCastException}, though
 an application-specific exception class may be used if appropriate.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a brief human readable description of this constraint, such as
 "Not null".]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constraint on the keys and values that may be added to a {@code Map} or
 {@code Multimap}. For example, {@link MapConstraints#notNull()}, which
 prevents a map from including any null keys or values, could be implemented
 like this: <pre>   {@code

   public void checkKeyValue(Object key, Object value) {
     if (key == null || value == null) {
       throw new NullPointerException();
     }
   }}</pre>

 In order to be effective, constraints should be deterministic; that is, they
 should not depend on state that can change (such as external state, random
 variables, and time) and should only depend on the value of the passed-in key
 and value. A non-deterministic constraint cannot reliably enforce that all
 the collection's elements meet the constraint, since the constraint is only
 enforced when elements are added.

 @author Mike Bostock
 @see MapConstraints
 @see Constraint
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapConstraint -->
  <!-- start class com.google.common.collect.MapConstraints -->
  <class name="MapConstraints" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="notNull" return="com.google.common.collect.MapConstraint&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a constraint that verifies that neither the key nor the value is
 null. If either is null, a {@link NullPointerException} is thrown.]]>
      </doc>
    </method>
    <method name="constrainedMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified map, using the specified
 constraint. Any operations that add new mappings will call the provided
 constraint. However, this method does not verify that existing mappings
 satisfy the constraint.

 <p>The returned map is not serializable.

 @param map the map to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified map]]>
      </doc>
    </method>
    <method name="constrainedMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified multimap, using the specified
 constraint. Any operations that add new mappings will call the provided
 constraint. However, this method does not verify that existing mappings
 satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.

 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the multimap]]>
      </doc>
    </method>
    <method name="constrainedListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified list multimap, using the
 specified constraint. Any operations that add new mappings will call the
 provided constraint. However, this method does not verify that existing
 mappings satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.

 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified multimap]]>
      </doc>
    </method>
    <method name="constrainedSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified set multimap, using the
 specified constraint. Any operations that add new mappings will call the
 provided constraint. However, this method does not verify that existing
 mappings satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.
 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified multimap]]>
      </doc>
    </method>
    <method name="constrainedSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified sorted-set multimap, using the
 specified constraint. Any operations that add new mappings will call the
 provided constraint. However, this method does not verify that existing
 mappings satisfy the constraint.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are not
 constrained.
 <p>The returned multimap is not serializable.

 @param multimap the multimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified multimap]]>
      </doc>
    </method>
    <method name="constrainedBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <param name="constraint" type="com.google.common.collect.MapConstraint&lt;? super K, ? super V&gt;"/>
      <doc>
      <![CDATA[Returns a constrained view of the specified bimap, using the specified
 constraint. Any operations that modify the bimap will have the associated
 keys and values verified with the constraint.

 <p>The returned bimap is not serializable.

 @param map the bimap to constrain
 @param constraint the constraint that validates added entries
 @return a constrained view of the specified bimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory and utilities pertaining to the {@code MapConstraint} interface.

 @see Constraints
 @author Mike Bostock
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MapConstraints -->
  <!-- start interface com.google.common.collect.MapDifference -->
  <interface name="MapDifference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="areEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there are no differences between the two maps;
 that is, if the maps are equal.]]>
      </doc>
    </method>
    <method name="entriesOnlyOnLeft" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries from the left map whose
 keys are not present in the right map.]]>
      </doc>
    </method>
    <method name="entriesOnlyOnRight" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries from the right map whose
 keys are not present in the left map.]]>
      </doc>
    </method>
    <method name="entriesInCommon" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries that appear in both
 maps; that is, the intersection of the two maps.]]>
      </doc>
    </method>
    <method name="entriesDiffering" return="java.util.Map&lt;K, com.google.common.collect.MapDifference.ValueDifference&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map describing keys that appear in both maps, but
 with different values.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this instance for equality. Returns
 {@code true} if the given object is also a {@code MapDifference} and the
 values returned by the {@link #entriesOnlyOnLeft()}, {@link
 #entriesOnlyOnRight()}, {@link #entriesInCommon()} and {@link
 #entriesDiffering()} of the two instances are equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this instance. This is defined as the hash code
 of <pre>   {@code

   Arrays.asList(entriesOnlyOnLeft(), entriesOnlyOnRight(),
       entriesInCommon(), entriesDiffering())}</pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object representing the differences between two maps.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapDifference -->
  <!-- start interface com.google.common.collect.MapDifference.ValueDifference -->
  <interface name="MapDifference.ValueDifference"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="leftValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value from the left map (possibly null).]]>
      </doc>
    </method>
    <method name="rightValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value from the right map (possibly null).]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two instances are considered equal if their {@link #leftValue()}
 values are equal and their {@link #rightValue()} values are also equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hash code equals the value
 {@code Arrays.asList(leftValue(), rightValue()).hashCode()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A difference between the mappings from two maps with the same key. The
 {@link #leftValue} and {@link #rightValue} are not equal, and one but not
 both of them may be null.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapDifference.ValueDifference -->
  <!-- start class com.google.common.collect.MapMaker -->
  <class name="MapMaker" extends="com.google.common.collect.GenericMapMaker&lt;java.lang.Object, java.lang.Object&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapMaker"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@code MapMaker} instance with default settings, including strong keys, strong
 values, and no automatic eviction of any kind.]]>
      </doc>
    </constructor>
    <method name="initialCapacity" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Sets the minimum total size for the internal hash tables. For example, if the initial capacity
 is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each
 having a hash table of size eight. Providing a large enough estimate at construction time
 avoids the need for expensive resizing operations later, but setting this value unnecessarily
 high wastes memory.

 @throws IllegalArgumentException if {@code initialCapacity} is negative
 @throws IllegalStateException if an initial capacity was already set]]>
      </doc>
    </method>
    <method name="concurrencyLevel" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="concurrencyLevel" type="int"/>
      <doc>
      <![CDATA[Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The
 table is internally partitioned to try to permit the indicated number of concurrent updates
 without contention. Because assignment of entries to these partitions is not necessarily
 uniform, the actual concurrency observed may vary. Ideally, you should choose a value to
 accommodate as many threads as will ever concurrently modify the table. Using a significantly
 higher value than you need can waste space and time, and a significantly lower value can lead
 to thread contention. But overestimates and underestimates within an order of magnitude do not
 usually have much noticeable impact. A value of one permits only one thread to modify the map
 at a time, but since read operations can proceed concurrently, this still yields higher
 concurrency than full synchronization. Defaults to 4.

 <p><b>Note:</b> Prior to Guava release 9.0, the default was 16. It is possible the default will
 change again in the future. If you care about this value, you should always choose it
 explicitly.

 @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive
 @throws IllegalStateException if a concurrency level was already set]]>
      </doc>
    </method>
    <method name="weakKeys" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each key (not value) stored in the map should be wrapped in a {@link
 WeakReference} (by default, strong references are used).

 <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})
 comparison to determine equality of keys, which is a technical violation of the {@link Map}
 specification, and may not be what you expect.

 @throws IllegalStateException if the key strength was already set
 @see WeakReference]]>
      </doc>
    </method>
    <method name="softKeys" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #softValues} to create a memory-sensitive map, or {@link #weakKeys} to
     create a map that doesn't hold strong references to the keys.
     lEsS_tHaNb>This method is scheduled for deletion in January 2013.lEsS_tHaN/b>">
      <doc>
      <![CDATA[<b>This method is broken.</b> Maps with soft keys offer no functional advantage over maps with
 weak keys, and they waste memory by keeping unreachable elements in the map. If your goal is to
 create a memory-sensitive map, then consider using soft values instead.

 <p>Specifies that each key (not value) stored in the map should be wrapped in a
 {@link SoftReference} (by default, strong references are used). Softly-referenced objects will
 be garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory
 demand.

 <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})
 comparison to determine equality of keys, which is a technical violation of the {@link Map}
 specification, and may not be what you expect.

 @throws IllegalStateException if the key strength was already set
 @see SoftReference
 @deprecated use {@link #softValues} to create a memory-sensitive map, or {@link #weakKeys} to
     create a map that doesn't hold strong references to the keys.
     <b>This method is scheduled for deletion in January 2013.</b>]]>
      </doc>
    </method>
    <method name="weakValues" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the map should be wrapped in a
 {@link WeakReference} (by default, strong references are used).

 <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor
 candidate for caching; consider {@link #softValues} instead.

 <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})
 comparison to determine equality of values. This technically violates the specifications of
 the methods {@link Map#containsValue containsValue},
 {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and
 {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you
 expect.

 @throws IllegalStateException if the value strength was already set
 @see WeakReference]]>
      </doc>
    </method>
    <method name="softValues" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the map should be wrapped in a
 {@link SoftReference} (by default, strong references are used). Softly-referenced objects will
 be garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory
 demand.

 <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain
 #maximumSize maximum size} instead of using soft references. You should only use this method if
 you are well familiar with the practical consequences of soft references.

 <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})
 comparison to determine equality of values. This technically violates the specifications of
 the methods {@link Map#containsValue containsValue},
 {@link ConcurrentMap#remove(Object, Object) remove(Object, Object)} and
 {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V, V)}, and may not be what you
 expect.

 @throws IllegalStateException if the value strength was already set
 @see SoftReference]]>
      </doc>
    </method>
    <method name="makeMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a thread-safe map, without on-demand computation of values. This method does not alter
 the state of this {@code MapMaker} instance, so it can be invoked again to create multiple
 independent maps.

 <p>The bulk operations {@code putAll}, {@code equals}, and {@code clear} are not guaranteed to
 be performed atomically on the returned map. Additionally, {@code size} and {@code
 containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent
 writes.

 @return a serializable concurrent map having the requested features]]>
      </doc>
    </method>
    <method name="makeComputingMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Caching functionality in {@code MapMaker} is being moved to
     {@link com.google.common.cache.CacheBuilder}, with {@link #makeComputingMap} being replaced
     by {@link com.google.common.cache.CacheBuilder#build}. See the
     lEsS_tHaNa href=quote_cHaRhttp://code.google.com/p/guava-libraries/wiki/MapMakerMigrationquote_cHaR>MapMaker
     Migration GuidelEsS_tHaN/a> for more details.
     lEsS_tHaNb>This method is scheduled for deletion in February 2013.lEsS_tHaN/b>">
      <param name="computingFunction" type="com.google.common.base.Function&lt;? super K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Builds a map that supports atomic, on-demand computation of values. {@link Map#get} either
 returns an already-computed value for the given key, atomically computes it using the supplied
 function, or, if another thread is currently computing the value for this key, simply waits for
 that thread to finish and returns its computed value. Note that the function may be executed
 concurrently by multiple threads, but only for distinct keys.

 <p>New code should use {@link com.google.common.cache.CacheBuilder}, which supports
 {@linkplain com.google.common.cache.CacheStats statistics} collection, introduces the
 {@link com.google.common.cache.CacheLoader} interface for loading entries into the cache
 (allowing checked exceptions to be thrown in the process), and more cleanly separates
 computation from the cache's {@code Map} view.

 <p>If an entry's value has not finished computing yet, query methods besides {@code get} return
 immediately as if an entry doesn't exist. In other words, an entry isn't externally visible
 until the value's computation completes.

 <p>{@link Map#get} on the returned map will never return {@code null}. It may throw:

 <ul>
 <li>{@link NullPointerException} if the key is null or the computing function returns a null
     result
 <li>{@link ComputationException} if an exception was thrown by the computing function. If that
 exception is already of type {@link ComputationException} it is propagated directly; otherwise
 it is wrapped.
 </ul>

 <p><b>Note:</b> Callers of {@code get} <i>must</i> ensure that the key argument is of type
 {@code K}. The {@code get} method accepts {@code Object}, so the key type is not checked at
 compile time. Passing an object of a type other than {@code K} can result in that object being
 unsafely passed to the computing function as type {@code K}, and unsafely stored in the map.

 <p>If {@link Map#put} is called before a computation completes, other threads waiting on the
 computation will wake up and return the stored value.

 <p>This method does not alter the state of this {@code MapMaker} instance, so it can be invoked
 again to create multiple independent maps.

 <p>Insertion, removal, update, and access operations on the returned map safely execute
 concurrently by multiple threads. Iterators on the returned map are weakly consistent,
 returning elements reflecting the state of the map at some point at or since the creation of
 the iterator. They do not throw {@link ConcurrentModificationException}, and may proceed
 concurrently with other operations.

 <p>The bulk operations {@code putAll}, {@code equals}, and {@code clear} are not guaranteed to
 be performed atomically on the returned map. Additionally, {@code size} and {@code
 containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent
 writes.

 @param computingFunction the function used to compute new values
 @return a serializable concurrent map having the requested features
 @deprecated Caching functionality in {@code MapMaker} is being moved to
     {@link com.google.common.cache.CacheBuilder}, with {@link #makeComputingMap} being replaced
     by {@link com.google.common.cache.CacheBuilder#build}. See the
     <a href="http://code.google.com/p/guava-libraries/wiki/MapMakerMigration">MapMaker
     Migration Guide</a> for more details.
     <b>This method is scheduled for deletion in February 2013.</b>]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this MapMaker instance. The exact form of the returned
 string is not specificed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>A builder of {@link ConcurrentMap} instances having any combination of the following features:

 <ul>
 <li>keys or values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain
     SoftReference soft} references
 <li>notification of evicted (or otherwise removed) entries
 <li>on-demand computation of values for keys not already present
 </ul>

 <p>Usage example: <pre>   {@code

   ConcurrentMap<Key, Graph> graphs = new MapMaker()
       .concurrencyLevel(4)
       .weakKeys()
       .makeComputingMap(
           new Function<Key, Graph>() {
             public Graph apply(Key key) {
               return createExpensiveGraph(key);
             }
           });}</pre>

 These features are all optional; {@code new MapMaker().makeMap()} returns a valid concurrent map
 that behaves similarly to a {@link ConcurrentHashMap}.

 <p>The returned map is implemented as a hash table with similar performance characteristics to
 {@link ConcurrentHashMap}. It supports all optional operations of the {@code ConcurrentMap}
 interface. It does not permit null keys or values.

 <p><b>Note:</b> by default, the returned map uses equality comparisons (the {@link Object#equals
 equals} method) to determine equality for keys or values. However, if {@link #weakKeys} or {@link
 #softKeys} was specified, the map uses identity ({@code ==}) comparisons instead for keys.
 Likewise, if {@link #weakValues} or {@link #softValues} was specified, the map uses identity
 comparisons for values.

 <p>The view collections of the returned map have <i>weakly consistent iterators</i>. This means
 that they are safe for concurrent use, but if other threads modify the map after the iterator is
 created, it is undefined which of these changes, if any, are reflected in that iterator. These
 iterators never throw {@link ConcurrentModificationException}.

 <p>If soft or weak references were requested, it is possible for a key or value present in the
 the map to be reclaimed by the garbage collector. If this happens, the entry automatically
 disappears from the map. A partially-reclaimed entry is never exposed to the user. Any {@link
 java.util.Map.Entry} instance retrieved from the map's {@linkplain Map#entrySet entry set} is a
 snapshot of that entry's state at the time of retrieval; such entries do, however, support {@link
 java.util.Map.Entry#setValue}, which simply calls {@link Map#put} on the entry's key.

 <p>The maps produced by {@code MapMaker} are serializable, and the deserialized maps retain all
 the configuration properties of the original map. During deserialization, if the original map had
 used soft or weak references, the entries are reconstructed as they were, but it's not unlikely
 they'll be quickly garbage-collected before they are ever accessed.

 <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for {@link
 java.util.WeakHashMap}, but note that it compares keys using object identity whereas {@code
 WeakHashMap} uses {@link Object#equals}.

 @author Bob Lee
 @author Charles Fry
 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MapMaker -->
  <!-- start class com.google.common.collect.Maps -->
  <class name="Maps" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newHashMap" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code HashMap} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#of()} instead.

 <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link
 #newEnumMap} instead.

 @return a new, empty {@code HashMap}]]>
      </doc>
    </method>
    <method name="newHashMapWithExpectedSize" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates a {@code HashMap} instance, with a high enough "initial capacity"
 that it <i>should</i> hold {@code expectedSize} elements without growth.
 This behavior cannot be broadly guaranteed, but it is observed to be true
 for OpenJDK 1.6. It also can't be guaranteed that the method isn't
 inadvertently <i>oversizing</i> the returned map.

 @param expectedSize the number of elements you expect to add to the
        returned map
 @return a new, empty {@code HashMap} with enough capacity to hold {@code
         expectedSize} elements without resizing
 @throws IllegalArgumentException if {@code expectedSize} is negative]]>
      </doc>
    </method>
    <method name="newHashMap" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as
 the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#copyOf(Map)} instead.

 <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link
 #newEnumMap} instead.

 @param map the mappings to be placed in the new map
 @return a new {@code HashMap} initialized with the mappings from {@code
         map}]]>
      </doc>
    </method>
    <method name="newLinkedHashMap" return="java.util.LinkedHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap}
 instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#of()} instead.

 @return a new, empty {@code LinkedHashMap}]]>
      </doc>
    </method>
    <method name="newLinkedHashMap" return="java.util.LinkedHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance
 with the same mappings as the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableMap#copyOf(Map)} instead.

 @param map the mappings to be placed in the new map
 @return a new, {@code LinkedHashMap} initialized with the mappings from
         {@code map}]]>
      </doc>
    </method>
    <method name="newConcurrentMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a general-purpose instance of {@code ConcurrentMap}, which supports
 all optional operations of the ConcurrentMap interface. It does not permit
 null keys or values. It is serializable.

 <p>This is currently accomplished by calling {@link MapMaker#makeMap()}.

 <p>It is preferable to use {@code MapMaker} directly (rather than through
 this method), as it presents numerous useful configuration options,
 such as the concurrency level, load factor, key/value reference types,
 and value computation.

 @return a new, empty {@code ConcurrentMap}
 @since 3.0]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural
 ordering of its elements.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedMap#of()} instead.

 @return a new, empty {@code TreeMap}]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as
 the specified map and using the same ordering as the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedMap#copyOfSorted(SortedMap)} instead.

 @param map the sorted map whose mappings are to be placed in the new map
        and whose comparator is to be used to sort the new map
 @return a new {@code TreeMap} initialized with the mappings from {@code
         map} and using the comparator of {@code map}]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;C&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given
 comparator.

 <p><b>Note:</b> if mutability is not required, use {@code
 ImmutableSortedMap.orderedBy(comparator).build()} instead.

 @param comparator the comparator to sort the keys with
 @return a new, empty {@code TreeMap}]]>
      </doc>
    </method>
    <method name="newEnumMap" return="java.util.EnumMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;K&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumMap} instance.

 @param type the key type for this map
 @return a new, empty {@code EnumMap}]]>
      </doc>
    </method>
    <method name="newEnumMap" return="java.util.EnumMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumMap} with the same mappings as the specified map.

 @param map the map from which to initialize this {@code EnumMap}
 @return a new {@code EnumMap} initialized with the mappings from {@code
         map}
 @throws IllegalArgumentException if {@code m} is not an {@code EnumMap}
         instance and contains no mappings]]>
      </doc>
    </method>
    <method name="newIdentityHashMap" return="java.util.IdentityHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an {@code IdentityHashMap} instance.

 @return a new, empty {@code IdentityHashMap}]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.MapDifference&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="right" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Computes the difference between two maps. This difference is an immutable
 snapshot of the state of the maps at the time this method is called. It
 will never change, even if the maps change at a later time.

 <p>Since this method uses {@code HashMap} instances internally, the keys of
 the supplied maps must be well-behaved with respect to
 {@link Object#equals} and {@link Object#hashCode}.

 <p><b>Note:</b>If you only need to know whether two maps have the same
 mappings, call {@code left.equals(right)} instead of this method.

 @param left the map to treat as the "left" map for purposes of comparison
 @param right the map to treat as the "right" map for purposes of comparison
 @return the difference between the two maps]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.MapDifference&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="right" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="valueEquivalence" type="com.google.common.base.Equivalence&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Computes the difference between two maps. This difference is an immutable
 snapshot of the state of the maps at the time this method is called. It
 will never change, even if the maps change at a later time.

 <p>Values are compared using a provided equivalence, in the case of
 equality, the value on the 'left' is returned in the difference.

 <p>Since this method uses {@code HashMap} instances internally, the keys of
 the supplied maps must be well-behaved with respect to
 {@link Object#equals} and {@link Object#hashCode}.

 @param left the map to treat as the "left" map for purposes of comparison
 @param right the map to treat as the "right" map for purposes of comparison
 @param valueEquivalence the equivalence relationship to use to compare
    values
 @return the difference between the two maps
 @since 10.0]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.SortedMapDifference&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <param name="right" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Computes the difference between two sorted maps, using the comparator of
 the left map, or {@code Ordering.natural()} if the left map uses the
 natural ordering of its elements. This difference is an immutable snapshot
 of the state of the maps at the time this method is called. It will never
 change, even if the maps change at a later time.

 <p>Since this method uses {@code TreeMap} instances internally, the keys of
 the right map must all compare as distinct according to the comparator
 of the left map.

 <p><b>Note:</b>If you only need to know whether two sorted maps have the
 same mappings, call {@code left.equals(right)} instead of this method.

 @param left the map to treat as the "left" map for purposes of comparison
 @param right the map to treat as the "right" map for purposes of comparison
 @return the difference between the two maps
 @since 11.0]]>
      </doc>
    </method>
    <method name="uniqueIndex" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map for which the {@link Map#values} are the given
 elements in the given order, and each key is the product of invoking a
 supplied function on its corresponding value.

 @param values the values to use when constructing the {@code Map}
 @param keyFunction the function used to produce the key for each value
 @return a map mapping the result of evaluating the function {@code
         keyFunction} on each value in the input collection to that value
 @throws IllegalArgumentException if {@code keyFunction} produces the same
         key for more than one value in the input collection
 @throws NullPointerException if any elements of {@code values} is null, or
         if {@code keyFunction} produces {@code null} for any value]]>
      </doc>
    </method>
    <method name="uniqueIndex" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Iterator&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map for which the {@link Map#values} are the given
 elements in the given order, and each key is the product of invoking a
 supplied function on its corresponding value.

 @param values the values to use when constructing the {@code Map}
 @param keyFunction the function used to produce the key for each value
 @return a map mapping the result of evaluating the function {@code
         keyFunction} on each value in the input collection to that value
 @throws IllegalArgumentException if {@code keyFunction} produces the same
         key for more than one value in the input collection
 @throws NullPointerException if any elements of {@code values} is null, or
         if {@code keyFunction} produces {@code null} for any value
 @since 10.0]]>
      </doc>
    </method>
    <method name="fromProperties" return="com.google.common.collect.ImmutableMap&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates an {@code ImmutableMap<String, String>} from a {@code Properties}
 instance. Properties normally derive from {@code Map<Object, Object>}, but
 they typically contain strings, which is awkward. This method lets you get
 a plain-old-{@code Map} out of a {@code Properties}.

 @param properties a {@code Properties} object to be converted
 @return an immutable map containing all the entries in {@code properties}
 @throws ClassCastException if any key in {@code Properties} is not a {@code
         String}
 @throws NullPointerException if any key or value in {@code Properties} is
         null]]>
      </doc>
    </method>
    <method name="immutableEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map entry with the specified key and value. The {@link
 Entry#setValue} operation throws an {@link UnsupportedOperationException}.

 <p>The returned entry is serializable.

 @param key the key to be associated with the returned entry
 @param value the value to be associated with the returned entry]]>
      </doc>
    </method>
    <method name="synchronizedBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bimap" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) bimap backed by the specified bimap.
 In order to guarantee serial access, it is critical that <b>all</b> access
 to the backing bimap is accomplished through the returned bimap.

 <p>It is imperative that the user manually synchronize on the returned map
 when accessing any of its collection views: <pre>   {@code

   BiMap<Long, String> map = Maps.synchronizedBiMap(
       HashBiMap.<Long, String>create());
   ...
   Set<Long> set = map.keySet();  // Needn't be in synchronized block
   ...
   synchronized (map) {  // Synchronizing on map, not set!
     Iterator<Long> it = set.iterator(); // Must be in synchronized block
     while (it.hasNext()) {
       foo(it.next());
     }
   }}</pre>

 Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned bimap will be serializable if the specified bimap is
 serializable.

 @param bimap the bimap to be wrapped in a synchronized view
 @return a sychronized view of the specified bimap]]>
      </doc>
    </method>
    <method name="unmodifiableBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bimap" type="com.google.common.collect.BiMap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified bimap. This method allows
 modules to provide users with "read-only" access to internal bimaps. Query
 operations on the returned bimap "read through" to the specified bimap, and
 attempts to modify the returned map, whether direct or via its collection
 views, result in an {@code UnsupportedOperationException}.

 <p>The returned bimap will be serializable if the specified bimap is
 serializable.

 @param bimap the bimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified bimap]]>
      </doc>
    </method>
    <method name="transformValues" return="java.util.Map&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.Map&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a map where each value is transformed by a function. All
 other properties of the map, such as iteration order, are left intact. For
 example, the code: <pre>   {@code

   Map<String, Integer> map = ImmutableMap.of("a", 4, "b", 9);
   Function<Integer, Double> sqrt =
       new Function<Integer, Double>() {
         public Double apply(Integer in) {
           return Math.sqrt((int) in);
         }
       };
   Map<String, Double> transformed = Maps.transformValues(map, sqrt);
   System.out.println(transformed);}</pre>

 ... prints {@code {a=2.0, b=3.0}}.

 <p>Changes in the underlying map are reflected in this view. Conversely,
 this view supports removal operations, and these are reflected in the
 underlying map.

 <p>It's acceptable for the underlying map to contain null keys, and even
 null values provided that the function is capable of accepting null input.
 The transformed map might contain null values, if the function sometimes
 gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the
 underlying map is.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned map to be a view, but it means that the function will be
 applied many times for bulk operations like {@link Map#containsValue} and
 {@code Map.toString()}. For this to perform well, {@code function} should
 be fast. To avoid lazy evaluation when the returned map doesn't need to be
 a view, copy the returned map into a new map of your choosing.]]>
      </doc>
    </method>
    <method name="transformValues" return="java.util.SortedMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.SortedMap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a sorted map where each value is transformed by a
 function. All other properties of the map, such as iteration order, are
 left intact. For example, the code: <pre>   {@code

   SortedMap<String, Integer> map = ImmutableSortedMap.of("a", 4, "b", 9);
   Function<Integer, Double> sqrt =
       new Function<Integer, Double>() {
         public Double apply(Integer in) {
           return Math.sqrt((int) in);
         }
       };
   SortedMap<String, Double> transformed =
        Maps.transformSortedValues(map, sqrt);
   System.out.println(transformed);}</pre>

 ... prints {@code {a=2.0, b=3.0}}.

 <p>Changes in the underlying map are reflected in this view. Conversely,
 this view supports removal operations, and these are reflected in the
 underlying map.

 <p>It's acceptable for the underlying map to contain null keys, and even
 null values provided that the function is capable of accepting null input.
 The transformed map might contain null values, if the function sometimes
 gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the
 underlying map is.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned map to be a view, but it means that the function will be
 applied many times for bulk operations like {@link Map#containsValue} and
 {@code Map.toString()}. For this to perform well, {@code function} should
 be fast. To avoid lazy evaluation when the returned map doesn't need to be
 a view, copy the returned map into a new map of your choosing.

 @since 11.0]]>
      </doc>
    </method>
    <method name="transformValues" return="java.util.NavigableMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.NavigableMap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a navigable map where each value is transformed by a
 function. All other properties of the map, such as iteration order, are
 left intact.  For example, the code: <pre>   {@code

   NavigableMap<String, Integer> map = Maps.newTreeMap();
   map.put("a", 4);
   map.put("b", 9);
   Function<Integer, Double> sqrt =
       new Function<Integer, Double>() {
         public Double apply(Integer in) {
           return Math.sqrt((int) in);
         }
       };
   NavigableMap<String, Double> transformed =
        Maps.transformNavigableValues(map, sqrt);
   System.out.println(transformed);}</pre>

 ... prints {@code {a=2.0, b=3.0}}.

 Changes in the underlying map are reflected in this view.
 Conversely, this view supports removal operations, and these are reflected
 in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys, and even
 null values provided that the function is capable of accepting null input.
 The transformed map might contain null values, if the function sometimes
 gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the
 underlying map is.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned map to be a view, but it means that the function will be
 applied many times for bulk operations like {@link Map#containsValue} and
 {@code Map.toString()}. For this to perform well, {@code function} should
 be fast. To avoid lazy evaluation when the returned map doesn't need to be
 a view, copy the returned map into a new map of your choosing.

 @since 13.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="java.util.Map&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.Map&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a map whose values are derived from the original map's
 entries. In contrast to {@link #transformValues}, this method's
 entry-transformation logic may depend on the key as well as the value.

 <p>All other properties of the transformed map, such as iteration order,
 are left intact. For example, the code: <pre>   {@code

   Map<String, Boolean> options =
       ImmutableMap.of("verbose", true, "sort", false);
   EntryTransformer<String, Boolean, String> flagPrefixer =
       new EntryTransformer<String, Boolean, String>() {
         public String transformEntry(String key, Boolean value) {
           return value ? key : "no" + key;
         }
       };
   Map<String, String> transformed =
       Maps.transformEntries(options, flagPrefixer);
   System.out.println(transformed);}</pre>

 ... prints {@code {verbose=verbose, sort=nosort}}.

 <p>Changes in the underlying map are reflected in this view. Conversely,
 this view supports removal operations, and these are reflected in the
 underlying map.

 <p>It's acceptable for the underlying map to contain null keys and null
 values provided that the transformer is capable of accepting null inputs.
 The transformed map might contain null values if the transformer sometimes
 gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the
 underlying map is.

 <p>The transformer is applied lazily, invoked when needed. This is
 necessary for the returned map to be a view, but it means that the
 transformer will be applied many times for bulk operations like {@link
 Map#containsValue} and {@link Object#toString}. For this to perform well,
 {@code transformer} should be fast. To avoid lazy evaluation when the
 returned map doesn't need to be a view, copy the returned map into a new
 map of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of
 {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
 that {@code k2} is also of type {@code K}. Using an {@code
 EntryTransformer} key type for which this may not hold, such as {@code
 ArrayList}, may risk a {@code ClassCastException} when calling methods on
 the transformed map.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="java.util.SortedMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.SortedMap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a sorted map whose values are derived from the original
 sorted map's entries. In contrast to {@link #transformValues}, this
 method's entry-transformation logic may depend on the key as well as the
 value.

 <p>All other properties of the transformed map, such as iteration order,
 are left intact. For example, the code: <pre>   {@code

   Map<String, Boolean> options =
       ImmutableSortedMap.of("verbose", true, "sort", false);
   EntryTransformer<String, Boolean, String> flagPrefixer =
       new EntryTransformer<String, Boolean, String>() {
         public String transformEntry(String key, Boolean value) {
           return value ? key : "yes" + key;
         }
       };
   SortedMap<String, String> transformed =
       LabsMaps.transformSortedEntries(options, flagPrefixer);
   System.out.println(transformed);}</pre>

 ... prints {@code {sort=yessort, verbose=verbose}}.

 <p>Changes in the underlying map are reflected in this view. Conversely,
 this view supports removal operations, and these are reflected in the
 underlying map.

 <p>It's acceptable for the underlying map to contain null keys and null
 values provided that the transformer is capable of accepting null inputs.
 The transformed map might contain null values if the transformer sometimes
 gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the
 underlying map is.

 <p>The transformer is applied lazily, invoked when needed. This is
 necessary for the returned map to be a view, but it means that the
 transformer will be applied many times for bulk operations like {@link
 Map#containsValue} and {@link Object#toString}. For this to perform well,
 {@code transformer} should be fast. To avoid lazy evaluation when the
 returned map doesn't need to be a view, copy the returned map into a new
 map of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of
 {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
 that {@code k2} is also of type {@code K}. Using an {@code
 EntryTransformer} key type for which this may not hold, such as {@code
 ArrayList}, may risk a {@code ClassCastException} when calling methods on
 the transformed map.

 @since 11.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="java.util.NavigableMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.NavigableMap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a navigable map whose values are derived from the
 original navigable map's entries. In contrast to {@link
 #transformValues}, this method's entry-transformation logic may
 depend on the key as well as the value.

 <p>All other properties of the transformed map, such as iteration order,
 are left intact. For example, the code: <pre>   {@code

   NavigableMap<String, Boolean> options = Maps.newTreeMap();
   options.put("verbose", false);
   options.put("sort", true);
   EntryTransformer<String, Boolean, String> flagPrefixer =
       new EntryTransformer<String, Boolean, String>() {
         public String transformEntry(String key, Boolean value) {
           return value ? key : ("yes" + key);
         }
       };
   NavigableMap<String, String> transformed =
       LabsMaps.transformNavigableEntries(options, flagPrefixer);
   System.out.println(transformed);}</pre>

 ... prints {@code {sort=yessort, verbose=verbose}}.

 <p>Changes in the underlying map are reflected in this view.
 Conversely, this view supports removal operations, and these are reflected
 in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys and null
 values provided that the transformer is capable of accepting null inputs.
 The transformed map might contain null values if the transformer sometimes
 gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the
 underlying map is.

 <p>The transformer is applied lazily, invoked when needed. This is
 necessary for the returned map to be a view, but it means that the
 transformer will be applied many times for bulk operations like {@link
 Map#containsValue} and {@link Object#toString}. For this to perform well,
 {@code transformer} should be fast. To avoid lazy evaluation when the
 returned map doesn't need to be a view, copy the returned map into a new
 map of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of
 {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
 that {@code k2} is also of type {@code K}. Using an {@code
 EntryTransformer} key type for which this may not hold, such as {@code
 ArrayList}, may risk a {@code ClassCastException} when calling methods on
 the transformed map.

 @since 13.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} whose keys
 satisfy a predicate. The returned map is a live view of {@code unfiltered};
 changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. When given a key that
 doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}
 methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings whose keys satisfy the
 filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}. Do not provide a
 predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is
 inconsistent with equals.]]>
      </doc>
    </method>
    <method name="filterKeys" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedMap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a sorted map containing the mappings in {@code unfiltered} whose
 keys satisfy a predicate. The returned map is a live view of {@code
 unfiltered}; changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. When given a key that
 doesn't satisfy the predicate, the map's {@code put()} and {@code putAll()}
 methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings whose keys satisfy the
 filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}. Do not provide a
 predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is
 inconsistent with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterValues" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} whose values
 satisfy a predicate. The returned map is a live view of {@code unfiltered};
 changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. When given a value
 that doesn't satisfy the predicate, the map's {@code put()}, {@code
 putAll()}, and {@link Entry#setValue} methods throw an {@link
 IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings whose values satisfy the
 filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}. Do not provide a
 predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is
 inconsistent with equals.]]>
      </doc>
    </method>
    <method name="filterValues" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedMap&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a sorted map containing the mappings in {@code unfiltered} whose
 values satisfy a predicate. The returned map is a live view of {@code
 unfiltered}; changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. When given a value
 that doesn't satisfy the predicate, the map's {@code put()}, {@code
 putAll()}, and {@link Entry#setValue} methods throw an {@link
 IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings whose values satisfy the
 filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}. Do not provide a
 predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is
 inconsistent with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterEntries" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} that satisfy a
 predicate. The returned map is a live view of {@code unfiltered}; changes
 to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. When given a
 key/value pair that doesn't satisfy the predicate, the map's {@code put()}
 and {@code putAll()} methods throw an {@link IllegalArgumentException}.
 Similarly, the map's entries have a {@link Entry#setValue} method that
 throws an {@link IllegalArgumentException} when the existing key and the
 provided value don't satisfy the predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings that satisfy the filter
 will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}.]]>
      </doc>
    </method>
    <method name="filterEntries" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedMap&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a sorted map containing the mappings in {@code unfiltered} that
 satisfy a predicate. The returned map is a live view of {@code unfiltered};
 changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code
 values()} views have iterators that don't support {@code remove()}, but all
 other methods are supported by the map and its views. When given a
 key/value pair that doesn't satisfy the predicate, the map's {@code put()}
 and {@code putAll()} methods throw an {@link IllegalArgumentException}.
 Similarly, the map's entries have a {@link Entry#setValue} method that
 throws an {@link IllegalArgumentException} when the existing key and the
 provided value don't satisfy the predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called
 on the filtered map or its views, only mappings that satisfy the filter
 will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code
 unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()},
 iterate across every key/value mapping in the underlying map and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="unmodifiableNavigableMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.NavigableMap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified navigable map. Query operations on the returned
 map read through to the specified map, and attempts to modify the returned map, whether direct
 or via its views, result in an {@code UnsupportedOperationException}.

 <p>The returned navigable map will be serializable if the specified navigable map is
 serializable.

 @param map the navigable map for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified navigable map
 @since 12.0]]>
      </doc>
    </method>
    <method name="synchronizedNavigableMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="navigableMap" type="java.util.NavigableMap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) navigable map backed by the specified
 navigable map.  In order to guarantee serial access, it is critical that
 <b>all</b> access to the backing navigable map is accomplished
 through the returned navigable map (or its views).

 <p>It is imperative that the user manually synchronize on the returned
 navigable map when iterating over any of its collection views, or the
 collections views of any of its {@code descendingMap}, {@code subMap},
 {@code headMap} or {@code tailMap} views. <pre>   {@code

   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());

   // Needn't be in synchronized block
   NavigableSet<K> set = map.navigableKeySet();

   synchronized (map) { // Synchronizing on map, not set!
     Iterator<K> it = set.iterator(); // Must be in synchronized block
     while (it.hasNext()){
       foo(it.next());
     }
   }}</pre>

 or: <pre>   {@code

   NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());
   NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);

   // Needn't be in synchronized block
   NavigableSet<K> set2 = map2.descendingKeySet();

   synchronized (map) { // Synchronizing on map, not map2 or set2!
     Iterator<K> it = set2.iterator(); // Must be in synchronized block
     while (it.hasNext()){
       foo(it.next());
     }
   }}</pre>

 Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned navigable map will be serializable if the specified
 navigable map is serializable.

 @param navigableMap the navigable map to be "wrapped" in a synchronized
    navigable map.
 @return a synchronized view of the specified navigable map.
 @since 13.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Map} instances (including instances of
 {@link SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts
 {@link Lists}, {@link Sets} and {@link Queues}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Maps">
 {@code Maps}</a>.

 @author Kevin Bourrillion
 @author Mike Bostock
 @author Isaac Shum
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Maps -->
  <!-- start interface com.google.common.collect.Maps.EntryTransformer -->
  <interface name="Maps.EntryTransformer"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transformEntry" return="V2"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V1"/>
      <doc>
      <![CDATA[Determines an output value based on a key-value pair. This method is
 <i>generally expected</i>, but not absolutely required, to have the
 following properties:

 <ul>
 <li>Its execution does not cause any observable side effects.
 <li>The computation is <i>consistent with equals</i>; that is,
     {@link Objects#equal Objects.equal}{@code (k1, k2) &&}
     {@link Objects#equal}{@code (v1, v2)} implies that {@code
     Objects.equal(transformer.transform(k1, v1),
     transformer.transform(k2, v2))}.
 </ul>

 @throws NullPointerException if the key or value is null and this
     transformer does not accept null arguments]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A transformation of the value of a key-value pair, using both key and value
 as inputs. To apply the transformation to a map, use
 {@link Maps#transformEntries(Map, EntryTransformer)}.

 @param <K> the key type of the input and output entries
 @param <V1> the value type of the input entry
 @param <V2> the value type of the output entry
 @since 7.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Maps.EntryTransformer -->
  <!-- start class com.google.common.collect.MinMaxPriorityQueue -->
  <class name="MinMaxPriorityQueue" extends="java.util.AbstractQueue&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new min-max priority queue with default settings: natural order,
 no maximum size, no initial contents, and an initial expected size of 11.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialContents" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new min-max priority queue using natural order, no maximum size,
 and initially containing the given elements.]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;B&gt;"/>
      <doc>
      <![CDATA[Creates and returns a new builder, configured to build {@code
 MinMaxPriorityQueue} instances that use {@code comparator} to determine the
 least and greatest elements.]]>
      </doc>
    </method>
    <method name="expectedSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;java.lang.Comparable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates and returns a new builder, configured to build {@code
 MinMaxPriorityQueue} instances sized appropriately to hold {@code
 expectedSize} elements.]]>
      </doc>
    </method>
    <method name="maximumSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;java.lang.Comparable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maximumSize" type="int"/>
      <doc>
      <![CDATA[Creates and returns a new builder, configured to build {@code
 MinMaxPriorityQueue} instances that are limited to {@code maximumSize}
 elements. Each time a queue grows beyond this bound, it immediately
 removes its greatest element (according to its comparator), which might be
 the element that was just added.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds the given element to this queue. If this queue has a maximum size,
 after adding {@code element} the queue will automatically evict its
 greatest element (according to its comparator), which may be {@code
 element} itself.

 @return {@code true} always]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds the given element to this queue. If this queue has a maximum size,
 after adding {@code element} the queue will automatically evict its
 greatest element (according to its comparator), which may be {@code
 element} itself.]]>
      </doc>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the least element of this queue, or returns {@code
 null} if the queue is empty.]]>
      </doc>
    </method>
    <method name="removeFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the least element of this queue.

 @throws NoSuchElementException if the queue is empty]]>
      </doc>
    </method>
    <method name="peekFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves, but does not remove, the least element of this queue, or returns
 {@code null} if the queue is empty.]]>
      </doc>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the greatest element of this queue, or returns {@code
 null} if the queue is empty.]]>
      </doc>
    </method>
    <method name="removeLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the greatest element of this queue.

 @throws NoSuchElementException if the queue is empty]]>
      </doc>
    </method>
    <method name="peekLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves, but does not remove, the greatest element of this queue, or
 returns {@code null} if the queue is empty.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an iterator over the elements contained in this collection,
 <i>in no particular order</i>.

 <p>The iterator is <i>fail-fast</i>: If the MinMaxPriorityQueue is modified
 at any time after the iterator is created, in any way except through the
 iterator's own remove method, the iterator will generally throw a
 {@link ConcurrentModificationException}. Thus, in the face of concurrent
 modification, the iterator fails quickly and cleanly, rather than risking
 arbitrary, non-deterministic behavior at an undetermined time in the
 future.

 <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
 as it is, generally speaking, impossible to make any hard guarantees in the
 presence of unsynchronized concurrent modification.  Fail-fast iterators
 throw {@code ConcurrentModificationException} on a best-effort basis.
 Therefore, it would be wrong to write a program that depended on this
 exception for its correctness: <i>the fail-fast behavior of iterators
 should be used only to detect bugs.</i>

 @return an iterator over the elements contained in this collection]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator used to order the elements in this queue. Obeys the
 general contract of {@link PriorityQueue#comparator}, but returns {@link
 Ordering#natural} instead of {@code null} to indicate natural ordering.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A double-ended priority queue, which provides constant-time access to both
 its least element and its greatest element, as determined by the queue's
 specified comparator. If no comparator is given at construction time, the
 natural order of elements is used.

 <p>As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its
 head element -- the implicit target of the methods {@link #peek()}, {@link
 #poll()} and {@link #remove()} -- is defined as the <i>least</i> element in
 the queue according to the queue's comparator. But unlike a regular priority
 queue, the methods {@link #peekLast}, {@link #pollLast} and
 {@link #removeLast} are also provided, to act on the <i>greatest</i> element
 in the queue instead.

 <p>A min-max priority queue can be configured with a maximum size. If so,
 each time the size of the queue exceeds that value, the queue automatically
 removes its greatest element according to its comparator (which might be the
 element that was just added). This is different from conventional bounded
 queues, which either block or reject new elements when full.

 <p>This implementation is based on the
 <a href="http://portal.acm.org/citation.cfm?id=6621">min-max heap</a>
 developed by Atkinson, et al. Unlike many other double-ended priority queues,
 it stores elements in a single array, as compact as the traditional heap data
 structure used in {@link PriorityQueue}.

 <p>This class is not thread-safe, and does not accept null elements.

 <p><i>Performance notes:</i>

 <ul>
 <li>The retrieval operations {@link #peek}, {@link #peekFirst}, {@link
     #peekLast}, {@link #element}, and {@link #size} are constant-time
 <li>The enqueing and dequeing operations ({@link #offer}, {@link #add}, and
     all the forms of {@link #poll} and {@link #remove()}) run in {@code
     O(log n) time}
 <li>The {@link #remove(Object)} and {@link #contains} operations require
     linear ({@code O(n)}) time
 <li>If you only access one end of the queue, and don't use a maximum size,
     this class is functionally equivalent to {@link PriorityQueue}, but
     significantly slower.
 </ul>

 @author Sverre Sundsdal
 @author Torbjorn Gannholm
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MinMaxPriorityQueue -->
  <!-- start class com.google.common.collect.MinMaxPriorityQueue.Builder -->
  <class name="MinMaxPriorityQueue.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="expectedSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Configures this builder to build min-max priority queues with an initial
 expected size of {@code expectedSize}.]]>
      </doc>
    </method>
    <method name="maximumSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maximumSize" type="int"/>
      <doc>
      <![CDATA[Configures this builder to build {@code MinMaxPriorityQueue} instances
 that are limited to {@code maximumSize} elements. Each time a queue grows
 beyond this bound, it immediately removes its greatest element (according
 to its comparator), which might be the element that was just added.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new min-max priority queue using the previously specified
 options, and having no initial contents.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialContents" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Builds a new min-max priority queue using the previously specified
 options, and having the given initial elements.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The builder class used in creation of min-max priority queues. Instead of
 constructing one directly, use {@link
 MinMaxPriorityQueue#orderedBy(Comparator)}, {@link
 MinMaxPriorityQueue#expectedSize(int)} or {@link
 MinMaxPriorityQueue#maximumSize(int)}.

 @param <B> the upper bound on the eventual type that can be produced by
     this builder (for example, a {@code Builder<Number>} can produce a
     {@code Queue<Number>} or {@code Queue<Integer>} but not a {@code
     Queue<Object>}).
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MinMaxPriorityQueue.Builder -->
  <!-- start interface com.google.common.collect.Multimap -->
  <interface name="Multimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value pairs in the multimap.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains no key-value pairs.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains any values for the specified
 key.

 @param key key to search for in multimap]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains the specified value for any
 key.

 @param value value to search for in multimap]]>
      </doc>
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the multimap contains the specified key-value pair.

 @param key key to search for in multimap
 @param value value to search for in multimap]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Stores a key-value pair in the multimap.

 <p>Some multimap implementations allow duplicate key-value pairs, in which
 case {@code put} always adds a new key-value pair and increases the
 multimap size by 1. Other implementations prohibit duplicates, and storing
 a key-value pair that's already in the multimap has no effect.

 @param key key to store in the multimap
 @param value value to store in the multimap
 @return {@code true} if the method increased the size of the multimap, or
     {@code false} if the multimap already contained the key-value pair and
     doesn't allow duplicates]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes a single key-value pair from the multimap.

 @param key key of entry to remove from the multimap
 @param value value of entry to remove the multimap
 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key.

 @param key key to store in the multimap
 @param values values to store in the multimap
 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Copies all of another multimap's key-value pairs into this multimap. The
 order in which the mappings are added is determined by
 {@code multimap.entries()}.

 @param multimap mappings to store in this multimap
 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key, replacing any existing
 values for that key.

 @param key key to store in the multimap
 @param values values to store in the multimap
 @return the collection of replaced values, or an empty collection if no
     values were previously associated with the key. The collection
     <i>may</i> be modifiable, but updating it will have no effect on the
     multimap.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes all values associated with a given key.

 @param key key of entries to remove from the multimap
 @return the collection of removed values, or an empty collection if no
     values were associated with the provided key. The collection
     <i>may</i> be modifiable, but updating it will have no effect on the
     multimap.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all key-value pairs from the multimap.]]>
      </doc>
    </method>
    <method name="get" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns a collection view of all values associated with a key. If no
 mappings in the multimap have the provided key, an empty collection is
 returned.

 <p>Changes to the returned collection will update the underlying multimap,
 and vice versa.

 @param key key to search for in multimap
 @return the collection of values that the key maps to]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of all keys, each appearing once in the returned set.
 Changes to the returned set will update the underlying multimap, and vice
 versa.

 @return the collection of distinct keys]]>
      </doc>
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection, which may contain duplicates, of all keys. The number
 of times of key appears in the returned multiset equals the number of
 mappings the key has in the multimap. Changes to the returned multiset will
 update the underlying multimap, and vice versa.

 @return a multiset with keys corresponding to the distinct keys of the
     multimap and frequencies corresponding to the number of values that
     each key maps to]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all values in the multimap. Changes to the returned
 collection will update the underlying multimap, and vice versa.

 @return collection of values, which may include the same value multiple
     times if it occurs in multiple mappings]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Collection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all key-value pairs. Changes to the returned
 collection will update the underlying multimap, and vice versa. The entries
 collection does not support the {@code add} or {@code addAll} operations.

 @return collection of map entries consisting of key-value pairs]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map view that associates each key with the corresponding values
 in the multimap. Changes to the returned map, such as element removal, will
 update the underlying multimap. The map does not support {@code setValue()}
 on its entries, {@code put}, or {@code putAll}.

 <p>When passed a key that is present in the map, {@code
 asMap().get(Object)} has the same behavior as {@link #get}, returning a
 live collection. When passed a key that is not present, however, {@code
 asMap().get(Object)} returns {@code null} instead of an empty collection.

 @return a map view from a key to its collection of values]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this multimap for equality. Two
 multimaps are equal when their map views, as returned by {@link #asMap},
 are also equal.

 <p>In general, two multimaps with identical key-value mappings may or may
 not be equal, depending on the implementation. For example, two
 {@link SetMultimap} instances with the same key-value mappings are equal,
 but equality of two {@link ListMultimap} instances depends on the ordering
 of the values for each key.

 <p>A non-empty {@link SetMultimap} cannot be equal to a non-empty
 {@link ListMultimap}, since their {@link #asMap} views contain unequal
 collections as values. However, any two empty multimaps are equal, because
 they both have empty {@link #asMap} views.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multimap.

 <p>The hash code of a multimap is defined as the hash code of the map view,
 as returned by {@link Multimap#asMap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection that maps keys to values, similar to {@link Map}, but in which
 each key may be associated with <i>multiple</i> values. You can visualize the
 contents of a multimap either as a map from keys to collections of values:

 <ul>
 <li>a # 1, 2
 <li>b # 3
 </ul>

 ... or as a single "flattened" collection of key-value pairs:

 <ul>
 <li>a # 1
 <li>a # 2
 <li>b # 3
 </ul>

 <p><b>Important:</b> although the first interpretation resembles how most
 multimaps are <i>implemented</i>, the design of the {@code Multimap} API is
 based on the <i>second</i> form. So, using the multimap shown above as an
 example, the {@link #size} is {@code 3}, not {@code 2}, and the {@link
 #values} collection is {@code [1, 2, 3]}, not {@code [[1, 2], [3]]}. For
 those times when the first style is more useful, use the multimap's {@link
 #asMap} view.

 <h3>Example</h3>

 <p>The following code: <pre>   {@code

   ListMultimap<String, String> multimap = ArrayListMultimap.create();
   for (President pres : US_PRESIDENTS_IN_ORDER) {
     multimap.put(pres.firstName(), pres.lastName());
   }
   for (String firstName : multimap.keySet()) {
     List<String> lastNames = multimap.get(firstName);
     out.println(firstName + ": " + lastNames);
   }}</pre>

 ... produces output such as: <pre>   {@code

   Zachary: [Taylor]
   John: [Adams, Adams, Tyler, Kennedy]
   George: [Washington, Bush, Bush]
   Grover: [Cleveland]
   ...}</pre>

 <h3>Views</h3>

 <p>Much of the power of the multimap API comes from the <i>view
 collections</i> it provides. These always reflect the latest state of the
 multimap itself. When they support modification, the changes are
 <i>write-through</i> (they automatically update the backing multimap). These
 view collections are:

 <ul>
 <li>{@link #asMap}, mentioned above</li>
 <li>{@link #keys}, {@link #keySet}, {@link #values}, {@link #entries}, which
     are similar to the corresponding view collections of {@link Map}
 <li>and, notably, even the collection returned by {@link #get get(key)} is an
     active view of the values corresponding to {@code key}
 </ul>

 <p>The collections returned by the {@link #replaceValues replaceValues} and
 {@link #removeAll removeAll} methods, which contain values that have just
 been removed from the multimap, are naturally <i>not</i> views.

 <h3>Subinterfaces</h3>

 <p>Instead of using the {@code Multimap} interface directly, prefer the
 subinterfaces {@link ListMultimap} and {@link SetMultimap}. These take their
 names from the fact that the collections they return from {@code get} behave
 like (and, of course, implement) {@link List} and {@link Set}, respectively.

 <p>For example, the "presidents" code snippet above used a {@code
 ListMultimap}; if it had used a {@code SetMultimap} instead, two presidents
 would have vanished, and last names might or might not appear in
 chronological order.

 <h3>Uses</h3>

 <p>Multimaps are commonly used anywhere a {@code Map<K, Collection<V>>} would
 otherwise have appeared. The advantages include:

 <ul>
 <li>There is no need to populate an empty collection before adding an entry
     with {@link #put put}.
 <li>{@code get} never returns {@code null}, only an empty collection.
 <li>It will not retain empty collections after the last value for a key is
     removed. As a result, {@link #containsKey} behaves logically, and the
     multimap won't leak memory.
 <li>The total entry count is available as {@link #size}.
 <li>Many complex operations become easier; for example, {@code
     Collections.min(multimap.values())} finds the smallest value across all
     keys.
 </ul>

 <h3>Implementations</h3>

 <p>As always, prefer the immutable implementations, {@link
 ImmutableListMultimap} and {@link ImmutableSetMultimap}. General-purpose
 mutable implementations are listed above under "All Known Implementing
 Classes". You can also create a <i>custom</i> multimap, backed by any {@code
 Map} and {@link Collection} types, using the {@link Multimaps#newMultimap
 Multimaps.newMultimap} family of methods. Finally, another popular way to
 obtain a multimap is using {@link Multimaps#index Multimaps.index}. See
 the {@link Multimaps} class for these and other static utilities related
 to multimaps.

 <h3>Other Notes</h3>

 <p>All methods that modify the multimap are optional. The view collections
 returned by the multimap may or may not be modifiable. Any modification
 method that is not supported will throw {@link
 UnsupportedOperationException}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multimap -->
  <!-- start class com.google.common.collect.Multimaps -->
  <class name="Multimaps" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Collection&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code Multimap} that uses the provided map and factory. It
 can generate a multimap based on arbitrary {@link Map} and
 {@link Collection} classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()}
 does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 collections generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedMultimap}.

 <p>Call this method only when the simpler methods
 {@link ArrayListMultimap#create()}, {@link HashMultimap#create()},
 {@link LinkedHashMultimap#create()}, {@link LinkedListMultimap#create()},
 {@link TreeMultimap#create()}, and
 {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the collections returned by {@code factory}. Those objects should not be
 manually updated and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty collections that will each hold all
     values for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.List&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListMultimap} that uses the provided map and factory.
 It can generate a multimap based on arbitrary {@link Map} and {@link List}
 classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. The multimap's {@code get}, {@code
 removeAll}, and {@code replaceValues} methods return {@code RandomAccess}
 lists if the factory does. However, the multimap's {@code get} method
 returns instances of a different class than does {@code factory.get()}.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 lists generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedListMultimap}.

 <p>Call this method only when the simpler methods
 {@link ArrayListMultimap#create()} and {@link LinkedListMultimap#create()}
 won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the lists returned by {@code factory}. Those objects should not be manually
 updated, they should be empty when provided, and they should not use soft,
 weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty lists that will each hold all values
     for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Set&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code SetMultimap} that uses the provided map and factory.
 It can generate a multimap based on arbitrary {@link Map} and {@link Set}
 classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()}
 does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 sets generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedSetMultimap}.

 <p>Call this method only when the simpler methods
 {@link HashMultimap#create()}, {@link LinkedHashMultimap#create()},
 {@link TreeMultimap#create()}, and
 {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the sets returned by {@code factory}. Those objects should not be manually
 updated and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty sets that will each hold all values
     for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.SortedSet&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code SortedSetMultimap} that uses the provided map and
 factory. It can generate a multimap based on arbitrary {@link Map} and
 {@link SortedSet} classes.

 <p>The {@code factory}-generated and {@code map} classes determine the
 multimap iteration order. They also specify the behavior of the
 {@code equals}, {@code hashCode}, and {@code toString} methods for the
 multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()}
 does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the
 sets generated by {@code factory}, and the multimap contents are all
 serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the
 multimap, even if {@code map} and the instances generated by
 {@code factory} are. Concurrent read operations will work correctly. To
 allow concurrent update operations, wrap the multimap with a call to
 {@link #synchronizedSortedSetMultimap}.

 <p>Call this method only when the simpler methods
 {@link TreeMultimap#create()} and
 {@link TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and
 the sets returned by {@code factory}. Those objects should not be manually
 updated and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding
     values
 @param factory supplier of new, empty sorted sets that will each hold
     all values for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="invertFrom" return="M extends com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.common.collect.Multimap&lt;? extends V, ? extends K&gt;"/>
      <param name="dest" type="M extends com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Copies each key-value mapping in {@code source} into {@code dest}, with
 its key and value reversed.

 <p>If {@code source} is an {@link ImmutableMultimap}, consider using
 {@link ImmutableMultimap#inverse} instead.

 @param source any multimap
 @param dest the multimap to copy into; usually empty
 @return {@code dest}]]>
      </doc>
    </method>
    <method name="synchronizedMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) multimap backed by the specified
 multimap. In order to guarantee serial access, it is critical that
 <b>all</b> access to the backing multimap is accomplished through the
 returned multimap.

 <p>It is imperative that the user manually synchronize on the returned
 multimap when accessing any of its collection views: <pre>   {@code

   Multimap<K, V> multimap = Multimaps.synchronizedMultimap(
       HashMultimap.<K, V>create());
   ...
   Collection<V> values = multimap.get(key);  // Needn't be in synchronized block
   ...
   synchronized (multimap) {  // Synchronizing on multimap, not values!
     Iterator<V> i = values.iterator(); // Must be in synchronized block
     while (i.hasNext()) {
       foo(i.next());
     }
   }}</pre>

 Failure to follow this advice may result in non-deterministic behavior.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that aren't
 synchronized.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param multimap the multimap to be wrapped in a synchronized view
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified multimap. Query operations on
 the returned multimap "read through" to the specified multimap, and
 attempts to modify the returned multimap, either directly or through the
 multimap's views, result in an {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="delegate" type="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="synchronizedSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code SetMultimap} backed by the
 specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code SetMultimap}. Query
 operations on the returned multimap "read through" to the specified
 multimap, and attempts to modify the returned multimap, either directly or
 through the multimap's views, result in an
 {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="delegate" type="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="synchronizedSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by
 the specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code SortedSetMultimap}.
 Query operations on the returned multimap "read through" to the specified
 multimap, and attempts to modify the returned multimap, either directly or
 through the multimap's views, result in an
 {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="synchronizedListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code ListMultimap} backed by the
 specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code ListMultimap}. Query
 operations on the returned multimap "read through" to the specified
 multimap, and attempts to modify the returned multimap, either directly or
 through the multimap's views, result in an
 {@code UnsupportedOperationException}.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and
 {@link Multimap#replaceValues} methods return collections that are
 modifiable.

 <p>The returned multimap will be serializable if the specified multimap is
 serializable.

 @param delegate the multimap for which an unmodifiable view is to be
     returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="delegate" type="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a multimap view of the specified map. The multimap is backed by the
 map, so changes to the map are reflected in the multimap, and vice versa.
 If the map is modified while an iteration over one of the multimap's
 collection views is in progress (except through the iterator's own {@code
 remove} operation, or through the {@code setValue} operation on a map entry
 returned by the iterator), the results of the iteration are undefined.

 <p>The multimap supports mapping removal, which removes the corresponding
 mapping from the map. It does not support any operations which might add
 mappings, such as {@code put}, {@code putAll} or {@code replaceValues}.

 <p>The returned multimap will be serializable if the specified map is
 serializable.

 @param map the backing map for the returned multimap view]]>
      </doc>
    </method>
    <method name="transformValues" return="com.google.common.collect.Multimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMultimap" type="com.google.common.collect.Multimap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a multimap where each value is transformed by a function.
 All other properties of the multimap, such as iteration order, are left
 intact. For example, the code: <pre>   {@code

 Multimap<String, Integer> multimap =
     ImmutableSetMultimap.of("a", 2, "b", -3, "b", -3, "a", 4, "c", 6);
 Function<Integer, String> square = new Function<Integer, String>() {
     public String apply(Integer in) {
       return Integer.toString(in * in);
     }
 };
 Multimap<String, String> transformed =
     Multimaps.transformValues(multimap, square);
   System.out.println(transformed);}</pre>

 ... prints {@code {a=[4, 16], b=[9, 9], c=[6]}}.

 <p>Changes in the underlying multimap are reflected in this view.
 Conversely, this view supports removal operations, and these are reflected
 in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys, and
 even null values provided that the function is capable of accepting null
 input.  The transformed multimap might contain null values, if the function
 sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the
 underlying multimap is.  The {@code equals} and {@code hashCode} methods
 of the returned multimap are meaningless, since there is not a definition
 of {@code equals} or {@code hashCode} for general collections, and
 {@code get()} will return a general {@code Collection} as opposed to a
 {@code List} or a {@code Set}.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned multimap to be a view, but it means that the function will
 be applied many times for bulk operations like
 {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to
 perform well, {@code function} should be fast. To avoid lazy evaluation
 when the returned multimap doesn't need to be a view, copy the returned
 multimap into a new multimap of your choosing.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="com.google.common.collect.Multimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="com.google.common.collect.Multimap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a multimap whose values are derived from the original
 multimap's entries. In contrast to {@link #transformValues}, this method's
 entry-transformation logic may depend on the key as well as the value.

 <p>All other properties of the transformed multimap, such as iteration
 order, are left intact. For example, the code: <pre>   {@code

   SetMultimap<String, Integer> multimap =
       ImmutableSetMultimap.of("a", 1, "a", 4, "b", -6);
   EntryTransformer<String, Integer, String> transformer =
       new EntryTransformer<String, Integer, String>() {
         public String transformEntry(String key, Integer value) {
            return (value >= 0) ? key : "no" + key;
         }
       };
   Multimap<String, String> transformed =
       Multimaps.transformEntries(multimap, transformer);
   System.out.println(transformed);}</pre>

 ... prints {@code {a=[a, a], b=[nob]}}.

 <p>Changes in the underlying multimap are reflected in this view.
 Conversely, this view supports removal operations, and these are reflected
 in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys and
 null values provided that the transformer is capable of accepting null
 inputs. The transformed multimap might contain null values if the
 transformer sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the
 underlying multimap is.  The {@code equals} and {@code hashCode} methods
 of the returned multimap are meaningless, since there is not a definition
 of {@code equals} or {@code hashCode} for general collections, and
 {@code get()} will return a general {@code Collection} as opposed to a
 {@code List} or a {@code Set}.

 <p>The transformer is applied lazily, invoked when needed. This is
 necessary for the returned multimap to be a view, but it means that the
 transformer will be applied many times for bulk operations like {@link
 Multimap#containsValue} and {@link Object#toString}. For this to perform
 well, {@code transformer} should be fast. To avoid lazy evaluation when the
 returned multimap doesn't need to be a view, copy the returned multimap
 into a new multimap of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of
 {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
 that {@code k2} is also of type {@code K}. Using an {@code
 EntryTransformer} key type for which this may not hold, such as {@code
 ArrayList}, may risk a {@code ClassCastException} when calling methods on
 the transformed multimap.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformValues" return="com.google.common.collect.ListMultimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMultimap" type="com.google.common.collect.ListMultimap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a {@code ListMultimap} where each value is transformed by
 a function. All other properties of the multimap, such as iteration order,
 are left intact. For example, the code: <pre>   {@code

   ListMultimap<String, Integer> multimap
        = ImmutableListMultimap.of("a", 4, "a", 16, "b", 9);
   Function<Integer, Double> sqrt =
       new Function<Integer, Double>() {
         public Double apply(Integer in) {
           return Math.sqrt((int) in);
         }
       };
   ListMultimap<String, Double> transformed = Multimaps.transformValues(map,
       sqrt);
   System.out.println(transformed);}</pre>

 ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.

 <p>Changes in the underlying multimap are reflected in this view.
 Conversely, this view supports removal operations, and these are reflected
 in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys, and
 even null values provided that the function is capable of accepting null
 input.  The transformed multimap might contain null values, if the function
 sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the
 underlying multimap is.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned multimap to be a view, but it means that the function will
 be applied many times for bulk operations like
 {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to
 perform well, {@code function} should be fast. To avoid lazy evaluation
 when the returned multimap doesn't need to be a view, copy the returned
 multimap into a new multimap of your choosing.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="com.google.common.collect.ListMultimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="com.google.common.collect.ListMultimap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a {@code ListMultimap} whose values are derived from the
 original multimap's entries. In contrast to
 {@link #transformValues(ListMultimap, Function)}, this method's
 entry-transformation logic may depend on the key as well as the value.

 <p>All other properties of the transformed multimap, such as iteration
 order, are left intact. For example, the code: <pre>   {@code

   Multimap<String, Integer> multimap =
       ImmutableMultimap.of("a", 1, "a", 4, "b", 6);
   EntryTransformer<String, Integer, String> transformer =
       new EntryTransformer<String, Integer, String>() {
         public String transformEntry(String key, Integer value) {
           return key + value;
         }
       };
   Multimap<String, String> transformed =
       Multimaps.transformEntries(multimap, transformer);
   System.out.println(transformed);}</pre>

 ... prints {@code {"a"=["a1", "a4"], "b"=["b6"]}}.

 <p>Changes in the underlying multimap are reflected in this view.
 Conversely, this view supports removal operations, and these are reflected
 in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys and
 null values provided that the transformer is capable of accepting null
 inputs. The transformed multimap might contain null values if the
 transformer sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the
 underlying multimap is.

 <p>The transformer is applied lazily, invoked when needed. This is
 necessary for the returned multimap to be a view, but it means that the
 transformer will be applied many times for bulk operations like {@link
 Multimap#containsValue} and {@link Object#toString}. For this to perform
 well, {@code transformer} should be fast. To avoid lazy evaluation when the
 returned multimap doesn't need to be a view, copy the returned multimap
 into a new multimap of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of
 {@code EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies
 that {@code k2} is also of type {@code K}. Using an {@code
 EntryTransformer} key type for which this may not hold, such as {@code
 ArrayList}, may risk a {@code ClassCastException} when calling methods on
 the transformed multimap.

 @since 7.0]]>
      </doc>
    </method>
    <method name="index" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Creates an index {@code ImmutableListMultimap} that contains the results of
 applying a specified function to each item in an {@code Iterable} of
 values. Each value will be stored as a value in the resulting multimap,
 yielding a multimap with the same size as the input iterable. The key used
 to store that value in the multimap will be the result of calling the
 function on that value. The resulting multimap is created as an immutable
 snapshot. In the returned multimap, keys appear in the order they are first
 encountered, and the values corresponding to each key appear in the same
 order as they are encountered.

 <p>For example, <pre>   {@code

   List<String> badGuys =
       Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
   Function<String, Integer> stringLengthFunction = ...;
   Multimap<Integer, String> index =
       Multimaps.index(badGuys, stringLengthFunction);
   System.out.println(index);}</pre>

 prints <pre>   {@code

   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>

 The returned multimap is serializable if its keys and values are all
 serializable.

 @param values the values to use when constructing the {@code
     ImmutableListMultimap}
 @param keyFunction the function used to produce the key for each value
 @return {@code ImmutableListMultimap} mapping the result of evaluating the
     function {@code keyFunction} on each value in the input collection to
     that value
 @throws NullPointerException if any of the following cases is true:
     <ul>
     <li>{@code values} is null
     <li>{@code keyFunction} is null
     <li>An element in {@code values} is null
     <li>{@code keyFunction} returns {@code null} for any element of {@code
         values}
     </ul>]]>
      </doc>
    </method>
    <method name="index" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Iterator&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Creates an index {@code ImmutableListMultimap} that contains the results of
 applying a specified function to each item in an {@code Iterator} of
 values. Each value will be stored as a value in the resulting multimap,
 yielding a multimap with the same size as the input iterator. The key used
 to store that value in the multimap will be the result of calling the
 function on that value. The resulting multimap is created as an immutable
 snapshot. In the returned multimap, keys appear in the order they are first
 encountered, and the values corresponding to each key appear in the same
 order as they are encountered.

 <p>For example, <pre>   {@code

   List<String> badGuys =
       Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
   Function<String, Integer> stringLengthFunction = ...;
   Multimap<Integer, String> index =
       Multimaps.index(badGuys.iterator(), stringLengthFunction);
   System.out.println(index);}</pre>

 prints <pre>   {@code

   {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}}</pre>

 The returned multimap is serializable if its keys and values are all
 serializable.

 @param values the values to use when constructing the {@code
     ImmutableListMultimap}
 @param keyFunction the function used to produce the key for each value
 @return {@code ImmutableListMultimap} mapping the result of evaluating the
     function {@code keyFunction} on each value in the input collection to
     that value
 @throws NullPointerException if any of the following cases is true:
     <ul>
     <li>{@code values} is null
     <li>{@code keyFunction} is null
     <li>An element in {@code values} is null
     <li>{@code keyFunction} returns {@code null} for any element of {@code
         values}
     </ul>
 @since 10.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} whose keys
 satisfy a predicate. The returned multimap is a live view of
 {@code unfiltered}; changes to one affect the other.

 <p>The resulting multimap's views have iterators that don't support
 {@code remove()}, but all other methods are supported by the multimap and
 its views. When adding a key that doesn't satisfy the predicate, the
 multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}
 methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on
 the filtered multimap or its views, only mappings whose keys satisfy the
 filter will be removed from the underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate
 across every key/value mapping in the underlying multimap and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered multimap and use the copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>,
 as documented at {@link Predicate#apply}. Do not provide a predicate such
 as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent
 with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterValues" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} whose values
 satisfy a predicate. The returned multimap is a live view of
 {@code unfiltered}; changes to one affect the other.

 <p>The resulting multimap's views have iterators that don't support
 {@code remove()}, but all other methods are supported by the multimap and
 its views. When adding a value that doesn't satisfy the predicate, the
 multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}
 methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on
 the filtered multimap or its views, only mappings whose value satisfy the
 filter will be removed from the underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate
 across every key/value mapping in the underlying multimap and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered multimap and use the copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}. Do not provide a
 predicate such as {@code Predicates.instanceOf(ArrayList.class)}, which is
 inconsistent with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterEntries" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} that
 satisfy a predicate. The returned multimap is a live view of
 {@code unfiltered}; changes to one affect the other.

 <p>The resulting multimap's views have iterators that don't support
 {@code remove()}, but all other methods are supported by the multimap and
 its views. When adding a key/value pair that doesn't satisfy the predicate,
 multimap's {@code put()}, {@code putAll()}, and {@code replaceValues()}
 methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on
 the filtered multimap or its views, only mappings whose keys satisfy the
 filter will be removed from the underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate
 across every key/value mapping in the underlying multimap and determine
 which satisfy the filter. When a live view is <i>not</i> needed, it may be
 faster to copy the filtered multimap and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with
 equals</i>, as documented at {@link Predicate#apply}.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods acting on or generating a {@code Multimap}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Multimaps">
 {@code Multimaps}</a>.

 @author Jared Levy
 @author Robert Konigsberg
 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Multimaps -->
  <!-- start interface com.google.common.collect.Multiset -->
  <interface name="Multiset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the number of occurrences of an element in this multiset (the
 <i>count</i> of the element). Note that for an {@link Object#equals}-based
 multiset, this gives the same result as {@link Collections#frequency}
 (which would presumably perform more poorly).

 <p><b>Note:</b> the utility method {@link Iterables#frequency} generalizes
 this operation; it correctly delegates to this method when dealing with a
 multiset, but it can also accept any other iterable type.

 @param element the element to count occurrences of
 @return the number of occurrences of the element in this multiset; possibly
     zero but never negative]]>
      </doc>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this multiset. Note that if
 {@code occurrences == 1}, this method has the identical effect to {@link
 #add(Object)}. This method is functionally equivalent (except in the case
 of overflow) to the call {@code addAll(Collections.nCopies(element,
 occurrences))}, which would presumably perform much more poorly.

 @param element the element to add occurrences of; may be null only if
     explicitly allowed by the implementation
 @param occurrences the number of occurrences of the element to add. May be
     zero, in which case no change will be made.
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative, or if
     this operation would result in more than {@link Integer#MAX_VALUE}
     occurrences of the element
 @throws NullPointerException if {@code element} is null and this
     implementation does not permit null elements. Note that if {@code
     occurrences} is zero, the implementation may opt to return normally.]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes a number of occurrences of the specified element from this
 multiset. If the multiset contains fewer than this number of occurrences to
 begin with, all occurrences will be removed.  Note that if
 {@code occurrences == 1}, this is functionally equivalent to the call
 {@code remove(element)}.

 @param element the element to conditionally remove occurrences of
 @param occurrences the number of occurrences of the element to remove. May
     be zero, in which case no change will be made.
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the
 element attains the desired count.

 @param element the element to add or remove occurrences of; may be null
     only if explicitly allowed by the implementation
 @param count the desired count of the element in this multiset
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code count} is negative
 @throws NullPointerException if {@code element} is null and this
     implementation does not permit null elements. Note that if {@code
     count} is zero, the implementor may optionally return zero instead.]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Conditionally sets the count of an element to a new value, as described in
 {@link #setCount(Object, int)}, provided that the element has the expected
 current count. If the current count is not {@code oldCount}, no change is
 made.

 @param element the element to conditionally set the count of; may be null
     only if explicitly allowed by the implementation
 @param oldCount the expected present count of the element in this multiset
 @param newCount the desired count of the element in this multiset
 @return {@code true} if the condition for modification was met. This
     implies that the multiset was indeed modified, unless
     {@code oldCount == newCount}.
 @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is
     negative
 @throws NullPointerException if {@code element} is null and the
     implementation does not permit null elements. Note that if {@code
     oldCount} and {@code newCount} are both zero, the implementor may
     optionally return {@code true} instead.]]>
      </doc>
    </method>
    <method name="elementSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of distinct elements contained in this multiset. The
 element set is backed by the same data as the multiset, so any change to
 either is immediately reflected in the other. The order of the elements in
 the element set is unspecified.

 <p>If the element set supports any removal operations, these necessarily
 cause <b>all</b> occurrences of the removed element(s) to be removed from
 the multiset. Implementations are not expected to support the add
 operations, although this is possible.

 <p>A common use for the element set is to find the number of distinct
 elements in the multiset: {@code elementSet().size()}.

 @return a view of the set of distinct elements in this multiset]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of the contents of this multiset, grouped into {@code
 Multiset.Entry} instances, each providing an element of the multiset and
 the count of that element. This set contains exactly one entry for each
 distinct element in the multiset (thus it always has the same size as the
 {@link #elementSet}). The order of the elements in the element set is
 unspecified.

 <p>The entry set is backed by the same data as the multiset, so any change
 to either is immediately reflected in the other. However, multiset changes
 may or may not be reflected in any {@code Entry} instances already
 retrieved from the entry set (this is implementation-dependent).
 Furthermore, implementations are not required to support modifications to
 the entry set at all, and the {@code Entry} instances themselves don't
 even have methods for modification. See the specific implementation class
 for more details on how its entry set handles modifications.

 @return a set of entries representing the data of this multiset]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this multiset for equality. Returns
 {@code true} if the given object is also a multiset and contains equal
 elements with equal counts, regardless of order.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multiset. This is defined as the sum of
 <pre>   {@code

   ((element == null) ? 0 : element.hashCode()) ^ count(element)}</pre>

 over all distinct elements in the multiset. It follows that a multiset and
 its entry set always have the same hash code.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>It is recommended, though not mandatory, that this method return the
 result of invoking {@link #toString} on the {@link #entrySet}, yielding a
 result such as {@code [a x 3, c, d x 2, e]}.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Elements that occur multiple times in the multiset will appear
 multiple times in this iterator, though not necessarily sequentially.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Determines whether this multiset contains the specified element.

 <p>This method refines {@link Collection#contains} to further specify that
 it <b>may not</b> throw an exception in response to {@code element} being
 null or of the wrong type.

 @param element the element to check for
 @return {@code true} if this multiset contains at least one occurrence of
     the element]]>
      </doc>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if this multiset contains at least one occurrence of
 each element in the specified collection.

 <p>This method refines {@link Collection#containsAll} to further specify
 that it <b>may not</b> throw an exception in response to any of {@code
 elements} being null or of the wrong type.

 <p><b>Note:</b> this method does not take into account the occurrence
 count of an element in the two collections; it may still return {@code
 true} even if {@code elements} contains several occurrences of an element
 and this multiset contains only one. This is no different than any other
 collection type like {@link List}, but it may be unexpected to the user of
 a multiset.

 @param elements the collection of elements to be checked for containment in
     this multiset
 @return {@code true} if this multiset contains at least one occurrence of
     each element contained in {@code elements}
 @throws NullPointerException if {@code elements} is null]]>
      </doc>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds a single occurrence of the specified element to this multiset.

 <p>This method refines {@link Collection#add}, which only <i>ensures</i>
 the presence of the element, to further specify that a successful call must
 always increment the count of the element, and the overall size of the
 collection, by one.

 @param element the element to add one occurrence of; may be null only if
     explicitly allowed by the implementation
 @return {@code true} always, since this call is required to modify the
     multiset, unlike other {@link Collection} types
 @throws NullPointerException if {@code element} is null and this
     implementation does not permit null elements
 @throws IllegalArgumentException if {@link Integer#MAX_VALUE} occurrences
     of {@code element} are already contained in this multiset]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes a <i>single</i> occurrence of the specified element from this
 multiset, if present.

 <p>This method refines {@link Collection#remove} to further specify that it
 <b>may not</b> throw an exception in response to {@code element} being null
 or of the wrong type.

 @param element the element to remove one occurrence of
 @return {@code true} if an occurrence was found and removed]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This method ignores how often any element might appear in
 {@code c}, and only cares whether or not an element appears at all.
 If you wish to remove one occurrence in this multiset for every occurrence
 in {@code c}, see {@link Multisets#removeOccurrences(Multiset, Multiset)}.
 
 <p>This method refines {@link Collection#removeAll} to further specify that
 it <b>may not</b> throw an exception in response to any of {@code elements}
 being null or of the wrong type.]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This method ignores how often any element might appear in
 {@code c}, and only cares whether or not an element appears at all.
 If you wish to remove one occurrence in this multiset for every occurrence
 in {@code c}, see {@link Multisets#retainOccurrences(Multiset, Multiset)}.
 
 <p>This method refines {@link Collection#retainAll} to further specify that
 it <b>may not</b> throw an exception in response to any of {@code elements}
 being null or of the wrong type.
 
 @see Multisets#retainOccurrences(Multiset, Multiset)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection that supports order-independent equality, like {@link Set}, but
 may have duplicate elements. A multiset is also sometimes called a
 <i>bag</i>.

 <p>Elements of a multiset that are equal to one another are referred to as
 <i>occurrences</i> of the same single element. The total number of
 occurrences of an element in a multiset is called the <i>count</i> of that
 element (the terms "frequency" and "multiplicity" are equivalent, but not
 used in this API). Since the count of an element is represented as an {@code
 int}, a multiset may never contain more than {@link Integer#MAX_VALUE}
 occurrences of any one element.

 <p>{@code Multiset} refines the specifications of several methods from
 {@code Collection}. It also defines an additional query operation, {@link
 #count}, which returns the count of an element. There are five new
 bulk-modification operations, for example {@link #add(Object, int)}, to add
 or remove multiple occurrences of an element at once, or to set the count of
 an element to a specific value. These modification operations are optional,
 but implementations which support the standard collection operations {@link
 #add(Object)} or {@link #remove(Object)} are encouraged to implement the
 related methods as well. Finally, two collection views are provided: {@link
 #elementSet} contains the distinct elements of the multiset "with duplicates
 collapsed", and {@link #entrySet} is similar but contains {@link Entry
 Multiset.Entry} instances, each providing both a distinct element and the
 count of that element.

 <p>In addition to these required methods, implementations of {@code
 Multiset} are expected to provide two {@code static} creation methods:
 {@code create()}, returning an empty multiset, and {@code
 create(Iterable<? extends E>)}, returning a multiset containing the
 given initial elements. This is simply a refinement of {@code Collection}'s
 constructor recommendations, reflecting the new developments of Java 5.

 <p>As with other collection types, the modification operations are optional,
 and should throw {@link UnsupportedOperationException} when they are not
 implemented. Most implementations should support either all add operations
 or none of them, all removal operations or none of them, and if and only if
 all of these are supported, the {@code setCount} methods as well.

 <p>A multiset uses {@link Object#equals} to determine whether two instances
 should be considered "the same," <i>unless specified otherwise</i> by the
 implementation.

 <p>Common implementations include {@link ImmutableMultiset}, {@link
 HashMultiset}, and {@link ConcurrentHashMultiset}.

 <p>If your values may be zero, negative, or outside the range of an int, you
 may wish to use {@link com.google.common.util.concurrent.AtomicLongMap}
 instead. Note, however, that unlike {@code Multiset}, {@code AtomicLongMap}
 does not automatically remove zeros.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset">
 {@code Multiset}</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multiset -->
  <!-- start interface com.google.common.collect.Multiset.Entry -->
  <interface name="Multiset.Entry"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getElement" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the multiset element corresponding to this entry. Multiple calls
 to this method always return the same instance.

 @return the element corresponding to this entry]]>
      </doc>
    </method>
    <method name="getCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the count of the associated element in the underlying multiset.
 This count may either be an unchanging snapshot of the count at the time
 the entry was retrieved, or a live view of the current count of the
 element in the multiset, depending on the implementation. Note that in
 the former case, this method can never return zero, while in the latter,
 it will return zero if all occurrences of the element were since removed
 from the multiset.

 @return the count of the element; never negative]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Returns {@code true} if the given object is also a multiset entry and
 the two entries represent the same element and count. That is, two
 entries {@code a} and {@code b} are equal if: <pre>   {@code

   Objects.equal(a.getElement(), b.getElement())
       && a.getCount() == b.getCount()}</pre>]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The hash code of a multiset entry for element {@code element} and
 count {@code count} is defined as: <pre>   {@code

   ((element == null) ? 0 : element.hashCode()) ^ count}</pre>]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the canonical string representation of this entry, defined as
 follows. If the count for this entry is one, this is simply the string
 representation of the corresponding element. Otherwise, it is the string
 representation of the element, followed by the three characters {@code
 " x "} (space, letter x, space), followed by the count.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An unmodifiable element-count pair for a multiset. The {@link
 Multiset#entrySet} method returns a view of the multiset whose elements
 are of this class. A multiset implementation may return Entry instances
 that are either live "read-through" views to the Multiset, or immutable
 snapshots. Note that this type is unrelated to the similarly-named type
 {@code Map.Entry}.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multiset.Entry -->
  <!-- start class com.google.common.collect.Multisets -->
  <class name="Multisets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="unmodifiableMultiset" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset" type="com.google.common.collect.Multiset&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified multiset. Query operations on
 the returned multiset "read through" to the specified multiset, and
 attempts to modify the returned multiset result in an
 {@link UnsupportedOperationException}.

 <p>The returned multiset will be serializable if the specified multiset is
 serializable.

 @param multiset the multiset for which an unmodifiable view is to be
     generated
 @return an unmodifiable view of the multiset]]>
      </doc>
    </method>
    <method name="unmodifiableMultiset" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="multiset" type="com.google.common.collect.ImmutableMultiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="unmodifiableSortedMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedMultiset" type="com.google.common.collect.SortedMultiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified sorted multiset. Query
 operations on the returned multiset "read through" to the specified
 multiset, and attempts to modify the returned multiset result in an {@link
 UnsupportedOperationException}.

 <p>The returned multiset will be serializable if the specified multiset is
 serializable.

 @param sortedMultiset the sorted multiset for which an unmodifiable view is
     to be generated
 @return an unmodifiable view of the multiset
 @since 11.0]]>
      </doc>
    </method>
    <method name="immutableEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns an immutable multiset entry with the specified element and count.
 The entry will be serializable if {@code e} is.

 @param e the element to be associated with the returned entry
 @param n the count to be associated with the returned entry
 @throws IllegalArgumentException if {@code n} is negative]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset1" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <param name="multiset2" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the intersection of two multisets.
 An element's count in the multiset is the smaller of its counts in the two
 backing multisets. The iteration order of the returned multiset matches the
 element set of {@code multiset1}, with repeated occurrences of the same
 element appearing consecutively.

 <p>Results are undefined if {@code multiset1} and {@code multiset2} are
 based on different equivalence relations (as {@code HashMultiset} and
 {@code TreeMultiset} are).

 @since 2.0]]>
      </doc>
    </method>
    <method name="containsOccurrences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="superMultiset" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <param name="subMultiset" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code subMultiset.count(o) <=
 superMultiset.count(o)} for all {@code o}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="retainOccurrences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multisetToModify" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <param name="multisetToRetain" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Modifies {@code multisetToModify} so that its count for an element
 {@code e} is at most {@code multisetToRetain.count(e)}.

 <p>To be precise, {@code multisetToModify.count(e)} is set to
 {@code Math.min(multisetToModify.count(e),
 multisetToRetain.count(e))}. This is similar to
 {@link #intersection(Multiset, Multiset) intersection}
 {@code (multisetToModify, multisetToRetain)}, but mutates
 {@code multisetToModify} instead of returning a view.

 <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps
 all occurrences of elements that appear at all in {@code
 multisetToRetain}, and deletes all occurrences of all other elements.

 @return {@code true} if {@code multisetToModify} was changed as a result
         of this operation
 @since 10.0]]>
      </doc>
    </method>
    <method name="removeOccurrences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multisetToModify" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <param name="occurrencesToRemove" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[For each occurrence of an element {@code e} in {@code occurrencesToRemove},
 removes one occurrence of {@code e} in {@code multisetToModify}.

 <p>Equivalently, this method modifies {@code multisetToModify} so that
 {@code multisetToModify.count(e)} is set to
 {@code Math.max(0, multisetToModify.count(e) -
 occurrencesToRemove.count(e))}.

 <p>This is <i>not</i> the same as {@code multisetToModify.}
 {@link Multiset#removeAll removeAll}{@code (occurrencesToRemove)}, which
 removes all occurrences of elements that appear in
 {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent
 to, albeit more efficient than, the following: <pre>   {@code

   for (E e : occurrencesToRemove) {
     multisetToModify.remove(e);
   }}</pre>

 @return {@code true} if {@code multisetToModify} was changed as a result of
         this operation
 @since 10.0]]>
      </doc>
    </method>
    <method name="copyHighestCountFirst" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order is
 highest count first, with ties broken by the iteration order of the original multiset.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static utility methods for creating and working with {@link
 Multiset} instances.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Multisets">
 {@code Multisets}</a>.

 @author Kevin Bourrillion
 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Multisets -->
  <!-- start class com.google.common.collect.MutableClassToInstanceMap -->
  <class name="MutableClassToInstanceMap" extends="com.google.common.collect.MapConstraints.ConstrainedMap&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ClassToInstanceMap&lt;B&gt;"/>
    <method name="create" return="com.google.common.collect.MutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@code MutableClassToInstanceMap} instance backed by a {@link
 HashMap} using the default initial capacity and load factor.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code MutableClassToInstanceMap} instance backed by a given
 empty {@code backingMap}. The caller surrenders control of the backing map,
 and thus should not allow any direct references to it to remain accessible.]]>
      </doc>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A mutable class-to-instance map backed by an arbitrary user-provided map.
 See also {@link ImmutableClassToInstanceMap}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#ClassToInstanceMap">
 {@code ClassToInstanceMap}</a>.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MutableClassToInstanceMap -->
  <!-- start class com.google.common.collect.ObjectArrays -->
  <class name="ObjectArrays" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a new array of the given length with the specified component type.

 @param type the component type
 @param length the length of the new array]]>
      </doc>
    </method>
    <method name="newArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a new array of the given length with the same type as a reference
 array.

 @param reference any array of the desired type
 @param length the length of the new array]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="T[]"/>
      <param name="second" type="T[]"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new array that contains the concatenated contents of two arrays.

 @param first the first array of elements to concatenate
 @param second the second array of elements to concatenate
 @param type the component type of the returned array]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="T"/>
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[Returns a new array that prepends {@code element} to {@code array}.

 @param element the element to prepend to the front of {@code array}
 @param array the array of elements to append
 @return an array whose size is one larger than {@code array}, with
     {@code element} occupying the first position, and the
     elements of {@code array} occupying the remaining elements.]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <param name="element" type="T"/>
      <doc>
      <![CDATA[Returns a new array that appends {@code element} to {@code array}.

 @param array the array of elements to prepend
 @param element the element to append to the end
 @return an array whose size is one larger than {@code array}, with
     the same contents as {@code array}, plus {@code element} occupying the
     last position.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to object arrays.

 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ObjectArrays -->
  <!-- start class com.google.common.collect.Ordering -->
  <class name="Ordering" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator&lt;T&gt;"/>
    <constructor name="Ordering"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class (only invokable by the subclass
 constructor, typically implicit).]]>
      </doc>
    </constructor>
    <method name="natural" return="com.google.common.collect.Ordering&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable ordering that uses the natural order of the values.
 The ordering throws a {@link NullPointerException} when passed a null
 parameter.

 <p>The type specification is {@code <C extends Comparable>}, instead of
 the technically correct {@code <C extends Comparable<? super C>>}, to
 support legacy types from before Java 5.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an ordering based on an <i>existing</i> comparator instance. Note
 that there's no need to create a <i>new</i> comparator just to pass it in
 here; simply subclass {@code Ordering} and implement its {@code compareTo}
 method directly instead.

 @param comparator the comparator that defines the order
 @return comparator itself if it is already an {@code Ordering}; otherwise
     an ordering that wraps that comparator]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="ordering" type="com.google.common.collect.Ordering&lt;T&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this]]>
      </doc>
    </method>
    <method name="explicit" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valuesInOrder" type="java.util.List&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an ordering that compares objects according to the order in
 which they appear in the given list. Only objects present in the list
 (according to {@link Object#equals}) may be compared. This comparator
 imposes a "partial ordering" over the type {@code T}. Subsequent changes
 to the {@code valuesInOrder} list will have no effect on the returned
 comparator. Null values in the list are not supported.

 <p>The returned comparator throws an {@link ClassCastException} when it
 receives an input parameter that isn't among the provided values.

 <p>The generated comparator is serializable if all the provided values are
 serializable.

 @param valuesInOrder the values that the returned comparator will be able
     to compare, in the order the comparator should induce
 @return the comparator described above
 @throws NullPointerException if any of the provided values is null
 @throws IllegalArgumentException if {@code valuesInOrder} contains any
     duplicate values (according to {@link Object#equals})]]>
      </doc>
    </method>
    <method name="explicit" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leastValue" type="T"/>
      <param name="remainingValuesInOrder" type="T[]"/>
      <doc>
      <![CDATA[Returns an ordering that compares objects according to the order in
 which they are given to this method. Only objects present in the argument
 list (according to {@link Object#equals}) may be compared. This comparator
 imposes a "partial ordering" over the type {@code T}. Null values in the
 argument list are not supported.

 <p>The returned comparator throws a {@link ClassCastException} when it
 receives an input parameter that isn't among the provided values.

 <p>The generated comparator is serializable if all the provided values are
 serializable.

 @param leastValue the value which the returned comparator should consider
     the "least" of all values
 @param remainingValuesInOrder the rest of the values that the returned
     comparator will be able to compare, in the order the comparator should
     follow
 @return the comparator described above
 @throws NullPointerException if any of the provided values is null
 @throws IllegalArgumentException if any duplicate values (according to
     {@link Object#equals(Object)}) are present among the method arguments]]>
      </doc>
    </method>
    <method name="allEqual" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering which treats all values as equal, indicating "no
 ordering." Passing this ordering to any <i>stable</i> sort algorithm
 results in no change to the order of elements. Note especially that {@link
 #sortedCopy} and {@link #immutableSortedCopy} are stable, and in the
 returned instance these are implemented by simply copying the source list.

 <p>Example: <pre>   {@code

   Ordering.allEqual().nullsLast().sortedCopy(
       asList(t, null, e, s, null, t, null))}</pre>

 Assuming {@code t}, {@code e} and {@code s} are non-null, this returns
 {@code [t, e, s, t, null, null, null]} regardlesss of the true comparison
 order of those three values (which might not even implement {@link
 Comparable} at all).

 <p><b>Warning:</b> by definition, this comparator is not <i>consistent with
 equals</i> (as defined {@linkplain Comparator here}). Avoid its use in
 APIs, such as {@link TreeSet#TreeSet(Comparator)}, where such consistency
 is expected.

 <p>The returned comparator is serializable.]]>
      </doc>
    </method>
    <method name="usingToString" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that compares objects by the natural ordering of their
 string representations as returned by {@code toString()}. It does not
 support null values.

 <p>The comparator is serializable.]]>
      </doc>
    </method>
    <method name="arbitrary" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary ordering over all objects, for which {@code compare(a,
 b) == 0} implies {@code a == b} (identity equality). There is no meaning
 whatsoever to the order imposed, but it is constant for the life of the VM.

 <p>Because the ordering is identity-based, it is not "consistent with
 {@link Object#equals(Object)}" as defined by {@link Comparator}. Use
 caution when building a {@link SortedSet} or {@link SortedMap} from it, as
 the resulting collection will not behave exactly according to spec.

 <p>This ordering is not serializable, as its implementation relies on
 {@link System#identityHashCode(Object)}, so its behavior cannot be
 preserved across serialization.

 @since 2.0]]>
      </doc>
    </method>
    <method name="reverse" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reverse of this ordering; the {@code Ordering} equivalent to
 {@link Collections#reverseOrder(Comparator)}.]]>
      </doc>
    </method>
    <method name="nullsFirst" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that treats {@code null} as less than all other values
 and uses {@code this} to compare non-null values.]]>
      </doc>
    </method>
    <method name="nullsLast" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that treats {@code null} as greater than all other
 values and uses this ordering to compare non-null values.]]>
      </doc>
    </method>
    <method name="onResultOf" return="com.google.common.collect.Ordering&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a new ordering on {@code F} which orders elements by first applying
 a function to them, then comparing those results using {@code this}. For
 example, to compare objects by their string forms, in a case-insensitive
 manner, use: <pre>   {@code

   Ordering.from(String.CASE_INSENSITIVE_ORDER)
       .onResultOf(Functions.toStringFunction())}</pre>]]>
      </doc>
    </method>
    <method name="compound" return="com.google.common.collect.Ordering&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="secondaryComparator" type="java.util.Comparator&lt;? super U&gt;"/>
      <doc>
      <![CDATA[Returns an ordering which first uses the ordering {@code this}, but which
 in the event of a "tie", then delegates to {@code secondaryComparator}.
 For example, to sort a bug list first by status and second by priority, you
 might use {@code byStatus.compound(byPriority)}. For a compound ordering
 with three or more components, simply chain multiple calls to this method.

 <p>An ordering produced by this method, or a chain of calls to this method,
 is equivalent to one created using {@link Ordering#compound(Iterable)} on
 the same component comparators.]]>
      </doc>
    </method>
    <method name="compound" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparators" type="java.lang.Iterable&lt;? extends java.util.Comparator&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an ordering which tries each given comparator in order until a
 non-zero result is found, returning that result, and returning zero only if
 all comparators return zero. The returned ordering is based on the state of
 the {@code comparators} iterable at the time it was provided to this
 method.

 <p>The returned ordering is equivalent to that produced using {@code
 Ordering.from(comp1).compound(comp2).compound(comp3) . . .}.

 <p><b>Warning:</b> Supplying an argument with undefined iteration order,
 such as a {@link HashSet}, will produce non-deterministic results.

 @param comparators the comparators to try in order]]>
      </doc>
    </method>
    <method name="lexicographical" return="com.google.common.collect.Ordering&lt;java.lang.Iterable&lt;S&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new ordering which sorts iterables by comparing corresponding
 elements pairwise until a nonzero result is found; imposes "dictionary
 order". If the end of one iterable is reached, but not the other, the
 shorter iterable is considered to be less than the longer one. For example,
 a lexicographical natural ordering over integers considers {@code
 [] < [1] < [1, 1] < [1, 2] < [2]}.

 <p>Note that {@code ordering.lexicographical().reverse()} is not
 equivalent to {@code ordering.reverse().lexicographical()} (consider how
 each would order {@code [1]} and {@code [1, 1]}).

 @since 2.0]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="T"/>
      <param name="right" type="T"/>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the least of the specified values according to this ordering. If
 there are multiple least values, the first of those is returned. The
 iterator will be left exhausted: its {@code hasNext()} method will return
 {@code false}.

 @param iterator the iterator whose minimum element is to be determined
 @throws NoSuchElementException if {@code iterator} is empty
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.

 @since 11.0]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the least of the specified values according to this ordering. If
 there are multiple least values, the first of those is returned.

 @param iterable the iterable whose minimum element is to be determined
 @throws NoSuchElementException if {@code iterable} is empty
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <doc>
      <![CDATA[Returns the lesser of the two values according to this ordering. If the
 values compare as 0, the first is returned.

 <p><b>Implementation note:</b> this method is invoked by the default
 implementations of the other {@code min} overloads, so overriding it will
 affect their behavior.

 @param a value to compare, returned if less than or equal to b.
 @param b value to compare.
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <param name="c" type="E extends T"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns the least of the specified values according to this ordering. If
 there are multiple least values, the first of those is returned.

 @param a value to compare, returned if less than or equal to the rest.
 @param b value to compare
 @param c value to compare
 @param rest values to compare
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the greatest of the specified values according to this ordering. If
 there are multiple greatest values, the first of those is returned. The
 iterator will be left exhausted: its {@code hasNext()} method will return
 {@code false}.

 @param iterator the iterator whose maximum element is to be determined
 @throws NoSuchElementException if {@code iterator} is empty
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.

 @since 11.0]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the greatest of the specified values according to this ordering. If
 there are multiple greatest values, the first of those is returned.

 @param iterable the iterable whose maximum element is to be determined
 @throws NoSuchElementException if {@code iterable} is empty
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <doc>
      <![CDATA[Returns the greater of the two values according to this ordering. If the
 values compare as 0, the first is returned.

 <p><b>Implementation note:</b> this method is invoked by the default
 implementations of the other {@code max} overloads, so overriding it will
 affect their behavior.

 @param a value to compare, returned if greater than or equal to b.
 @param b value to compare.
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <param name="c" type="E extends T"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns the greatest of the specified values according to this ordering. If
 there are multiple greatest values, the first of those is returned.

 @param a value to compare, returned if greater than or equal to the rest.
 @param b value to compare
 @param c value to compare
 @param rest values to compare
 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i> under this ordering.]]>
      </doc>
    </method>
    <method name="leastOf" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code k} least elements of the given iterable according to
 this ordering, in order from least to greatest.  If there are fewer than
 {@code k} elements present, all will be included.

 <p>The implementation does not necessarily use a <i>stable</i> sorting
 algorithm; when multiple elements are equivalent, it is undefined which
 will come first.

 @return an immutable {@code RandomAccess} list of the {@code k} least
     elements in ascending order
 @throws IllegalArgumentException if {@code k} is negative
 @since 8.0]]>
      </doc>
    </method>
    <method name="greatestOf" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code k} greatest elements of the given iterable according to
 this ordering, in order from greatest to least. If there are fewer than
 {@code k} elements present, all will be included.

 <p>The implementation does not necessarily use a <i>stable</i> sorting
 algorithm; when multiple elements are equivalent, it is undefined which
 will come first.

 @return an immutable {@code RandomAccess} list of the {@code k} greatest
     elements in <i>descending order</i>
 @throws IllegalArgumentException if {@code k} is negative
 @since 8.0]]>
      </doc>
    </method>
    <method name="sortedCopy" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a copy of the given iterable sorted by this ordering. The input is
 not modified. The returned list is modifiable, serializable, and has random
 access.

 <p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard
 elements that are duplicates according to the comparator. The sort
 performed is <i>stable</i>, meaning that such elements will appear in the
 resulting list in the same order they appeared in the input.

 @param iterable the elements to be copied and sorted
 @return a new list containing the given elements in sorted order]]>
      </doc>
    </method>
    <method name="immutableSortedCopy" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an <i>immutable</i> copy of the given iterable sorted by this
 ordering. The input is not modified.

 <p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard
 elements that are duplicates according to the comparator. The sort
 performed is <i>stable</i>, meaning that such elements will appear in the
 resulting list in the same order they appeared in the input.

 @param iterable the elements to be copied and sorted
 @return a new immutable list containing the given elements in sorted order
 @throws NullPointerException if {@code iterable} or any of its elements is
     null
 @since 3.0]]>
      </doc>
    </method>
    <method name="isOrdered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is
 greater than or equal to the element that preceded it, according to this
 ordering. Note that this is always true when the iterable has fewer than
 two elements.]]>
      </doc>
    </method>
    <method name="isStrictlyOrdered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is
 <i>strictly</i> greater than the element that preceded it, according to
 this ordering. Note that this is always true when the iterable has fewer
 than two elements.]]>
      </doc>
    </method>
    <method name="binarySearch" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedList" type="java.util.List&lt;? extends T&gt;"/>
      <param name="key" type="T"/>
      <doc>
      <![CDATA[{@link Collections#binarySearch(List, Object, Comparator) Searches}
 {@code sortedList} for {@code key} using the binary search algorithm. The
 list must be sorted using this ordering.

 @param sortedList the list to be searched
 @param key the key to be searched for]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A comparator, with additional methods to support common operations. This is
 an "enriched" version of {@code Comparator}, in the same sense that {@link
 FluentIterable} is an enriched {@link Iterable}). For example: <pre>   {@code

   if (Ordering.from(comparator).reverse().isOrdered(list)) { ... }}</pre>

 The {@link #from(Comparator)} method returns the equivalent {@code Ordering}
 instance for a pre-existing comparator. You can also skip the comparator step
 and extend {@code Ordering} directly: <pre>   {@code

   Ordering<String> byLengthOrdering = new Ordering<String>() {
     public int compare(String left, String right) {
       return Ints.compare(left.length(), right.length());
     }
   };}</pre>

 Except as noted, the orderings returned by the factory methods of this
 class are serializable if and only if the provided instances that back them
 are. For example, if {@code ordering} and {@code function} can themselves be
 serialized, then {@code ordering.onResultOf(function)} can as well.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/OrderingExplained">
 {@code Ordering}</a>.

 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Ordering -->
  <!-- start interface com.google.common.collect.PeekingIterator -->
  <interface name="PeekingIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <method name="peek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element in the iteration, without advancing the iteration.

 <p>Calls to {@code peek()} should not change the state of the iteration,
 except that it <i>may</i> prevent removal of the most recent element via
 {@link #remove()}.

 @throws NoSuchElementException if the iteration has no more elements
     according to {@link #hasNext()}]]>
      </doc>
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The objects returned by consecutive calls to {@link #peek()} then {@link
 #next()} are guaranteed to be equal to each other.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Implementations may or may not support removal when a call to {@link
 #peek()} has occurred since the most recent call to {@link #next()}.

 @throws IllegalStateException if there has been a call to {@link #peek()}
     since the most recent call to {@link #next()} and this implementation
     does not support this sequence of calls (optional)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator that supports a one-element lookahead while iterating.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionHelpersExplained#PeekingIterator">
 {@code PeekingIterator}</a>.

 @author Mick Killianey
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.PeekingIterator -->
  <!-- start class com.google.common.collect.Queues -->
  <class name="Queues" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArrayBlockingQueue" return="java.util.concurrent.ArrayBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capacity" type="int"/>
      <doc>
      <![CDATA[Creates an empty {@code ArrayBlockingQueue} instance.

 @return a new, empty {@code ArrayBlockingQueue}]]>
      </doc>
    </method>
    <method name="newArrayDeque" return="java.util.ArrayDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code ArrayDeque} instance.

 @return a new, empty {@code ArrayDeque}
 @since 12.0]]>
      </doc>
    </method>
    <method name="newArrayDeque" return="java.util.ArrayDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code ArrayDeque} instance containing the given elements.

 @param elements the elements that the queue should contain, in order
 @return a new {@code ArrayDeque} containing those elements
 @since 12.0]]>
      </doc>
    </method>
    <method name="newConcurrentLinkedQueue" return="java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code ConcurrentLinkedQueue} instance.

 @return a new, empty {@code ConcurrentLinkedQueue}]]>
      </doc>
    </method>
    <method name="newConcurrentLinkedQueue" return="java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code ConcurrentLinkedQueue} instance containing the given elements.

 @param elements the elements that the queue should contain, in order
 @return a new {@code ConcurrentLinkedQueue} containing those elements]]>
      </doc>
    </method>
    <method name="newLinkedBlockingDeque" return="java.util.concurrent.LinkedBlockingDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code LinkedBlockingDeque} instance.

 @return a new, empty {@code LinkedBlockingDeque}
 @since 12.0]]>
      </doc>
    </method>
    <method name="newLinkedBlockingDeque" return="java.util.concurrent.LinkedBlockingDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capacity" type="int"/>
      <doc>
      <![CDATA[Creates a {@code LinkedBlockingDeque} with the given (fixed) capacity.

 @param capacity the capacity of this deque
 @return a new, empty {@code LinkedBlockingDeque}
 @throws IllegalArgumentException if {@code capacity} is less than 1
 @since 12.0]]>
      </doc>
    </method>
    <method name="newLinkedBlockingDeque" return="java.util.concurrent.LinkedBlockingDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code LinkedBlockingDeque} instance containing the given elements.

 @param elements the elements that the queue should contain, in order
 @return a new {@code LinkedBlockingDeque} containing those elements
 @since 12.0]]>
      </doc>
    </method>
    <method name="newLinkedBlockingQueue" return="java.util.concurrent.LinkedBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code LinkedBlockingQueue} instance.

 @return a new, empty {@code LinkedBlockingQueue}]]>
      </doc>
    </method>
    <method name="newLinkedBlockingQueue" return="java.util.concurrent.LinkedBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capacity" type="int"/>
      <doc>
      <![CDATA[Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.

 @param capacity the capacity of this queue
 @return a new, empty {@code LinkedBlockingQueue}
 @throws IllegalArgumentException if {@code capacity} is less than 1]]>
      </doc>
    </method>
    <method name="newLinkedBlockingQueue" return="java.util.concurrent.LinkedBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code LinkedBlockingQueue} instance containing the given elements.

 @param elements the elements that the queue should contain, in order
 @return a new {@code LinkedBlockingQueue} containing those elements]]>
      </doc>
    </method>
    <method name="newPriorityBlockingQueue" return="java.util.concurrent.PriorityBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code PriorityBlockingQueue} instance.

 @return a new, empty {@code PriorityBlockingQueue}]]>
      </doc>
    </method>
    <method name="newPriorityBlockingQueue" return="java.util.concurrent.PriorityBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code PriorityBlockingQueue} instance containing the given elements.

 @param elements the elements that the queue should contain, in order
 @return a new {@code PriorityBlockingQueue} containing those elements]]>
      </doc>
    </method>
    <method name="newPriorityQueue" return="java.util.PriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code PriorityQueue} instance.

 @return a new, empty {@code PriorityQueue}]]>
      </doc>
    </method>
    <method name="newPriorityQueue" return="java.util.PriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code PriorityQueue} instance containing the given elements.

 @param elements the elements that the queue should contain, in order
 @return a new {@code PriorityQueue} containing those elements]]>
      </doc>
    </method>
    <method name="newSynchronousQueue" return="java.util.concurrent.SynchronousQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code SynchronousQueue} instance.

 @return a new, empty {@code SynchronousQueue}]]>
      </doc>
    </method>
    <method name="drain" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="q" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="buffer" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="numElements" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested 
 {@code numElements} elements are not available, it will wait for them up to the specified
 timeout.
 
 @param q the blocking queue to be drained
 @param buffer where to add the transferred elements
 @param numElements the number of elements to be waited for
 @param timeout how long to wait before giving up, in units of {@code unit}
 @param unit a {@code TimeUnit} determining how to interpret the timeout parameter
 @return the number of elements transferred
 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="drainUninterruptibly" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="q" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="buffer" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="numElements" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Drains the queue as {@linkplain #drain(BlockingQueue, Collection, int, long, TimeUnit)}, 
 but with a different behavior in case it is interrupted while waiting. In that case, the 
 operation will continue as usual, and in the end the thread's interruption status will be set 
 (no {@code InterruptedException} is thrown). 
 
 @param q the blocking queue to be drained
 @param buffer where to add the transferred elements
 @param numElements the number of elements to be waited for
 @param timeout how long to wait before giving up, in units of {@code unit}
 @param unit a {@code TimeUnit} determining how to interpret the timeout parameter
 @return the number of elements transferred]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Queue} and {@link Deque} instances.
 Also see this class's counterparts {@link Lists}, {@link Sets}, and {@link Maps}.

 @author Kurt Alfred Kluever
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Queues -->
  <!-- start class com.google.common.collect.Range -->
  <class name="Range" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Predicate&lt;C&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="hasLowerBound" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this range has a lower endpoint.]]>
      </doc>
    </method>
    <method name="lowerEndpoint" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lower endpoint of this range.

 @throws IllegalStateException if this range is unbounded below (that is, {@link
     #hasLowerBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="lowerBoundType" return="com.google.common.collect.BoundType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of this range's lower bound: {@link BoundType#CLOSED} if the range includes
 its lower endpoint, {@link BoundType#OPEN} if it does not.

 @throws IllegalStateException if this range is unbounded below (that is, {@link
     #hasLowerBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="hasUpperBound" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this range has an upper endpoint.]]>
      </doc>
    </method>
    <method name="upperEndpoint" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the upper endpoint of this range.

 @throws IllegalStateException if this range is unbounded above (that is, {@link
     #hasUpperBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="upperBoundType" return="com.google.common.collect.BoundType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of this range's upper bound: {@link BoundType#CLOSED} if the range includes
 its upper endpoint, {@link BoundType#OPEN} if it does not.

 @throws IllegalStateException if this range is unbounded above (that is, {@link
     #hasUpperBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this range is of the form {@code [v..v)} or {@code (v..v]}. (This does
 not encompass ranges of the form {@code (v..v)}, because such ranges are <i>invalid</i> and
 can't be constructed at all.)

 <p>Note that certain discrete ranges such as the integer range {@code (3..4)} are <b>not</b>
 considered empty, even though they contain no actual values.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code value} is within the bounds of this range. For example, on the
 range {@code [0..2)}, {@code contains(1)} returns {@code true}, while {@code contains(2)}
 returns {@code false}.]]>
      </doc>
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Equivalent to {@link #contains}; provided only to satisfy the {@link Predicate} interface. When
 using a reference of type {@code Range}, always invoke {@link #contains} directly instead.]]>
      </doc>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;? extends C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element in {@code values} is {@linkplain #contains contained} in
 this range.]]>
      </doc>
    </method>
    <method name="encloses" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if the bounds of {@code other} do not extend outside the bounds of this
 range. Examples:

 <ul>
 <li>{@code [3..6]} encloses {@code [4..5]}
 <li>{@code (3..6)} encloses {@code (3..6)}
 <li>{@code [3..6]} encloses {@code [4..4)} (even though the latter is empty)
 <li>{@code (3..6]} does not enclose {@code [3..6]}
 <li>{@code [4..5]} does not enclose {@code (3..6)} (even though it contains every value
     contained by the latter range)
 <li>{@code [3..6]} does not enclose {@code (1..1]} (even though it contains every value
     contained by the latter range)
 </ul>

 Note that if {@code a.encloses(b)}, then {@code b.contains(v)} implies {@code a.contains(v)},
 but as the last two examples illustrate, the converse is not always true.

 <p>Being reflexive, antisymmetric and transitive, the {@code encloses} relation defines a
 <i>partial order</i> over ranges. There exists a unique {@linkplain Ranges#all maximal} range
 according to this relation, and also numerous {@linkplain #isEmpty minimal} ranges. Enclosure
 also implies {@linkplain #isConnected connectedness}.]]>
      </doc>
    </method>
    <method name="isConnected" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if there exists a (possibly empty) range which is {@linkplain #encloses
 enclosed} by both this range and {@code other}.

 <p>For example,
 <ul>
 <li>{@code [2, 4)} and {@code [5, 7)} are not connected
 <li>{@code [2, 4)} and {@code [3, 5)} are connected, because both enclose {@code [3, 4)}
 <li>{@code [2, 4)} and {@code [4, 6)} are connected, because both enclose the empty range
     {@code [4, 4)}
 </ul>

 <p>Note that this range and {@code other} have a well-defined {@linkplain #span union} and
 {@linkplain #intersection intersection} (as a single, possibly-empty range) if and only if this
 method returns {@code true}.

 <p>The connectedness relation is both reflexive and symmetric, but does not form an {@linkplain
 Equivalence equivalence relation} as it is not transitive.]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="connectedRange" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the maximal range {@linkplain #encloses enclosed} by both this range and {@code
 connectedRange}, if such a range exists.

 <p>For example, the intersection of {@code [1..5]} and {@code (3..7)} is {@code (3..5]}. The
 resulting range may be empty; for example, {@code [1..5)} intersected with {@code [5..7)}
 yields the empty range {@code [5..5)}.

 <p>The intersection exists if and only if the two ranges are {@linkplain #isConnected
 connected}.

 <p>The intersection operation is commutative, associative and idempotent, and its identity
 element is {@link Ranges#all}).

 @throws IllegalArgumentException if {@code isConnected(connectedRange)} is {@code false}]]>
      </doc>
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the minimal range that {@linkplain #encloses encloses} both this range and {@code
 other}. For example, the span of {@code [1..3]} and {@code (5..7)} is {@code [1..7)}.

 <p><i>If</i> the input ranges are {@linkplain #isConnected connected}, the returned range can
 also be called their <i>union</i>. If they are not, note that the span might contain values
 that are not contained in either input range.

 <p>Like {@link #intersection(Range) intersection}, this operation is commutative, associative
 and idempotent. Unlike it, it is always well-defined for any two input ranges.]]>
      </doc>
    </method>
    <method name="asSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="com.google.common.collect.DiscreteDomain&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns an {@link ContiguousSet} containing the same values in the given domain
 {@linkplain Range#contains contained} by this range.

 <p><b>Note:</b> {@code a.asSet(d).equals(b.asSet(d))} does not imply {@code a.equals(b)}! For
 example, {@code a} and {@code b} could be {@code [2..4]} and {@code (1..5)}, or the empty
 ranges {@code [3..3)} and {@code [4..4)}.

 <p><b>Warning:</b> Be extremely careful what you do with the {@code asSet} view of a large
 range (such as {@code Ranges.greaterThan(0)}). Certain operations on such a set can be
 performed efficiently, but others (such as {@link Set#hashCode} or {@link
 Collections#frequency}) can cause major performance problems.

 <p>The returned set's {@link Object#toString} method returns a short-hand form of the set's
 contents, such as {@code "[1..100]}"}.

 @throws IllegalArgumentException if neither this range nor the domain has a lower bound, or if
     neither has an upper bound]]>
      </doc>
    </method>
    <method name="canonical" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="com.google.common.collect.DiscreteDomain&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the canonical form of this range in the given domain. The canonical form has the
 following properties:

 <ul>
 <li>equivalence: {@code a.canonical().contains(v) == a.contains(v)} for all {@code v} (in other
     words, {@code a.canonical(domain).asSet(domain).equals(a.asSet(domain))}
 <li>uniqueness: unless {@code a.isEmpty()}, {@code a.asSet(domain).equals(b.asSet(domain))}
     implies {@code a.canonical(domain).equals(b.canonical(domain))}
 <li>idempotence: {@code a.canonical(domain).canonical(domain).equals(a.canonical(domain))}
 </ul>

 Furthermore, this method guarantees that the range returned will be one of the following
 canonical forms:

 <ul>
 <li>[start..end)
 <li>[start..+#)
 <li>(-#..end) (only if type {@code C} is unbounded below)
 <li>(-#..+#) (only if type {@code C} is unbounded below)
 </ul>]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is a range having the same endpoints and bound types as
 this range. Note that discrete ranges such as {@code (1..4)} and {@code [2..3]} are <b>not</b>
 equal to one another, despite the fact that they each contain precisely the same set of values.
 Similarly, empty ranges are not equal unless they have exactly the same representation, so
 {@code [3..3)}, {@code (3..3]}, {@code (4..4]} are all unequal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code for this range.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this range, such as {@code "[3..5)"} (other examples are
 listed in the class documentation).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A range (or "interval") defines the <i>boundaries</i> around a contiguous span of values of some
 {@code Comparable} type; for example, "integers from 1 to 100 inclusive." Note that it is not
 possible to <i>iterate</i> over these contained values unless an appropriate {@link
 DiscreteDomain} can be provided to the {@link #asSet asSet} method.

 <h3>Types of ranges</h3>

 <p>Each end of the range may be bounded or unbounded. If bounded, there is an associated
 <i>endpoint</i> value, and the range is considered to be either <i>open</i> (does not include the
 endpoint) or <i>closed</i> (includes the endpoint) on that side. With three possibilities on each
 side, this yields nine basic types of ranges, enumerated below. (Notation: a square bracket
 ({@code [ ]}) indicates that the range is closed on that side; a parenthesis ({@code ( )}) means
 it is either open or unbounded. The construct {@code {x | statement}} is read "the set of all
 <i>x</i> such that <i>statement</i>.")

 <blockquote><table>
 <tr><td><b>Notation</b> <td><b>Definition</b>        <td><b>Factory method</b>
 <tr><td>{@code (a..b)}  <td>{@code {x | a < x < b}}  <td>{@link Ranges#open open}
 <tr><td>{@code [a..b]}  <td>{@code {x | a <= x <= b}}<td>{@link Ranges#closed closed}
 <tr><td>{@code (a..b]}  <td>{@code {x | a < x <= b}} <td>{@link Ranges#openClosed openClosed}
 <tr><td>{@code [a..b)}  <td>{@code {x | a <= x < b}} <td>{@link Ranges#closedOpen closedOpen}
 <tr><td>{@code (a..+#)} <td>{@code {x | x > a}}      <td>{@link Ranges#greaterThan greaterThan}
 <tr><td>{@code [a..+#)} <td>{@code {x | x >= a}}     <td>{@link Ranges#atLeast atLeast}
 <tr><td>{@code (-#..b)} <td>{@code {x | x < b}}      <td>{@link Ranges#lessThan lessThan}
 <tr><td>{@code (-#..b]} <td>{@code {x | x <= b}}     <td>{@link Ranges#atMost atMost}
 <tr><td>{@code (-#..+#)}<td>{@code {x}}              <td>{@link Ranges#all all}
 </table></blockquote>

 <p>When both endpoints exist, the upper endpoint may not be less than the lower. The endpoints
 may be equal only if at least one of the bounds is closed:

 <ul>
 <li>{@code [a..a]} : a singleton range
 <li>{@code [a..a); (a..a]} : {@linkplain #isEmpty empty} ranges; also valid
 <li>{@code (a..a)} : <b>invalid</b>; an exception will be thrown
 </ul>

 <h3>Warnings</h3>

 <ul>
 <li>Use immutable value types only, if at all possible. If you must use a mutable type, <b>do
     not</b> allow the endpoint instances to mutate after the range is created!
 <li>Your value type's comparison method should be {@linkplain Comparable consistent with equals}
     if at all possible. Otherwise, be aware that concepts used throughout this documentation such
     as "equal", "same", "unique" and so on actually refer to whether {@link Comparable#compareTo
     compareTo} returns zero, not whether {@link Object#equals equals} returns {@code true}.
 <li>A class which implements {@code Comparable<UnrelatedType>} is very broken, and will cause
     undefined horrible things to happen in {@code Range}. For now, the Range API does not prevent
     its use, because this would also rule out all ungenerified (pre-JDK1.5) data types. <b>This
     may change in the future.</b>
 </ul>

 <h3>Other notes</h3>

 <ul>
 <li>Instances of this type are obtained using the static factory methods in the {@link Ranges}
     class.
 <li>Ranges are <i>convex</i>: whenever two values are contained, all values in between them must
     also be contained. More formally, for any {@code c1 <= c2 <= c3} of type {@code C}, {@code
     r.contains(c1) && r.contains(c3)} implies {@code r.contains(c2)}). This means that a {@code
     Range<Integer>} can never be used to represent, say, "all <i>prime</i> numbers from 1 to
     100."
 <li>When evaluated as a {@link Predicate}, a range yields the same result as invoking {@link
     #contains}.
 <li>Terminology note: a range {@code a} is said to be the <i>maximal</i> range having property
     <i>P</i> if, for all ranges {@code b} also having property <i>P</i>, {@code a.encloses(b)}.
     Likewise, {@code a} is <i>minimal</i> when {@code b.encloses(a)} for all {@code b} having
     property <i>P</i>. See, for example, the definition of {@link #intersection intersection}.
 </ul>

 <h3>Further reading</h3>

 <p>See the Guava User Guide article on
 <a href="http://code.google.com/p/guava-libraries/wiki/RangesExplained">{@code Range}</a>.

 @author Kevin Bourrillion
 @author Gregory Kick
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Range -->
  <!-- start class com.google.common.collect.Ranges -->
  <class name="Ranges" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="open" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly greater than {@code
 lower} and strictly less than {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than <i>or
     equal to</i> {@code upper}]]>
      </doc>
    </method>
    <method name="closed" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values greater than or equal to
 {@code lower} and less than or equal to {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than {@code
     upper}]]>
      </doc>
    </method>
    <method name="closedOpen" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values greater than or equal to
 {@code lower} and strictly less than {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than {@code
     upper}]]>
      </doc>
    </method>
    <method name="openClosed" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly greater than {@code
 lower} and less than or equal to {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than {@code
     upper}]]>
      </doc>
    </method>
    <method name="range" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="lowerType" type="com.google.common.collect.BoundType"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upperType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a range that contains any value from {@code lower} to {@code
 upper}, where each endpoint may be either inclusive (closed) or exclusive
 (open).

 @throws IllegalArgumentException if {@code lower} is greater than {@code
     upper}]]>
      </doc>
    </method>
    <method name="lessThan" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly less than {@code
 endpoint}.]]>
      </doc>
    </method>
    <method name="atMost" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values less than or equal to
 {@code endpoint}.]]>
      </doc>
    </method>
    <method name="upTo" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a range with no lower bound up to the given endpoint, which may be
 either inclusive (closed) or exclusive (open).]]>
      </doc>
    </method>
    <method name="greaterThan" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly greater than {@code
 endpoint}.]]>
      </doc>
    </method>
    <method name="atLeast" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values greater than or equal to
 {@code endpoint}.]]>
      </doc>
    </method>
    <method name="downTo" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a range from the given endpoint, which may be either inclusive
 (closed) or exclusive (open), with no upper bound.]]>
      </doc>
    </method>
    <method name="all" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a range that contains every value of type {@code C}.]]>
      </doc>
    </method>
    <method name="singleton" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that {@linkplain Range#contains(Comparable) contains} only
 the given value. The returned range is {@linkplain BoundType#CLOSED closed}
 on both ends.]]>
      </doc>
    </method>
    <method name="encloseAll" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the minimal range that
 {@linkplain Range#contains(Comparable) contains} all of the given values.
 The returned range is {@linkplain BoundType#CLOSED closed} on both ends.

 @throws ClassCastException if the parameters are not <i>mutually
     comparable</i>
 @throws NoSuchElementException if {@code values} is empty
 @throws NullPointerException if any of {@code values} is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static methods pertaining to {@link Range} instances.  Each of the
 {@link Range nine types of ranges} can be constructed with a corresponding
 factory method:

 <dl>
 <dt>{@code (a..b)}
 <dd>{@link #open}
 <dt>{@code [a..b]}
 <dd>{@link #closed}
 <dt>{@code [a..b)}
 <dd>{@link #closedOpen}
 <dt>{@code (a..b]}
 <dd>{@link #openClosed}
 <dt>{@code (a..+#)}
 <dd>{@link #greaterThan}
 <dt>{@code [a..+#)}
 <dd>{@link #atLeast}
 <dt>{@code (-#..b)}
 <dd>{@link #lessThan}
 <dt>{@code (-#..b]}
 <dd>{@link #atMost}
 <dt>{@code (-#..+#)}
 <dd>{@link #all}
 </dl>

 <p>Additionally, {@link Range} instances can be constructed by passing the
 {@link BoundType bound types} explicitly.

 <dl>
 <dt>Bounded on both ends
 <dd>{@link #range}
 <dt>Unbounded on top ({@code (a..+#)} or {@code (a..+#)})
 <dd>{@link #downTo}
 <dt>Unbounded on bottom ({@code (-#..b)} or {@code (-#..b]})
 <dd>{@link #upTo}
 </dl>
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/RangesExplained">
 {@code Range}</a>.

 @author Kevin Bourrillion
 @author Gregory Kick
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Ranges -->
  <!-- start interface com.google.common.collect.RowSortedTable -->
  <interface name="RowSortedTable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Table&lt;R, C, V&gt;"/>
    <method name="rowKeySet" return="java.util.SortedSet&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a {@link SortedSet}, instead of the {@code Set}
 specified in the {@link Table} interface.]]>
      </doc>
    </method>
    <method name="rowMap" return="java.util.SortedMap&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a {@link SortedMap}, instead of the {@code Map}
 specified in the {@link Table} interface.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface that extends {@code Table} and whose rows are sorted.

 <p>The {@link #rowKeySet} method returns a {@link SortedSet} and the {@link
 #rowMap} method returns a {@link SortedMap}, instead of the {@link Set} and
 {@link Map} specified by the {@link Table} interface.

 @author Warren Dukes
 @since 8.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.RowSortedTable -->
  <!-- start interface com.google.common.collect.SetMultimap -->
  <interface name="SetMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.

 <p>Any duplicates in {@code values} will be stored in the multimap once.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this
 method returns a {@link Set}, instead of the {@link java.util.Collection}
 specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Though the method signature doesn't say so explicitly, the returned map
 has {@link Set} values.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code SetMultimap} instances are equal if, for each key, they
 contain the same values. Equality does not depend on the ordering of keys
 or values.

 <p>An empty {@code SetMultimap} is equal to any other empty {@code
 Multimap}, including an empty {@code ListMultimap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multimap} that cannot hold duplicate key-value pairs. Adding a
 key-value pair that's already in the multimap has no effect. See the {@link
 Multimap} documentation for information common to all multimaps.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods
 each return a {@link Set} of values, while {@link #entries} returns a {@code
 Set} of map entries. Though the method signature doesn't say so explicitly,
 the map returned by {@link #asMap} has {@code Set} values.

 <p>If the values corresponding to a single key should be ordered according to
 a {@link java.util.Comparator} (or the natural order), see the
 {@link SortedSetMultimap} subinterface.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SetMultimap -->
  <!-- start class com.google.common.collect.Sets -->
  <class name="Sets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="immutableEnumSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="anElement" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="otherElements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set instance containing the given enum elements.
 Internally, the returned set will be backed by an {@link EnumSet}.

 <p>The iteration order of the returned set follows the enum's iteration
 order, not the order in which the elements are provided to the method.

 @param anElement one of the elements the set should contain
 @param otherElements the rest of the elements the set should contain
 @return an immutable set containing those elements, minus duplicates]]>
      </doc>
    </method>
    <method name="immutableEnumSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set instance containing the given enum elements.
 Internally, the returned set will be backed by an {@link EnumSet}.

 <p>The iteration order of the returned set follows the enum's iteration
 order, not the order in which the elements appear in the given collection.

 @param elements the elements, all of the same {@code enum} type, that the
     set should contain
 @return an immutable set containing those elements, minus duplicates]]>
      </doc>
    </method>
    <method name="newEnumSet" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="elementType" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code EnumSet} instance containing the given elements.
 Unlike {@link EnumSet#copyOf(Collection)}, this method does not produce an
 exception on an empty collection, and it may be called on any iterable, not
 just a {@code Collection}.]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code HashSet} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSet#of()} instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link
 EnumSet#noneOf} instead.

 @return a new, empty {@code HashSet}]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given
 elements in unspecified order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use an overload of {@link ImmutableSet#of()} (for varargs) or
 {@link ImmutableSet#copyOf(Object[])} (for an array) instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link
 EnumSet#of(Enum, Enum[])} instead.

 @param elements the elements that the set should contain
 @return a new {@code HashSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newHashSetWithExpectedSize" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates a {@code HashSet} instance, with a high enough "initial capacity"
 that it <i>should</i> hold {@code expectedSize} elements without growth.
 This behavior cannot be broadly guaranteed, but it is observed to be true
 for OpenJDK 1.6. It also can't be guaranteed that the method isn't
 inadvertently <i>oversizing</i> the returned set.

 @param expectedSize the number of elements you expect to add to the
        returned set
 @return a new, empty {@code HashSet} with enough capacity to hold {@code
         expectedSize} elements without resizing
 @throws IllegalArgumentException if {@code expectedSize} is negative]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given
 elements in unspecified order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, use
 {@link #newEnumSet(Iterable, Class)} instead.

 @param elements the elements that the set should contain
 @return a new {@code HashSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given
 elements in unspecified order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an
 {@link EnumSet} instead.

 @param elements the elements that the set should contain
 @return a new {@code HashSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newLinkedHashSet" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSet#of()} instead.

 @return a new, empty {@code LinkedHashSet}]]>
      </doc>
    </method>
    <method name="newLinkedHashSetWithExpectedSize" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates a {@code LinkedHashSet} instance, with a high enough "initial
 capacity" that it <i>should</i> hold {@code expectedSize} elements without
 growth. This behavior cannot be broadly guaranteed, but it is observed to
 be true for OpenJDK 1.6. It also can't be guaranteed that the method isn't
 inadvertently <i>oversizing</i> the returned set.

 @param expectedSize the number of elements you expect to add to the
        returned set
 @return a new, empty {@code LinkedHashSet} with enough capacity to hold
         {@code expectedSize} elements without resizing
 @throws IllegalArgumentException if {@code expectedSize} is negative
 @since 11.0]]>
      </doc>
    </method>
    <method name="newLinkedHashSet" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code LinkedHashSet} instance containing the
 given elements in order.

 <p><b>Note:</b> if mutability is not required and the elements are
 non-null, use {@link ImmutableSet#copyOf(Iterable)} instead.

 @param elements the elements that the set should contain, in order
 @return a new {@code LinkedHashSet} containing those elements (minus
     duplicates)]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeSet} instance sorted by the
 natural sort ordering of its elements.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedSet#of()} instead.

 @return a new, empty {@code TreeSet}]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code TreeSet} instance containing the given
 elements sorted by their natural ordering.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedSet#copyOf(Iterable)} instead.

 <p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit
 comparator, this method has different behavior than
 {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code TreeSet} with
 that comparator.

 @param elements the elements that the set should contain
 @return a new {@code TreeSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeSet} instance with the given
 comparator.

 <p><b>Note:</b> if mutability is not required, use {@code
 ImmutableSortedSet.orderedBy(comparator).build()} instead.

 @param comparator the comparator to use to sort the set
 @return a new, empty {@code TreeSet}
 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="newIdentityHashSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code Set} that uses identity to determine equality. It
 compares object references, instead of calling {@code equals}, to
 determine whether a provided object matches an element in the set. For
 example, {@code contains} returns {@code false} when passed an object that
 equals a set member, but isn't the same instance. This behavior is similar
 to the way {@code IdentityHashMap} handles key lookups.

 @since 8.0]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArraySet" return="java.util.concurrent.CopyOnWriteArraySet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code CopyOnWriteArraySet} instance.

 <p><b>Note:</b> if you need an immutable empty {@link Set}, use
 {@link Collections#emptySet} instead.

 @return a new, empty {@code CopyOnWriteArraySet}
 @since 12.0]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArraySet" return="java.util.concurrent.CopyOnWriteArraySet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code CopyOnWriteArraySet} instance containing the given elements.

 @param elements the elements that the set should contain, in order
 @return a new {@code CopyOnWriteArraySet} containing those elements
 @since 12.0]]>
      </doc>
    </method>
    <method name="complementOf" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumSet} consisting of all enum values that are not in
 the specified collection. If the collection is an {@link EnumSet}, this
 method has the same behavior as {@link EnumSet#complementOf}. Otherwise,
 the specified collection must contain at least one element, in order to
 determine the element type. If the collection could be empty, use
 {@link #complementOf(Collection, Class)} instead of this method.

 @param collection the collection whose complement should be stored in the
     enum set
 @return a new, modifiable {@code EnumSet} containing all values of the enum
     that aren't present in the given collection
 @throws IllegalArgumentException if {@code collection} is not an
     {@code EnumSet} instance and contains no elements]]>
      </doc>
    </method>
    <method name="complementOf" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumSet} consisting of all enum values that are not in
 the specified collection. This is equivalent to
 {@link EnumSet#complementOf}, but can act on any input collection, as long
 as the elements are of enum type.

 @param collection the collection whose complement should be stored in the
     {@code EnumSet}
 @param type the type of the elements in the set
 @return a new, modifiable {@code EnumSet} initially containing all the
     values of the enum not present in the given collection]]>
      </doc>
    </method>
    <method name="newSetFromMap" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;E, java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Returns a set backed by the specified map. The resulting set displays
 the same ordering, concurrency, and performance characteristics as the
 backing map. In essence, this factory method provides a {@link Set}
 implementation corresponding to any {@link Map} implementation. There is no
 need to use this method on a {@link Map} implementation that already has a
 corresponding {@link Set} implementation (such as {@link java.util.HashMap}
 or {@link java.util.TreeMap}).

 <p>Each method invocation on the set returned by this method results in
 exactly one method invocation on the backing map or its {@code keySet}
 view, with one exception. The {@code addAll} method is implemented as a
 sequence of {@code put} invocations on the backing map.

 <p>The specified map must be empty at the time this method is invoked,
 and should not be accessed directly after this method returns. These
 conditions are ensured if the map is created empty, passed directly
 to this method, and no reference to the map is retained, as illustrated
 in the following code fragment: <pre>  {@code

   Set<Object> identityHashSet = Sets.newSetFromMap(
       new IdentityHashMap<Object, Boolean>());}</pre>

 This method has the same behavior as the JDK 6 method
 {@code Collections.newSetFromMap()}. The returned set is serializable if
 the backing map is.

 @param map the backing map
 @return the set backed by the map
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="union" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;? extends E&gt;"/>
      <param name="set2" type="java.util.Set&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the union of two sets. The returned
 set contains all elements that are contained in either backing set.
 Iterating over the returned set iterates first over all the elements of
 {@code set1}, then over each element of {@code set2}, in order, that is not
 contained in {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based on
 different equivalence relations (as {@link HashSet}, {@link TreeSet}, and
 the {@link Map#keySet} of an {@code IdentityHashMap} all are).

 <p><b>Note:</b> The returned view performs better when {@code set1} is the
 smaller of the two sets. If you have reason to believe one of your sets
 will generally be smaller than the other, pass it first.

 <p>Further, note that the current implementation is not suitable for nested
 {@code union} views, i.e. the following should be avoided when in a loop:
 {@code union = Sets.union(union, anotherSet);}, since iterating over the resulting
 set has a cubic complexity to the depth of the nesting.]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;E&gt;"/>
      <param name="set2" type="java.util.Set&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the intersection of two sets. The
 returned set contains all elements that are contained by both backing sets.
 The iteration order of the returned set matches that of {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based
 on different equivalence relations (as {@code HashSet}, {@code TreeSet},
 and the keySet of an {@code IdentityHashMap} all are).

 <p><b>Note:</b> The returned view performs slightly better when {@code
 set1} is the smaller of the two sets. If you have reason to believe one of
 your sets will generally be smaller than the other, pass it first.
 Unfortunately, since this method sets the generic type of the returned set
 based on the type of the first set passed, this could in rare cases force
 you to make a cast, for example: <pre>   {@code

   Set<Object> aFewBadObjects = ...
   Set<String> manyBadStrings = ...

   // impossible for a non-String to be in the intersection
   SuppressWarnings("unchecked")
   Set<String> badStrings = (Set) Sets.intersection(
       aFewBadObjects, manyBadStrings);}</pre>

 This is unfortunate, but should come up only very rarely.]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;E&gt;"/>
      <param name="set2" type="java.util.Set&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the difference of two sets. The
 returned set contains all elements that are contained by {@code set1} and
 not contained by {@code set2}. {@code set2} may also contain elements not
 present in {@code set1}; these are simply ignored. The iteration order of
 the returned set matches that of {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based
 on different equivalence relations (as {@code HashSet}, {@code TreeSet},
 and the keySet of an {@code IdentityHashMap} all are).]]>
      </doc>
    </method>
    <method name="symmetricDifference" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;? extends E&gt;"/>
      <param name="set2" type="java.util.Set&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the symmetric difference of two
 sets. The returned set contains all elements that are contained in either
 {@code set1} or {@code set2} but not in both. The iteration order of the
 returned set is undefined.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based
 on different equivalence relations (as {@code HashSet}, {@code TreeSet},
 and the keySet of an {@code IdentityHashMap} all are).

 @since 3.0]]>
      </doc>
    </method>
    <method name="filter" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Set&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The
 returned set is a live view of {@code unfiltered}; changes to one affect
 the other.

 <p>The resulting set's iterator does not support {@code remove()}, but all
 other set methods are supported. When given an element that doesn't satisfy
 the predicate, the set's {@code add()} and {@code addAll()} methods throw
 an {@link IllegalArgumentException}. When methods such as {@code
 removeAll()} and {@code clear()} are called on the filtered set, only
 elements that satisfy the filter will be removed from the underlying set.

 <p>The returned set isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered set's methods, such as {@code size()}, iterate
 across every element in the underlying set and determine which elements
 satisfy the filter. When a live view is <i>not</i> needed, it may be faster
 to copy {@code Iterables.filter(unfiltered, predicate)} and use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,
 as documented at {@link Predicate#apply}. Do not provide a predicate such
 as {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent
 with equals. (See {@link Iterables#filter(Iterable, Class)} for related
 functionality.)]]>
      </doc>
    </method>
    <method name="filter" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedSet&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of a {@code SortedSet}, {@code unfiltered}, that
 satisfy a predicate. The returned set is a live view of {@code unfiltered};
 changes to one affect the other.

 <p>The resulting set's iterator does not support {@code remove()}, but all
 other set methods are supported. When given an element that doesn't satisfy
 the predicate, the set's {@code add()} and {@code addAll()} methods throw
 an {@link IllegalArgumentException}. When methods such as
 {@code removeAll()} and {@code clear()} are called on the filtered set,
 only elements that satisfy the filter will be removed from the underlying
 set.

 <p>The returned set isn't threadsafe or serializable, even if
 {@code unfiltered} is.

 <p>Many of the filtered set's methods, such as {@code size()}, iterate across
 every element in the underlying set and determine which elements satisfy
 the filter. When a live view is <i>not</i> needed, it may be faster to copy
 {@code Iterables.filter(unfiltered, predicate)} and use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>,
 as documented at {@link Predicate#apply}. Do not provide a predicate such as
 {@code Predicates.instanceOf(ArrayList.class)}, which is inconsistent with
 equals. (See {@link Iterables#filter(Iterable, Class)} for related
 functionality.)

 @since 11.0]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.Set&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sets" type="java.util.List&lt;? extends java.util.Set&lt;? extends B&gt;&gt;"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element
 from each of the given sets in order; the "n-ary
 <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the sets. For example: <pre>   {@code

   Sets.cartesianProduct(ImmutableList.of(
       ImmutableSet.of(1, 2),
       ImmutableSet.of("A", "B", "C")))}</pre>

 returns a set containing six lists:

 <ul>
 <li>{@code ImmutableList.of(1, "A")}
 <li>{@code ImmutableList.of(1, "B")}
 <li>{@code ImmutableList.of(1, "C")}
 <li>{@code ImmutableList.of(2, "A")}
 <li>{@code ImmutableList.of(2, "B")}
 <li>{@code ImmutableList.of(2, "C")}
 </ul>

 The order in which these lists are returned is not guaranteed, however the
 position of an element inside a tuple always corresponds to the position of
 the set from which it came in the input list. Note that if any input set is
 empty, the Cartesian product will also be empty. If no sets at all are
 provided (an empty list), the resulting Cartesian product has one element,
 an empty list (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of sets of size
 {@code m, n, p} is a set of size {@code m x n x p}, its actual memory
 consumption is much smaller. When the cartesian set is constructed, the
 input sets are merely copied. Only as the resulting set is iterated are the
 individual lists created, and these are not retained after iteration.

 @param sets the sets to choose elements from, in the order that
     the elements chosen from those sets should appear in the resulting
     lists
 @param <B> any common base class shared by all axes (often just {@link
     Object})
 @return the Cartesian product, as an immutable set containing immutable
     lists
 @throws NullPointerException if {@code sets}, any one of the {@code sets},
     or any element of a provided set is null
 @since 2.0]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.Set&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sets" type="java.util.Set[]"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element
 from each of the given sets in order; the "n-ary
 <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the sets. For example: <pre>   {@code

   Sets.cartesianProduct(
       ImmutableSet.of(1, 2),
       ImmutableSet.of("A", "B", "C"))}</pre>

 returns a set containing six lists:

 <ul>
 <li>{@code ImmutableList.of(1, "A")}
 <li>{@code ImmutableList.of(1, "B")}
 <li>{@code ImmutableList.of(1, "C")}
 <li>{@code ImmutableList.of(2, "A")}
 <li>{@code ImmutableList.of(2, "B")}
 <li>{@code ImmutableList.of(2, "C")}
 </ul>

 The order in which these lists are returned is not guaranteed, however the
 position of an element inside a tuple always corresponds to the position of
 the set from which it came in the input list. Note that if any input set is
 empty, the Cartesian product will also be empty. If no sets at all are
 provided, the resulting Cartesian product has one element, an empty list
 (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of sets of size
 {@code m, n, p} is a set of size {@code m x n x p}, its actual memory
 consumption is much smaller. When the cartesian set is constructed, the
 input sets are merely copied. Only as the resulting set is iterated are the
 individual lists created, and these are not retained after iteration.

 @param sets the sets to choose elements from, in the order that
     the elements chosen from those sets should appear in the resulting
     lists
 @param <B> any common base class shared by all axes (often just {@link
     Object})
 @return the Cartesian product, as an immutable set containing immutable
     lists
 @throws NullPointerException if {@code sets}, any one of the {@code sets},
     or any element of a provided set is null
 @since 2.0]]>
      </doc>
    </method>
    <method name="powerSet" return="java.util.Set&lt;java.util.Set&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the set of all possible subsets of {@code set}. For example,
 {@code powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{},
 {1}, {2}, {1, 2}}}.

 <p>Elements appear in these subsets in the same iteration order as they
 appeared in the input set. The order in which these subsets appear in the
 outer set is undefined. Note that the power set of the empty set is not the
 empty set, but a one-element set containing the empty set.

 <p>The returned set and its constituent sets use {@code equals} to decide
 whether two elements are identical, even if the input set uses a different
 concept of equivalence.

 <p><i>Performance notes:</i> while the power set of a set with size {@code
 n} is of size {@code 2^n}, its memory usage is only {@code O(n)}. When the
 power set is constructed, the input set is merely copied. Only as the
 power set is iterated are the individual subsets created, and these subsets
 themselves occupy only a few bytes of memory regardless of their size.

 @param set the set of elements to construct a power set from
 @return the power set, as an immutable set of immutable sets
 @throws IllegalArgumentException if {@code set} has more than 30 unique
     elements (causing the power set size to exceed the {@code int} range)
 @throws NullPointerException if {@code set} is or contains {@code null}
 @see <a href="http://en.wikipedia.org/wiki/Power_set">Power set article at
      Wikipedia</a>
 @since 4.0]]>
      </doc>
    </method>
    <method name="unmodifiableNavigableSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.NavigableSet&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified navigable set. This method
 allows modules to provide users with "read-only" access to internal
 navigable sets. Query operations on the returned set "read through" to the
 specified set, and attempts to modify the returned set, whether direct or
 via its collection views, result in an
 {@code UnsupportedOperationException}.

 <p>The returned navigable set will be serializable if the specified
 navigable set is serializable.

 @param set the navigable set for which an unmodifiable view is to be
        returned
 @return an unmodifiable view of the specified navigable set
 @since 12.0]]>
      </doc>
    </method>
    <method name="synchronizedNavigableSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="navigableSet" type="java.util.NavigableSet&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) navigable set backed by the specified
 navigable set.  In order to guarantee serial access, it is critical that
 <b>all</b> access to the backing navigable set is accomplished
 through the returned navigable set (or its views).

 <p>It is imperative that the user manually synchronize on the returned
 sorted set when iterating over it or any of its {@code descendingSet},
 {@code subSet}, {@code headSet}, or {@code tailSet} views. <pre>   {@code

   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());
    ...
   synchronized (set) {
     // Must be in the synchronized block
     Iterator<E> it = set.iterator();
     while (it.hasNext()){
       foo(it.next());
     }
   }}</pre>

 or: <pre>   {@code

   NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());
   NavigableSet<E> set2 = set.descendingSet().headSet(foo);
    ...
   synchronized (set) { // Note: set, not set2!!!
     // Must be in the synchronized block
     Iterator<E> it = set2.descendingIterator();
     while (it.hasNext())
       foo(it.next());
     }
   }}</pre>

 Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned navigable set will be serializable if the specified
 navigable set is serializable.

 @param navigableSet the navigable set to be "wrapped" in a synchronized
    navigable set.
 @return a synchronized view of the specified navigable set.
 @since 13.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Set} instances. Also see this
 class's counterparts {@link Lists} and {@link Maps}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Sets">
 {@code Sets}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @author Chris Povirk
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Sets -->
  <!-- start class com.google.common.collect.Sets.SetView -->
  <class name="Sets.SetView" extends="java.util.AbstractSet&lt;E&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="immutableCopy" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable copy of the current contents of this set view.
 Does not support null elements.

 <p><b>Warning:</b> this may have unexpected results if a backing set of
 this view uses a nonstandard notion of equivalence, for example if it is
 a {@link TreeSet} using a comparator that is inconsistent with {@link
 Object#equals(Object)}.]]>
      </doc>
    </method>
    <method name="copyInto" return="S extends java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="S extends java.util.Set&lt;E&gt;"/>
      <doc>
      <![CDATA[Copies the current contents of this set view into an existing set. This
 method has equivalent behavior to {@code set.addAll(this)}, assuming that
 all the sets involved are based on the same notion of equivalence.

 @return a reference to {@code set}, for convenience]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An unmodifiable view of a set which may be backed by other sets; this view
 will change as the backing sets do. Contains methods to copy the data into
 a new set which will then remain stable. There is usually no reason to
 retain a reference of type {@code SetView}; typically, you either use it
 as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or
 {@link #copyInto} and forget the {@code SetView} itself.

 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Sets.SetView -->
  <!-- start interface com.google.common.collect.SortedMapDifference -->
  <interface name="SortedMapDifference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.MapDifference&lt;K, V&gt;"/>
    <method name="entriesOnlyOnLeft" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entriesOnlyOnRight" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entriesInCommon" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entriesDiffering" return="java.util.SortedMap&lt;K, com.google.common.collect.MapDifference.ValueDifference&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An object representing the differences between two sorted maps.

 @author Louis Wasserman
 @since 8.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SortedMapDifference -->
  <!-- start interface com.google.common.collect.SortedMultiset -->
  <interface name="SortedMultiset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multiset&lt;E&gt;"/>
    <implements name="com.google.common.collect.SortedIterable&lt;E&gt;"/>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders this multiset, or
 {@link Ordering#natural()} if the natural ordering of the elements is used.]]>
      </doc>
    </method>
    <method name="firstEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entry of the first element in this multiset, or {@code null} if
 this multiset is empty.]]>
      </doc>
    </method>
    <method name="lastEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entry of the last element in this multiset, or {@code null} if
 this multiset is empty.]]>
      </doc>
    </method>
    <method name="pollFirstEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns and removes the entry associated with the lowest element in this
 multiset, or returns {@code null} if this multiset is empty.]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns and removes the entry associated with the greatest element in this
 multiset, or returns {@code null} if this multiset is empty.]]>
      </doc>
    </method>
    <method name="elementSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link SortedSet} view of the distinct elements in this multiset.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator returns the elements in ascending order according to this
 multiset's comparator.]]>
      </doc>
    </method>
    <method name="descendingMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a descending view of this multiset. Modifications made to either
 map will be reflected in the other.]]>
      </doc>
    </method>
    <method name="headMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a view of this multiset restricted to the elements less than
 {@code upperBound}, optionally including {@code upperBound} itself. The
 returned multiset is a view of this multiset, so changes to one will be
 reflected in the other. The returned multiset supports all operations that
 this multiset supports.
 
 <p>The returned multiset will throw an {@link IllegalArgumentException} on
 attempts to add elements outside its range.]]>
      </doc>
    </method>
    <method name="subMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E"/>
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBound" type="E"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a view of this multiset restricted to the range between
 {@code lowerBound} and {@code upperBound}. The returned multiset is a view
 of this multiset, so changes to one will be reflected in the other. The
 returned multiset supports all operations that this multiset supports.
 
 <p>The returned multiset will throw an {@link IllegalArgumentException} on
 attempts to add elements outside its range.
 
 <p>This method is equivalent to
 {@code tailMultiset(lowerBound, lowerBoundType).headMultiset(upperBound,
 upperBoundType)}.]]>
      </doc>
    </method>
    <method name="tailMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a view of this multiset restricted to the elements greater than
 {@code lowerBound}, optionally including {@code lowerBound} itself. The
 returned multiset is a view of this multiset, so changes to one will be
 reflected in the other. The returned multiset supports all operations that
 this multiset supports.
 
 <p>The returned multiset will throw an {@link IllegalArgumentException} on
 attempts to add elements outside its range.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Multiset} which maintains the ordering of its elements, according to
 either their natural order or an explicit {@link Comparator}. In all cases,
 this implementation uses {@link Comparable#compareTo} or
 {@link Comparator#compare} instead of {@link Object#equals} to determine
 equivalence of instances.
 
 <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as
 explained by the {@link Comparable} class specification. Otherwise, the
 resulting multiset will violate the {@link Collection} contract, which it is
 specified in terms of {@link Object#equals}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset">
 {@code Multiset}</a>.
 
 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SortedMultiset -->
  <!-- start interface com.google.common.collect.SortedSetMultimap -->
  <interface name="SortedSetMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns a collection view of all values associated with a key. If no
 mappings in the multimap have the provided key, an empty collection is
 returned.

 <p>Changes to the returned collection will update the underlying multimap,
 and vice versa.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given
 key, this method returns a {@link SortedSet}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes all values associated with a given key.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given
 key, this method returns a {@link SortedSet}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key, replacing any existing
 values for that key.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given
 key, this method returns a {@link SortedSet}, instead of the
 {@link java.util.Collection} specified in the {@link Multimap} interface.

 <p>Any duplicates in {@code values} will be stored in the multimap once.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map view that associates each key with the corresponding values
 in the multimap. Changes to the returned map, such as element removal, will
 update the underlying multimap. The map does not support {@code setValue()}
 on its entries, {@code put}, or {@code putAll}.

 <p>When passed a key that is present in the map, {@code
 asMap().get(Object)} has the same behavior as {@link #get}, returning a
 live collection. When passed a key that is not present, however, {@code
 asMap().get(Object)} returns {@code null} instead of an empty collection.

 <p>Though the method signature doesn't say so explicitly, the returned map
 has {@link SortedSet} values.]]>
      </doc>
    </method>
    <method name="valueComparator" return="java.util.Comparator&lt;? super V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the multimap values, with {@code null}
 indicating that natural ordering is used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code SetMultimap} whose set of values for a given key are kept sorted;
 that is, they comprise a {@link SortedSet}. It cannot hold duplicate
 key-value pairs; adding a key-value pair that's already in the multimap has
 no effect. This interface does not specify the ordering of the multimap's
 keys. See the {@link Multimap} documentation for information common to all
 multimaps.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods
 each return a {@link SortedSet} of values, while {@link Multimap#entries()}
 returns a {@link Set} of map entries. Though the method signature doesn't say
 so explicitly, the map returned by {@link #asMap} has {@code SortedSet}
 values.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SortedSetMultimap -->
  <!-- start interface com.google.common.collect.Table -->
  <interface name="Table"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified
 row and column keys.

 @param rowKey key of row to search for
 @param columnKey key of column to search for]]>
      </doc>
    </method>
    <method name="containsRow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified
 row key.

 @param rowKey key of row to search for]]>
      </doc>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified
 column.

 @param columnKey key of column to search for]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified
 value.

 @param value value to search for]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value corresponding to the given row and column keys, or
 {@code null} if no such mapping exists.

 @param rowKey key of row to search for
 @param columnKey key of column to search for]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if the table contains no mappings.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of row key / column key / value mappings in the table.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this table for equality. Two tables are
 equal when their cell views, as returned by {@link #cellSet}, are equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this table. The hash code of a table is defined
 as the hash code of its cell view, as returned by {@link #cellSet}.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all mappings from the table.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates the specified value with the specified keys. If the table
 already contained a mapping for those keys, the old value is replaced with
 the specified value.

 @param rowKey row key that the value should be associated with
 @param columnKey column key that the value should be associated with
 @param value value to be associated with the specified keys
 @return the value previously associated with the keys, or {@code null} if
     no mapping existed for the keys]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Copies all mappings from the specified table to this table. The effect is
 equivalent to calling {@link #put} with each row key / column key / value
 mapping in {@code table}.

 @param table the table to add to this table]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes the mapping, if any, associated with the given keys.

 @param rowKey row key of mapping to be removed
 @param columnKey column key of mapping to be removed
 @return the value previously associated with the keys, or {@code null} if
     no such value existed]]>
      </doc>
    </method>
    <method name="row" return="java.util.Map&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given row key. For each row
 key / column key / value mapping in the table with that row key, the
 returned map associates the column key with the value. If no mappings in
 the table have the provided row key, an empty map is returned.

 <p>Changes to the returned map will update the underlying table, and vice
 versa.

 @param rowKey key of row to search for in the table
 @return the corresponding map from column keys to values]]>
      </doc>
    </method>
    <method name="column" return="java.util.Map&lt;R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given column key. For each row
 key / column key / value mapping in the table with that column key, the
 returned map associates the row key with the value. If no mappings in the
 table have the provided column key, an empty map is returned.

 <p>Changes to the returned map will update the underlying table, and vice
 versa.

 @param columnKey key of column to search for in the table
 @return the corresponding map from row keys to values]]>
      </doc>
    </method>
    <method name="cellSet" return="java.util.Set&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of all row key / column key / value triplets. Changes to the
 returned set will update the underlying table, and vice versa. The cell set
 does not support the {@code add} or {@code addAll} methods.

 @return set of table cells consisting of row key / column key / value
     triplets]]>
      </doc>
    </method>
    <method name="rowKeySet" return="java.util.Set&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of row keys that have one or more values in the table.
 Changes to the set will update the underlying table, and vice versa.

 @return set of row keys]]>
      </doc>
    </method>
    <method name="columnKeySet" return="java.util.Set&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of column keys that have one or more values in the table.
 Changes to the set will update the underlying table, and vice versa.

 @return set of column keys]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all values, which may contain duplicates. Changes
 to the returned collection will update the underlying table, and vice
 versa.

 @return collection of values]]>
      </doc>
    </method>
    <method name="rowMap" return="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view that associates each row key with the corresponding map from
 column keys to values. Changes to the returned map will update this table.
 The returned map does not support {@code put()} or {@code putAll()}, or
 {@code setValue()} on its entries.

 <p>In contrast, the maps returned by {@code rowMap().get()} have the same
 behavior as those returned by {@link #row}. Those maps may support {@code
 setValue()}, {@code put()}, and {@code putAll()}.

 @return a map view from each row key to a secondary map from column keys to
     values]]>
      </doc>
    </method>
    <method name="columnMap" return="java.util.Map&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view that associates each column key with the corresponding map
 from row keys to values. Changes to the returned map will update this
 table. The returned map does not support {@code put()} or {@code putAll()},
 or {@code setValue()} on its entries.

 <p>In contrast, the maps returned by {@code columnMap().get()} have the
 same behavior as those returned by {@link #column}. Those maps may support
 {@code setValue()}, {@code put()}, and {@code putAll()}.

 @return a map view from each column key to a secondary map from row keys to
     values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection that associates an ordered pair of keys, called a row key and a
 column key, with a single value. A table may be sparse, with only a small
 fraction of row key / column key pairs possessing a corresponding value.

 <p>The mappings corresponding to a given row key may be viewed as a {@link
 Map} whose keys are the columns. The reverse is also available, associating a
 column with a row key / value map. Note that, in some implementations, data
 access by column key may have fewer supported operations or worse performance
 than data access by row key.

 <p>The methods returning collections or maps always return views of the
 underlying table. Updating the table can change the contents of those
 collections, and updating the collections will change the table.

 <p>All methods that modify the table are optional, and the views returned by
 the table may or may not be modifiable. When modification isn't supported,
 those methods will throw an {@link UnsupportedOperationException}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Table">
 {@code Table}</a>.

 @author Jared Levy
 @param <R> the type of the table row keys
 @param <C> the type of the table column keys
 @param <V> the type of the mapped values
 @since 7.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Table -->
  <!-- start interface com.google.common.collect.Table.Cell -->
  <interface name="Table.Cell"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRowKey" return="R"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the row key of this cell.]]>
      </doc>
    </method>
    <method name="getColumnKey" return="C"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the column key of this cell.]]>
      </doc>
    </method>
    <method name="getValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this cell.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares the specified object with this cell for equality. Two cells are
 equal when they have equal row keys, column keys, and values.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code of this cell.

 <p>The hash code of a table cell is equal to {@link
 Objects#hashCode}{@code (e.getRowKey(), e.getColumnKey(), e.getValue())}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Row key / column key / value triplet corresponding to a mapping in a table.

 @since 7.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Table.Cell -->
  <!-- start class com.google.common.collect.Tables -->
  <class name="Tables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="immutableCell" return="com.google.common.collect.Table.Cell&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns an immutable cell with the specified row key, column key, and
 value.

 <p>The returned cell is serializable.

 @param rowKey the row key to be associated with the returned cell
 @param columnKey the column key to be associated with the returned cell
 @param value the value to be associated with the returned cell]]>
      </doc>
    </method>
    <method name="transpose" return="com.google.common.collect.Table&lt;C, R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;R, C, V&gt;"/>
      <doc>
      <![CDATA[Creates a transposed view of a given table that flips its row and column
 keys. In other words, calling {@code get(columnKey, rowKey)} on the
 generated table always returns the same value as calling {@code
 get(rowKey, columnKey)} on the original table. Updating the original table
 changes the contents of the transposed table and vice versa.

 <p>The returned table supports update operations as long as the input table
 supports the analogous operation with swapped rows and columns. For
 example, in a {@link HashBasedTable} instance, {@code
 rowKeySet().iterator()} supports {@code remove()} but {@code
 columnKeySet().iterator()} doesn't. With a transposed {@link
 HashBasedTable}, it's the other way around.]]>
      </doc>
    </method>
    <method name="newCustomTable" return="com.google.common.collect.Table&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Map&lt;C, V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a table that uses the specified backing map and factory. It can
 generate a table based on arbitrary {@link Map} classes.

 <p>The {@code factory}-generated and {@code backingMap} classes determine
 the table iteration order. However, the table's {@code row()} method
 returns instances of a different class than {@code factory.get()} does.

 <p>Call this method only when the simpler factory methods in classes like
 {@link HashBasedTable} and {@link TreeBasedTable} won't suffice.

 <p>The views returned by the {@code Table} methods {@link Table#column},
 {@link Table#columnKeySet}, and {@link Table#columnMap} have iterators that
 don't support {@code remove()}. Otherwise, all optional operations are
 supported. Null row keys, columns keys, and values are not supported.

 <p>Lookups by row key are often faster than lookups by column key, because
 the data is stored in a {@code Map<R, Map<C, V>>}. A method call like
 {@code column(columnKey).get(rowKey)} still runs quickly, since the row key
 is provided. However, {@code column(columnKey).size()} takes longer, since
 an iteration across all row keys occurs.

 <p>Note that this implementation is not synchronized. If multiple threads
 access this table concurrently and one of the threads modifies the table,
 it must be synchronized externally.

 <p>The table is serializable if {@code backingMap}, {@code factory}, the
 maps generated by {@code factory}, and the table contents are all
 serializable.

 <p>Note: the table assumes complete ownership over of {@code backingMap}
 and the maps returned by {@code factory}. Those objects should not be
 manually updated and they should not use soft, weak, or phantom references.

 @param backingMap place to store the mapping from each row key to its
     corresponding column key / value map
 @param factory supplier of new, empty maps that will each hold all column
     key / value mappings for a given row key
 @throws IllegalArgumentException if {@code backingMap} is not empty
 @since 10.0]]>
      </doc>
    </method>
    <method name="transformValues" return="com.google.common.collect.Table&lt;R, C, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromTable" type="com.google.common.collect.Table&lt;R, C, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a table where each value is transformed by a function.
 All other properties of the table, such as iteration order, are left
 intact.

 <p>Changes in the underlying table are reflected in this view. Conversely,
 this view supports removal operations, and these are reflected in the
 underlying table.

 <p>It's acceptable for the underlying table to contain null keys, and even
 null values provided that the function is capable of accepting null input.
 The transformed table might contain null values, if the function sometimes
 gives a null result.

 <p>The returned table is not thread-safe or serializable, even if the
 underlying table is.

 <p>The function is applied lazily, invoked when needed. This is necessary
 for the returned table to be a view, but it means that the function will be
 applied many times for bulk operations like {@link Table#containsValue} and
 {@code Table.toString()}. For this to perform well, {@code function} should
 be fast. To avoid lazy evaluation when the returned table doesn't need to
 be a view, copy the returned table into a new table of your choosing.

 @since 10.0]]>
      </doc>
    </method>
    <method name="unmodifiableTable" return="com.google.common.collect.Table&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified table. This method allows modules to provide
 users with "read-only" access to internal tables. Query operations on the returned table
 "read through" to the specified table, and attempts to modify the returned table, whether
 direct or via its collection views, result in an {@code UnsupportedOperationException}.
 
 <p>The returned table will be serializable if the specified table is serializable.

 <p>Consider using an {@link ImmutableTable}, which is guaranteed never to change.
 
 @param table
          the table for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified table
 @since 11.0]]>
      </doc>
    </method>
    <method name="unmodifiableRowSortedTable" return="com.google.common.collect.RowSortedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.RowSortedTable&lt;R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified row-sorted table. This method allows modules to
 provide users with "read-only" access to internal tables. Query operations on the returned
 table "read through" to the specified table, and attemps to modify the returned table, whether
 direct or via its collection views, result in an {@code UnsupportedOperationException}.
 
 <p>The returned table will be serializable if the specified table is serializable.
 
 @param table the row-sorted table for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified table
 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods that involve a {@code Table}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/CollectionUtilitiesExplained#Tables">
 {@code Tables}</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Tables -->
  <!-- start class com.google.common.collect.TreeBasedTable -->
  <class name="TreeBasedTable" extends="com.google.common.collect.StandardRowSortedTable&lt;R, C, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.TreeBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code TreeBasedTable} that uses the natural orderings
 of both row and column keys.

 <p>The method signature specifies {@code R extends Comparable} with a raw
 {@link Comparable}, instead of {@code R extends Comparable<? super R>},
 and the same for {@code C}. That's necessary to support classes defined
 without generics.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowComparator" type="java.util.Comparator&lt;? super R&gt;"/>
      <param name="columnComparator" type="java.util.Comparator&lt;? super C&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code TreeBasedTable} that is ordered by the specified
 comparators.

 @param rowComparator the comparator that orders the row keys
 @param columnComparator the comparator that orders the column keys]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.TreeBasedTable&lt;R, C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a {@code TreeBasedTable} with the same mappings and sort order
 as the specified {@code TreeBasedTable}.]]>
      </doc>
    </method>
    <method name="rowComparator" return="java.util.Comparator&lt;? super R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the rows. With natural ordering,
 {@link Ordering#natural()} is returned.]]>
      </doc>
    </method>
    <method name="columnComparator" return="java.util.Comparator&lt;? super C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the columns. With natural ordering,
 {@link Ordering#natural()} is returned.]]>
      </doc>
    </method>
    <method name="row" return="java.util.SortedMap&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeBasedTable} has unique sorted values for a given
 row, this method returns a {@link SortedMap}, instead of the {@link Map}
 specified in the {@link Table} interface.
 @since 10.0
     (<a href="http://code.google.com/p/guava-libraries/wiki/Compatibility"
     >mostly source-compatible</a> since 7.0)]]>
      </doc>
    </method>
    <method name="rowKeySet" return="java.util.SortedSet&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="rowMap" return="java.util.SortedMap&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="containsRow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="java.lang.Object"/>
      <param name="columnKey" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Table} whose row keys and column keys are ordered
 by their natural ordering or by supplied comparators. When constructing a
 {@code TreeBasedTable}, you may provide comparators for the row keys and
 the column keys, or you may use natural ordering for both.

 <p>The {@link #rowKeySet} method returns a {@link SortedSet} and the {@link
 #rowMap} method returns a {@link SortedMap}, instead of the {@link Set} and
 {@link Map} specified by the {@link Table} interface.

 <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link
 #columnMap()} have iterators that don't support {@code remove()}. Otherwise,
 all optional operations are supported. Null row keys, columns keys, and
 values are not supported.

 <p>Lookups by row key are often faster than lookups by column key, because
 the data is stored in a {@code Map<R, Map<C, V>>}. A method call like {@code
 column(columnKey).get(rowKey)} still runs quickly, since the row key is
 provided. However, {@code column(columnKey).size()} takes longer, since an
 iteration across all row keys occurs.

 <p>Because a {@code TreeBasedTable} has unique sorted values for a given
 row, both {@code row(rowKey)} and {@code rowMap().get(rowKey)} are {@link
 SortedMap} instances, instead of the {@link Map} specified in the {@link
 Table} interface.

 <p>Note that this implementation is not synchronized. If multiple threads
 access this table concurrently and one of the threads modifies the table, it
 must be synchronized externally.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Table">
 {@code Table}</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeBasedTable -->
  <!-- start class com.google.common.collect.TreeMultimap -->
  <class name="TreeMultimap" extends="com.google.common.collect.AbstractSortedSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code TreeMultimap} ordered by the natural ordering of
 its keys and values.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code TreeMultimap} instance using explicit comparators.
 Neither comparator may be null; use {@link Ordering#natural()} to specify
 natural order.

 @param keyComparator the comparator that determines the key ordering
 @param valueComparator the comparator that determines the value ordering]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code TreeMultimap}, ordered by the natural ordering of its
 keys and values, with the same mappings as the specified multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="keyComparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the multimap keys.]]>
      </doc>
    </method>
    <method name="valueComparator" return="java.util.Comparator&lt;? super V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.SortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeMultimap} has unique sorted keys, this method
 returns a {@link SortedSet}, instead of the {@link java.util.Set} specified
 in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.SortedMap&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeMultimap} has unique sorted keys, this method
 returns a {@link SortedMap}, instead of the {@link java.util.Map} specified
 in the {@link Multimap} interface.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} whose keys and values are ordered by
 their natural ordering or by supplied comparators. In all cases, this
 implementation uses {@link Comparable#compareTo} or {@link
 Comparator#compare} instead of {@link Object#equals} to determine
 equivalence of instances.

 <p><b>Warning:</b> The comparators or comparables used must be <i>consistent
 with equals</i> as explained by the {@link Comparable} class specification.
 Otherwise, the resulting multiset will violate the general contract of {@link
 SetMultimap}, which it is specified in terms of {@link Object#equals}.

 <p>The collections returned by {@code keySet} and {@code asMap} iterate
 through the keys according to the key comparator ordering or the natural
 ordering of the keys. Similarly, {@code get}, {@code removeAll}, and {@code
 replaceValues} return collections that iterate through the values according
 to the value comparator ordering or the natural ordering of the values. The
 collections generated by {@code entries}, {@code keys}, and {@code values}
 iterate across the keys according to the above key ordering, and for each
 key they iterate across the values according to the value ordering.

 <p>The multimap does not store duplicate key-value pairs. Adding a new
 key-value pair equal to an existing key-value pair has no effect.

 <p>Null keys and values are permitted (provided, of course, that the
 respective comparators support them). All optional multimap methods are
 supported, and all returned views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the
 multimap. Concurrent read operations will work correctly. To allow concurrent
 update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedSortedSetMultimap}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multimap">
 {@code Multimap}</a>.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeMultimap -->
  <!-- start class com.google.common.collect.TreeMultiset -->
  <class name="TreeMultiset" extends="com.google.common.collect.AbstractSortedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty multiset, sorted according to the elements' natural order. All elements
 inserted into the multiset must implement the {@code Comparable} interface. Furthermore, all
 such elements must be <i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a
 {@code ClassCastException} for any elements {@code e1} and {@code e2} in the multiset. If the
 user attempts to add an element to the multiset that violates this constraint (for example,
 the user attempts to add a string element to a set whose elements are integers), the
 {@code add(Object)} call will throw a {@code ClassCastException}.

 <p>The type specification is {@code <E extends Comparable>}, instead of the more specific
 {@code <E extends Comparable<? super E>>}, to support classes defined without generics.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Creates a new, empty multiset, sorted according to the specified comparator. All elements
 inserted into the multiset must be <i>mutually comparable</i> by the specified comparator:
 {@code comparator.compare(e1,
 e2)} must not throw a {@code ClassCastException} for any elements {@code e1} and {@code e2} in
 the multiset. If the user attempts to add an element to the multiset that violates this
 constraint, the {@code add(Object)} call will throw a {@code ClassCastException}.

 @param comparator
          the comparator that will be used to sort this multiset. A null value indicates that
          the elements' <i>natural ordering</i> should be used.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an empty multiset containing the given initial elements, sorted according to the
 elements' natural order.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.

 <p>The type specification is {@code <E extends Comparable>}, instead of the more specific
 {@code <E extends Comparable<? super E>>}, to support classes defined without generics.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
    </method>
    <method name="headMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="tailMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <doc>
    <![CDATA[A multiset which maintains the ordering of its elements, according to either their natural order
 or an explicit {@link Comparator}. In all cases, this implementation uses
 {@link Comparable#compareTo} or {@link Comparator#compare} instead of {@link Object#equals} to
 determine equivalence of instances.

 <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the
 {@link Comparable} class specification. Otherwise, the resulting multiset will violate the
 {@link java.util.Collection} contract, which is specified in terms of {@link Object#equals}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/NewCollectionTypesExplained#Multiset">
 {@code Multiset}</a>.

 @author Louis Wasserman
 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeMultiset -->
  <!-- start class com.google.common.collect.UnmodifiableIterator -->
  <class name="UnmodifiableIterator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <constructor name="UnmodifiableIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the underlying data unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator that does not support {@link #remove}.

 @author Jared Levy
 @since 2.0 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.UnmodifiableIterator -->
  <!-- start class com.google.common.collect.UnmodifiableListIterator -->
  <class name="UnmodifiableListIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.ListIterator&lt;E&gt;"/>
    <constructor name="UnmodifiableListIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the underlying data unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the underlying data unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A list iterator that does not support {@link #remove}, {@link #add}, or
 {@link #set}.

 @since 7.0
 @author Louis Wasserman]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.UnmodifiableListIterator -->
</package>
<package name="com.google.common.eventbus">
  <!-- start class com.google.common.eventbus.AllowConcurrentEvents -->
  <class name="AllowConcurrentEvents"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks an event handling method as being thread-safe.  This annotation
 indicates that EventBus may invoke the event handler simultaneously from
 multiple threads.

 <p>This does not mark the method as an event handler, and so should be used
 in combination with {@link Subscribe}.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.AllowConcurrentEvents -->
  <!-- start class com.google.common.eventbus.AsyncEventBus -->
  <class name="AsyncEventBus" extends="com.google.common.eventbus.EventBus"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AsyncEventBus" type="java.lang.String, java.util.concurrent.Executor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new AsyncEventBus that will use {@code executor} to dispatch
 events.  Assigns {@code identifier} as the bus's name for logging purposes.

 @param identifier short name for the bus, for logging purposes.
 @param executor   Executor to use to dispatch events. It is the caller's
        responsibility to shut down the executor after the last event has
        been posted to this event bus.]]>
      </doc>
    </constructor>
    <constructor name="AsyncEventBus" type="java.util.concurrent.Executor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new AsyncEventBus that will use {@code executor} to dispatch
 events.

 @param executor Executor to use to dispatch events. It is the caller's
        responsibility to shut down the executor after the last event has
        been posted to this event bus.]]>
      </doc>
    </constructor>
    <method name="dispatchQueuedEvents"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Dispatch {@code events} in the order they were posted, regardless of
 the posting thread.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link EventBus} that takes the Executor of your choice and uses it to
 dispatch events, allowing dispatch to occur asynchronously.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.AsyncEventBus -->
  <!-- start class com.google.common.eventbus.DeadEvent -->
  <class name="DeadEvent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DeadEvent" type="java.lang.Object, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new DeadEvent.

 @param source  object broadcasting the DeadEvent (generally the
                {@link EventBus}).
 @param event   the event that could not be delivered.]]>
      </doc>
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the object that originated this event (<em>not</em> the object that
 originated the wrapped event).  This is generally an {@link EventBus}.

 @return the source of this event.]]>
      </doc>
    </method>
    <method name="getEvent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the wrapped, 'dead' event, which the system was unable to deliver
 to any registered handler.

 @return the 'dead' event that could not be delivered.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Wraps an event that was posted, but which had no subscribers and thus could
 not be delivered.

 <p>Subscribing a DeadEvent handler is useful for debugging or logging, as it
 can detect misconfigurations in a system's event distribution.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.DeadEvent -->
  <!-- start class com.google.common.eventbus.EventBus -->
  <class name="EventBus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EventBus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new EventBus named "default".]]>
      </doc>
    </constructor>
    <constructor name="EventBus" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new EventBus with the given {@code identifier}.

 @param identifier  a brief name for this bus, for logging purposes.  Should
                    be a valid Java identifier.]]>
      </doc>
    </constructor>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Registers all handler methods on {@code object} to receive events.
 Handler methods are selected and classified using this EventBus's
 {@link HandlerFindingStrategy}; the default strategy is the
 {@link AnnotatedHandlerFinder}.

 @param object  object whose handler methods should be registered.]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Unregisters all handler methods on a registered {@code object}.

 @param object  object whose handler methods should be unregistered.
 @throws IllegalArgumentException if the object was not previously registered.]]>
      </doc>
    </method>
    <method name="post"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="java.lang.Object"/>
      <doc>
      <![CDATA[Posts an event to all registered handlers.  This method will return
 successfully after the event has been posted to all handlers, and
 regardless of any exceptions thrown by handlers.

 <p>If no handlers have been subscribed for {@code event}'s class, and
 {@code event} is not already a {@link DeadEvent}, it will be wrapped in a
 DeadEvent and reposted.

 @param event  event to post.]]>
      </doc>
    </method>
    <method name="dispatchQueuedEvents"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="This method should not be overridden outside of the eventbus package. It is
     scheduled for removal in Guava 14.0.">
      <doc>
      <![CDATA[Drain the queue of events to be dispatched. As the queue is being drained,
 new events may be posted to the end of the queue.

 @deprecated This method should not be overridden outside of the eventbus package. It is
     scheduled for removal in Guava 14.0.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Dispatches events to listeners, and provides ways for listeners to register
 themselves.

 <p>The EventBus allows publish-subscribe-style communication between
 components without requiring the components to explicitly register with one
 another (and thus be aware of each other).  It is designed exclusively to
 replace traditional Java in-process event distribution using explicit
 registration. It is <em>not</em> a general-purpose publish-subscribe system,
 nor is it intended for interprocess communication.

 <h2>Receiving Events</h2>
 To receive events, an object should:<ol>
 <li>Expose a public method, known as the <i>event handler</i>, which accepts
     a single argument of the type of event desired;</li>
 <li>Mark it with a {@link Subscribe} annotation;</li>
 <li>Pass itself to an EventBus instance's {@link #register(Object)} method.
     </li>
 </ol>

 <h2>Posting Events</h2>
 To post an event, simply provide the event object to the
 {@link #post(Object)} method.  The EventBus instance will determine the type
 of event and route it to all registered listeners.

 <p>Events are routed based on their type &mdash; an event will be delivered
 to any handler for any type to which the event is <em>assignable.</em>  This
 includes implemented interfaces, all superclasses, and all interfaces
 implemented by superclasses.

 <p>When {@code post} is called, all registered handlers for an event are run
 in sequence, so handlers should be reasonably quick.  If an event may trigger
 an extended process (such as a database load), spawn a thread or queue it for
 later.  (For a convenient way to do this, use an {@link AsyncEventBus}.)

 <h2>Handler Methods</h2>
 Event handler methods must accept only one argument: the event.

 <p>Handlers should not, in general, throw.  If they do, the EventBus will
 catch and log the exception.  This is rarely the right solution for error
 handling and should not be relied upon; it is intended solely to help find
 problems during development.

 <p>The EventBus guarantees that it will not call a handler method from
 multiple threads simultaneously, unless the method explicitly allows it by
 bearing the {@link AllowConcurrentEvents} annotation.  If this annotation is
 not present, handler methods need not worry about being reentrant, unless
 also called from outside the EventBus.

 <h2>Dead Events</h2>
 If an event is posted, but no registered handlers can accept it, it is
 considered "dead."  To give the system a second chance to handle dead events,
 they are wrapped in an instance of {@link DeadEvent} and reposted.

 <p>If a handler for a supertype of all events (such as Object) is registered,
 no event will ever be considered dead, and no DeadEvents will be generated.
 Accordingly, while DeadEvent extends {@link Object}, a handler registered to
 receive any Object will never receive a DeadEvent.

 <p>This class is safe for concurrent use.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/EventBusExplained">
 {@code EventBus}</a>.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.EventBus -->
  <!-- start class com.google.common.eventbus.Subscribe -->
  <class name="Subscribe"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a method as an event handler, as used by
 {@link AnnotatedHandlerFinder} and {@link EventBus}.

 <p>The type of event will be indicated by the method's first (and only)
 parameter.  If this annotation is applied to methods with zero parameters,
 or more than one parameter, the object containing the method will not be able
 to register for event delivery from the {@link EventBus}.

 <p>Unless also annotated with @{@link AllowConcurrentEvents}, event handler
 methods will be invoked serially by each event bus that they are registered
 with.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.Subscribe -->
</package>
<package name="com.google.common.hash">
  <!-- start class com.google.common.hash.BloomFilter -->
  <class name="BloomFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="copy" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code BloomFilter} that's a copy of this instance. The new instance is equal to
 this instance but shares no mutable state.

 @since 12.0]]>
      </doc>
    </method>
    <method name="mightContain" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if the element <i>might</i> have been put in this Bloom filter,
 {@code false} if this is <i>definitely</i> not the case.]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="T"/>
      <doc>
      <![CDATA[Puts an element into this {@code BloomFilter}. Ensures that subsequent invocations of
 {@link #mightContain(Object)} with the same element will always return {@code true}.

 @return true if the bloom filter's bits changed as a result of this operation. If the bits
         changed, this is <i>definitely</i> the first time {@code object} has been added to the
         filter. If the bits haven't changed, this <i>might</i> be the first time {@code object}
         has been added to the filter. Note that {@code put(t)} always returns the
         <i>opposite</i> result to what {@code mightContain(t)} would have returned at the time
         it is called."
 @since 12.0 (present in 11.0 with {@code void} return type})]]>
      </doc>
    </method>
    <method name="expectedFalsePositiveProbability" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the probability that {@linkplain #mightContain(Object)} will erroneously return
 {@code true} for an object that has not actually been put in the {@code BloomFilter}.

 <p>Ideally, this number should be close to the {@code falsePositiveProbability} parameter
 passed in {@linkplain #create(Funnel, int, double)}, or smaller. If it is
 significantly higher, it is usually the case that too many elements (more than
 expected) have been put in the {@code BloomFilter}, degenerating it.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation uses reference equality to compare funnels.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="create" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;T&gt;"/>
      <param name="expectedInsertions" type="int"/>
      <param name="falsePositiveProbability" type="double"/>
      <doc>
      <![CDATA[Creates a {@code Builder} of a {@link BloomFilter BloomFilter<T>}, with the expected number
 of insertions and expected false positive probability.

 <p>Note that overflowing a {@code BloomFilter} with significantly more elements
 than specified, will result in its saturation, and a sharp deterioration of its
 false positive probability.

 <p>The constructed {@code BloomFilter<T>} will be serializable if the provided
 {@code Funnel<T>} is.

 <p>It is recommended the funnel is implemented as a Java enum. This has the benefit of ensuring
 proper serialization and deserialization, which is important since {@link #equals} also relies
 on object identity of funnels.

 @param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use
 @param expectedInsertions the number of expected insertions to the constructed
        {@code BloomFilter<T>}; must be positive
 @param falsePositiveProbability the desired false positive probability (must be positive and
        less than 1.0)
 @return a {@code BloomFilter}]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;T&gt;"/>
      <param name="expectedInsertions" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Builder} of a {@link BloomFilter BloomFilter<T>}, with the expected number
 of insertions, and a default expected false positive probability of 3%.

 <p>Note that overflowing a {@code BloomFilter} with significantly more elements
 than specified, will result in its saturation, and a sharp deterioration of its
 false positive probability.

 <p>The constructed {@code BloomFilter<T>} will be serializable if the provided
 {@code Funnel<T>} is.

 @param funnel the funnel of T's that the constructed {@code BloomFilter<T>} will use
 @param expectedInsertions the number of expected insertions to the constructed
        {@code BloomFilter<T>}; must be positive
 @return a {@code BloomFilter}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Bloom filter for instances of {@code T}. A Bloom filter offers an approximate containment test
 with one-sided error: if it claims that an element is contained in it, this might be in error,
 but if it claims that an element is <i>not</i> contained in it, then this is definitely true.

 <p>If you are unfamiliar with Bloom filters, this nice
 <a href="http://llimllib.github.com/bloomfilter-tutorial/">tutorial</a> may help you understand
 how they work.


 @param <T> the type of instances that the {@code BloomFilter} accepts
 @author Dimitris Andreou
 @author Kevin Bourrillion
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.BloomFilter -->
  <!-- start interface com.google.common.hash.Funnel -->
  <interface name="Funnel"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="funnel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="T"/>
      <param name="into" type="com.google.common.hash.PrimitiveSink"/>
      <doc>
      <![CDATA[Sends a stream of data from the {@code from} object into the sink {@code into}. There
 is no requirement that this data be complete enough to fully reconstitute the object
 later.

 @since 12.0 (in 11.0 version, {@code PrimitiveSink} was still called {@code Sink})]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object which can send data from an object of type {@code T} into a {@code PrimitiveSink}.
 
 @author Dimitris Andreou
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.Funnel -->
  <!-- start class com.google.common.hash.Funnels -->
  <class name="Funnels" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="byteArrayFunnel" return="com.google.common.hash.Funnel&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel that extracts the bytes from a {@code byte} array.]]>
      </doc>
    </method>
    <method name="stringFunnel" return="com.google.common.hash.Funnel&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel that extracts the characters from a {@code CharSequence}.]]>
      </doc>
    </method>
    <method name="integerFunnel" return="com.google.common.hash.Funnel&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel for integers.
 
 @since 13.0]]>
      </doc>
    </method>
    <method name="longFunnel" return="com.google.common.hash.Funnel&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel for longs.
 
 @since 13.0]]>
      </doc>
    </method>
    <method name="asOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sink" type="com.google.common.hash.PrimitiveSink"/>
      <doc>
      <![CDATA[Wraps a {@code PrimitiveSink} as an {@link OutputStream}, so it is easy to
 {@link Funnel#funnel funnel} an object to a {@code PrimitiveSink}
 if there is already a way to write the contents of the object to an {@code OutputStream}.  
 
 <p>The {@code close} and {@code flush} methods of the returned {@code OutputStream}
 do nothing, and no method throws {@code IOException}.
 
 @since 13.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Funnels for common types. All implementations are serializable.

 @author Dimitris Andreou
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.Funnels -->
  <!-- start class com.google.common.hash.HashCode -->
  <class name="HashCode" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="asInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the first four bytes of {@linkplain #asBytes() this hashcode's bytes}, converted to
 an {@code int} value in little-endian order.]]>
      </doc>
    </method>
    <method name="asLong" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the first eight bytes of {@linkplain #asBytes() this hashcode's bytes}, converted to
 a {@code long} value in little-endian order.

 @throws IllegalStateException if {@code bits() < 64}]]>
      </doc>
    </method>
    <method name="asBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this hash code as a byte array. The caller may modify the byte array;
 changes to it will <i>not</i> be reflected in this {@code HashCode} object or any other arrays
 returned by this method.]]>
      </doc>
    </method>
    <method name="writeBytesTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dest" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="maxLength" type="int"/>
      <doc>
      <![CDATA[Copies bytes from this hash code into {@code dest}.

 @param dest the byte array into which the hash code will be written
 @param offset the start offset in the data
 @param maxLength the maximum number of bytes to write
 @return the number of bytes written to {@code dest}
 @throws IndexOutOfBoundsException if there is not enough room in {@code dest}]]>
      </doc>
    </method>
    <method name="bits" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bits in this hash code; a positive multiple of 32.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a "Java hash code" for this {@code HashCode} instance; this is well-defined
 (so, for example, you can safely put {@code HashCode} instances into a {@code
 HashSet}) but is otherwise probably not what you want to use.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string containing each byte of {@link #asBytes}, in order, as a two-digit unsigned
 hexadecimal number in lower case.

 <p>Note that if the output is considered to be a single hexadecimal number, this hash code's
 bytes are the <i>big-endian</i> representation of that number. This may be surprising since
 everything else in the hashing API uniformly treats multibyte values as little-endian. But
 this format conveniently matches that of utilities such as the UNIX {@code md5sum} command.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable hash code of arbitrary bit length.

 @author Dimitris Andreou
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.HashCode -->
  <!-- start class com.google.common.hash.HashCodes -->
  <class name="HashCodes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="fromInt" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hash" type="int"/>
      <doc>
      <![CDATA[Creates a 32-bit {@code HashCode}, of which the bytes will form the passed int, interpreted 
 in little endian order.]]>
      </doc>
    </method>
    <method name="fromLong" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hash" type="long"/>
      <doc>
      <![CDATA[Creates a 64-bit {@code HashCode}, of which the bytes will form the passed long, interpreted 
 in little endian order.]]>
      </doc>
    </method>
    <method name="fromBytes" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Creates a {@code HashCode} from a byte array. The array is defensively copied to preserve
 the immutability contract of {@code HashCode}. The array must be at least of length 4.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static factories for creating {@link HashCode} instances; most users should never have to use
 this. All returned instances are {@link Serializable}.

 @author Dimitris Andreou
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.HashCodes -->
  <!-- start interface com.google.common.hash.Hasher -->
  <interface name="Hasher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.hash.PrimitiveSink"/>
    <method name="putByte" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
    </method>
    <method name="putBytes" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
    </method>
    <method name="putBytes" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="putShort" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="short"/>
    </method>
    <method name="putInt" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="putLong" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
    </method>
    <method name="putFloat" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <doc>
      <![CDATA[Equivalent to {@code putInt(Float.floatToRawIntBits(f))}.]]>
      </doc>
    </method>
    <method name="putDouble" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <doc>
      <![CDATA[Equivalent to {@code putLong(Double.doubleToRawLongBits(d))}.]]>
      </doc>
    </method>
    <method name="putBoolean" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Equivalent to {@code putByte(b ? (byte) 1 : (byte) 0)}.]]>
      </doc>
    </method>
    <method name="putChar" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
    </method>
    <method name="putString" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Equivalent to processing each {@code char} value in the {@code CharSequence}, in order.
 The input must not be updated while this method is in progress.]]>
      </doc>
    </method>
    <method name="putString" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Equivalent to {@code putBytes(charSequence.toString().getBytes(charset))}.]]>
      </doc>
    </method>
    <method name="putObject" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <doc>
      <![CDATA[A simple convenience for {@code funnel.funnel(object, this)}.]]>
      </doc>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a hash code based on the data that have been provided to this hasher. The result is
 unspecified if this method is called more than once on the same instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link PrimitiveSink} that can compute a hash code after reading the input. Each hasher should
 translate all multibyte values ({@link #putInt(int)}, {@link #putLong(long)}, etc) to bytes
 in little-endian order.

 @author Kevin Bourrillion
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.Hasher -->
  <!-- start interface com.google.common.hash.HashFunction -->
  <interface name="HashFunction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newHasher" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Begins a new hash code computation by returning an initialized, stateful {@code
 Hasher} instance that is ready to receive data. Example: <pre>   {@code

   HashFunction hf = Hashing.md5();
   HashCode hc = hf.newHasher()
       .putLong(id)
       .putString(name)
       .hash();}</pre>]]>
      </doc>
    </method>
    <method name="newHasher" return="com.google.common.hash.Hasher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedInputSize" type="int"/>
      <doc>
      <![CDATA[Begins a new hash code computation as {@link #newHasher()}, but provides a hint of the
 expected size of the input (in bytes). This is only important for non-streaming hash
 functions (hash functions that need to buffer their whole input before processing any
 of it).]]>
      </doc>
    </method>
    <method name="hashInt" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="int"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putInt(input).hash()}; returns the hash code for the given
 {@code int} value, interpreted in little-endian byte order. The implementation <i>might</i>
 perform better than its longhand equivalent, but should not perform worse.

 @since 12.0]]>
      </doc>
    </method>
    <method name="hashLong" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="long"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putLong(input).hash()}; returns the hash code for the
 given {@code long} value, interpreted in little-endian byte order. The implementation
 <i>might</i> perform better than its longhand equivalent, but should not perform worse.]]>
      </doc>
    </method>
    <method name="hashBytes" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putBytes(input).hash()}. The implementation
 <i>might</i> perform better than its longhand equivalent, but should not perform
 worse.]]>
      </doc>
    </method>
    <method name="hashBytes" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putBytes(input, off, len).hash()}. The implementation
 <i>might</i> perform better than its longhand equivalent, but should not perform
 worse.

 @throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length}
   or {@code len < 0}]]>
      </doc>
    </method>
    <method name="hashString" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putString(input).hash()}. The implementation <i>might</i>
 perform better than its longhand equivalent, but should not perform worse. Note that no
 character encoding is performed; the low byte and high byte of each character are hashed
 directly (in that order). This is equivalent to using
 {@code hashString(input, Charsets.UTF_16LE)}.]]>
      </doc>
    </method>
    <method name="hashString" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putString(input, charset).hash()}. Characters are encoded
 using the given {@link Charset}. The implementation <i>might</i> perform better than its
 longhand equivalent, but should not perform worse.]]>
      </doc>
    </method>
    <method name="bits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bits (a multiple of 32) that each hash code produced by this
 hash function has.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A hash function is a collision-averse pure function that maps an arbitrary block of
 data to a number called a <i>hash code</i>.

 <h3>Definition</h3>

 <p>Unpacking this definition:

 <ul>
 <li><b>block of data:</b> the input for a hash function is always, in concept, an
     ordered byte array. This hashing API accepts an arbitrary sequence of byte and
     multibyte values (via {@link Hasher}), but this is merely a convenience; these are
     always translated into raw byte sequences under the covers.

 <li><b>hash code:</b> each hash function always yields hash codes of the same fixed bit
     length (given by {@link #bits}). For example, {@link Hashing#sha1} produces a
     160-bit number, while {@link Hashing#murmur3_32()} yields only 32 bits. Because a
     {@code long} value is clearly insufficient to hold all hash code values, this API
     represents a hash code as an instance of {@link HashCode}.

 <li><b>pure function:</b> the value produced must depend only on the input bytes, in
     the order they appear. Input data is never modified. {@link HashFunction} instances
     should always be stateless, and therefore thread-safe.

 <li><b>collision-averse:</b> while it can't be helped that a hash function will
     sometimes produce the same hash code for distinct inputs (a "collision"), every
     hash function strives to <i>some</i> degree to make this unlikely. (Without this
     condition, a function that always returns zero could be called a hash function. It
     is not.)
 </ul>

 <p>Summarizing the last two points: "equal yield equal <i>always</i>; unequal yield
 unequal <i>often</i>." This is the most important characteristic of all hash functions.

 <h3>Desirable properties</h3>

 <p>A high-quality hash function strives for some subset of the following virtues:

 <ul>
 <li><b>collision-resistant:</b> while the definition above requires making at least
     <i>some</i> token attempt, one measure of the quality of a hash function is <i>how
     well</i> it succeeds at this goal. Important note: it may be easy to achieve the
     theoretical minimum collision rate when using completely <i>random</i> sample
     input. The true test of a hash function is how it performs on representative
     real-world data, which tends to contain many hidden patterns and clumps. The goal
     of a good hash function is to stamp these patterns out as thoroughly as possible.

 <li><b>bit-dispersing:</b> masking out any <i>single bit</i> from a hash code should
     yield only the expected <i>twofold</i> increase to all collision rates. Informally,
     the "information" in the hash code should be as evenly "spread out" through the
     hash code's bits as possible. The result is that, for example, when choosing a
     bucket in a hash table of size 2^8, <i>any</i> eight bits could be consistently
     used.

 <li><b>cryptographic:</b> certain hash functions such as {@link Hashing#sha512} are
     designed to make it as infeasible as possible to reverse-engineer the input that
     produced a given hash code, or even to discover <i>any</i> two distinct inputs that
     yield the same result. These are called <i>cryptographic hash functions</i>. But,
     whenever it is learned that either of these feats has become computationally
     feasible, the function is deemed "broken" and should no longer be used for secure
     purposes. (This is the likely eventual fate of <i>all</i> cryptographic hashes.)

 <li><b>fast:</b> perhaps self-explanatory, but often the most important consideration.
     We have published <a href="#noWeHaventYet">microbenchmark results</a> for many
     common hash functions.
 </ul>

 <h3>Providing input to a hash function</h3>

 <p>The primary way to provide the data that your hash function should act on is via a
 {@link Hasher}. Obtain a new hasher from the hash function using {@link #newHasher},
 "push" the relevant data into it using methods like {@link Hasher#putBytes(byte[])},
 and finally ask for the {@code HashCode} when finished using {@link Hasher#hash}. (See
 an {@linkplain #newHasher example} of this.)

 <p>If all you want to hash is a single byte array, string or {@code long} value, there
 are convenient shortcut methods defined directly on {@link HashFunction} to make this
 easier.

 <p>Hasher accepts primitive data types, but can also accept any Object of type {@code
 T} provided that you implement a {@link Funnel Funnel<T>} to specify how to "feed" data
 from that object into the function. (See {@linkplain Hasher#putObject an example} of
 this.)

 <p><b>Compatibility note:</b> Throughout this API, multibyte values are always
 interpreted in <i>little-endian</i> order. That is, hashing the byte array {@code
 {0x01, 0x02, 0x03, 0x04}} is equivalent to hashing the {@code int} value {@code
 0x04030201}. If this isn't what you need, methods such as {@link Integer#reverseBytes}
 and {@link Ints#toByteArray} will help.

 <h3>Relationship to {@link Object#hashCode}</h3>

 <p>Java's baked-in concept of hash codes is constrained to 32 bits, and provides no
 separation between hash algorithms and the data they act on, so alternate hash
 algorithms can't be easily substituted. Also, implementations of {@code hashCode} tend
 to be poor-quality, in part because they end up depending on <i>other</i> existing
 poor-quality {@code hashCode} implementations, including those in many JDK classes.

 <p>{@code Object.hashCode} implementations tend to be very fast, but have weak
 collision prevention and <i>no</i> expectation of bit dispersion. This leaves them
 perfectly suitable for use in hash tables, because extra collisions cause only a slight
 performance hit, while poor bit dispersion is easily corrected using a secondary hash
 function (which all reasonable hash table implementations in Java use). For the many
 uses of hash functions beyond data structures, however, {@code Object.hashCode} almost
 always falls short -- hence this library.

 @author Kevin Bourrillion
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.HashFunction -->
  <!-- start class com.google.common.hash.Hashing -->
  <class name="Hashing" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="goodFastHash" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="minimumBits" type="int"/>
      <doc>
      <![CDATA[Returns a general-purpose, <b>non-cryptographic-strength</b>, streaming hash function that
 produces hash codes of length at least {@code minimumBits}. Users without specific
 compatibility requirements and who do not persist the hash codes are encouraged to
 choose this hash function.

 <p>Repeated calls to {@link #goodFastHash} with the same {@code minimumBits} value will
 return {@link HashFunction} instances with identical behavior (but not necessarily the
 same instance) for the duration of the current virtual machine.

 <p><b>Warning: the implementation is unspecified and is subject to change.</b>

 @throws IllegalArgumentException if {@code minimumBits} is not positive]]>
      </doc>
    </method>
    <method name="murmur3_32" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="int"/>
      <doc>
      <![CDATA[Returns a hash function implementing the
 <a href="http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp">32-bit murmur3
 algorithm</a> (little-endian variant), using the given seed value.]]>
      </doc>
    </method>
    <method name="murmur3_32" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the
 <a href="http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp">32-bit murmur3
 algorithm</a> (little-endian variant), using a seed value of zero.]]>
      </doc>
    </method>
    <method name="murmur3_128" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="int"/>
      <doc>
      <![CDATA[Returns a hash function implementing the
 <a href="http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp">
 128-bit murmur3 algorithm, x64 variant</a> (little-endian variant), using the given seed
 value.]]>
      </doc>
    </method>
    <method name="murmur3_128" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the
 <a href="http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp">
 128-bit murmur3 algorithm, x64 variant</a>  (little-endian variant), using a seed value
 of zero.]]>
      </doc>
    </method>
    <method name="md5" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the MD5 hash algorithm (128 hash bits) by delegating to
 the MD5 {@link MessageDigest}.]]>
      </doc>
    </method>
    <method name="sha1" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the SHA-1 algorithm (160 hash bits) by delegating to the
 SHA-1 {@link MessageDigest}.]]>
      </doc>
    </method>
    <method name="sha256" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the SHA-256 algorithm (256 hash bits) by delegating to
 the SHA-256 {@link MessageDigest}.]]>
      </doc>
    </method>
    <method name="sha512" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the SHA-512 algorithm (512 hash bits) by delegating to the
 SHA-512 {@link MessageDigest}.]]>
      </doc>
    </method>
    <method name="padToLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashCode" type="com.google.common.hash.HashCode"/>
      <doc>
      <![CDATA[If {@code hashCode} has enough bits, returns {@code hashCode.asLong()}, otherwise
 returns a {@code long} value with {@code hashCode.asInt()} as the least-significant
 four bytes and {@code 0x00} as each of the most-significant four bytes.]]>
      </doc>
    </method>
    <method name="consistentHash" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashCode" type="com.google.common.hash.HashCode"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Assigns to {@code hashCode} a "bucket" in the range {@code [0, buckets)}, in a uniform
 manner that minimizes the need for remapping as {@code buckets} grows. That is,
 {@code consistentHash(h, n)} equals:

 <ul>
 <li>{@code n - 1}, with approximate probability {@code 1/n}
 <li>{@code consistentHash(h, n - 1)}, otherwise (probability {@code 1 - 1/n})
 </ul>

 <p>See the <a href="http://en.wikipedia.org/wiki/Consistent_hashing">wikipedia
 article on consistent hashing</a> for more information.
 <p>
 If you might want to have weights for the buckets in the future, take a look at
 {@code weightedConsistentHash}.]]>
      </doc>
    </method>
    <method name="consistentHash" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="long"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Assigns to {@code input} a "bucket" in the range {@code [0, buckets)}, in a uniform
 manner that minimizes the need for remapping as {@code buckets} grows. That is,
 {@code consistentHash(h, n)} equals:

 <ul>
 <li>{@code n - 1}, with approximate probability {@code 1/n}
 <li>{@code consistentHash(h, n - 1)}, otherwise (probability {@code 1 - 1/n})
 </ul>

 <p>See the <a href="http://en.wikipedia.org/wiki/Consistent_hashing">wikipedia
 article on consistent hashing</a> for more information.
 <p>
 If you might want to have weights for the buckets in the future, take a look at
 {@code weightedConsistentHash}.]]>
      </doc>
    </method>
    <method name="combineOrdered" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashCodes" type="java.lang.Iterable&lt;com.google.common.hash.HashCode&gt;"/>
      <doc>
      <![CDATA[Returns a hash code, having the same bit length as each of the input hash codes,
 that combines the information of these hash codes in an ordered fashion. That
 is, whenever two equal hash codes are produced by two calls to this method, it
 is <i>as likely as possible</i> that each was computed from the <i>same</i>
 input hash codes in the <i>same</i> order.

 @throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes
     do not all have the same bit length]]>
      </doc>
    </method>
    <method name="combineUnordered" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashCodes" type="java.lang.Iterable&lt;com.google.common.hash.HashCode&gt;"/>
      <doc>
      <![CDATA[Returns a hash code, having the same bit length as each of the input hash codes,
 that combines the information of these hash codes in an unordered fashion. That
 is, whenever two equal hash codes are produced by two calls to this method, it
 is <i>as likely as possible</i> that each was computed from the <i>same</i>
 input hash codes in <i>some</i> order.

 @throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes
     do not all have the same bit length]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static methods to obtain {@link HashFunction} instances, and other static
 hashing-related utilities.

 @author Kevin Bourrillion
 @author Dimitris Andreou
 @author Kurt Alfred Kluever
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.Hashing -->
  <!-- start interface com.google.common.hash.PrimitiveSink -->
  <interface name="PrimitiveSink"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="putByte" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Puts a byte into this sink.

 @param b a byte
 @return this instance]]>
      </doc>
    </method>
    <method name="putBytes" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Puts an array of bytes into this sink.

 @param bytes a byte array
 @return this instance]]>
      </doc>
    </method>
    <method name="putBytes" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Puts a chunk of an array of bytes into this sink. {@code bytes[off]} is the first byte written,
 {@code bytes[off + len - 1]} is the last. 
 
 @param bytes a byte array
 @param off the start offset in the array
 @param len the number of bytes to write
 @return this instance 
 @throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length} or
   {@code len < 0}]]>
      </doc>
    </method>
    <method name="putShort" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="short"/>
      <doc>
      <![CDATA[Puts a short into this sink.]]>
      </doc>
    </method>
    <method name="putInt" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Puts an int into this sink.]]>
      </doc>
    </method>
    <method name="putLong" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <doc>
      <![CDATA[Puts a long into this sink.]]>
      </doc>
    </method>
    <method name="putFloat" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <doc>
      <![CDATA[Puts a float into this sink.]]>
      </doc>
    </method>
    <method name="putDouble" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <doc>
      <![CDATA[Puts a double into this sink.]]>
      </doc>
    </method>
    <method name="putBoolean" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Puts a boolean into this sink.]]>
      </doc>
    </method>
    <method name="putChar" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Puts a character into this sink.]]>
      </doc>
    </method>
    <method name="putString" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Puts a string into this sink.]]>
      </doc>
    </method>
    <method name="putString" return="com.google.common.hash.PrimitiveSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Puts a string into this sink using the given charset.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object which can receive a stream of primitive values.
 
 @author Kevin Bourrillion
 @since 12.0 (in 11.0 as {@code Sink})]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.PrimitiveSink -->
</package>
<package name="com.google.common.io">
  <!-- start interface com.google.common.io.ByteArrayDataInput -->
  <interface name="ByteArrayDataInput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataInput"/>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="skipBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUTF" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An extension of {@code DataInput} for reading from in-memory byte arrays; its
 methods offer identical functionality but do not throw {@link IOException}.

 <p><b>Warning:<b> The caller is responsible for not attempting to read past
 the end of the array. If any method encounters the end of the array
 prematurely, it throws {@link IllegalStateException} to signify <i>programmer
 error</i>. This behavior is a technical violation of the supertype's
 contract, which specifies a checked exception.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataInput -->
  <!-- start interface com.google.common.io.ByteArrayDataOutput -->
  <interface name="ByteArrayDataOutput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataOutput"/>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="boolean"/>
    </method>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeShort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeChar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
    </method>
    <method name="writeChars"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeUTF"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method is dangerous as it discards the high byte of
 every character. For UTF-8, use {@code write(s.getBytes(Charsets.UTF_8))}.">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated This method is dangerous as it discards the high byte of
 every character. For UTF-8, use {@code write(s.getBytes(Charsets.UTF_8))}.]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contents that have been written to this instance,
 as a byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An extension of {@code DataOutput} for writing to in-memory byte arrays; its
 methods offer identical functionality but do not throw {@link IOException}.

 @author Jayaprabhakar Kadarkarai
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataOutput -->
  <!-- start interface com.google.common.io.ByteProcessor -->
  <interface name="ByteProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processBytes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called for each chunk of bytes in an
 input stream. The implementation should process the bytes
 from {@code buf[off]} through {@code buf[off + len - 1]}
 (inclusive).

 @param buf the byte array containing the data to process
 @param off the initial offset into the array
 @param len the length of data to be processed
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the bytes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback interface to process bytes from a stream.

 <p>{@link #processBytes} will be called for each line that is read, and
 should return {@code false} when you want to stop processing.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteProcessor -->
  <!-- start class com.google.common.io.ByteStreams -->
  <class name="ByteStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.ByteArrayInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link ByteArrayInputStream} that read from the given byte array.

 @param b the input buffer
 @return the factory]]>
      </doc>
    </method>
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.ByteArrayInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link ByteArrayInputStream} that read from the given byte array.

 @param b the input buffer
 @param off the offset in the buffer of the first byte to read
 @param len the maximum number of bytes to read from the buffer
 @return the factory]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="byte[]"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a byte array to an output stream from the given supplier.

 @param from the bytes to write
 @param to the output supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens input and output streams from the given suppliers, copies all
 bytes from the input to the output, and closes the streams.

 @param from the input factory
 @param to the output factory
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an input stream from the supplier, copies all bytes from the
 input to the output, and closes the input stream. Does not close
 or flush the output stream.

 @param from the input factory
 @param to the output stream to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.InputStream"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an output stream from the supplier, copies all bytes from the input
 to the output, and closes the output stream. Does not close or flush the
 input stream.

 @param from the input stream to read from
 @param to the output factory
 @return the number of bytes copied
 @throws IOException if an I/O error occurs
 @since 10.0]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.InputStream"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the input stream to the output stream.
 Does not close or flush either stream.

 @param from the input stream to read from
 @param to the output stream to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.nio.channels.ReadableByteChannel"/>
      <param name="to" type="java.nio.channels.WritableByteChannel"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the readable channel to the writable channel.
 Does not close or flush either channel.

 @param from the readable channel to read from
 @param to the writable channel to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from an input stream into a byte array.
 Does not close the stream.

 @param in the input stream to read from
 @return a byte array containing all the bytes from the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the data from a {@link InputStream} factory as a byte array.

 @param supplier the factory
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code
 bytes} array from the beginning.]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code
 bytes} array, starting at the given position.

 @throws IndexOutOfBoundsException if {@code start} is negative or greater
     than the length of the array]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance with a default size.]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance sized to hold
 {@code size} bytes before resizing.

 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the length of a supplied input stream, in bytes.]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier1" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="supplier2" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the supplied input streams contain the same bytes.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read enough bytes from the stream to fill the given byte array,
 with the same behavior as {@link DataInput#readFully(byte[])}.
 Does not close the stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @throws EOFException if this stream reaches the end before reading all
     the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read {@code len} bytes from the stream into the given array
 starting at {@code off}, with the same behavior as
 {@link DataInput#readFully(byte[], int, int)}. Does not close the
 stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @param off an int specifying the offset into the data.
 @param len an int specifying the number of bytes to read.
 @throws EOFException if this stream reaches the end before reading all
     the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} bytes of data from the input stream. This method
 will block until the full amount has been skipped. Does not close the
 stream.

 @param in the input stream to read from
 @param n the number of bytes to skip
 @throws EOFException if this stream reaches the end before skipping all
     the bytes
 @throws IOException if an I/O error occurs, or the stream does not
     support skipping]]>
      </doc>
    </method>
    <method name="readBytes" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of a supplied stream

 @param supplier the input stream factory
 @param processor the object to which to pass the bytes of the stream
 @return the result of the byte processor
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getChecksum" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="checksum" type="java.util.zip.Checksum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the checksum value for a supplied input stream.
 The checksum object is reset when this method returns successfully.

 @param supplier the input stream factory
 @param checksum the checksum object
 @return the result of {@link Checksum#getValue} after updating the
     checksum object with all of the bytes in the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="hashFunction" type="com.google.common.hash.HashFunction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes the hash code of the data supplied by {@code supplier} using {@code
 hashFunction}.

 @param supplier the input stream factory
 @param hashFunction the hash function to use to hash the data
 @return the {@link HashCode} of all of the bytes in the input stream
 @throws IOException if an I/O error occurs
 @since 12.0]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads some bytes from an input stream and stores them into the buffer array
 {@code b}. This method blocks until {@code len} bytes of input data have
 been read into the array, or end of file is detected. The number of bytes
 read is returned, possibly zero. Does not close the stream.

 <p>A caller can detect EOF if the number of bytes read is less than
 {@code len}. All subsequent calls on the same stream will return zero.

 <p>If {@code b} is null, a {@code NullPointerException} is thrown. If
 {@code off} is negative, or {@code len} is negative, or {@code off+len} is
 greater than the length of the array {@code b}, then an
 {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then
 no bytes are read. Otherwise, the first byte read is stored into element
 {@code b[off]}, the next one into {@code b[off+1]}, and so on. The number
 of bytes read is, at most, equal to {@code len}.

 @param in the input stream to read from
 @param b the buffer into which the data is read
 @param off an int specifying the offset into the data
 @param len an int specifying the number of bytes to read
 @return the number of bytes read
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="slice" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="offset" type="long"/>
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Returns an {@link InputSupplier} that returns input streams from the
 an underlying supplier, where each stream starts at the given
 offset and is limited to the specified number of bytes.

 @param supplier the supplier from which to get the raw streams
 @param offset the offset in bytes into the underlying stream where
     the returned streams will start
 @param length the maximum length of the returned streams
 @throws IllegalArgumentException if offset or length are negative]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="java.lang.Iterable&lt;? extends com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;&gt;"/>
      <doc>
      <![CDATA[Joins multiple {@link InputStream} suppliers into a single supplier.
 Streams returned from the supplier will contain the concatenated data from
 the streams of the underlying suppliers.

 <p>Only one underlying input stream will be open at a time. Closing the
 joined stream will close the open underlying stream.

 <p>Reading from the joined stream will throw a {@link NullPointerException}
 if any of the suppliers are null or return null.

 @param suppliers the suppliers to concatenate
 @return a supplier that will return a stream containing the concatenated
     stream data]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="com.google.common.io.InputSupplier[]"/>
      <doc>
      <![CDATA[Varargs form of {@link #join(Iterable)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with byte arrays and I/O streams.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.ByteStreams -->
  <!-- start class com.google.common.io.CharStreams -->
  <class name="CharStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.StringReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link StringReader} that
 read a string value.

 @param value the string to read
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link InputStreamReader},
 using the given {@link InputStream} factory and character set.

 @param in the factory that will be used to open input streams
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter},
 using the given {@link OutputStream} factory and character set.

 @param out the factory that will be used to open output streams
 @param charset the charset used to encode the output stream; see {@link
     Charsets} for helpful predefined constants
 @return the factory]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a character sequence (such as a string) to an appendable
 object from the given supplier.

 @param from the character sequence to write
 @param to the output supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens {@link Readable} and {@link Appendable} objects from the
 given factories, copies all characters between the two, and closes
 them.

 @param from the input factory
 @param to the output factory
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a {@link Readable} object from the supplier, copies all characters
 to the {@link Appendable} object, and closes the input. Does not close
 or flush the output.

 @param from the input factory
 @param to the object to write to
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.Readable"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters between the {@link Readable} and {@link Appendable}
 objects. Does not close or flush either object.

 @param from the object to read from
 @param to the object to write to
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a {@link Readable} object into a {@link String}.
 Does not close the {@code Readable}.

 @param r the object to read from
 @return a string containing all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the characters from a {@link Readable} & {@link Closeable} object
 supplied by a factory as a {@link String}.

 @param supplier the factory to read from
 @return a string containing all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFirstLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line from a {@link Readable} & {@link Closeable} object
 supplied by a factory. The line does not include line-termination
 characters, but does include other leading and trailing whitespace.

 @param supplier the factory to read from
 @return the first line, or null if the reader is empty
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a {@link Readable} & {@link Closeable} object
 supplied by a factory. The lines do not include line-termination
 characters, but do include other leading and trailing whitespace.

 @param supplier the factory to read from
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a {@link Readable} object. The lines do
 not include line-termination characters, but do include other
 leading and trailing whitespace.

 <p>Does not close the {@code Readable}. If reading files or resources you
 should use the {@link Files#readLines} and {@link Resources#readLines}
 methods.

 @param r the object to read from
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link Readable} and {@link Closeable} object
 supplied by a factory, stopping when our callback returns false, or we
 have read all of the lines.

 @param supplier the factory to read from
 @param callback the LineProcessor to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.Reader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="java.lang.Iterable&lt;? extends com.google.common.io.InputSupplier&lt;? extends java.io.Reader&gt;&gt;"/>
      <doc>
      <![CDATA[Joins multiple {@link Reader} suppliers into a single supplier.
 Reader returned from the supplier will contain the concatenated data
 from the readers of the underlying suppliers.

 <p>Reading from the joined reader will throw a {@link NullPointerException}
 if any of the suppliers are null or return null.

 <p>Only one underlying reader will be open at a time. Closing the
 joined reader will close the open underlying reader.

 @param suppliers the suppliers to concatenate
 @return a supplier that will return a reader containing the concatenated
     data]]>
      </doc>
    </method>
    <method name="join" return="com.google.common.io.InputSupplier&lt;java.io.Reader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suppliers" type="com.google.common.io.InputSupplier[]"/>
      <doc>
      <![CDATA[Varargs form of {@link #join(Iterable)}.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} characters of data from the reader. This method
 will block until the full amount has been skipped. Does not close the
 reader.

 @param reader the reader to read from
 @param n the number of characters to skip
 @throws EOFException if this stream reaches the end before skipping all
     the bytes
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="asWriter" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.Appendable"/>
      <doc>
      <![CDATA[Returns a Writer that sends all output to the given {@link Appendable}
 target. Closing the writer will close the target if it is {@link
 Closeable}, and flushing the writer will flush the target if it is {@link
 java.io.Flushable}.

 @param target the object to which output will be sent
 @return a new Writer object, unless target is a Writer, in which case the
     target is returned]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with character streams.

 <p>All method parameters must be non-null unless documented otherwise.

 <p>Some of the methods in this class take arguments with a generic type of
 {@code Readable & Closeable}. A {@link java.io.Reader} implements both of
 those interfaces. Similarly for {@code Appendable & Closeable} and
 {@link java.io.Writer}.

 @author Chris Nokleberg
 @author Bin Zhu
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CharStreams -->
  <!-- start class com.google.common.io.Closeables -->
  <class name="Closeables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.io.Closeable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes a {@link Closeable}, with control over whether an
 {@code IOException} may be thrown. This is primarily useful in a
 finally block, where a thrown exception needs to be logged but not
 propagated (otherwise the original exception will be lost).

 <p>If {@code swallowIOException} is true then we never throw
 {@code IOException} but merely log it.

 <p>Example:

 <p><pre>public void useStreamNicely() throws IOException {
 SomeStream stream = new SomeStream("foo");
 boolean threw = true;
 try {
   // Some code which does something with the Stream. May throw a
   // Throwable.
   threw = false; // No throwable thrown.
 } finally {
   // Close the stream.
   // If an exception occurs, only rethrow it if (threw==false).
   Closeables.close(stream, threw);
 }
 </pre>

 @param closeable the {@code Closeable} object to be closed, or null,
     in which case this method does nothing
 @param swallowIOException if true, don't propagate IO exceptions
     thrown by the {@code close} methods
 @throws IOException if {@code swallowIOException} is false and
     {@code close} throws an {@code IOException}.]]>
      </doc>
    </method>
    <method name="closeQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="java.io.Closeable"/>
      <doc>
      <![CDATA[Equivalent to calling {@code close(closeable, true)}, but with no
 IOException in the signature.
 @param closeable the {@code Closeable} object to be closed, or null, in
      which case this method does nothing]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Closeable} objects.

 @author Michael Lancaster
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Closeables -->
  <!-- start class com.google.common.io.CountingInputStream -->
  <class name="CountingInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, counting the number of bytes read.

 @param in the input stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes read.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that counts the number of bytes read.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingInputStream -->
  <!-- start class com.google.common.io.CountingOutputStream -->
  <class name="CountingOutputStream" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another output stream, counting the number of bytes written.

 @param out the output stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes written.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An OutputStream that counts the number of bytes written.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingOutputStream -->
  <!-- start class com.google.common.io.FileBackedOutputStream -->
  <class name="FileBackedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileBackedOutputStream" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold, and does
 not reset the data when the {@link InputSupplier} returned by
 {@link #getSupplier} is finalized.

 @param fileThreshold the number of bytes before the stream should
     switch to buffering to a file]]>
      </doc>
    </constructor>
    <constructor name="FileBackedOutputStream" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold, and
 optionally resets the data when the {@link InputSupplier} returned
 by {@link #getSupplier} is finalized.

 @param fileThreshold the number of bytes before the stream should
     switch to buffering to a file
 @param resetOnFinalize if true, the {@link #reset} method will
     be called when the {@link InputSupplier} returned by {@link
     #getSupplier} is finalized]]>
      </doc>
    </constructor>
    <method name="getSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a supplier that may be used to retrieve the data buffered
 by this stream.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calls {@link #close} if not already closed, and then resets this
 object back to its initial state, for reuse. If data was buffered
 to a file, it will be deleted.

 @throws IOException if an I/O error occurred while deleting the file buffer]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link OutputStream} that starts buffering to a byte array, but
 switches to file buffering once the data reaches a configurable size.

 <p>This class is thread-safe.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.FileBackedOutputStream -->
  <!-- start class com.google.common.io.Files -->
  <class name="Files" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReader" return="java.io.BufferedReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered reader that reads from a file using the given
 character set.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return the buffered reader]]>
      </doc>
    </method>
    <method name="newWriter" return="java.io.BufferedWriter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered writer that writes to a file using the given
 character set.

 @param file the file to write to
 @param charset the charset used to encode the output stream; see {@link
     Charsets} for helpful predefined constants
 @return the buffered writer]]>
      </doc>
    </method>
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.FileInputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileInputStream}
 that read from a file.

 @param file the file to read from
 @return the factory]]>
      </doc>
    </method>
    <method name="newOutputStreamSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.FileOutputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileOutputStream}
 that write to a file.

 @param file the file to write to
 @return the factory]]>
      </doc>
    </method>
    <method name="newOutputStreamSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.FileOutputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="append" type="boolean"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link FileOutputStream}
 that write to or append to a file.

 @param file the file to write to
 @param append if true, the encoded characters will be appended to the file;
     otherwise the file is overwritten
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link InputStreamReader} that read a file using the given character set.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter}
 that write to a file using the given character set.

 @param file the file to write to
 @param charset the charset used to encode the output stream; see {@link
     Charsets} for helpful predefined constants
 @return the factory]]>
      </doc>
    </method>
    <method name="newWriterSupplier" return="com.google.common.io.OutputSupplier&lt;java.io.OutputStreamWriter&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="append" type="boolean"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link OutputStreamWriter}
 that write to or append to a file using the given character set.

 @param file the file to write to
 @param charset the charset used to encode the output stream; see {@link
     Charsets} for helpful predefined constants
 @param append if true, the encoded characters will be appended to the file;
     otherwise the file is overwritten
 @return the factory]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a file into a byte array.

 @param file the file to read from
 @return a byte array containing all the bytes from file
 @throws IllegalArgumentException if the file is bigger than the largest
     possible byte array (2^31 - 1)
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a file into a {@link String}, using the given
 character set.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return a string containing all the characters from the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;? extends java.io.InputStream&gt;"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies to a file all bytes from an {@link InputStream} supplied by a
 factory.

 @param from the input factory
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="byte[]"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Overwrites a file with the contents of a byte array.

 @param from the bytes to write
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;? extends java.io.OutputStream&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a file to an {@link OutputStream} supplied by
 a factory.

 @param from the source file
 @param to the output factory
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a file to an output stream.

 @param from the source file
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all the bytes from one file to another.
.
 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs
 @throws IllegalArgumentException if {@code from.equals(to)}]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.io.InputSupplier&lt;R&gt;"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies to a file all characters from a {@link Readable} and
 {@link Closeable} object supplied by a factory, using the given
 character set.

 @param from the readable supplier
 @param to the destination file
 @param charset the charset used to encode the output stream; see {@link
     Charsets} for helpful predefined constants
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a character sequence (such as a string) to a file using the given
 character set.

 @param from the character sequence to write
 @param to the destination file
 @param charset the charset used to encode the output stream; see {@link
     Charsets} for helpful predefined constants
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends a character sequence (such as a string) to a file using the given
 character set.

 @param from the character sequence to append
 @param to the destination file
 @param charset the charset used to encode the output stream; see {@link
     Charsets} for helpful predefined constants
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="to" type="com.google.common.io.OutputSupplier&lt;W&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters from a file to a {@link Appendable} &
 {@link Closeable} object supplied by a factory, using the given
 character set.

 @param from the source file
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @param to the appendable supplier
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters from a file to an appendable object,
 using the given character set.

 @param from the source file
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @param to the appendable object
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file1" type="java.io.File"/>
      <param name="file2" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the files contains the same bytes.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="createTempDir" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Atomically creates a new directory somewhere beneath the system's
 temporary directory (as defined by the {@code java.io.tmpdir} system
 property), and returns its name.

 <p>Use this method instead of {@link File#createTempFile(String, String)}
 when you wish to create a directory, not a regular file.  A common pitfall
 is to call {@code createTempFile}, delete the file and create a
 directory in its place, but this leads a race condition which can be
 exploited to create security vulnerabilities, especially when executable
 files are to be written into the directory.

 <p>This method assumes that the temporary volume is writable, has free
 inodes and free blocks, and that it will not be called thousands of times
 per second.

 @return the newly-created directory
 @throws IllegalStateException if the directory could not be created]]>
      </doc>
    </method>
    <method name="touch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates an empty file or updates the last updated timestamp on the
 same as the unix command of the same name.

 @param file the file to create or update
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="createParentDirs"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates any necessary but nonexistent parent directories of the specified
 file. Note that if this operation fails it may have succeeded in creating
 some (but not all) of the necessary parent directories.

 @throws IOException if an I/O error occurs, or if any necessary but
     nonexistent parent directories of the specified file could not be
     created.
 @since 4.0]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Moves the file from one path to another. This method can rename a file or
 move it to a different directory, like the Unix {@code mv} command.

 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs
 @throws IllegalArgumentException if {@code from.equals(to)}]]>
      </doc>
    </method>
    <method name="readFirstLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line from a file. The line does not include
 line-termination characters, but does include other leading and
 trailing whitespace.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return the first line, or null if the file is empty
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a file. The lines do not include
 line-termination characters, but do include other leading and
 trailing whitespace.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link File}, stopping when our callback returns
 false, or we have read all of the lines.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @param callback the {@link LineProcessor} to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readBytes" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of a file.

 <p>(If this seems too complicated, maybe you're looking for
 {@link #toByteArray}.)

 @param file the file to read
 @param processor the object to which the bytes of the file are passed.
 @return the result of the byte processor
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getChecksum" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="checksum" type="java.util.zip.Checksum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes and returns the checksum value for a file.
 The checksum object is reset when this method returns successfully.

 @param file the file to read
 @param checksum the checksum object
 @return the result of {@link Checksum#getValue} after updating the
     checksum object with all of the bytes in the file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="hashFunction" type="com.google.common.hash.HashFunction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes the hash code of the {@code file} using {@code hashFunction}.

 @param file the file to read
 @param hashFunction the hash function to use to hash the data
 @return the {@link HashCode} of all of the bytes in the file
 @throws IOException if an I/O error occurs
 @since 12.0]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully maps a file read-only in to memory as per
 {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.

 <p>Files are mapped from offset 0 to its length.

 <p>This only works for files <= {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @return a read-only buffer reflecting {@code file}
 @throws FileNotFoundException if the {@code file} does not exist
 @throws IOException if an I/O error occurs

 @see FileChannel#map(MapMode, long, long)
 @since 2.0]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="mode" type="java.nio.channels.FileChannel.MapMode"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully maps a file in to memory as per
 {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}
 using the requested {@link MapMode}.

 <p>Files are mapped from offset 0 to its length.

 <p>This only works for files <= {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @param mode the mode to use when mapping {@code file}
 @return a buffer reflecting {@code file}
 @throws FileNotFoundException if the {@code file} does not exist
 @throws IOException if an I/O error occurs

 @see FileChannel#map(MapMode, long, long)
 @since 2.0]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="mode" type="java.nio.channels.FileChannel.MapMode"/>
      <param name="size" type="long"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Maps a file in to memory as per
 {@link FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}
 using the requested {@link MapMode}.

 <p>Files are mapped from offset 0 to {@code size}.

 <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist,
 it will be created with the requested {@code size}. Thus this method is
 useful for creating memory mapped files which do not yet exist.

 <p>This only works for files <= {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @param mode the mode to use when mapping {@code file}
 @return a buffer reflecting {@code file}
 @throws IOException if an I/O error occurs

 @see FileChannel#map(MapMode, long, long)
 @since 2.0]]>
      </doc>
    </method>
    <method name="simplifyPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathname" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the lexically cleaned form of the path name, <i>usually</i> (but
 not always) equivalent to the original. The following heuristics are used:

 <ul>
 <li>empty string becomes .
 <li>. stays as .
 <li>fold out ./
 <li>fold out ../ when possible
 <li>collapse multiple slashes
 <li>delete trailing slashes (unless the path is just "/")
 </ul>

 These heuristics do not always match the behavior of the filesystem. In
 particular, consider the path {@code a/../b}, which {@code simplifyPath}
 will change to {@code b}. If {@code a} is a symlink to {@code x}, {@code
 a/../b} may refer to a sibling of {@code x}, rather than the sibling of
 {@code a} referred to by {@code b}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="getFileExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Filename_extension">file
 extension</a> for the given file name, or the empty string if the file has
 no extension.  The result does not include the '{@code .}'.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with files.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Files -->
  <!-- start class com.google.common.io.Flushables -->
  <class name="Flushables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush a {@link Flushable}, with control over whether an
 {@code IOException} may be thrown.

 <p>If {@code swallowIOException} is true, then we don't rethrow
 {@code IOException}, but merely log it.

 @param flushable the {@code Flushable} object to be flushed.
 @param swallowIOException if true, don't propagate IO exceptions
     thrown by the {@code flush} method
 @throws IOException if {@code swallowIOException} is false and
     {@link Flushable#flush} throws an {@code IOException}.
 @see Closeables#close]]>
      </doc>
    </method>
    <method name="flushQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <doc>
      <![CDATA[Equivalent to calling {@code flush(flushable, true)}, but with no
 {@code IOException} in the signature.

 @param flushable the {@code Flushable} object to be flushed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Flushable} objects.

 @author Michael Lancaster
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Flushables -->
  <!-- start interface com.google.common.io.InputSupplier -->
  <interface name="InputSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getInput" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns an object that encapsulates a readable resource.
 <p>
 Like {@link Iterable#iterator}, this method may be called repeatedly to
 get independent channels to the same underlying resource.
 <p>
 Where the channel maintains a position within the resource, moving that
 cursor within one channel should not affect the starting position of
 channels returned by other calls.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A factory for readable streams of bytes or characters.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.InputSupplier -->
  <!-- start class com.google.common.io.LimitInputStream -->
  <class name="LimitInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LimitInputStream" type="java.io.InputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, limiting the number of bytes which can be read.

 @param in the input stream to be wrapped
 @param limit the maximum number of bytes to be read]]>
      </doc>
    </constructor>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An InputStream that limits the number of bytes which can be read.

 @author Charles Fry
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LimitInputStream -->
  <!-- start interface com.google.common.io.LineProcessor -->
  <interface name="LineProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processLine" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="line" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called once for each line.

 @param line the line read from the input, without delimiter
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the lines.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback to be used with the streaming {@code readLines} methods.

 <p>{@link #processLine} will be called for each line that is read, and
 should return {@code false} when you want to stop processing.

 @author Miles Barr
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.LineProcessor -->
  <!-- start class com.google.common.io.LineReader -->
  <class name="LineReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LineReader" type="java.lang.Readable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that will read lines from the given
 {@code Readable} object.]]>
      </doc>
    </constructor>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a line of text. A line is considered to be terminated by any
 one of a line feed ({@code '\n'}), a carriage return
 ({@code '\r'}), or a carriage return followed immediately by a linefeed
 ({@code "\r\n"}).

 @return a {@code String} containing the contents of the line, not
     including any line-termination characters, or {@code null} if the
     end of the stream has been reached.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for reading lines of text. Provides the same functionality
 as {@link java.io.BufferedReader#readLine()} but for all {@link Readable}
 objects, not just instances of {@link Reader}.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LineReader -->
  <!-- start class com.google.common.io.LittleEndianDataInputStream -->
  <class name="LittleEndianDataInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataInput"/>
    <constructor name="LittleEndianDataInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code LittleEndianDataInputStream} that wraps the given stream.

 @param in the stream to delegate to]]>
      </doc>
    </constructor>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method will throw an {@link UnsupportedOperationException}.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readUnsignedByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads an unsigned {@code short} as specified by
 {@link DataInputStream#readUnsignedShort()}, except using little-endian
 byte order.

 @return the next two bytes of the input stream, interpreted as an 
         unsigned 16-bit integer in little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads an integer as specified by {@link DataInputStream#readInt()}, except
 using little-endian byte order.

 @return the next four bytes of the input stream, interpreted as an 
         {@code int} in little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code long} as specified by {@link DataInputStream#readLong()},
 except using little-endian byte order.

 @return the next eight bytes of the input stream, interpreted as a 
         {@code long} in little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code float} as specified by {@link DataInputStream#readFloat()},
 except using little-endian byte order.

 @return the next four bytes of the input stream, interpreted as a
         {@code float} in little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code double} as specified by
 {@link DataInputStream#readDouble()}, except using little-endian byte
 order.

 @return the next eight bytes of the input stream, interpreted as a
         {@code double} in little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readUTF" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code short} as specified by {@link DataInputStream#readShort()},
 except using little-endian byte order.

 @return the next two bytes of the input stream, interpreted as a
         {@code short} in little-endian byte order.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a char as specified by {@link DataInputStream#readChar()}, except
 using little-endian byte order.

 @return the next two bytes of the input stream, interpreted as a 
         {@code char} in little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An implementation of {@link DataInput} that uses little-endian byte ordering
 for reading {@code short}, {@code int}, {@code float}, {@code double}, and
 {@code long} values.
 <p>
 <b>Note:</b> This class intentionally violates the specification of its
 supertype {@code DataInput}, which explicitly requires big-endian byte order.

 @author Chris Nokleberg
 @author Keith Bottner
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LittleEndianDataInputStream -->
  <!-- start class com.google.common.io.LittleEndianDataOutputStream -->
  <class name="LittleEndianDataOutputStream" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataOutput"/>
    <constructor name="LittleEndianDataOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code LittleEndianDataOutputStream} that wraps the given stream.

 @param out the stream to delegate to]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="The semantics of {@code writeBytes(String s)} are considered
             dangerous. Please use {@link #writeUTF(String s)},
             {@link #writeChars(String s)} or another write method instead.">
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated The semantics of {@code writeBytes(String s)} are considered
             dangerous. Please use {@link #writeUTF(String s)},
             {@link #writeChars(String s)} or another write method instead.]]>
      </doc>
    </method>
    <method name="writeChar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a char as specified by {@link DataOutputStream#writeChar(int)},
 except using little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeChars"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code String} as specified by
 {@link DataOutputStream#writeChars(String)}, except each character is
 written using little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code double} as specified by
 {@link DataOutputStream#writeDouble(double)}, except using little-endian
 byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code float} as specified by
 {@link DataOutputStream#writeFloat(float)}, except using little-endian byte
 order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes an {@code int} as specified by
 {@link DataOutputStream#writeInt(int)}, except using little-endian byte
 order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code long} as specified by
 {@link DataOutputStream#writeLong(long)}, except using little-endian byte
 order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeShort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code short} as specified by
 {@link DataOutputStream#writeShort(int)}, except using little-endian byte
 order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeUTF"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An implementation of {@link DataOutput} that uses little-endian byte ordering
 for writing {@code char}, {@code short}, {@code int}, {@code float}, {@code
 double}, and {@code long} values.
 <p>
 <b>Note:</b> This class intentionally violates the specification of its
 supertype {@code DataOutput}, which explicitly requires big-endian byte
 order.

 @author Chris Nokleberg
 @author Keith Bottner
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LittleEndianDataOutputStream -->
  <!-- start class com.google.common.io.NullOutputStream -->
  <class name="NullOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullOutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Discards the specified byte.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Discards the specified byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@link OutputStream} that simply discards written bytes.

 @author Spencer Kimball
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.NullOutputStream -->
  <!-- start interface com.google.common.io.OutputSupplier -->
  <interface name="OutputSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getOutput" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns an object that encapsulates a writable resource.
 <p>
 Like {@link Iterable#iterator}, this method may be called repeatedly to
 get independent channels to the same underlying resource.
 <p>
 Where the channel maintains a position within the resource, moving that
 cursor within one channel should not affect the starting position of
 channels returned by other calls.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A factory for writable streams of bytes or characters.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.OutputSupplier -->
  <!-- start class com.google.common.io.PatternFilenameFilter -->
  <class name="PatternFilenameFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.FilenameFilter"/>
    <constructor name="PatternFilenameFilter" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.
 @param patternStr the pattern string on which to filter file names

 @throws PatternSyntaxException if pattern compilation fails (runtime)]]>
      </doc>
    </constructor>
    <constructor name="PatternFilenameFilter" type="java.util.regex.Pattern"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.
 @param pattern the pattern on which to filter file names]]>
      </doc>
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="fileName" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[File name filter that only accepts files matching a regular expression. This
 class is thread-safe and immutable.

 @author Apple Chow
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.PatternFilenameFilter -->
  <!-- start class com.google.common.io.Resources -->
  <class name="Resources" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newInputStreamSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStream&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of {@link InputStream} that
 read from the given URL.

 @param url the URL to read from
 @return the factory]]>
      </doc>
    </method>
    <method name="newReaderSupplier" return="com.google.common.io.InputSupplier&lt;java.io.InputStreamReader&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a factory that will supply instances of
 {@link InputStreamReader} that read a URL using the given character set.

 @param url the URL to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return the factory]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a URL into a byte array.

 @param url the URL to read from
 @return a byte array containing all the bytes from the URL
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a URL into a {@link String}, using the given
 character set.

 @param url the URL to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return a string containing all the characters from the URL
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readLines" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a URL, stopping when our callback returns false, or we
 have read all of the lines.

 @param url the URL to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @param callback the LineProcessor to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a URL. The lines do not include
 line-termination characters, but do include other leading and trailing
 whitespace.

 @param url the URL to read from
 @param charset the charset used to decode the input stream; see {@link
     Charsets} for helpful predefined constants
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.net.URL"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a URL to an output stream.

 @param from the URL to read from
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code URL} pointing to {@code resourceName} if the resource is
 found in the class path. {@code Resources.class.getClassLoader()} is used
 to locate the resource.
 
 @throws IllegalArgumentException if resource is not found]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code URL} pointing to {@code resourceName} that is relative to
 {@code contextClass}, if the resource is found in the class path. 
 
 @throws IllegalArgumentException if resource is not found]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with resources in the classpath.
 Note that even though these methods use {@link URL} parameters, they
 are usually not appropriate for HTTP or other non-classpath resources.

 <p>All method parameters must be non-null unless documented otherwise.

 @author Chris Nokleberg
 @author Ben Yu
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Resources -->
</package>
<package name="com.google.common.math">
  <!-- start class com.google.common.math.BigIntegerMath -->
  <class name="BigIntegerMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a power of two.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
         is not a power of two]]>
      </doc>
    </method>
    <method name="log10" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
         is not a power of ten]]>
      </doc>
    </method>
    <method name="sqrt" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the square root of {@code x}, rounded with the specified rounding mode.

 @throws IllegalArgumentException if {@code x < 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and
         {@code sqrt(x)} is not an integer]]>
      </doc>
    </method>
    <method name="divide" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.math.BigInteger"/>
      <param name="q" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the result of dividing {@code p} by {@code q}, rounding using the specified
 {@code RoundingMode}.

 @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
         is not an integer multiple of {@code b}]]>
      </doc>
    </method>
    <method name="factorial" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive
 integers, or {@code 1} if {@code n == 0}.

 <p><b>Warning</b>: the result takes <i>O(n log n)</i> space, so use cautiously.

 <p>This uses an efficient binary recursive algorithm to compute the factorial
 with balanced multiplies.  It also removes all the 2s from the intermediate
 products (shifting them back in at the end).

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="binomial" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and
 {@code k}, that is, {@code n! / (k! (n - k)!)}.

 <p><b>Warning</b>: the result can take as much as <i>O(k log n)</i> space.

 @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on values of type {@code BigInteger}.

 <p>The implementations of many methods in this class are based on material from Henry S. Warren,
 Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).

 <p>Similar functionality for {@code int} and for {@code long} can be found in
 {@link IntMath} and {@link LongMath} respectively.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.BigIntegerMath -->
  <!-- start class com.google.common.math.DoubleMath -->
  <class name="DoubleMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="roundToInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the {@code int} value that is equal to {@code x} rounded with the specified rounding
 mode, if possible.

 @throws ArithmeticException if
         <ul>
         <li>{@code x} is infinite or NaN
         <li>{@code x}, after being rounded to a mathematical integer using the specified
         rounding mode, is either less than {@code Integer.MIN_VALUE} or greater than {@code
         Integer.MAX_VALUE}
         <li>{@code x} is not a mathematical integer and {@code mode} is
         {@link RoundingMode#UNNECESSARY}
         </ul>]]>
      </doc>
    </method>
    <method name="roundToLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the {@code long} value that is equal to {@code x} rounded with the specified rounding
 mode, if possible.

 @throws ArithmeticException if
         <ul>
         <li>{@code x} is infinite or NaN
         <li>{@code x}, after being rounded to a mathematical integer using the specified
         rounding mode, is either less than {@code Long.MIN_VALUE} or greater than {@code
         Long.MAX_VALUE}
         <li>{@code x} is not a mathematical integer and {@code mode} is
         {@link RoundingMode#UNNECESSARY}
         </ul>]]>
      </doc>
    </method>
    <method name="roundToBigInteger" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the {@code BigInteger} value that is equal to {@code x} rounded with the specified
 rounding mode, if possible.

 @throws ArithmeticException if
         <ul>
         <li>{@code x} is infinite or NaN
         <li>{@code x} is not a mathematical integer and {@code mode} is
         {@link RoundingMode#UNNECESSARY}
         </ul>]]>
      </doc>
    </method>
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} is exactly equal to {@code 2^k} for some finite integer
 {@code k}.]]>
      </doc>
    </method>
    <method name="log2" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Returns the base 2 logarithm of a double value.

 <p>Special cases:
 <ul>
 <li>If {@code x} is NaN or less than zero, the result is NaN.
 <li>If {@code x} is positive infinity, the result is positive infinity.
 <li>If {@code x} is positive or negative zero, the result is negative infinity.
 </ul>

 <p>The computed result is within 1 ulp of the exact result.

 <p>If the result of this method will be immediately rounded to an {@code int},
 {@link #log2(double, RoundingMode)} is faster.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base 2 logarithm of a double value, rounded with the specified rounding mode to an
 {@code int}.

 <p>Regardless of the rounding mode, this is faster than {@code (int) log2(x)}.

 @throws IllegalArgumentException if {@code x <= 0.0}, {@code x} is NaN, or {@code x} is
         infinite]]>
      </doc>
    </method>
    <method name="isMathematicalInteger" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a mathematical integer.

 <p>This is equivalent to, but not necessarily implemented as, the expression {@code
 !Double.isNaN(x) && !Double.isInfinite(x) && x == Math.rint(x)}.]]>
      </doc>
    </method>
    <method name="factorial" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive
 integers, {@code 1} if {@code n == 0}, or e n!}, or
 {@link Double#POSITIVE_INFINITY} if {@code n! > Double.MAX_VALUE}.

 <p>The result is within 1 ulp of the true value.

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="fuzzyEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <param name="tolerance" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code a} and {@code b} are within {@code tolerance} of each other.

 <p>Technically speaking, this is equivalent to
 {@code Math.abs(a - b) <= tolerance || Double.valueOf(a).equals(Double.valueOf(b))}.

 <p>Notable special cases include:
 <ul>
 <li>All NaNs are fuzzily equal.
 <li>If {@code a == b}, then {@code a} and {@code b} are always fuzzily equal.
 <li>Positive and negative zero are always fuzzily equal.
 <li>If {@code tolerance} is zero, and neither {@code a} nor {@code b} is NaN, then
 {@code a} and {@code b} are fuzzily equal if and only if {@code a == b}.
 <li>With {@link Double#POSITIVE_INFINITY} tolerance, all non-NaN values are fuzzily equal.
 <li>With finite tolerance, {@code Double.POSITIVE_INFINITY} and {@code
 Double.NEGATIVE_INFINITY} are fuzzily equal only to themselves.
 </li>

 <p>This is reflexive and symmetric, but <em>not</em> transitive, so it is <em>not</em> an
 equivalence relation and <em>not</em> suitable for use in {@link Object#equals}
 implementations.

 @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN
 @since 13.0]]>
      </doc>
    </method>
    <method name="fuzzyCompare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <param name="tolerance" type="double"/>
      <doc>
      <![CDATA[Compares {@code a} and {@code b} "fuzzily," with a tolerance for nearly-equal values.

 <p>This method is equivalent to
 {@code fuzzyEquals(a, b, tolerance) ? 0 : Double.compare(a, b)}. In particular, like
 {@link Double#compare(double, double)}, it treats all NaN values as equal and greater than all
 other values (including {@link Double#POSITIVE_INFINITY}).

 <p>This is <em>not</em> a total ordering and is <em>not</em> suitable for use in
 {@link Comparable#compareTo} implementations.  In particular, it is not transitive.

 @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN
 @since 13.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on doubles that is not covered by {@link java.lang.Math}.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.DoubleMath -->
  <!-- start class com.google.common.math.IntMath -->
  <class name="IntMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a power of two.

 <p>This differs from {@code Integer.bitCount(x) == 1}, because
 {@code Integer.bitCount(Integer.MIN_VALUE) == 1}, but {@link Integer#MIN_VALUE} is not a power
 of two.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
         is not a power of two]]>
      </doc>
    </method>
    <method name="log10" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
         is not a power of ten]]>
      </doc>
    </method>
    <method name="pow" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to
 {@code BigInteger.valueOf(b).pow(k).intValue()}. This implementation runs in {@code O(log k)}
 time.

 <p>Compare {@link #checkedPow}, which throws an {@link ArithmeticException} upon overflow.

 @throws IllegalArgumentException if {@code k < 0}]]>
      </doc>
    </method>
    <method name="sqrt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the square root of {@code x}, rounded with the specified rounding mode.

 @throws IllegalArgumentException if {@code x < 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and
         {@code sqrt(x)} is not an integer]]>
      </doc>
    </method>
    <method name="divide" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="int"/>
      <param name="q" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the result of dividing {@code p} by {@code q}, rounding using the specified
 {@code RoundingMode}.

 @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
         is not an integer multiple of {@code b}]]>
      </doc>
    </method>
    <method name="mod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="m" type="int"/>
      <doc>
      <![CDATA[Returns {@code x mod m}. This differs from {@code x % m} in that it always returns a
 non-negative result.

 <p>For example:<pre> {@code

 mod(7, 4) == 3
 mod(-7, 4) == 1
 mod(-1, 4) == 3
 mod(-8, 4) == 0
 mod(8, 4) == 0}</pre>

 @throws ArithmeticException if {@code m <= 0}]]>
      </doc>
    </method>
    <method name="gcd" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if
 {@code a == 0 && b == 0}.

 @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}]]>
      </doc>
    </method>
    <method name="checkedAdd" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the sum of {@code a} and {@code b}, provided it does not overflow.

 @throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic]]>
      </doc>
    </method>
    <method name="checkedSubtract" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the difference of {@code a} and {@code b}, provided it does not overflow.

 @throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic]]>
      </doc>
    </method>
    <method name="checkedMultiply" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the product of {@code a} and {@code b}, provided it does not overflow.

 @throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic]]>
      </doc>
    </method>
    <method name="checkedPow" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code b} to the {@code k}th power, provided it does not overflow.

 <p>{@link #pow} may be faster, but does not check for overflow.

 @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed
         {@code int} arithmetic]]>
      </doc>
    </method>
    <method name="factorial" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive
 integers, {@code 1} if {@code n == 0}, or {@link Integer#MAX_VALUE} if the
 result does not fit in a {@code int}.

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="binomial" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and
 {@code k}, or {@link Integer#MAX_VALUE} if the result does not fit in an {@code int}.

 @throws IllegalArgumentException if {@code n < 0}, {@code k < 0} or {@code k > n}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on values of type {@code int}. Where possible, methods are defined and
 named analogously to their {@code BigInteger} counterparts.

 <p>The implementations of many methods in this class are based on material from Henry S. Warren,
 Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).

 <p>Similar functionality for {@code long} and for {@link BigInteger} can be found in
 {@link LongMath} and {@link BigIntegerMath} respectively.  For other common operations on
 {@code int} values, see {@link com.google.common.primitives.Ints}.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.IntMath -->
  <!-- start class com.google.common.math.LongMath -->
  <class name="LongMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a power of two.

 <p>This differs from {@code Long.bitCount(x) == 1}, because
 {@code Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
         is not a power of two]]>
      </doc>
    </method>
    <method name="log10" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
         is not a power of ten]]>
      </doc>
    </method>
    <method name="pow" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="long"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to
 {@code BigInteger.valueOf(b).pow(k).longValue()}. This implementation runs in {@code O(log k)}
 time.

 @throws IllegalArgumentException if {@code k < 0}]]>
      </doc>
    </method>
    <method name="sqrt" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the square root of {@code x}, rounded with the specified rounding mode.

 @throws IllegalArgumentException if {@code x < 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and
         {@code sqrt(x)} is not an integer]]>
      </doc>
    </method>
    <method name="divide" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="long"/>
      <param name="q" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the result of dividing {@code p} by {@code q}, rounding using the specified
 {@code RoundingMode}.

 @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
         is not an integer multiple of {@code b}]]>
      </doc>
    </method>
    <method name="mod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="m" type="int"/>
      <doc>
      <![CDATA[Returns {@code x mod m}. This differs from {@code x % m} in that it always returns a
 non-negative result.

 <p>For example:

 <pre> {@code

 mod(7, 4) == 3
 mod(-7, 4) == 1
 mod(-1, 4) == 3
 mod(-8, 4) == 0
 mod(8, 4) == 0}</pre>

 @throws ArithmeticException if {@code m <= 0}]]>
      </doc>
    </method>
    <method name="mod" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="m" type="long"/>
      <doc>
      <![CDATA[Returns {@code x mod m}. This differs from {@code x % m} in that it always returns a
 non-negative result.

 <p>For example:

 <pre> {@code

 mod(7, 4) == 3
 mod(-7, 4) == 1
 mod(-1, 4) == 3
 mod(-8, 4) == 0
 mod(8, 4) == 0}</pre>

 @throws ArithmeticException if {@code m <= 0}]]>
      </doc>
    </method>
    <method name="gcd" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if
 {@code a == 0 && b == 0}.

 @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}]]>
      </doc>
    </method>
    <method name="checkedAdd" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the sum of {@code a} and {@code b}, provided it does not overflow.

 @throws ArithmeticException if {@code a + b} overflows in signed {@code long} arithmetic]]>
      </doc>
    </method>
    <method name="checkedSubtract" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the difference of {@code a} and {@code b}, provided it does not overflow.

 @throws ArithmeticException if {@code a - b} overflows in signed {@code long} arithmetic]]>
      </doc>
    </method>
    <method name="checkedMultiply" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the product of {@code a} and {@code b}, provided it does not overflow.

 @throws ArithmeticException if {@code a * b} overflows in signed {@code long} arithmetic]]>
      </doc>
    </method>
    <method name="checkedPow" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="long"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code b} to the {@code k}th power, provided it does not overflow.

 @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed
         {@code long} arithmetic]]>
      </doc>
    </method>
    <method name="factorial" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive
 integers, {@code 1} if {@code n == 0}, or {@link Long#MAX_VALUE} if the
 result does not fit in a {@code long}.

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="binomial" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and
 {@code k}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.

 @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on values of type {@code long}. Where possible, methods are defined and
 named analogously to their {@code BigInteger} counterparts.

 <p>The implementations of many methods in this class are based on material from Henry S. Warren,
 Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).

 <p>Similar functionality for {@code int} and for {@link BigInteger} can be found in
 {@link IntMath} and {@link BigIntegerMath} respectively.  For other common operations on
 {@code long} values, see {@link com.google.common.primitives.Longs}.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.LongMath -->
</package>
<package name="com.google.common.net">
  <!-- start class com.google.common.net.HostAndPort -->
  <class name="HostAndPort" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="getHostText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the portion of this {@code HostAndPort} instance that should
 represent the hostname or IPv4/IPv6 literal.

 A successful parse does not imply any degree of sanity in this field.
 For additional validation, see the {@link HostSpecifier} class.]]>
      </doc>
    </method>
    <method name="hasPort" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if this instance has a defined port.]]>
      </doc>
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current port number, failing if no port is defined.

 @return a validated port number, in the range [0..65535]
 @throws IllegalStateException if no port is defined.  You can use
         {@link #withDefaultPort(int)} to prevent this from occurring.]]>
      </doc>
    </method>
    <method name="getPortOrDefault" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Returns the current port number, with a default if no port is defined.]]>
      </doc>
    </method>
    <method name="fromParts" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <doc>
      <![CDATA[Build a HostAndPort instance from separate host and port values.

 <p>Note: Non-bracketed IPv6 literals are allowed.
 Use {@link #requireBracketsForIPv6()} to prohibit these.

 @param host the host string to parse.  Must not contain a port number.
 @param port a port number from [0..65535]
 @return if parsing was successful, a populated HostAndPort object.
 @throws IllegalArgumentException if {@code host} contains a port number,
     or {@code port} is out of range.]]>
      </doc>
    </method>
    <method name="fromString" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostPortString" type="java.lang.String"/>
      <doc>
      <![CDATA[Split a freeform string into a host and port, without strict validation.

 Note that the host-only formats will leave the port field undefined.  You
 can use {@link #withDefaultPort(int)} to patch in a default value.

 @param hostPortString the input string to parse.
 @return if parsing was successful, a populated HostAndPort object.
 @throws IllegalArgumentException if nothing meaningful could be parsed.]]>
      </doc>
    </method>
    <method name="withDefaultPort" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Provide a default port if the parsed string contained only a host.

 You can chain this after {@link #fromString(String)} to include a port in
 case the port was omitted from the input string.  If a port was already
 provided, then this method is a no-op.

 @param defaultPort a port number, from [0..65535]
 @return a HostAndPort instance, guaranteed to have a defined port.]]>
      </doc>
    </method>
    <method name="requireBracketsForIPv6" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate an error if the host might be a non-bracketed IPv6 literal.

 <p>URI formatting requires that IPv6 literals be surrounded by brackets,
 like "[2001:db8::1]".  Chain this call after {@link #fromString(String)}
 to increase the strictness of the parser, and disallow IPv6 literals
 that don't contain these brackets.

 <p>Note that this parser identifies IPv6 literals solely based on the
 presence of a colon.  To perform actual validation of IP addresses, see
 the {@link InetAddresses#forString(String)} method.

 @return {@code this}, to enable chaining of calls.
 @throws IllegalArgumentException if bracketless IPv6 is detected.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Rebuild the host:port string, including brackets if necessary.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable representation of a host and port.

 <p>Example usage:
 <pre>
 HostAndPort hp = HostAndPort.fromString("[2001:db8::1]")
     .withDefaultPort(80)
     .requireBracketsForIPv6();
 hp.getHostText();  // returns "2001:db8::1"
 hp.getPort();      // returns 80
 hp.toString();     // returns "[2001:db8::1]:80"
 </pre>

 <p>Here are some examples of recognized formats:
 <ul>
   <li>example.com
   <li>example.com:80
   <li>192.0.2.1
   <li>192.0.2.1:80
   <li>[2001:db8::1]     - {@link #getHostText()} omits brackets
   <li>[2001:db8::1]:80  - {@link #getHostText()} omits brackets
   <li>2001:db8::1       - Use {@link #requireBracketsForIPv6()} to prohibit this
 </ul>

 <p>Note that this is not an exhaustive list, because these methods are only
 concerned with brackets, colons, and port numbers.  Full validation of the
 host field (if desired) is the caller's responsibility.

 @author Paul Marks
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HostAndPort -->
  <!-- start class com.google.common.net.HostSpecifier -->
  <class name="HostSpecifier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="fromValid" return="com.google.common.net.HostSpecifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code HostSpecifier} built from the provided {@code specifier},
 which is already known to be valid.  If the {@code specifier} might be
 invalid, use {@link #from(String)} instead.

 <p>The specifier must be in one of these formats:
 <ul>
 <li>A domain name, like {@code google.com}
 <li>A IPv4 address string, like {@code 127.0.0.1}
 <li>An IPv6 address string with or without brackets, like
     {@code [2001:db8::1]} or {@code 2001:db8::1}
 </ul>

 @throws IllegalArgumentException if the specifier is not valid.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.net.HostSpecifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <exception name="ParseException" type="java.text.ParseException"/>
      <doc>
      <![CDATA[Attempts to return a {@code HostSpecifier} for the given string, throwing
 an exception if parsing fails. Always use this method in preference to
 {@link #fromValid(String)} for a specifier that is not already known to be
 valid.

 @throws ParseException if the specifier is not valid.]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Determines whether {@code specifier} represents a valid
 {@link HostSpecifier} as described in the documentation for
 {@link #fromValid(String)}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the host specifier suitable for
 inclusion in a URI.  If the host specifier is a domain name, the
 string will be normalized to all lower case.  If the specifier was
 an IPv6 address without brackets, brackets are added so that the
 result will be usable in the host part of a URI.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A syntactically valid host specifier, suitable for use in a URI.
 This may be either a numeric IP address in IPv4 or IPv6 notation, or a
 domain name.

 <p>Because this class is intended to represent host specifiers which can
 reasonably be used in a URI, the domain name case is further restricted to
 include only those domain names which end in a recognized public suffix; see
 {@link InternetDomainName#isPublicSuffix()} for details.

 <p>Note that no network lookups are performed by any {@code HostSpecifier}
 methods.  No attempt is made to verify that a provided specifier corresponds
 to a real or accessible host.  Only syntactic and pattern-based checks are
 performed.

 <p>If you know that a given string represents a numeric IP address, use
 {@link InetAddresses} to obtain and manipulate a
 {@link java.net.InetAddress} instance from it rather than using this class.
 Similarly, if you know that a given string represents a domain name, use
 {@link InternetDomainName} rather than this class.

 @author Craig Berry
 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HostSpecifier -->
  <!-- start class com.google.common.net.HttpHeaders -->
  <class name="HttpHeaders" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="CACHE_CONTROL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Cache-Control header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_LENGTH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-Length header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-Type header field name.]]>
      </doc>
    </field>
    <field name="DATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Date header field name.]]>
      </doc>
    </field>
    <field name="PRAGMA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Pragma header field name.]]>
      </doc>
    </field>
    <field name="VIA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Via header field name.]]>
      </doc>
    </field>
    <field name="WARNING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Warning header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Accept header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_CHARSET" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Accept-Charset header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_ENCODING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Accept-Encoding header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_LANGUAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Accept-Language header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_REQUEST_HEADERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Request-Headers header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_REQUEST_METHOD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Request-Method header field name.]]>
      </doc>
    </field>
    <field name="AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Authorization header field name.]]>
      </doc>
    </field>
    <field name="CONNECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Connection header field name.]]>
      </doc>
    </field>
    <field name="COOKIE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Cookie header field name.]]>
      </doc>
    </field>
    <field name="EXPECT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Expect header field name.]]>
      </doc>
    </field>
    <field name="FROM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP From header field name.]]>
      </doc>
    </field>
    <field name="HOST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Host header field name.]]>
      </doc>
    </field>
    <field name="IF_MATCH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP If-Match header field name.]]>
      </doc>
    </field>
    <field name="IF_MODIFIED_SINCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP If-Modified-Since header field name.]]>
      </doc>
    </field>
    <field name="IF_NONE_MATCH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP If-None-Match header field name.]]>
      </doc>
    </field>
    <field name="IF_RANGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP If-Range header field name.]]>
      </doc>
    </field>
    <field name="IF_UNMODIFIED_SINCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP If-Unmodified-Since header field name.]]>
      </doc>
    </field>
    <field name="LAST_EVENT_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Last-Event-ID header field name.]]>
      </doc>
    </field>
    <field name="MAX_FORWARDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Max-Forwards header field name.]]>
      </doc>
    </field>
    <field name="ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Origin header field name.]]>
      </doc>
    </field>
    <field name="PROXY_AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Proxy-Authorization header field name.]]>
      </doc>
    </field>
    <field name="RANGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Range header field name.]]>
      </doc>
    </field>
    <field name="REFERER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Referer header field name.]]>
      </doc>
    </field>
    <field name="TE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP TE header field name.]]>
      </doc>
    </field>
    <field name="UPGRADE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Upgrade header field name.]]>
      </doc>
    </field>
    <field name="USER_AGENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP User-Agent header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_RANGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Accept-Ranges header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_HEADERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Allow-Headers header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_METHODS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Allow-Methods header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Allow-Origin header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_CREDENTIALS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Allow-Credentials header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_EXPOSE_HEADERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Expose-Headers header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_MAX_AGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Access-Control-Max-Age header field name.]]>
      </doc>
    </field>
    <field name="AGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Age header field name.]]>
      </doc>
    </field>
    <field name="ALLOW" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Allow header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_DISPOSITION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-Disposition header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_ENCODING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-Encoding header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_LANGUAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-Language header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_LOCATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-Location header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_MD5" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-MD5 header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_RANGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Content-Range header field name.]]>
      </doc>
    </field>
    <field name="ETAG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP ETag header field name.]]>
      </doc>
    </field>
    <field name="EXPIRES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Expires header field name.]]>
      </doc>
    </field>
    <field name="LAST_MODIFIED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Last-Modified header field name.]]>
      </doc>
    </field>
    <field name="LINK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Link header field name.]]>
      </doc>
    </field>
    <field name="LOCATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Location header field name.]]>
      </doc>
    </field>
    <field name="P3P" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP P3P header field name. Limited browser support.]]>
      </doc>
    </field>
    <field name="PROXY_AUTHENTICATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Proxy-Authenticate header field name.]]>
      </doc>
    </field>
    <field name="REFRESH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Refresh header field name. Non-standard header supported by most browsers.]]>
      </doc>
    </field>
    <field name="RETRY_AFTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Retry-After header field name.]]>
      </doc>
    </field>
    <field name="SERVER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Server header field name.]]>
      </doc>
    </field>
    <field name="SET_COOKIE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Set-Cookie header field name.]]>
      </doc>
    </field>
    <field name="SET_COOKIE2" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Set-Cookie2 header field name.]]>
      </doc>
    </field>
    <field name="TRAILER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Trailer header field name.]]>
      </doc>
    </field>
    <field name="TRANSFER_ENCODING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Transfer-Encoding header field name.]]>
      </doc>
    </field>
    <field name="VARY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Vary header field name.]]>
      </doc>
    </field>
    <field name="WWW_AUTHENTICATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP WWW-Authenticate header field name.]]>
      </doc>
    </field>
    <field name="DNT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP DNT header field name.]]>
      </doc>
    </field>
    <field name="X_CONTENT_TYPE_OPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-Content-Type-Options header field name.]]>
      </doc>
    </field>
    <field name="X_DO_NOT_TRACK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-Do-Not-Track header field name.]]>
      </doc>
    </field>
    <field name="X_FORWARDED_FOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-Forwarded-For header field name.]]>
      </doc>
    </field>
    <field name="X_FORWARDED_PROTO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-Forwarded-Proto header field name.]]>
      </doc>
    </field>
    <field name="X_FRAME_OPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-Frame-Options header field name.]]>
      </doc>
    </field>
    <field name="X_POWERED_BY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-Powered-By header field name.]]>
      </doc>
    </field>
    <field name="X_REQUESTED_WITH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-Requested-With header field name.]]>
      </doc>
    </field>
    <field name="X_USER_IP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-User-IP header field name.]]>
      </doc>
    </field>
    <field name="X_XSS_PROTECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP X-XSS-Protection header field name.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Contains constant definitions for the HTTP header field names. See:
 <ul>
 <li><a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a>
 <li><a href="http://www.ietf.org/rfc/rfc2183.txt">RFC 2183</a>
 <li><a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>
 <li><a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a>
 <li><a href="http://www.ietf.org/rfc/rfc5988.txt">RFC 5988</a>
 </ul>

 @author Kurt Alfred Kluever
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HttpHeaders -->
  <!-- start class com.google.common.net.InetAddresses -->
  <class name="InetAddresses" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="forString" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the {@link InetAddress} having the given string representation.

 <p>This deliberately avoids all nameservice lookups (e.g. no DNS).

 @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g.
     {@code "192.168.0.1"} or {@code "2001:db8::1"}
 @return {@link InetAddress} representing the argument
 @throws IllegalArgumentException if the argument is not a valid IP string literal]]>
      </doc>
    </method>
    <method name="isInetAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the supplied string is a valid IP string
 literal, {@code false} otherwise.

 @param ipString {@code String} to evaluated as an IP string literal
 @return {@code true} if the argument is a valid IP string literal]]>
      </doc>
    </method>
    <method name="toAddrString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns the string representation of an {@link InetAddress}.

 <p>For IPv4 addresses, this is identical to
 {@link InetAddress#getHostAddress()}, but for IPv6 addresses, the output
 follows <a href="http://tools.ietf.org/html/rfc5952">RFC 5952</a>
 section 4.  The main difference is that this method uses "::" for zero
 compression, while Java's version uses the uncompressed form.

 <p>This method uses hexadecimal for all IPv6 addresses, including
 IPv4-mapped IPv6 addresses such as "::c000:201".  The output does not
 include a Scope ID.

 @param ip {@link InetAddress} to be converted to an address string
 @return {@code String} containing the text-formatted IP address
 @since 10.0]]>
      </doc>
    </method>
    <method name="toUriString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns the string representation of an {@link InetAddress} suitable
 for inclusion in a URI.

 <p>For IPv4 addresses, this is identical to
 {@link InetAddress#getHostAddress()}, but for IPv6 addresses it
 compresses zeroes and surrounds the text with square brackets; for example
 {@code "[2001:db8::1]"}.

 <p>Per section 3.2.2 of
 <a target="_parent"
    href="http://tools.ietf.org/html/rfc3986#section-3.2.2"
  >http://tools.ietf.org/html/rfc3986</a>,
 a URI containing an IPv6 string literal is of the form
 {@code "http://[2001:db8::1]:8888/index.html"}.

 <p>Use of either {@link InetAddresses#toAddrString},
 {@link InetAddress#getHostAddress()}, or this method is recommended over
 {@link InetAddress#toString()} when an IP address string literal is
 desired.  This is because {@link InetAddress#toString()} prints the
 hostname and the IP address string joined by a "/".

 @param ip {@link InetAddress} to be converted to URI string literal
 @return {@code String} containing URI-safe string literal]]>
      </doc>
    </method>
    <method name="forUriString" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostAddr" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an InetAddress representing the literal IPv4 or IPv6 host
 portion of a URL, encoded in the format specified by RFC 3986 section 3.2.2.

 <p>This function is similar to {@link InetAddresses#forString(String)},
 however, it requires that IPv6 addresses are surrounded by square brackets.

 <p>This function is the inverse of
 {@link InetAddresses#toUriString(java.net.InetAddress)}.

 @param hostAddr A RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address
 @return an InetAddress representing the address in {@code hostAddr}
 @throws IllegalArgumentException if {@code hostAddr} is not a valid
     IPv4 address, or IPv6 address surrounded by square brackets]]>
      </doc>
    </method>
    <method name="isUriInetAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the supplied string is a valid URI IP string
 literal, {@code false} otherwise.

 @param ipString {@code String} to evaluated as an IP URI host string literal
 @return {@code true} if the argument is a valid IP URI host]]>
      </doc>
    </method>
    <method name="isCompatIPv4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an IPv6 "compat" address.

 <p>An "IPv4 compatible", or "compat", address is one with 96 leading
 bits of zero, with the remaining 32 bits interpreted as an
 IPv4 address.  These are conventionally represented in string
 literals as {@code "::192.168.0.1"}, though {@code "::c0a8:1"} is
 also considered an IPv4 compatible address (and equivalent to
 {@code "::192.168.0.1"}).

 <p>For more on IPv4 compatible addresses see section 2.5.5.1 of
 <a target="_parent"
    href="http://tools.ietf.org/html/rfc4291#section-2.5.5.1"
    >http://tools.ietf.org/html/rfc4291</a>

 <p>NOTE: This method is different from
 {@link Inet6Address#isIPv4CompatibleAddress} in that it more
 correctly classifies {@code "::"} and {@code "::1"} as
 proper IPv6 addresses (which they are), NOT IPv4 compatible
 addresses (which they are generally NOT considered to be).

 @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format
 @return {@code true} if the argument is a valid "compat" address]]>
      </doc>
    </method>
    <method name="getCompatIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in an IPv4 compatible address.

 @param ip {@link Inet6Address} to be examined for an embedded IPv4 address
 @return {@link Inet4Address} of the embedded IPv4 address
 @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address]]>
      </doc>
    </method>
    <method name="is6to4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is a 6to4 address.

 <p>6to4 addresses begin with the {@code "2002::/16"} prefix.
 The next 32 bits are the IPv4 address of the host to which
 IPv6-in-IPv4 tunneled packets should be routed.

 <p>For more on 6to4 addresses see section 2 of
 <a target="_parent" href="http://tools.ietf.org/html/rfc3056#section-2"
    >http://tools.ietf.org/html/rfc3056</a>

 @param ip {@link Inet6Address} to be examined for 6to4 address format
 @return {@code true} if the argument is a 6to4 address]]>
      </doc>
    </method>
    <method name="get6to4IPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in a 6to4 address.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address
 @return {@link Inet4Address} of embedded IPv4 in 6to4 address
 @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address]]>
      </doc>
    </method>
    <method name="isTeredoAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is a Teredo address.

 <p>Teredo addresses begin with the {@code "2001::/32"} prefix.

 @param ip {@link Inet6Address} to be examined for Teredo address format
 @return {@code true} if the argument is a Teredo address]]>
      </doc>
    </method>
    <method name="getTeredoInfo" return="com.google.common.net.InetAddresses.TeredoInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the Teredo information embedded in a Teredo address.

 @param ip {@link Inet6Address} to be examined for embedded Teredo information
 @return extracted {@code TeredoInfo}
 @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address]]>
      </doc>
    </method>
    <method name="isIsatapAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an ISATAP address.

 <p>From RFC 5214: "ISATAP interface identifiers are constructed in
 Modified EUI-64 format [...] by concatenating the 24-bit IANA OUI
 (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit IPv4
 address in network byte order [...]"

 <p>For more on ISATAP addresses see section 6.1 of
 <a target="_parent" href="http://tools.ietf.org/html/rfc5214#section-6.1"
    >http://tools.ietf.org/html/rfc5214</a>

 @param ip {@link Inet6Address} to be examined for ISATAP address format
 @return {@code true} if the argument is an ISATAP address]]>
      </doc>
    </method>
    <method name="getIsatapIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in an ISATAP address.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address
 @return {@link Inet4Address} of embedded IPv4 in an ISATAP address
 @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address]]>
      </doc>
    </method>
    <method name="hasEmbeddedIPv4ClientAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Examines the Inet6Address to determine if it is an IPv6 address of one
 of the specified address types that contain an embedded IPv4 address.

 <p>NOTE: ISATAP addresses are explicitly excluded from this method
 due to their trivial spoofability.  With other transition addresses
 spoofing involves (at least) infection of one's BGP routing table.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 client address
 @return {@code true} if there is an embedded IPv4 client address
 @since 7.0]]>
      </doc>
    </method>
    <method name="getEmbeddedIPv4ClientAddress" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Examines the Inet6Address to extract the embedded IPv4 client address
 if the InetAddress is an IPv6 address of one of the specified address
 types that contain an embedded IPv4 address.

 <p>NOTE: ISATAP addresses are explicitly excluded from this method
 due to their trivial spoofability.  With other transition addresses
 spoofing involves (at least) infection of one's BGP routing table.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 client address
 @return {@link Inet4Address} of embedded IPv4 client address
 @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address]]>
      </doc>
    </method>
    <method name="isMappedIPv4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an "IPv4 mapped" IPv6 address.

 <p>An "IPv4 mapped" address is anything in the range ::ffff:0:0/96
 (sometimes written as ::ffff:0.0.0.0/96), with the last 32 bits
 interpreted as an IPv4 address.

 <p>For more on IPv4 mapped addresses see section 2.5.5.2 of
 <a target="_parent"
    href="http://tools.ietf.org/html/rfc4291#section-2.5.5.2"
    >http://tools.ietf.org/html/rfc4291</a>

 <p>Note: This method takes a {@code String} argument because
 {@link InetAddress} automatically collapses mapped addresses to IPv4.
 (It is actually possible to avoid this using one of the obscure
 {@link Inet6Address} methods, but it would be unwise to depend on such
 a poorly-documented feature.)

 @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format
 @return {@code true} if the argument is a valid "mapped" address
 @since 10.0]]>
      </doc>
    </method>
    <method name="getCoercedIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Coerces an IPv6 address into an IPv4 address.

 <p>HACK: As long as applications continue to use IPv4 addresses for
 indexing into tables, accounting, et cetera, it may be necessary to
 <b>coerce</b> IPv6 addresses into IPv4 addresses. This function does
 so by hashing the upper 64 bits into {@code 224.0.0.0/3}
 (64 bits into 29 bits).

 <p>A "coerced" IPv4 address is equivalent to itself.

 <p>NOTE: This function is failsafe for security purposes: ALL IPv6
 addresses (except localhost (::1)) are hashed to avoid the security
 risk associated with extracting an embedded IPv4 address that might
 permit elevated privileges.

 @param ip {@link InetAddress} to "coerce"
 @return {@link Inet4Address} represented "coerced" address
 @since 7.0]]>
      </doc>
    </method>
    <method name="coerceToInteger" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns an integer representing an IPv4 address regardless of
 whether the supplied argument is an IPv4 address or not.

 <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being
 converted to integers.

 <p>As long as there are applications that assume that all IP addresses
 are IPv4 addresses and can therefore be converted safely to integers
 (for whatever purpose) this function can be used to handle IPv6
 addresses as well until the application is suitably fixed.

 <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used
 for such purposes as rudimentary identification or indexing into a
 collection of real {@link InetAddress}es.  They cannot be used as
 real addresses for the purposes of network communication.

 @param ip {@link InetAddress} to convert
 @return {@code int}, "coerced" if ip is not an IPv4 address
 @since 7.0]]>
      </doc>
    </method>
    <method name="fromInteger" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="int"/>
      <doc>
      <![CDATA[Returns an Inet4Address having the integer value specified by
 the argument.

 @param address {@code int}, the 32bit integer address to be converted
 @return {@link Inet4Address} equivalent of the argument]]>
      </doc>
    </method>
    <method name="fromLittleEndianByteArray" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="byte[]"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns an address from a <b>little-endian ordered</b> byte array
 (the opposite of what {@link InetAddress#getByAddress} expects).

 <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array
 must be 16 bytes long.

 @param addr the raw IP address in little-endian byte order
 @return an InetAddress object created from the raw IP address
 @throws UnknownHostException if IP address is of illegal length]]>
      </doc>
    </method>
    <method name="increment" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns a new InetAddress that is one more than the passed in address.
 This method works for both IPv4 and IPv6 addresses.

 @param address the InetAddress to increment
 @return a new InetAddress that is one more than the passed in address
 @throws IllegalArgumentException if InetAddress is at the end of its range
 @since 10.0]]>
      </doc>
    </method>
    <method name="isMaximum" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns true if the InetAddress is either 255.255.255.255 for IPv4 or
 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.

 @return true if the InetAddress is either 255.255.255.255 for IPv4 or
     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6
 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link InetAddress} instances.

 <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the
 methods of this class never cause DNS services to be accessed. For
 this reason, you should prefer these methods as much as possible over
 their JDK equivalents whenever you are expecting to handle only
 IP address string literals -- there is no blocking DNS penalty for a
 malformed string.

 <p>When dealing with {@link Inet4Address} and {@link Inet6Address}
 objects as byte arrays (vis. {@code InetAddress.getAddress()}) they
 are 4 and 16 bytes in length, respectively, and represent the address
 in network byte order.

 <p>Examples of IP addresses and their byte representations:
 <ul>
 <li>The IPv4 loopback address, {@code "127.0.0.1"}.<br/>
     {@code 7f 00 00 01}

 <li>The IPv6 loopback address, {@code "::1"}.<br/>
     {@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}

 <li>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}),
     {@code "2001:db8::1"}.<br/>
     {@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}

 <li>An IPv6 "IPv4 compatible" (or "compat") address,
     {@code "::192.168.0.1"}.<br/>
     {@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}

 <li>An IPv6 "IPv4 mapped" address, {@code "::ffff:192.168.0.1"}.<br/>
     {@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}
 </ul>

 <p>A few notes about IPv6 "IPv4 mapped" addresses and their observed
 use in Java.
 <br><br>
 "IPv4 mapped" addresses were originally a representation of IPv4
 addresses for use on an IPv6 socket that could receive both IPv4
 and IPv6 connections (by disabling the {@code IPV6_V6ONLY} socket
 option on an IPv6 socket).  Yes, it's confusing.  Nevertheless,
 these "mapped" addresses were never supposed to be seen on the
 wire.  That assumption was dropped, some say mistakenly, in later
 RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.

 <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire
 format of a "mapped" address, as shown above, and transmit it in an
 IPv6 packet header.  However, Java's InetAddress creation methods
 appear to adhere doggedly to the original intent of the "mapped"
 address: all "mapped" addresses return {@link Inet4Address} objects.

 <p>For added safety, it is common for IPv6 network operators to filter
 all packets where either the source or destination address appears to
 be a "compat" or "mapped" address.  Filtering suggestions usually
 recommend discarding any packets with source or destination addresses
 in the invalid range {@code ::/3}, which includes both of these bizarre
 address formats.  For more information on "bogons", including lists
 of IPv6 bogon space, see:

 <ul>
 <li><a target="_parent"
        href="http://en.wikipedia.org/wiki/Bogon_filtering"
       >http://en.wikipedia.org/wiki/Bogon_filtering</a>
 <li><a target="_parent"
        href="http://www.cymru.com/Bogons/ipv6.txt"
       >http://www.cymru.com/Bogons/ipv6.txt</a>
 <li><a target="_parent"
        href="http://www.cymru.com/Bogons/v6bogon.html"
       >http://www.cymru.com/Bogons/v6bogon.html</a>
 <li><a target="_parent"
        href="http://www.space.net/~gert/RIPE/ipv6-filters.html"
       >http://www.space.net/~gert/RIPE/ipv6-filters.html</a>
 </ul>

 @author Erik Kline
 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InetAddresses -->
  <!-- start class com.google.common.net.InetAddresses.TeredoInfo -->
  <class name="InetAddresses.TeredoInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InetAddresses.TeredoInfo" type="java.net.Inet4Address, java.net.Inet4Address, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TeredoInfo instance.

 <p>Both server and client can be {@code null}, in which case the
 value {@code "0.0.0.0"} will be assumed.

 @throws IllegalArgumentException if either of the {@code port} or the {@code flags}
     arguments are out of range of an unsigned short]]>
      </doc>
    </constructor>
    <method name="getServer" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClient" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFlags" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simple immutable data class to encapsulate the information to be found in a
 Teredo address.

 <p>All of the fields in this class are encoded in various portions
 of the IPv6 address as part of the protocol.  More protocols details
 can be found at:
 <a target="_parent" href="http://en.wikipedia.org/wiki/Teredo_tunneling"
    >http://en.wikipedia.org/wiki/Teredo_tunneling</a>.

 <p>The RFC can be found here:
 <a target="_parent" href="http://tools.ietf.org/html/rfc4380"
    >http://tools.ietf.org/html/rfc4380</a>.

 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InetAddresses.TeredoInfo -->
  <!-- start class com.google.common.net.InternetDomainName -->
  <class name="InternetDomainName" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="fromLenient" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #from(String)}">
      <param name="domain" type="java.lang.String"/>
      <doc>
      <![CDATA[A deprecated synonym for {@link #from(String)}.

 @param domain A domain name (not IP address)
 @throws IllegalArgumentException if {@code name} is not syntactically valid
     according to {@link #isValidLenient}
 @since 8.0 (previously named {@code from})
 @deprecated Use {@link #from(String)}]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an instance of {@link InternetDomainName} after lenient
 validation.  Specifically, validation against <a
 href="http://www.ietf.org/rfc/rfc3490.txt">RFC 3490</a>
 ("Internationalizing Domain Names in Applications") is skipped, while
 validation against <a
 href="http://www.ietf.org/rfc/rfc1035.txt">RFC 1035</a> is relaxed in
 the following ways:
 <ul>
 <li>Any part containing non-ASCII characters is considered valid.
 <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.
 <li>Parts other than the final part may start with a digit.
 </ul>


 @param domain A domain name (not IP address)
 @throws IllegalArgumentException if {@code name} is not syntactically valid
     according to {@link #isValid}
 @since 10.0 (previously named {@code fromLenient})]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the domain name, normalized to all lower case.]]>
      </doc>
    </method>
    <method name="parts" return="com.google.common.collect.ImmutableList&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the individual components of this domain name, normalized to all
 lower case. For example, for the domain name {@code mail.google.com}, this
 method returns the list {@code ["mail", "google", "com"]}.]]>
      </doc>
    </method>
    <method name="isPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name represents a <i>public suffix</i>, as
 defined by the Mozilla Foundation's
 <a href="http://publicsuffix.org/">Public Suffix List</a> (PSL). A public
 suffix is one under which Internet users can directly register names, such
 as {@code com}, {@code co.uk} or {@code pvt.k12.wy.us}. Examples of domain
 names that are <i>not</i> public suffixes include {@code google}, {@code
 google.com} and {@code foo.co.uk}.

 @return {@code true} if this domain name appears exactly on the public
     suffix list
 @since 6.0]]>
      </doc>
    </method>
    <method name="hasPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isPublicSuffix()
 public suffix}, including if it is a public suffix itself. For example,
 returns {@code true} for {@code www.google.com}, {@code foo.co.uk} and
 {@code com}, but not for {@code google} or {@code google.foo}. This is
 the recommended method for determining whether a domain is potentially an
 addressable host.

 @since 6.0]]>
      </doc>
    </method>
    <method name="publicSuffix" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@linkplain #isPublicSuffix() public suffix} portion of the
 domain name, or {@code null} if no public suffix is present.

 @since 6.0]]>
      </doc>
    </method>
    <method name="isUnderPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isPublicSuffix()
 public suffix}, while not being a public suffix itself. For example,
 returns {@code true} for {@code www.google.com}, {@code foo.co.uk} and
 {@code bar.ca.us}, but not for {@code google}, {@code com}, or {@code
 google.foo}.

 <p><b>Warning:</b> a {@code false} result from this method does not imply
 that the domain does not represent an addressable host, as many public
 suffixes are also addressable hosts. Use {@link #hasPublicSuffix()} for
 that test.

 <p>This method can be used to determine whether it will probably be
 possible to set cookies on the domain, though even that depends on
 individual browsers' implementations of cookie controls. See
 <a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a> for details.

 @since 6.0]]>
      </doc>
    </method>
    <method name="isTopPrivateDomain" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name is composed of exactly one subdomain
 component followed by a {@linkplain #isPublicSuffix() public suffix}. For
 example, returns {@code true} for {@code google.com} and {@code foo.co.uk},
 but not for {@code www.google.com} or {@code co.uk}.

 <p><b>Warning:</b> A {@code true} result from this method does not imply
 that the domain is at the highest level which is addressable as a host, as
 many public suffixes are also addressable hosts. For example, the domain
 {@code bar.uk.com} has a public suffix of {@code uk.com}, so it would
 return {@code true} from this method. But {@code uk.com} is itself an
 addressable host.

 <p>This method can be used to determine whether a domain is probably the
 highest level for which cookies may be set, though even that depends on
 individual browsers' implementations of cookie controls. See
 <a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a> for details.

 @since 6.0]]>
      </doc>
    </method>
    <method name="topPrivateDomain" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the portion of this domain name that is one level beneath the
 public suffix. For example, for {@code x.adwords.google.co.uk} it returns
 {@code google.co.uk}, since {@code co.uk} is a public suffix.

 <p>If {@link #isTopPrivateDomain()} is true, the current domain name
 instance is returned.

 <p>This method should not be used to determine the topmost parent domain
 which is addressable as a host, as many public suffixes are also
 addressable hosts. For example, the domain {@code foo.bar.uk.com} has
 a public suffix of {@code uk.com}, so it would return {@code bar.uk.com}
 from this method. But {@code uk.com} is itself an addressable host.

 <p>This method can be used to determine the probable highest level parent
 domain for which cookies may be set, though even that depends on individual
 browsers' implementations of cookie controls.

 @throws IllegalStateException if this domain does not end with a
     public suffix
 @since 6.0]]>
      </doc>
    </method>
    <method name="hasParent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain is composed of two or more parts.]]>
      </doc>
    </method>
    <method name="parent" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code InternetDomainName} that is the immediate ancestor of
 this one; that is, the current domain with the leftmost part removed. For
 example, the parent of {@code www.google.com} is {@code google.com}.

 @throws IllegalStateException if the domain has no parent, as determined
     by {@link #hasParent}]]>
      </doc>
    </method>
    <method name="child" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leftParts" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates and returns a new {@code InternetDomainName} by prepending the
 argument and a dot to the current name. For example, {@code
 InternetDomainName.from("foo.com").child("www.bar")} returns a new
 {@code InternetDomainName} with the value {@code www.bar.foo.com}. Only
 lenient validation is performed, as described {@link #from(String) here}.

 @throws NullPointerException if leftParts is null
 @throws IllegalArgumentException if the resulting name is not valid]]>
      </doc>
    </method>
    <method name="isValidLenient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #isValid(String)} instead">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[A deprecated synonym for {@link #isValid(String)}.

 @since 8.0 (previously named {@code isValid})
 @deprecated Use {@link #isValid(String)} instead]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Indicates whether the argument is a syntactically valid domain name using
 lenient validation. Specifically, validation against <a
 href="http://www.ietf.org/rfc/rfc3490.txt">RFC 3490</a>
 ("Internationalizing Domain Names in Applications") is skipped.

 <p>The following two code snippets are equivalent:

 <pre>   {@code

   domainName = InternetDomainName.isValid(name)
       ? InternetDomainName.from(name)
       : DEFAULT_DOMAIN;
   }</pre>

 <pre>   {@code

   try {
     domainName = InternetDomainName.from(name);
   } catch (IllegalArgumentException e) {
     domainName = DEFAULT_DOMAIN;
   }}</pre>

 @since 8.0 (previously named {@code isValidLenient})]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Equality testing is based on the text supplied by the caller,
 after normalization as described in the class documentation. For
 example, a non-ASCII Unicode domain name and the Punycode version
 of the same domain name would not be considered equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable well-formed internet domain name, such as {@code com} or {@code
 foo.co.uk}. Only syntactic analysis is performed; no DNS lookups or other
 network interactions take place. Thus there is no guarantee that the domain
 actually exists on the internet.

 <p>One common use of this class is to determine whether a given string is
 likely to represent an addressable domain on the web -- that is, for a
 candidate string {@code "xxx"}, might browsing to {@code "http://xxx/"}
 result in a webpage being displayed? In the past, this test was frequently
 done by determining whether the domain ended with a {@linkplain
 #isPublicSuffix() public suffix} but was not itself a public suffix. However,
 this test is no longer accurate. There are many domains which are both public
 suffixes and addressable as hosts; {@code "uk.com"} is one example. As a
 result, the only useful test to determine if a domain is a plausible web host
 is {@link #hasPublicSuffix()}. This will return {@code true} for many domains
 which (currently) are not hosts, such as {@code "com"}), but given that any
 public suffix may become a host without warning, it is better to err on the
 side of permissiveness and thus avoid spurious rejection of valid sites.

 <p>During construction, names are normalized in two ways:
 <ol>
 <li>ASCII uppercase characters are converted to lowercase.
 <li>Unicode dot separators other than the ASCII period ({@code '.'}) are
 converted to the ASCII period.
 </ol>
 The normalized values will be returned from {@link #name()} and
 {@link #parts()}, and will be reflected in the result of
 {@link #equals(Object)}.

 <p><a href="http://en.wikipedia.org/wiki/Internationalized_domain_name">
 internationalized domain names</a> such as {@code .cn} are supported, as
 are the equivalent <a
 href="http://en.wikipedia.org/wiki/Internationalized_domain_name">IDNA
 Punycode-encoded</a> versions.

 @author Craig Berry
 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InternetDomainName -->
  <!-- start class com.google.common.net.MediaType -->
  <class name="MediaType" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="type" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the top-level media type.  For example, {@code "text"} in {@code "text/plain"}.]]>
      </doc>
    </method>
    <method name="subtype" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the media subtype.  For example, {@code "plain"} in {@code "text/plain"}.]]>
      </doc>
    </method>
    <method name="parameters" return="com.google.common.collect.ImmutableListMultimap&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a multimap containing the parameters of this media type.]]>
      </doc>
    </method>
    <method name="charset" return="com.google.common.base.Optional&lt;java.nio.charset.Charset&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an optional charset for the value of the charset parameter if it is specified.

 @throws IllegalStateException if multiple charset values have been set for this media type
 @throws IllegalCharsetNameException if a charset value is present, but illegal
 @throws UnsupportedCharsetException if a charset value is present, but no support is available
     in this instance of the Java virtual machine]]>
      </doc>
    </method>
    <method name="withoutParameters" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance with the same type and subtype as this instance, but without any
 parameters.]]>
      </doc>
    </method>
    <method name="withParameters" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="com.google.common.collect.Multimap&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[<em>Replaces</em> all parameters with the given parameters.

 @throws IllegalArgumentException if any parameter or value is invalid]]>
      </doc>
    </method>
    <method name="withParameter" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[<em>Replaces</em> all parameters with the given attribute with a single parameter with the
 given value. If multiple parameters with the same attributes are necessary use
 {@link #withParameters}. Prefer {@link #withCharset} for setting the {@code charset} parameter
 when using a {@link Charset} object.

 @throws IllegalArgumentException if either {@code attribute} or {@code value} is invalid]]>
      </doc>
    </method>
    <method name="withCharset" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a new instance with the same type and subtype as this instance, with the
 {@code charset} parameter set to the {@link Charset#name name} of the given charset. Only one
 {@code charset} parameter will be present on the new instance regardless of the number set on
 this one.

 <p>If a charset must be specified that is not supported on this JVM (and thus is not
 representable as a {@link Charset} instance, use {@link #withParameter}.]]>
      </doc>
    </method>
    <method name="hasWildcard" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if either the type or subtype is the wildcard.]]>
      </doc>
    </method>
    <method name="is" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mediaTypeRange" type="com.google.common.net.MediaType"/>
      <doc>
      <![CDATA[Returns {@code true} if this instance falls within the range (as defined by
 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">the HTTP Accept header</a>)
 given by the argument according to three criteria:

 <ol>
 <li>The type of the argument is the wildcard or equal to the type of this instance.
 <li>The subtype of the argument is the wildcard or equal to the subtype of this instance.
 <li>All of the parameters present in the argument are present in this instance.
 </ol>

 For example: <pre>   {@code
   PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8) // true
   PLAIN_TEXT_UTF_8.is(HTML_UTF_8) // false
   PLAIN_TEXT_UTF_8.is(ANY_TYPE) // true
   PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE) // true
   PLAIN_TEXT_UTF_8.is(ANY_IMAGE_TYPE) // false
   PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_8)) // true
   PLAIN_TEXT_UTF_8.withoutParameters().is(ANY_TEXT_TYPE.withCharset(UTF_8)) // false
   PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_16)) // false}</pre>

 <p>Note that while it is possible to have the same parameter declared multiple times within a
 media type this method does not consider the number of occurrences of a parameter.  For
 example, {@code "text/plain; charset=UTF-8"} satisfies
 {@code "text/plain; charset=UTF-8; charset=UTF-8"}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <param name="subtype" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new media type with the given type and subtype.

 @throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the
 type, but not the subtype.]]>
      </doc>
    </method>
    <method name="parse" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses a media type from its string representation.

 @throws IllegalArgumentException if the input is not parsable]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the string representation of this media type in the format described in <a
 href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.]]>
      </doc>
    </method>
    <field name="ANY_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_TEXT_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_IMAGE_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_AUDIO_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_VIDEO_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_APPLICATION_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CACHE_MANIFEST_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CSS_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CSV_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HTML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="I_CALENDAR_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PLAIN_TEXT_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TEXT_JAVASCRIPT_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://www.rfc-editor.org/rfc/rfc4329.txt">RFC 4329</a> declares
 {@link #JAVASCRIPT_UTF_8 application/javascript} to be the correct media type for JavaScript,
 but this may be necessary in certain situations for compatibility.]]>
      </doc>
    </field>
    <field name="VCARD_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="XML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BMP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GIF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ICO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JPEG" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PNG" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SVG_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TIFF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WEBP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MP4_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MPEG_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OGG_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WEBM_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MP4_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MPEG_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OGG_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="QUICKTIME" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WEBM_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WMV" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATOM_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BZIP2" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FORM_DATA" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GZIP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVASCRIPT_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://www.rfc-editor.org/rfc/rfc4329.txt">RFC 4329</a> declares this to be the
 correct media type for JavaScript, but {@link #TEXT_JAVASCRIPT_UTF_8 text/javascript} may be
 necessary in certain situations for compatibility.]]>
      </doc>
    </field>
    <field name="JSON_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KML" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KMZ" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MBOX" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MICROSOFT_EXCEL" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MICROSOFT_POWERPOINT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MICROSOFT_WORD" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OCTET_STREAM" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OGG_CONTAINER" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OOXML_DOCUMENT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OOXML_PRESENTATION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OOXML_SHEET" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_GRAPHICS" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_PRESENTATION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_SPREADSHEET" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_TEXT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PDF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POSTSCRIPT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RTF_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHOCKWAVE_FLASH" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SKETCHUP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TAR" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="XHTML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ZIP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents an <a href="http://en.wikipedia.org/wiki/Internet_media_type">Internet Media Type</a>
 (also known as a MIME Type or Content Type). This class also supports the concept of media ranges
 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1">defined by HTTP/1.1</a>.
 As such, the {@code *} character is treated as a wildcard and is used to represent any acceptable
 type or subtype value. A media type may not have wildcard type with a declared subtype. The
 {@code *} character has no special meaning as part of a parameter. All values for type, subtype,
 parameter attributes or parameter values must be valid according to RFCs
 <a href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and
 <a href="http://www.ietf.org/rfc/rfc2046.txt">2046</a>.

 <p>All portions of the media type that are case-insensitive (type, subtype, parameter attributes)
 are normalized to lowercase. The value of the {@code charset} parameter is normalized to
 lowercase, but all others are left as-is.

 <p>Note that this specifically does <strong>not</strong> represent the value of the MIME
 {@code Content-Type} header and as such has no support for header-specific considerations such as
 line folding and comments.

 <p>For media types that take a charset the predefined constants default to UTF-8 and have a
 "_UTF_8" suffix. To get a version without a character set, use {@link #withoutParameters}.

 @since 12.0

 @author Gregory Kick]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.MediaType -->
</package>
<package name="com.google.common.primitives">
  <!-- start class com.google.common.primitives.Booleans -->
  <class name="Booleans" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Boolean) value).hashCode()}.

 @param value a primitive {@code boolean} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="boolean"/>
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Compares the two specified {@code boolean} values in the standard way
 ({@code false} is considered less than {@code true}). The sign of the
 value returned is the same as that of {@code ((Boolean) a).compareTo(b)}.

 @param a the first {@code boolean} to compare
 @param b the second {@code boolean} to compare
 @return a positive number if only {@code a} is {@code true}, a negative
     number if only {@code b} is true, or zero if {@code a == b}]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link
 BitSet} instead, replacing {@code Booleans.contains(array, true)}
 with {@code !bitSet.isEmpty()} and {@code Booleans.contains(array, false)}
 with {@code bitSet.nextClearBit(0) == sizeOfBitSet}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link BitSet}
 instead, and using {@link BitSet#nextSetBit(int)} or {@link
 BitSet#nextClearBit(int)}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="boolean[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new boolean[] {a, b}, new boolean[] {}, new
 boolean[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code boolean} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code boolean} values separated
 by {@code separator}. For example, {@code join("-", false, true, false)}
 returns the string {@code "false-true-false"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code boolean} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;boolean[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code boolean} arrays
 lexicographically. That is, it compares, using {@link
 #compare(boolean, boolean)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < [false] < [false, true] < [true]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(boolean[], boolean[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Boolean} instances into a new array of
 primitive {@code boolean} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 <p><b>Note:</b> consider representing the collection as a {@link
 BitSet} instead.

 @param collection a collection of {@code Boolean} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Boolean} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code boolean} primitives, that are not
 already found in either {@link Boolean} or {@link Arrays}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Booleans -->
  <!-- start class com.google.common.primitives.Bytes -->
  <class name="Bytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Byte) value).hashCode()}.

 @param value a primitive {@code byte} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="byte[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new byte[] {a, b}, new byte[] {}, new
 byte[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code byte} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="toArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to
 a {@code byte} value in the manner of {@link Number#byteValue}.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null
 @since 1.0 (parameter was {@code Collection<Byte>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Byte&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="byte[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Byte} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives, that are not
 already found in either {@link Byte} or {@link Arrays}, <i>and interpret
 bytes as neither signed nor unsigned</i>. The methods which specifically
 treat bytes as signed or unsigned are found in {@link SignedBytes} and {@link
 UnsignedBytes}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Bytes -->
  <!-- start class com.google.common.primitives.Chars -->
  <class name="Chars" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Character) value).hashCode()}.

 @param value a primitive {@code char} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code char} type
 @return the {@code char} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Character#MAX_VALUE} or less than {@link Character#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code char} if it is in the range of the
     {@code char} type, {@link Character#MAX_VALUE} if it is too large,
     or {@link Character#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="char"/>
      <param name="b" type="char"/>
      <doc>
      <![CDATA[Compares the two specified {@code char} values. The sign of the value
 returned is the same as that of {@code ((Character) a).compareTo(b)}.

 @param a the first {@code char} to compare
 @param b the second {@code char} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="char[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new char[] {a, b}, new char[] {}, new
 char[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code char} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 2-element byte
 array; equivalent to {@code
 ByteBuffer.allocate(2).putChar(value).array()}.  For example, the input
 value {@code '\\u5432'} would yield the byte array {@code {0x54, 0x32}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code char} value whose big-endian representation is
 stored in the first 2 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getChar()}. For example, the input byte array
 {@code {0x54, 0x32}} would yield the {@code char} value {@code '\\u5432'}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 2
     elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code char} value whose byte representation is the given 2
 bytes, in big-endian order; equivalent to {@code Chars.fromByteArray(new
 byte[] {b1, b2})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code char} values separated
 by {@code separator}. For example, {@code join("-", '1', '2', '3')} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code char} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;char[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code char} arrays
 lexicographically. That is, it compares, using {@link
 #compare(char, char)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < ['a'] < ['a', 'b'] < ['b']}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(char[], char[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Character&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Character} instances into a new array of
 primitive {@code char} values.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Character} objects
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="char[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Character} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code char}
 value.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code char} primitives, that are not
 already found in either {@link Character} or {@link Arrays}.

 <p>All the operations in this class treat {@code char} values strictly
 numerically; they are neither Unicode-aware nor locale-dependent.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Chars -->
  <!-- start class com.google.common.primitives.Doubles -->
  <class name="Doubles" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Double) value).hashCode()}.

 @param value a primitive {@code double} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <doc>
      <![CDATA[Compares the two specified {@code double} values. The sign of the value
 returned is the same as that of <code>((Double) a).{@linkplain
 Double#compareTo compareTo}(b)</code>. As with that method, {@code NaN} is
 treated as greater than all other values, and {@code 0.0 > -0.0}.

 @param a the first {@code double} to compare
 @param b the second {@code double} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="isFinite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code value} represents a real number. This is
 equivalent to, but not necessarily implemented as,
 {@code !(Double.isInfinite(value) || Double.isNaN(value))}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}. Note that this always returns {@code false} when {@code
 target} is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains
 {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of
 comparison as {@link Math#min(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules
 of comparison as {@link Math#max(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="double[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new double[] {a, b}, new double[] {}, new
 double[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code double} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code double} values, converted
 to strings as specified by {@link Double#toString(double)}, and separated
 by {@code separator}. For example, {@code join("-", 1.0, 2.0, 3.0)} returns
 the string {@code "1.0-2.0-3.0"}.

 <p>Note that {@link Double#toString(double)} formats {@code double}
 differently in GWT sometimes.  In the previous example, it returns the
 string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code double} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;double[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code double} arrays
 lexicographically. That is, it compares, using {@link
 #compare(double, double)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < [1.0] < [1.0, 2.0] < [2.0]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(double[], double[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to
 a {@code double} value in the manner of {@link Number#doubleValue}.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null
 @since 1.0 (parameter was {@code Collection<Double>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="double[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Double} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code
 NaN}, or if {@code NaN} is used as a parameter to any of its methods.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code double}
 value.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code double} primitives, that are not
 already found in either {@link Double} or {@link Arrays}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Doubles -->
  <!-- start class com.google.common.primitives.Floats -->
  <class name="Floats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Float) value).hashCode()}.

 @param value a primitive {@code float} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="float"/>
      <param name="b" type="float"/>
      <doc>
      <![CDATA[Compares the two specified {@code float} values using {@link
 Float#compare(float, float)}. You may prefer to invoke that method
 directly; this method exists only for consistency with the other utilities
 in this package.

 @param a the first {@code float} to compare
 @param b the second {@code float} to compare
 @return the result of invoking {@link Float#compare(float, float)}]]>
      </doc>
    </method>
    <method name="isFinite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code value} represents a real number. This is
 equivalent to, but not necessarily implemented as,
 {@code !(Float.isInfinite(value) || Float.isNaN(value))}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}. Note that this always returns {@code false} when {@code
 target} is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains
 {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}. Note that this always returns {@code -1} when {@code target}
 is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of
 comparison as {@link Math#min(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules
 of comparison as {@link Math#min(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="float[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new float[] {a, b}, new float[] {}, new
 float[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code float} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code float} values, converted
 to strings as specified by {@link Float#toString(float)}, and separated by
 {@code separator}. For example, {@code join("-", 1.0f, 2.0f, 3.0f)}
 returns the string {@code "1.0-2.0-3.0"}.

 <p>Note that {@link Float#toString(float)} formats {@code float}
 differently in GWT.  In the previous example, it returns the string {@code
 "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code float} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;float[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code float} arrays
 lexicographically. That is, it compares, using {@link
 #compare(float, float)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example, {@code [] < [1.0f] < [1.0f, 2.0f]
 < [2.0f]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(float[], float[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to
 a {@code float} value in the manner of {@link Number#floatValue}.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null
 @since 1.0 (parameter was {@code Collection<Float>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Float&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="float[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Float} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code
 NaN}, or if {@code NaN} is used as a parameter to any of its methods.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code float}
 value.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code float} primitives, that are not
 already found in either {@link Float} or {@link Arrays}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Floats -->
  <!-- start class com.google.common.primitives.Ints -->
  <class name="Ints" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Integer) value).hashCode()}.

 @param value a primitive {@code int} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code int} type
 @return the {@code int} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code int} if it is in the range of the
     {@code int} type, {@link Integer#MAX_VALUE} if it is too large,
     or {@link Integer#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Compares the two specified {@code int} values. The sign of the value
 returned is the same as that of {@code ((Integer) a).compareTo(b)}.

 @param a the first {@code int} to compare
 @param b the second {@code int} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="int[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new int[] {a, b}, new int[] {}, new
 int[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code int} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 4-element byte
 array; equivalent to {@code ByteBuffer.allocate(4).putInt(value).array()}.
 For example, the input value {@code 0x12131415} would yield the byte array
 {@code {0x12, 0x13, 0x14, 0x15}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code int} value whose big-endian representation is stored in
 the first 4 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getInt()}. For example, the input byte array {@code
 {0x12, 0x13, 0x14, 0x15, 0x33}} would yield the {@code int} value {@code
 0x12131415}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 4 elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <param name="b3" type="byte"/>
      <param name="b4" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code int} value whose byte representation is the given 4
 bytes, in big-endian order; equivalent to {@code Ints.fromByteArray(new
 byte[] {b1, b2, b3, b4})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code int} values separated
 by {@code separator}. For example, {@code join("-", 1, 2, 3)} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code int} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;int[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code int} arrays
 lexicographically. That is, it compares, using {@link
 #compare(int, int)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example, {@code [] < [1] < [1, 2] < [2]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(int[], int[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to
 a {@code int} value in the manner of {@link Number#intValue}.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null
 @since 1.0 (parameter was {@code Collection<Integer>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="int[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Integer} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <method name="tryParse" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the specified string as a signed decimal integer value. The ASCII
 character {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the
 minus sign.

 <p>Unlike {@link Integer#parseInt(String)}, this method returns
 {@code null} instead of throwing an exception if parsing fails.

 <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even
 under JDK 7, despite the change to {@link Integer#parseInt(String)} for
 that version.

 @param string the string representation of an integer value
 @return the integer value represented by {@code string}, or {@code null} if
     {@code string} has a length of zero or cannot be parsed as an integer
     value
 @since 11.0]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code int}
 value.]]>
      </doc>
    </field>
    <field name="MAX_POWER_OF_TWO" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as an {@code int}.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code int} primitives, that are not
 already found in either {@link Integer} or {@link Arrays}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Ints -->
  <!-- start class com.google.common.primitives.Longs -->
  <class name="Longs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Long) value).hashCode()}.

 <p>This method always return the value specified by {@link
 Long#hashCode()} in java, which might be different from
 {@code ((Long) value).hashCode()} in GWT because {@link Long#hashCode()}
 in GWT does not obey the JRE contract.

 @param value a primitive {@code long} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Compares the two specified {@code long} values. The sign of the value
 returned is the same as that of {@code ((Long) a).compareTo(b)}.

 @param a the first {@code long} to compare
 @param b the second {@code long} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="long[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new long[] {a, b}, new long[] {}, new
 long[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code long} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in an 8-element byte
 array; equivalent to {@code ByteBuffer.allocate(8).putLong(value).array()}.
 For example, the input value {@code 0x1213141516171819L} would yield the
 byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code long} value whose big-endian representation is
 stored in the first 8 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getLong()}. For example, the input byte array
 {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}} would yield the
 {@code long} value {@code 0x1213141516171819L}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 8
     elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <param name="b3" type="byte"/>
      <param name="b4" type="byte"/>
      <param name="b5" type="byte"/>
      <param name="b6" type="byte"/>
      <param name="b7" type="byte"/>
      <param name="b8" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code long} value whose byte representation is the given 8
 bytes, in big-endian order; equivalent to {@code Longs.fromByteArray(new
 byte[] {b1, b2, b3, b4, b5, b6, b7, b8})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code long} values separated
 by {@code separator}. For example, {@code join("-", 1L, 2L, 3L)} returns
 the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code long} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;long[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code long} arrays
 lexicographically. That is, it compares, using {@link
 #compare(long, long)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example,
 {@code [] < [1L] < [1L, 2L] < [2L]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(long[], long[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to
 a {@code long} value in the manner of {@link Number#longValue}.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null
 @since 1.0 (parameter was {@code Collection<Long>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="long[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Long} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code long}
 value.]]>
      </doc>
    </field>
    <field name="MAX_POWER_OF_TWO" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as a {@code long}.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code long} primitives, that are not
 already found in either {@link Long} or {@link Arrays}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Longs -->
  <!-- start class com.google.common.primitives.Primitives -->
  <class name="Primitives" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="allPrimitiveTypes" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of all nine primitive types (including {@code
 void}). Note that a simpler way to test whether a {@code Class} instance
 is a member of this set is to call {@link Class#isPrimitive}.

 @since 3.0]]>
      </doc>
    </method>
    <method name="allWrapperTypes" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of all nine primitive-wrapper types (including
 {@link Void}).

 @since 3.0]]>
      </doc>
    </method>
    <method name="isWrapperType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code type} is one of the nine
 primitive-wrapper types, such as {@link Integer}.

 @see Class#isPrimitive]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding wrapper type of {@code type} if it is a primitive
 type; otherwise returns {@code type} itself. Idempotent.
 <pre>
     wrap(int.class) == Integer.class
     wrap(Integer.class) == Integer.class
     wrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <method name="unwrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding primitive type of {@code type} if it is a
 wrapper type; otherwise returns {@code type} itself. Idempotent.
 <pre>
     unwrap(Integer.class) == int.class
     unwrap(int.class) == int.class
     unwrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static utility methods pertaining to primitive types and their
 corresponding wrapper types.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Primitives -->
  <!-- start class com.google.common.primitives.Shorts -->
  <class name="Shorts" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; equal to the result of invoking
 {@code ((Short) value).hashCode()}.

 @param value a primitive {@code short} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} value that is equal to {@code value}, if
 possible.

 @param value any value in the range of the {@code short} type
 @return the {@code short} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Short#MAX_VALUE} or less than {@link Short#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code short} if it is in the range of the
     {@code short} type, {@link Short#MAX_VALUE} if it is too large,
     or {@link Short#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="short"/>
      <param name="b" type="short"/>
      <doc>
      <![CDATA[Compares the two specified {@code short} values. The sign of the value
 returned is the same as that of {@code ((Short) a).compareTo(b)}.

 @param a the first {@code short} to compare
 @param b the second {@code short} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return {@code true} if {@code array[i] == target} for some value of {@code
     i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the least index {@code i} for which {@code array[i] == target}, or
     {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code
 target} within {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code
 java.util.Arrays.copyOfRange(array, i, i + target.length)} contains exactly
 the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in
 {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the greatest index {@code i} for which {@code array[i] == target},
     or {@code -1} if no such index exists.]]>
      </doc>
    </method>
    <method name="min" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="concat" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="short[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array.
 For example, {@code concat(new short[] {a, b}, new short[] {}, new
 short[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code short} arrays
 @return a single array containing all the values from the source arrays, in
     order]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 2-element byte
 array; equivalent to {@code
 ByteBuffer.allocate(2).putShort(value).array()}.  For example, the input
 value {@code (short) 0x1234} would yield the byte array {@code {0x12,
 0x34}}.

 <p>If you need to convert and concatenate several values (possibly even of
 different types), use a shared {@link java.nio.ByteBuffer} instance, or use
 {@link com.google.common.io.ByteStreams#newDataOutput()} to get a growable
 buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code short} value whose big-endian representation is
 stored in the first 2 bytes of {@code bytes}; equivalent to {@code
 ByteBuffer.wrap(bytes).getShort()}. For example, the input byte array
 {@code {0x54, 0x32}} would yield the {@code short} value {@code 0x5432}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that
 library exposes much more flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 2
     elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code short} value whose byte representation is the given 2
 bytes, in big-endian order; equivalent to {@code Shorts.fromByteArray(new
 byte[] {b1, b2})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but
 guaranteed to be of a specified minimum length. If {@code array} already
 has a length of at least {@code minLength}, it is returned directly.
 Otherwise, a new array of size {@code minLength + padding} is returned,
 containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is
     necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is
     negative
 @return an array containing the values of {@code array}, with guaranteed
     minimum length {@code minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code short} values separated
 by {@code separator}. For example, {@code join("-", (short) 1, (short) 2,
 (short) 3)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code short} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;short[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code short} arrays
 lexicographically. That is, it compares, using {@link
 #compare(short, short)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example, {@code [] < [(short) 1] <
 [(short) 1, (short) 2] < [(short) 2]}.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link Arrays#equals(short[], short[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to
 a {@code short} value in the manner of {@link Number#shortValue}.

 <p>Elements are copied from the argument collection as if by {@code
 collection.toArray()}.  Calling this method is as thread-safe as calling
 that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the
     same order, converted to primitives
 @throws NullPointerException if {@code collection} or any of its elements
     is null
 @since 1.0 (parameter was {@code Collection<Short>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Short&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="short[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)},
 but any attempt to set a value to {@code null} will result in a {@link
 NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of
 {@code Short} objects written to or read from it.  For example, whether
 {@code list.get(0) == list.get(0)} is true for the returned list is
 unspecified.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code short}
 value.]]>
      </doc>
    </field>
    <field name="MAX_POWER_OF_TWO" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as a {@code short}.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code short} primitives, that are not
 already found in either {@link Short} or {@link Arrays}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Shorts -->
  <!-- start class com.google.common.primitives.SignedBytes -->
  <class name="SignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code byte} type
 @return the {@code byte} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link
     Byte#MAX_VALUE} or less than {@link Byte#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code byte} if it is in the range of the
     {@code byte} type, {@link Byte#MAX_VALUE} if it is too large,
     or {@link Byte#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values. The sign of the value
 returned is the same as that of {@code ((Byte) a).compareTo(b)}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated
 by {@code separator}. For example, {@code join(":", 0x01, 0x02, -0x01)}
 returns the string {@code "1:2:-1"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code byte} arrays
 lexicographically. That is, it compares, using {@link
 #compare(byte, byte)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter
 array as the lesser. For example, {@code [] < [0x01] < [0x01, 0x80] <
 [0x01, 0x7F] < [0x02]}. Values are treated as signed.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link java.util.Arrays#equals(byte[], byte[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <field name="MAX_POWER_OF_TWO" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as a signed {@code byte}. 

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that
 interpret values as signed. The corresponding methods that treat the values
 as unsigned are found in {@link UnsignedBytes}, and the methods for which
 signedness is not an issue are in {@link Bytes}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.SignedBytes -->
  <!-- start class com.google.common.primitives.UnsignedBytes -->
  <class name="UnsignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Returns the value of the given byte as an integer, when treated as
 unsigned. That is, returns {@code value + 256} if {@code value} is
 negative; {@code value} itself otherwise.

 @since 6.0]]>
      </doc>
    </method>
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is equal to
 {@code value}, if possible.

 @param value a value between 0 and 255 inclusive
 @return the {@code byte} value that, when treated as unsigned, equals
     {@code value}
 @throws IllegalArgumentException if {@code value} is negative or greater
     than 255]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is nearest
 in value to {@code value}.

 @param value any {@code long} value
 @return {@code (byte) 255} if {@code value >= 255}, {@code (byte) 0} if
     {@code value <= 0}, and {@code value} cast to {@code byte} otherwise]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values, treating them as unsigned
 values between 0 and 255 inclusive. For example, {@code (byte) -127} is
 considered greater than {@code (byte) 127} because it is seen as having
 the value of positive {@code 129}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive
     value if {@code a} is greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to
     every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal
     to every other value in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="byte"/>
      <doc>
      <![CDATA[Returns a string representation of x, where x is treated as unsigned.

 @since 13.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="byte"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of {@code x} for the given radix, where {@code x} is treated
 as unsigned.

 @param x the value to convert to a string.
 @param radix the radix to use while working with {@code x}
 @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}
         and {@link Character#MAX_RADIX}.
 @since 13.0]]>
      </doc>
    </method>
    <method name="parseUnsignedByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code byte} value represented by the given decimal string.

 @throws NumberFormatException if the string does not contain a valid unsigned {@code long}
         value
 @since 13.0]]>
      </doc>
    </method>
    <method name="parseUnsignedByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns the unsigned {@code byte} value represented by a string with the given radix.

 @param string the string containing the unsigned {@code byte} representation to be parsed.
 @param radix the radix to use while parsing {@code string}
 @throws NumberFormatException if the string does not contain a valid unsigned {@code byte}
         with the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX}
         and {@link Character#MAX_RADIX}.
 @since 13.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated by
 {@code separator}. For example, {@code join(":", (byte) 1, (byte) 2,
 (byte) 255)} returns the string {@code "1:2:255"}.

 @param separator the text that should appear between consecutive values in
     the resulting string (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code byte} arrays
 lexicographically. That is, it compares, using {@link
 #compare(byte, byte)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter
 array as the lesser. For example, {@code [] < [0x01] < [0x01, 0x7F] <
 [0x01, 0x80] < [0x02]}. Values are treated as unsigned.

 <p>The returned comparator is inconsistent with {@link
 Object#equals(Object)} (since arrays support only identity equality), but
 it is consistent with {@link java.util.Arrays#equals(byte[], byte[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
     Lexicographical order article at Wikipedia</a>
 @since 2.0]]>
      </doc>
    </method>
    <field name="MAX_POWER_OF_TWO" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as an unsigned {@code
 byte}.

 @since 10.0]]>
      </doc>
    </field>
    <field name="MAX_VALUE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest value that fits into an unsigned byte.

 @since 13.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that interpret
 values as <i>unsigned</i> (that is, any negative value {@code b} is treated
 as the positive value {@code 256 + b}). The corresponding methods that treat
 the values as signed are found in {@link SignedBytes}, and the methods for
 which signedness is not an issue are in {@link Bytes}.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained">
 primitive utilities</a>.

 @author Kevin Bourrillion
 @author Martin Buchholz
 @author Hiroshi Yamauchi
 @author Louis Wasserman
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedBytes -->
  <!-- start class com.google.common.primitives.UnsignedInteger -->
  <class name="UnsignedInteger" extends="java.lang.Number"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable&lt;com.google.common.primitives.UnsignedInteger&gt;"/>
    <method name="asUnsigned" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} that, when treated as signed, is
 equal to {@code value}.]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} that is equal to {@code value},
 if possible.  The inverse operation of {@link #longValue()}.]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns a {@code UnsignedInteger} representing the same value as the specified
 {@link BigInteger}. This is the inverse operation of {@link #bigIntegerValue()}.
 
 @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^32}]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} holding the value of the specified {@code String}, parsed
 as an unsigned {@code int} value.
 
 @throws NumberFormatException if the string does not contain a parsable unsigned {@code int}
         value]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} holding the value of the specified {@code String}, parsed
 as an unsigned {@code int} value in the specified radix.
 
 @throws NumberFormatException if the string does not contain a parsable unsigned {@code int}
         value]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of adding this and {@code val}. If the result would have more than 32 bits,
 returns the low 32 bits of the result.]]>
      </doc>
    </method>
    <method name="subtract" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of subtracting this and {@code val}. If the result would be negative,
 returns the low 32 bits of the result.]]>
      </doc>
    </method>
    <method name="multiply" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of multiplying this and {@code val}. If the result would have more than 32
 bits, returns the low 32 bits of the result.]]>
      </doc>
    </method>
    <method name="divide" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of dividing this by {@code val}.]]>
      </doc>
    </method>
    <method name="remainder" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the remainder of dividing this by {@code val}.]]>
      </doc>
    </method>
    <method name="intValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as an {@code int}. This is an inverse
 operation to {@link #asUnsigned}.
 
 <p>Note that if this {@code UnsignedInteger} holds a value {@code >= 2^31}, the returned value
 will be equal to {@code this - 2^32}.]]>
      </doc>
    </method>
    <method name="longValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@code long}.]]>
      </doc>
    </method>
    <method name="floatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@code float}, analogous to a widening
 primitive conversion from {@code int} to {@code float}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="doubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@code float}, analogous to a widening
 primitive conversion from {@code int} to {@code double}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="bigIntegerValue" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@link BigInteger}.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Compares this unsigned integer to another unsigned integer.
 Returns {@code 0} if they are equal, a negative number if {@code this < other},
 and a positive number if {@code this > other}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedInteger} value, in base 10.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedInteger} value, in base {@code radix}.
 If {@code radix < Character.MIN_RADIX} or {@code radix > Character.MAX_RADIX}, the radix
 {@code 10} is used.]]>
      </doc>
    </method>
    <field name="ZERO" type="com.google.common.primitives.UnsignedInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ONE" type="com.google.common.primitives.UnsignedInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_VALUE" type="com.google.common.primitives.UnsignedInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A wrapper class for unsigned {@code int} values, supporting arithmetic operations.
 
 <p>In some cases, when speed is more important than code readability, it may be faster simply to
 treat primitive {@code int} values as unsigned, using the methods from {@link UnsignedInts}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained#Unsigned_support">
 unsigned primitive utilities</a>.
 
 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedInteger -->
  <!-- start class com.google.common.primitives.UnsignedInts -->
  <class name="UnsignedInts" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Compares the two specified {@code int} values, treating them as unsigned values between
 {@code 0} and {@code 2^32 - 1} inclusive.

 @param a the first unsigned {@code int} to compare
 @param b the second unsigned {@code int} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
         greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="toLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns the value of the given {@code int} as a {@code long}, when treated as unsigned.]]>
      </doc>
    </method>
    <method name="min" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code int} values
 @return the value present in {@code array} that is less than or equal to every other value in
         the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code int} values
 @return the value present in {@code array} that is greater than or equal to every other value
         in the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied unsigned {@code int} values separated by
 {@code separator}. For example, {@code join("-", 1, 2, 3)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting
        string (but not at the start or end)
 @param array an array of unsigned {@code int} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;int[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two arrays of unsigned {@code int} values lexicographically.
 That is, it compares, using {@link #compare(int, int)}), the first pair of values that follow
 any common prefix, or when one array is a prefix of the other, treats the shorter array as the
 lesser. For example, {@code [] < [1] < [1, 2] < [2] < [1 << 31]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(int[], int[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order"> Lexicographical order
      article at Wikipedia</a>]]>
      </doc>
    </method>
    <method name="divide" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="int"/>
      <param name="divisor" type="int"/>
      <doc>
      <![CDATA[Returns dividend / divisor, where the dividend and divisor are treated as unsigned 32-bit
 quantities.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0]]>
      </doc>
    </method>
    <method name="remainder" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="int"/>
      <param name="divisor" type="int"/>
      <doc>
      <![CDATA[Returns dividend % divisor, where the dividend and divisor are treated as unsigned 32-bit
 quantities.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0]]>
      </doc>
    </method>
    <method name="decode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code int} value represented by the given string.

 Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix:

 <ul>
 <li>{@code 0x}<i>HexDigits</i>
 <li>{@code 0X}<i>HexDigits</i>
 <li>{@code #}<i>HexDigits</i>
 <li>{@code 0}<i>OctalDigits</i>
 </ul>

 @throws NumberFormatException if the string does not contain a valid unsigned {@code int}
         value
 @since 13.0]]>
      </doc>
    </method>
    <method name="parseUnsignedInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code int} value represented by the given decimal string.

 @throws NumberFormatException if the string does not contain a valid unsigned integer, or if
         the value represented is too large to fit in an unsigned {@code int}.
 @throws NullPointerException if {@code s} is null]]>
      </doc>
    </method>
    <method name="parseUnsignedInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns the unsigned {@code int} value represented by a string with the given radix.

 @param string the string containing the unsigned integer representation to be parsed.
 @param radix the radix to use while parsing {@code s}; must be between
        {@link Character#MIN_RADIX} and {@link Character#MAX_RADIX}.
 @throws NumberFormatException if the string does not contain a valid unsigned {@code int}, or
         if supplied radix is invalid.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of x, where x is treated as unsigned.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of {@code x} for the given radix, where {@code x} is treated
 as unsigned.

 @param x the value to convert to a string.
 @param radix the radix to use while working with {@code x}
 @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}
         and {@link Character#MAX_RADIX}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code int} primitives that interpret values as
 <i>unsigned</i> (that is, any negative value {@code x} is treated as the positive value
 {@code 2^32 + x}). The methods for which signedness is not an issue are in {@link Ints}, as well
 as signed versions of methods for which signedness is an issue.

 <p>In addition, this class provides several static methods for converting an {@code int} to a
 {@code String} and a {@code String} to an {@code int} that treat the {@code int} as an unsigned
 number.

 <p>Users of these utilities must be <i>extremely careful</i> not to mix up signed and unsigned
 {@code int} values. When possible, it is recommended that the {@link UnsignedInteger} wrapper
 class be used, at a small efficiency penalty, to enforce the distinction in the type system.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained#Unsigned_support">
 unsigned primitive utilities</a>.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedInts -->
  <!-- start class com.google.common.primitives.UnsignedLong -->
  <class name="UnsignedLong" extends="java.lang.Number"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable&lt;com.google.common.primitives.UnsignedLong&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="asUnsigned" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedLong} that, when treated as signed, is equal to {@code value}. The
 inverse operation is {@link #longValue()}.
 
 <p>Put another way, if {@code value} is negative, the returned result will be equal to
 {@code 2^64 + value}; otherwise, the returned result will be equal to {@code value}.]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns a {@code UnsignedLong} representing the same value as the specified {@code BigInteger}
 . This is the inverse operation of {@link #bigIntegerValue()}.
 
 @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^64}]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedLong} holding the value of the specified {@code String}, parsed as
 an unsigned {@code long} value.
 
 @throws NumberFormatException if the string does not contain a parsable unsigned {@code long}
         value]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedLong} holding the value of the specified {@code String}, parsed as
 an unsigned {@code long} value in the specified radix.
 
 @throws NumberFormatException if the string does not contain a parsable unsigned {@code long}
         value, or {@code radix} is not between {@link Character#MIN_RADIX} and
         {@link Character#MAX_RADIX}]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of adding this and {@code val}. If the result would have more than 64 bits,
 returns the low 64 bits of the result.]]>
      </doc>
    </method>
    <method name="subtract" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of subtracting this and {@code val}. If the result would be negative,
 returns the low 64 bits of the result.]]>
      </doc>
    </method>
    <method name="multiply" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of multiplying this and {@code val}. If the result would have more than 64
 bits, returns the low 64 bits of the result.]]>
      </doc>
    </method>
    <method name="divide" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of dividing this by {@code val}.]]>
      </doc>
    </method>
    <method name="remainder" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the remainder of dividing this by {@code val}.]]>
      </doc>
    </method>
    <method name="intValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as an {@code int}.]]>
      </doc>
    </method>
    <method name="longValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@code long}. This is an inverse operation
 to {@link #asUnsigned}.
 
 <p>Note that if this {@code UnsignedLong} holds a value {@code >= 2^63}, the returned value
 will be equal to {@code this - 2^64}.]]>
      </doc>
    </method>
    <method name="floatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@code float}, analogous to a widening
 primitive conversion from {@code long} to {@code float}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="doubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@code double}, analogous to a widening
 primitive conversion from {@code long} to {@code double}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="bigIntegerValue" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@link BigInteger}.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="com.google.common.primitives.UnsignedLong"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedLong} value, in base 10.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedLong} value, in base {@code radix}. If
 {@code radix < Character.MIN_RADIX} or {@code radix > Character.MAX_RADIX}, the radix
 {@code 10} is used.]]>
      </doc>
    </method>
    <field name="ZERO" type="com.google.common.primitives.UnsignedLong"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ONE" type="com.google.common.primitives.UnsignedLong"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_VALUE" type="com.google.common.primitives.UnsignedLong"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A wrapper class for unsigned {@code long} values, supporting arithmetic operations.
 
 <p>In some cases, when speed is more important than code readability, it may be faster simply to
 treat primitive {@code long} values as unsigned, using the methods from {@link UnsignedLongs}.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained#Unsigned_support">
 unsigned primitive utilities</a>.
 
 @author Louis Wasserman
 @author Colin Evans
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedLong -->
  <!-- start class com.google.common.primitives.UnsignedLongs -->
  <class name="UnsignedLongs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Compares the two specified {@code long} values, treating them as unsigned values between
 {@code 0} and {@code 2^64 - 1} inclusive.

 @param a the first unsigned {@code long} to compare
 @param b the second unsigned {@code long} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
         greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code long} values
 @return the value present in {@code array} that is less than or equal to every other value in
         the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code long} values
 @return the value present in {@code array} that is greater than or equal to every other value
         in the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied unsigned {@code long} values separated by
 {@code separator}. For example, {@code join("-", 1, 2, 3)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting
        string (but not at the start or end)
 @param array an array of unsigned {@code long} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;long[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two arrays of unsigned {@code long} values
 lexicographically. That is, it compares, using {@link #compare(long, long)}), the first pair of
 values that follow any common prefix, or when one array is a prefix of the other, treats the
 shorter array as the lesser. For example, {@code [] < [1L] < [1L, 2L] < [2L] < [1L << 63]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with
 {@link Arrays#equals(long[], long[])}.

 @see <a href="http://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order
      article at Wikipedia</a>]]>
      </doc>
    </method>
    <method name="divide" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="long"/>
      <param name="divisor" type="long"/>
      <doc>
      <![CDATA[Returns dividend / divisor, where the dividend and divisor are treated as unsigned 64-bit
 quantities.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0]]>
      </doc>
    </method>
    <method name="remainder" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="long"/>
      <param name="divisor" type="long"/>
      <doc>
      <![CDATA[Returns dividend % divisor, where the dividend and divisor are treated as unsigned 64-bit
 quantities.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0
 @since 11.0]]>
      </doc>
    </method>
    <method name="parseUnsignedLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code long} value represented by the given decimal string.

 @throws NumberFormatException if the string does not contain a valid unsigned {@code long}
         value]]>
      </doc>
    </method>
    <method name="decode" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code long} value represented by the given string.

 Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix:

 <ul>
 <li>{@code 0x}<i>HexDigits</i>
 <li>{@code 0X}<i>HexDigits</i>
 <li>{@code #}<i>HexDigits</i>
 <li>{@code 0}<i>OctalDigits</i>
 </ul>

 @throws NumberFormatException if the string does not contain a valid unsigned {@code long}
         value
 @since 13.0]]>
      </doc>
    </method>
    <method name="parseUnsignedLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns the unsigned {@code long} value represented by a string with the given radix.

 @param s the string containing the unsigned {@code long} representation to be parsed.
 @param radix the radix to use while parsing {@code s}
 @throws NumberFormatException if the string does not contain a valid unsigned {@code long}
         with the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX}
         and {@link Character#MAX_RADIX}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <doc>
      <![CDATA[Returns a string representation of x, where x is treated as unsigned.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of {@code x} for the given radix, where {@code x} is treated
 as unsigned.

 @param x the value to convert to a string.
 @param radix the radix to use while working with {@code x}
 @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}
         and {@link Character#MAX_RADIX}.]]>
      </doc>
    </method>
    <field name="MAX_VALUE" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code long} primitives that interpret values as
 <i>unsigned</i> (that is, any negative value {@code x} is treated as the positive value
 {@code 2^64 + x}). The methods for which signedness is not an issue are in {@link Longs}, as
 well as signed versions of methods for which signedness is an issue.

 <p>In addition, this class provides several static methods for converting a {@code long} to a
 {@code String} and a {@code String} to a {@code long} that treat the {@code long} as an unsigned
 number.

 <p>Users of these utilities must be <i>extremely careful</i> not to mix up signed and unsigned
 {@code long} values. When possible, it is recommended that the {@link UnsignedLong} wrapper
 class be used, at a small efficiency penalty, to enforce the distinction in the type system.

 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/PrimitivesExplained#Unsigned_support">
 unsigned primitive utilities</a>.

 @author Louis Wasserman
 @author Brian Milch
 @author Colin Evans
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedLongs -->
</package>
<package name="com.google.common.reflect">
  <!-- start class com.google.common.reflect.AbstractInvocationHandler -->
  <class name="AbstractInvocationHandler" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.reflect.InvocationHandler"/>
    <constructor name="AbstractInvocationHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="invoke" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="proxy" type="java.lang.Object"/>
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="args" type="java.lang.Object[]"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[{@inheritDoc}
 
 <p>{@link Object#equals}, {@link Object#hashCode} are implemented according to referential
 equality (the default behavior of {@link Object}). {@link Object#toString} delegates to
 {@link #toString} that can be overridden by subclasses.]]>
      </doc>
    </method>
    <method name="handleInvocation" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="proxy" type="java.lang.Object"/>
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="args" type="java.lang.Object[]"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[{@link #invoke} delegates to this method upon any method invocation on the proxy instance,
 except {@link Object#equals}, {@link Object#hashCode} and {@link Object#toString}. The result
 will be returned as the proxied method's return value.
 
 <p>Unlike {@link #invoke}, {@code args} will never be null. When the method has no parameter,
 an empty array is passed in.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The dynamic proxies' {@link Object#toString} will delegate to this method. Subclasses can
 override this to provide custom string representation of the proxies.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract implementation of {@link InvocationHandler} that handles {@link Object#equals},
 {@link Object#hashCode} and {@link Object#toString}.

 @author Ben Yu
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.AbstractInvocationHandler -->
  <!-- start class com.google.common.reflect.ImmutableTypeToInstanceMap -->
  <class name="ImmutableTypeToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.reflect.TypeToInstanceMap&lt;B&gt;"/>
    <method name="of" return="com.google.common.reflect.ImmutableTypeToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty type to instance map.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.reflect.ImmutableTypeToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder.]]>
      </doc>
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Map&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A type-to-instance map backed by an {@link ImmutableMap}. See also {@link
 MutableTypeToInstanceMap}.

 @author Ben Yu
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.ImmutableTypeToInstanceMap -->
  <!-- start class com.google.common.reflect.ImmutableTypeToInstanceMap.Builder -->
  <class name="ImmutableTypeToInstanceMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="put" return="com.google.common.reflect.ImmutableTypeToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.reflect.ImmutableTypeToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate
 keys are not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.reflect.ImmutableTypeToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable type-to-instance map containing the entries
 provided to this builder.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable type-to-instance maps. Example:
 <pre>   {@code

   static final ImmutableTypeToInstanceMap<Handler<?>> HANDLERS =
       ImmutableTypeToInstanceMap.<Handler<?>>builder()
           .put(new TypeToken<Handler<Foo>>() {}, new FooHandler())
           .put(new TypeToken<Handler<Bar>>() {}, new SubBarHandler())
           .build();}</pre>

 After invoking {@link #build()} it is still possible to add more entries
 and build again. Thus each map generated by this builder will be a superset
 of any map generated before it.

 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.ImmutableTypeToInstanceMap.Builder -->
  <!-- start class com.google.common.reflect.MutableTypeToInstanceMap -->
  <class name="MutableTypeToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.reflect.TypeToInstanceMap&lt;B&gt;"/>
    <constructor name="MutableTypeToInstanceMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
    </method>
    <method name="put" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.common.reflect.TypeToken&lt;? extends B&gt;"/>
      <param name="value" type="B"/>
      <doc>
      <![CDATA[Not supported. Use {@link #putInstance} instead.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends com.google.common.reflect.TypeToken&lt;? extends B&gt;, ? extends B&gt;"/>
      <doc>
      <![CDATA[Not supported. Use {@link #putInstance} instead.]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Map&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A mutable type-to-instance map.
 See also {@link ImmutableTypeToInstanceMap}.

 @author Ben Yu
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.MutableTypeToInstanceMap -->
  <!-- start class com.google.common.reflect.Reflection -->
  <class name="Reflection" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getPackageName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cls" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the package name of {@code cls} according to the Java Language Specification (section
 6.7). Unlike {@link Class#getPackage}, this method only parses the class name, without
 attempting to define the {@link Package} and hence load files.]]>
      </doc>
    </method>
    <method name="getPackageName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classFullName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the package name of {@code classFullName} according to the Java Language Specification
 (section 6.7). Unlike {@link Class#getPackage}, this method only parses the class name, without
 attempting to define the {@link Package} and hence load files.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Ensures that the given classes are initialized, as described in
 <a href="http://java.sun.com/docs/books/jls/third_edition/html/execution.html#12.4.2">
 JLS Section 12.4.2</a>.

 <p>WARNING: Normally it's a smell if a class needs to be explicitly initialized, because static
 state hurts system maintainability and testability. In cases when you have no choice while
 inter-operating with a legacy framework, this method helps to keep the code less ugly.

 @throws ExceptionInInitializerError if an exception is thrown during
   initialization of a class]]>
      </doc>
    </method>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="handler" type="java.lang.reflect.InvocationHandler"/>
      <doc>
      <![CDATA[Returns a proxy instance that implements {@code interfaceType} by
 dispatching method invocations to {@code handler}. The class loader of
 {@code interfaceType} will be used to define the proxy class. To implement
 multiple interfaces or specify a class loader, use
 {@link Proxy#newProxyInstance}.

 @throws IllegalArgumentException if {@code interfaceType} does not specify
     the type of a Java interface]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utilities relating to Java reflection.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.Reflection -->
  <!-- start class com.google.common.reflect.TypeParameter -->
  <class name="TypeParameter" extends="com.google.common.reflect.TypeCapture&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeParameter"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Captures a free type variable that can be used in {@link TypeToken#where}.
 For example: <pre>   {@code

   static <T> TypeToken<List<T>> listOf(Class<T> elementType) {
     return new TypeToken<List<T>>() {}
         .where(new TypeParameter<T>() {}, elementType);
   }
 }</pre>

 @author Ben Yu
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.TypeParameter -->
  <!-- start interface com.google.common.reflect.TypeToInstanceMap -->
  <interface name="TypeToInstanceMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"/>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value the specified class is mapped to, or {@code null} if no
 entry for this class is present. This will only return a value that was
 bound to this specific class, not a value that may have been bound to a
 subtype.
 
 <p>{@code getInstance(Foo.class)} is equivalent to
 {@code getInstance(TypeToken.of(Foo.class))}.]]>
      </doc>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Maps the specified class to the specified value. Does <i>not</i> associate
 this value with any of the class's supertypes.
 
 <p>{@code putInstance(Foo.class, foo)} is equivalent to
 {@code putInstance(TypeToken.of(Foo.class), foo)}.

 @return the value previously associated with this class (possibly {@code null}),
         or {@code null} if there was no previous entry.]]>
      </doc>
    </method>
    <method name="getInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value the specified type is mapped to, or {@code null} if no
 entry for this type is present. This will only return a value that was
 bound to this specific type, not a value that may have been bound to a subtype.]]>
      </doc>
    </method>
    <method name="putInstance" return="T extends B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Maps the specified type to the specified value. Does <i>not</i> associate
 this value with any of the type's supertypes.

 @return the value previously associated with this type (possibly {@code null}),
         or {@code null} if there was no previous entry.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map, each entry of which maps a {@link TypeToken} to an instance of that type.
 In addition to implementing {@code Map}, the additional type-safe operations
 {@link #putInstance} and {@link #getInstance} are available.

 <p>Generally, implementations don't support {@link #put} and {@link #putAll}
 because there is no way to check an object at runtime to be an instance of a
 {@link TypeToken}. Instead, caller should use the type safe {@link #putInstance}.
 
 <p>Also, if caller suppresses unchecked warnings and passes in an {@code Iterable<String>}
 for type {@code Iterable<Integer>}, the map won't be able to detect and throw type error.

 <p>Like any other {@code Map<Class, Object>}, this map may contain entries
 for primitive types, and a primitive type and its corresponding wrapper type
 may map to different values.

 @param <B> the common supertype that all entries must share; often this is
     simply {@link Object}

 @author Ben Yu
 @since 13.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.reflect.TypeToInstanceMap -->
  <!-- start class com.google.common.reflect.TypeToken -->
  <class name="TypeToken" extends="com.google.common.reflect.TypeCapture&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="TypeToken"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type token of {@code T}.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute
 it at runtime despite erasure.

 <p>For example: <pre>   {@code

   TypeToken<List<String>> t = new TypeToken<List<String>>() {};
 }</pre>]]>
      </doc>
    </constructor>
    <constructor name="TypeToken" type="java.lang.Class&lt;?&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type token of {@code T} while resolving free type variables in the context of
 {@code declaringClass}.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute
 it at runtime despite erasure.

 <p>For example: <pre>   {@code

   abstract class IKnowMyType<T> {
     TypeToken<T> getMyType() {
       return new TypeToken<T>(getClass()) {};
     }
   }

   new IKnowMyType<String>() {}.getMyType() => String
 }</pre>]]>
      </doc>
    </constructor>
    <method name="of" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an instance of type token that wraps {@code type}.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.reflect.TypeToken&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns an instance of type token that wraps {@code type}.]]>
      </doc>
    </method>
    <method name="getRawType" return="java.lang.Class&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw type of {@code T}. Formally speaking, if {@code T} is returned by
 {@link java.lang.reflect.Method#getGenericReturnType}, the raw type is what's returned by
 {@link java.lang.reflect.Method#getReturnType} of the same method object. Specifically:
 <ul>
 <li>If {@code T} is a {@code Class} itself, {@code T} itself is returned.
 <li>If {@code T} is a {@link ParameterizedType}, the raw type of the parameterized type is
     returned.
 <li>If {@code T} is a {@link GenericArrayType}, the returned type is the corresponding array
     class. For example: {@code List<Integer>[] => List[]}.
 <li>If {@code T} is a type variable or a wildcard type, the raw type of the first upper bound
     is returned. For example: {@code <X extends Foo> => Foo}.
 </ul>]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the represented type.]]>
      </doc>
    </method>
    <method name="where" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="typeParam" type="com.google.common.reflect.TypeParameter&lt;X&gt;"/>
      <param name="typeArg" type="com.google.common.reflect.TypeToken&lt;X&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code TypeToken} where type variables represented by {@code typeParam}
 are substituted by {@code typeArg}. For example, it can be used to construct
 {@code Map<K, V>} for any {@code K} and {@code V} type: <pre>   {@code

   static <K, V> TypeToken<Map<K, V>> mapOf(
       TypeToken<K> keyType, TypeToken<V> valueType) {
     return new TypeToken<Map<K, V>>() {}
         .where(new TypeParameter<K>() {}, keyType)
         .where(new TypeParameter<V>() {}, valueType);
   }
 }</pre>

 @param <X> The parameter type
 @param typeParam the parameter type variable
 @param typeArg the actual type to substitute]]>
      </doc>
    </method>
    <method name="where" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="typeParam" type="com.google.common.reflect.TypeParameter&lt;X&gt;"/>
      <param name="typeArg" type="java.lang.Class&lt;X&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code TypeToken} where type variables represented by {@code typeParam}
 are substituted by {@code typeArg}. For example, it can be used to construct
 {@code Map<K, V>} for any {@code K} and {@code V} type: <pre>   {@code

   static <K, V> TypeToken<Map<K, V>> mapOf(
       Class<K> keyType, Class<V> valueType) {
     return new TypeToken<Map<K, V>>() {}
         .where(new TypeParameter<K>() {}, keyType)
         .where(new TypeParameter<V>() {}, valueType);
   }
 }</pre>

 @param <X> The parameter type
 @param typeParam the parameter type variable
 @param typeArg the actual type to substitute]]>
      </doc>
    </method>
    <method name="resolveType" return="com.google.common.reflect.TypeToken&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Resolves the given {@code type} against the type context represented by this type.
 For example: <pre>   {@code

   new TypeToken<List<String>>() {}.resolveType(
       List.class.getMethod("get", int.class).getGenericReturnType())
   => String.class
 }</pre>]]>
      </doc>
    </method>
    <method name="getTypes" return="com.google.common.reflect.TypeToken&lt;T&gt;.TypeSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of interfaces and classes that this type is or is a subtype of. The returned
 types are parameterized with proper type arguments.

 <p>Subtypes are always listed before supertypes. But the reverse is not true. A type isn't
 necessarily a subtype of all the types following. Order between types without subtype
 relationship is arbitrary and not guaranteed.

 <p>If this type is a type variable or wildcard, upper bounds that are themselves type variables
 aren't included (their super interfaces and superclasses are).]]>
      </doc>
    </method>
    <method name="getSupertype" return="com.google.common.reflect.TypeToken&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="superclass" type="java.lang.Class&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the generic form of {@code superclass}. For example, if this is
 {@code ArrayList<String>}, {@code Iterable<String>} is returned given the
 input {@code Iterable.class}.]]>
      </doc>
    </method>
    <method name="getSubtype" return="com.google.common.reflect.TypeToken&lt;? extends T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="subclass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns subtype of {@code this} with {@code subclass} as the raw class.
 For example, if this is {@code Iterable<String>} and {@code subclass} is {@code List},
 {@code List<String>} is returned.]]>
      </doc>
    </method>
    <method name="isAssignableFrom" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns true if this type is assignable from the given {@code type}.]]>
      </doc>
    </method>
    <method name="isAssignableFrom" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Check if this type is assignable from the given {@code type}.]]>
      </doc>
    </method>
    <method name="isArray" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this type is known to be an array type, such as {@code int[]}, {@code T[]},
 {@code <? extends Map<String, Integer>[]>} etc.]]>
      </doc>
    </method>
    <method name="getComponentType" return="com.google.common.reflect.TypeToken&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the array component type if this type represents an array ({@code int[]}, {@code T[]},
 {@code <? extends Map<String, Integer>[]>} etc.), or else {@code null} is returned.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if {@code o} is another {@code TypeToken} that represents the same {@link Type}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeReplace" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implemented to support serialization of subclasses.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Type} with generics.

 <p>Operations that are otherwise only available in {@link Class} are implemented to support
 {@code Type}, for example {@link #isAssignableFrom}, {@link #isArray} and {@link
 #getComponentType}. It also provides additional utilities such as {@link #getTypes} and {@link
 #resolveType} etc.

 <p>There are three ways to get a {@code TypeToken} instance: <ul>
 <li>Wrap a {@code Type} obtained via reflection. For example: {@code
 TypeToken.of(method.getGenericReturnType())}.
 <li>Capture a generic type with a (usually anonymous) subclass. For example: <pre>   {@code

   new TypeToken<List<String>>() {}
 }</pre>
 Note that it's critical that the actual type argument is carried by a subclass.
 The following code is wrong because it only captures the {@code <T>} type variable
 of the {@code listType()} method signature; while {@code <String>} is lost in erasure:
 <pre>   {@code

   class Util {
     static <T> TypeToken<List<T>> listType() {
       return new TypeToken<List<T>>() {};
     }
   }

   TypeToken<List<String>> stringListType = Util.<String>listType();
 }</pre>
 <li>Capture a generic type with a (usually anonymous) subclass and resolve it against
 a context class that knows what the type parameters are. For example: <pre>   {@code
   abstract class IKnowMyType<T> {
     TypeToken<T> type = new TypeToken<T>(getClass()) {};
   }
   new IKnowMyType<String>() {}.type => String
 }</pre>
 </ul>

 <p>{@code TypeToken} is serializable when no type variable is contained in the type.

 <p>Note to Guice users: {@code} TypeToken is similar to Guice's {@code TypeLiteral} class,
 but with one important difference: it supports non-reified types such as {@code T},
 {@code List<T>} or even {@code List<? extends Number>}; while TypeLiteral does not.
 TypeToken is also serializable and offers numerous additional utility methods.

 @author Bob Lee
 @author Sven Mawson
 @author Ben Yu
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.TypeToken -->
  <!-- start class com.google.common.reflect.TypeToken.TypeSet -->
  <class name="TypeToken.TypeSet" extends="com.google.common.collect.ForwardingSet&lt;com.google.common.reflect.TypeToken&lt;? super T&gt;&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="interfaces" return="com.google.common.reflect.TypeToken&lt;T&gt;.TypeSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the types that are interfaces implemented by this type.]]>
      </doc>
    </method>
    <method name="classes" return="com.google.common.reflect.TypeToken&lt;T&gt;.TypeSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the types that are classes.]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Set&lt;com.google.common.reflect.TypeToken&lt;? super T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="rawTypes" return="java.util.Set&lt;java.lang.Class&lt;? super T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw types of the types in this set, in the same order.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The set of interfaces and classes that {@code T} is or is a subtype of. {@link Object} is not
 included in the set if this type is an interface.]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.TypeToken.TypeSet -->
</package>
<package name="com.google.common.util.concurrent">
  <!-- start class com.google.common.util.concurrent.AbstractCheckedFuture -->
  <class name="AbstractCheckedFuture" extends="com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"/>
    <constructor name="AbstractCheckedFuture" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an {@code AbstractCheckedFuture} that wraps a delegate.]]>
      </doc>
    </constructor>
    <method name="mapException" return="X extends java.lang.Exception"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Translates from an {@link InterruptedException},
 {@link CancellationException} or {@link ExecutionException} thrown by
 {@code get} to an exception of type {@code X} to be thrown by
 {@code checkedGet}. Subclasses must implement this method.

 <p>If {@code e} is an {@code InterruptedException}, the calling
 {@code checkedGet} method has already restored the interrupt after catching
 the exception. If an implementation of {@link #mapException(Exception)}
 wishes to swallow the interrupt, it can do so by calling
 {@link Thread#interrupted()}.

 <p>Subclasses may choose to throw, rather than return, a subclass of
 {@code RuntimeException} to allow creating a CheckedFuture that throws
 both checked and unchecked exceptions.]]>
      </doc>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation calls {@link #get()} and maps that method's standard
 exceptions to instances of type {@code X} using {@link #mapException}.

 <p>In addition, if {@code get} throws an {@link InterruptedException}, this
 implementation will set the current thread's interrupt status before
 calling {@code mapException}.

 @throws X if {@link #get()} throws an {@link InterruptedException},
         {@link CancellationException}, or {@link ExecutionException}]]>
      </doc>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation calls {@link #get(long, TimeUnit)} and maps that
 method's standard exceptions (excluding {@link TimeoutException}, which is
 propagated) to instances of type {@code X} using {@link #mapException}.

 <p>In addition, if {@code get} throws an {@link InterruptedException}, this
 implementation will set the current thread's interrupt status before
 calling {@code mapException}.

 @throws X if {@link #get()} throws an {@link InterruptedException},
         {@link CancellationException}, or {@link ExecutionException}
 @throws TimeoutException {@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A delegating wrapper around a {@link ListenableFuture} that adds support for
 the {@link #checkedGet()} and {@link #checkedGet(long, TimeUnit)} methods.

 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractCheckedFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <class name="AbstractExecutionThreadService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractExecutionThreadService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service. This method is invoked on the execution thread.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="run"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run the service. This method is invoked on the execution thread.
 Implementations must respond to stop requests. You could poll for lifecycle
 changes in a work loop:
 <pre>
   public void run() {
     while ({@link #isRunning()}) {
       // perform a unit of work
     }
   }
 </pre>
 ...or you could respond to stop requests by implementing {@link
 #triggerShutdown()}, which should cause {@link #run()} to return.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service. This method is invoked on the execution thread.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="triggerShutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoked to request the service to stop.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service.
 Subclasses may override this method to use a custom {@link Executor}, which
 may configure its worker thread with a specific name, thread group or
 priority. The returned executor's {@link Executor#execute(Runnable)
 execute()} method is called when this service is started, and should return
 promptly.

 <p>The default implementation returns a new {@link Executor} that sets the
 name of its threads to the string returned by {@link #getServiceName}]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="getServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this service. {@link AbstractExecutionThreadService}
 may include the name in debugging output.

 <p>Subclasses may override this method.

 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Base class for services that can implement {@link #startUp}, {@link #run} and
 {@link #shutDown} methods. This class uses a single thread to execute the
 service; consider {@link AbstractService} if you would like to manage any
 threading manually.

 @author Jesse Wilson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <!-- start class com.google.common.util.concurrent.AbstractFuture -->
  <class name="AbstractFuture" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="AbstractFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The default {@link AbstractFuture} implementation throws {@code
 InterruptedException} if the current thread is interrupted before or during
 the call, even if the value is already available.

 @throws InterruptedException if the current thread was interrupted before
     or during the call (optional but recommended).
 @throws CancellationException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The default {@link AbstractFuture} implementation throws {@code
 InterruptedException} if the current thread is interrupted before or during
 the call, even if the value is already available.

 @throws InterruptedException if the current thread was interrupted before
     or during the call (optional but recommended).
 @throws CancellationException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="interruptTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Subclasses can override this method to implement interruption of the
 future's computation. The method is invoked automatically by a successful
 call to {@link #cancel(boolean) cancel(true)}.

 <p>The default implementation does nothing.

 @since 10.0]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 10.0]]>
      </doc>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Subclasses should invoke this method to set the result of the computation
 to {@code value}.  This will set the state of the future to
 {@link AbstractFuture.Sync#COMPLETED} and invoke the listeners if the
 state was successfully changed.

 @param value the value that was the result of the task.
 @return true if the state was successfully changed.]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Subclasses should invoke this method to set the result of the computation
 to an error, {@code throwable}.  This will set the state of the future to
 {@link AbstractFuture.Sync#COMPLETED} and invoke the listeners if the
 state was successfully changed.

 @param throwable the exception that the task failed with.
 @return true if the state was successfully changed.
 @throws Error if the throwable was an {@link Error}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract implementation of the {@link ListenableFuture} interface. This
 class is preferable to {@link java.util.concurrent.FutureTask} for two
 reasons: It implements {@code ListenableFuture}, and it does not implement
 {@code Runnable}. (If you want a {@code Runnable} implementation of {@code
 ListenableFuture}, create a {@link ListenableFutureTask}, or submit your
 tasks to a {@link ListeningExecutorService}.)

 <p>This class implements all methods in {@code ListenableFuture}.
 Subclasses should provide a way to set the result of the computation through
 the protected methods {@link #set(Object)} and
 {@link #setException(Throwable)}. Subclasses may also override {@link
 #interruptTask()}, which will be invoked automatically if a call to {@link
 #cancel(boolean) cancel(true)} succeeds in canceling the future.

 <p>{@code AbstractFuture} uses an {@link AbstractQueuedSynchronizer} to deal
 with concurrency issues and guarantee thread safety.

 <p>The state changing methods all return a boolean indicating success or
 failure in changing the future's state.  Valid states are running,
 completed, failed, or cancelled.

 <p>This class uses an {@link ExecutionList} to guarantee that all registered
 listeners will be executed, either when the future finishes or, for listeners
 that are added after the future completes, immediately.
 {@code Runnable}-{@code Executor} pairs are stored in the execution list but
 are not necessarily executed in the order in which they were added.  (If a
 listener is added after the Future is complete, it will be executed
 immediately, even if earlier listeners have not been executed. Additionally,
 executors need not guarantee FIFO execution, or different listeners may run
 in different executors.)

 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractIdleService -->
  <class name="AbstractIdleService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractIdleService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startUp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="state" type="com.google.common.util.concurrent.Service.State"/>
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service.
 Subclasses may override this method to use a custom {@link Executor}, which
 may configure its worker thread with a specific name, thread group or
 priority. The returned executor's {@link Executor#execute(Runnable)
 execute()} method is called when this service is started and stopped,
 and should return promptly.

 @param state {@link Service.State#STARTING} or
     {@link Service.State#STOPPING}, used by the default implementation for
     naming the thread]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <doc>
    <![CDATA[Base class for services that do not need a thread while "running"
 but may need one during startup and shutdown. Subclasses can
 implement {@link #startUp} and {@link #shutDown} methods, each
 which run in a executor which by default uses a separate thread
 for each method.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractIdleService -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService -->
  <class name="AbstractScheduledService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractScheduledService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="runOneIteration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run one iteration of the scheduled task. If any invocation of this method throws an exception,
 the service will transition to the {@link Service.State#FAILED} state and this method will no
 longer be called.]]>
      </doc>
    </method>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service. This is guaranteed not to run concurrently with {@link #runOneIteration}.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="scheduler" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Scheduler} object used to configure this service.  This method will only be
 called once.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link ScheduledExecutorService} that will be used to execute the {@link #startUp},
 {@link #runOneIteration} and {@link #shutDown} methods.  The executor will not be
 {@link ScheduledExecutorService#shutdown} when this service stops. Subclasses may override this
 method to use a custom {@link ScheduledExecutorService} instance.

 <p>By default this returns a new {@link ScheduledExecutorService} with a single thread thread
 pool.  This method will only be called once.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <doc>
    <![CDATA[Base class for services that can implement {@link #startUp} and {@link #shutDown} but while in
 the "running" state need to perform a periodic task.  Subclasses can implement {@link #startUp},
 {@link #shutDown} and also a {@link #runOneIteration} method that will be executed periodically.

 <p>This class uses the {@link ScheduledExecutorService} returned from {@link #executor} to run
 the {@link #startUp} and {@link #shutDown} methods and also uses that service to schedule the
 {@link #runOneIteration} that will be executed periodically as specified by its
 {@link Scheduler}. When this service is asked to stop via {@link #stop} or {@link #stopAndWait},
 it will cancel the periodic task (but not interrupt it) and wait for it to stop before running
 the {@link #shutDown} method.

 <p>Subclasses are guaranteed that the life cycle methods ({@link #runOneIteration}, {@link
 #startUp} and {@link #shutDown}) will never run concurrently. Notably, if any execution of {@link
 #runOneIteration} takes longer than its schedule defines, then subsequent executions may start
 late.  Also, all life cycle methods are executed with a lock held, so subclasses can safely
 modify shared state without additional synchronization necessary for visibility to later
 executions of the life cycle methods.

 <h3>Usage Example</h3>

 Here is a sketch of a service which crawls a website and uses the scheduling capabilities to
 rate limit itself. <pre> {@code
 class CrawlingService extends AbstractScheduledService {
   private Set<Uri> visited;
   private Queue<Uri> toCrawl;
   protected void startUp() throws Exception {
     toCrawl = readStartingUris();
   }

   protected void runOneIteration() throws Exception {
     Uri uri = toCrawl.remove();
     Collection<Uri> newUris = crawl(uri);
     visited.add(uri);
     for (Uri newUri : newUris) {
       if (!visited.contains(newUri)) { toCrawl.add(newUri); }
     }
   }

   protected void shutDown() throws Exception {
     saveUris(toCrawl);
   }

   protected Scheduler scheduler() {
     return Scheduler.newFixedRateSchedule(0, 1, TimeUnit.SECONDS);
   }
 }}</pre>

 This class uses the life cycle methods to read in a list of starting URIs and save the set of
 outstanding URIs when shutting down.  Also, it takes advantage of the scheduling functionality to
 rate limit the number of queries we perform.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler -->
  <class name="AbstractScheduledService.CustomScheduler" extends="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractScheduledService.CustomScheduler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNextSchedule" return="com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.Schedule"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Calculates the time at which to next invoke the task.

 <p>This is guaranteed to be called immediately after the task has completed an iteration and
 on the same thread as the previous execution of {@link
 AbstractScheduledService#runOneIteration}.

 @return a schedule that defines the delay before the next execution.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Scheduler} that provides a convenient way for the {@link AbstractScheduledService} to
 use a dynamically changing schedule.  After every execution of the task, assuming it hasn't
 been cancelled, the {@link #getNextSchedule} method will be called.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.Schedule -->
  <class name="AbstractScheduledService.CustomScheduler.Schedule" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="protected"
    deprecated="not deprecated">
    <constructor name="AbstractScheduledService.CustomScheduler.Schedule" type="long, java.util.concurrent.TimeUnit"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param delay the time from now to delay execution
 @param unit the time unit of the delay parameter]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A value object that represents an absolute delay until a task should be invoked.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.Schedule -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService.Scheduler -->
  <class name="AbstractScheduledService.Scheduler" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newFixedDelaySchedule" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialDelay" type="long"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns a {@link Scheduler} that schedules the task using the
 {@link ScheduledExecutorService#scheduleWithFixedDelay} method.

 @param initialDelay the time to delay first execution
 @param delay the delay between the termination of one execution and the commencement of the
        next
 @param unit the time unit of the initialDelay and delay parameters]]>
      </doc>
    </method>
    <method name="newFixedRateSchedule" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialDelay" type="long"/>
      <param name="period" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns a {@link Scheduler} that schedules the task using the
 {@link ScheduledExecutorService#scheduleAtFixedRate} method.

 @param initialDelay the time to delay first execution
 @param period the period between successive executions of the task
 @param unit the time unit of the initialDelay and period parameters]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scheduler defines the policy for how the {@link AbstractScheduledService} should run its
 task.

 <p>Consider using the {@link #newFixedDelaySchedule} and {@link #newFixedRateSchedule} factory
 methods, these provide {@link Scheduler} instances for the common use case of running the
 service with a fixed schedule.  If more flexibility is needed then consider subclassing the
 {@link CustomScheduler} abstract class in preference to creating your own {@link Scheduler}
 implementation.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService.Scheduler -->
  <!-- start class com.google.common.util.concurrent.AbstractService -->
  <class name="AbstractService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="doStart"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method is called by {@link #start} to initiate service startup. The invocation of this
 method should cause a call to {@link #notifyStarted()}, either during this method's run, or
 after it has returned. If startup fails, the invocation should cause a call to
 {@link #notifyFailed(Throwable)} instead.

 <p>This method should return promptly; prefer to do work on a different thread where it is
 convenient. It is invoked exactly once on service startup, even when {@link #start} is called
 multiple times.]]>
      </doc>
    </method>
    <method name="doStop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method should be used to initiate service shutdown. The invocation of this method should
 cause a call to {@link #notifyStopped()}, either during this method's run, or after it has
 returned. If shutdown fails, the invocation should cause a call to
 {@link #notifyFailed(Throwable)} instead.

 <p> This method should return promptly; prefer to do work on a different thread where it is
 convenient. It is invoked exactly once on service shutdown, even when {@link #stop} is called
 multiple times.]]>
      </doc>
    </method>
    <method name="start" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="notifyStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has started. It will cause
 the service to transition from {@link State#STARTING} to {@link State#RUNNING}.

 @throws IllegalStateException if the service is not {@link State#STARTING}.]]>
      </doc>
    </method>
    <method name="notifyStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has stopped. It will cause
 the service to transition from {@link State#STOPPING} to {@link State#TERMINATED}.

 @throws IllegalStateException if the service is neither {@link State#STOPPING} nor
         {@link State#RUNNING}.]]>
      </doc>
    </method>
    <method name="notifyFailed"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Invoke this method to transition the service to the {@link State#FAILED}. The service will
 <b>not be stopped</b> if it is running. Invoke this method when a service has failed critically
 or otherwise cannot be started nor stopped.]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for implementing services that can handle {@link #doStart} and {@link #doStop}
 requests, responding to them with {@link #notifyStarted()} and {@link #notifyStopped()}
 callbacks. Its subclasses must manage threads manually; consider
 {@link AbstractExecutionThreadService} if you need only a single execution thread.

 @author Jesse Wilson
 @author Luke Sandberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractService -->
  <!-- start interface com.google.common.util.concurrent.AsyncFunction -->
  <interface name="AsyncFunction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="I"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns an output {@code Future} to use in place of the given {@code
 input}. The output {@code Future} need not be {@linkplain Future#isDone
 done}, making {@code AsyncFunction} suitable for asynchronous derivations.

 <p>Throwing an exception from this method is equivalent to returning a
 failing {@code Future}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Transforms a value, possibly asynchronously. For an example usage and more
 information, see {@link Futures#transform(ListenableFuture, AsyncFunction)}.

 @author Chris Povirk
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.AsyncFunction -->
  <!-- start class com.google.common.util.concurrent.AtomicDouble -->
  <class name="AtomicDouble" extends="java.lang.Number"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="AtomicDouble" type="double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDouble} with the given initial value.

 @param initialValue the initial value]]>
      </doc>
    </constructor>
    <constructor name="AtomicDouble"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDouble} with initial value {@code 0.0}.]]>
      </doc>
    </constructor>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current value.

 @return the current value]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Sets to the given value.

 @param newValue the new value]]>
      </doc>
    </method>
    <method name="lazySet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Eventually sets to the given value.

 @param newValue the new value]]>
      </doc>
    </method>
    <method name="getAndSet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Atomically sets to the given value and returns the old value.

 @param newValue the new value
 @return the previous value]]>
      </doc>
    </method>
    <method name="compareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the value to the given updated value
 if the current value is <a href="#bitEquals">bitwise equal</a>
 to the expected value.

 @param expect the expected value
 @param update the new value
 @return {@code true} if successful. False return indicates that
 the actual value was not bitwise equal to the expected value.]]>
      </doc>
    </method>
    <method name="weakCompareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the value to the given updated value
 if the current value is <a href="#bitEquals">bitwise equal</a>
 to the expected value.

 <p>May <a
 href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious">
 fail spuriously</a>
 and does not provide ordering guarantees, so is only rarely an
 appropriate alternative to {@code compareAndSet}.

 @param expect the expected value
 @param update the new value
 @return {@code true} if successful]]>
      </doc>
    </method>
    <method name="getAndAdd" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the current value.

 @param delta the value to add
 @return the previous value]]>
      </doc>
    </method>
    <method name="addAndGet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the current value.

 @param delta the value to add
 @return the updated value]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the String representation of the current value.
 @return the String representation of the current value]]>
      </doc>
    </method>
    <method name="intValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as an {@code int}
 after a narrowing primitive conversion.]]>
      </doc>
    </method>
    <method name="longValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as a {@code long}
 after a narrowing primitive conversion.]]>
      </doc>
    </method>
    <method name="floatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as a {@code float}
 after a narrowing primitive conversion.]]>
      </doc>
    </method>
    <method name="doubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as a {@code double}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code double} value that may be updated atomically.  See the
 {@link java.util.concurrent.atomic} package specification for
 description of the properties of atomic variables.  An {@code
 AtomicDouble} is used in applications such as atomic accumulation,
 and cannot be used as a replacement for a {@link Double}.  However,
 this class does extend {@code Number} to allow uniform access by
 tools and utilities that deal with numerically-based classes.

 <p><a name="bitEquals">This class compares primitive {@code double}
 values in methods such as {@link #compareAndSet} by comparing their
 bitwise representation using {@link Double#doubleToRawLongBits},
 which differs from both the primitive double {@code ==} operator
 and from {@link Double#equals}, as if implemented by:
  <pre> {@code
 static boolean bitEquals(double x, double y) {
   long xBits = Double.doubleToRawLongBits(x);
   long yBits = Double.doubleToRawLongBits(y);
   return xBits == yBits;
 }}</pre>

 <p>It is possible to write a more scalable updater, at the cost of
 giving up strict atomicity.  See for example
 <a href="http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html"
 DoubleAdder>
 and
 <a href="http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html"
 DoubleMaxUpdater>.

 @author Doug Lea
 @author Martin Buchholz
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AtomicDouble -->
  <!-- start class com.google.common.util.concurrent.AtomicDoubleArray -->
  <class name="AtomicDoubleArray" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="AtomicDoubleArray" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDoubleArray} of the given length,
 with all elements initially zero.

 @param length the length of the array]]>
      </doc>
    </constructor>
    <constructor name="AtomicDoubleArray" type="double[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDoubleArray} with the same length
 as, and all elements copied from, the given array.

 @param array the array to copy elements from
 @throws NullPointerException if array is null]]>
      </doc>
    </constructor>
    <method name="length" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the length of the array.

 @return the length of the array]]>
      </doc>
    </method>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Gets the current value at position {@code i}.

 @param i the index
 @return the current value]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Sets the element at position {@code i} to the given value.

 @param i the index
 @param newValue the new value]]>
      </doc>
    </method>
    <method name="lazySet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Eventually sets the element at position {@code i} to the given value.

 @param i the index
 @param newValue the new value]]>
      </doc>
    </method>
    <method name="getAndSet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Atomically sets the element at position {@code i} to the given value
 and returns the old value.

 @param i the index
 @param newValue the new value
 @return the previous value]]>
      </doc>
    </method>
    <method name="compareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the element at position {@code i} to the given
 updated value
 if the current value is <a href="#bitEquals">bitwise equal</a>
 to the expected value.

 @param i the index
 @param expect the expected value
 @param update the new value
 @return true if successful. False return indicates that
 the actual value was not equal to the expected value.]]>
      </doc>
    </method>
    <method name="weakCompareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the element at position {@code i} to the given
 updated value
 if the current value is <a href="#bitEquals">bitwise equal</a>
 to the expected value.

 <p>May <a
 href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious">
 fail spuriously</a>
 and does not provide ordering guarantees, so is only rarely an
 appropriate alternative to {@code compareAndSet}.

 @param i the index
 @param expect the expected value
 @param update the new value
 @return true if successful]]>
      </doc>
    </method>
    <method name="getAndAdd" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the element at index {@code i}.

 @param i the index
 @param delta the value to add
 @return the previous value]]>
      </doc>
    </method>
    <method name="addAndGet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the element at index {@code i}.

 @param i the index
 @param delta the value to add
 @return the updated value]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the String representation of the current values of array.
 @return the String representation of the current values of array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code double} array in which elements may be updated atomically.
 See the {@link java.util.concurrent.atomic} package specification
 for description of the properties of atomic variables.

 <p><a name="bitEquals">This class compares primitive {@code double}
 values in methods such as {@link #compareAndSet} by comparing their
 bitwise representation using {@link Double#doubleToRawLongBits},
 which differs from both the primitive double {@code ==} operator
 and from {@link Double#equals}, as if implemented by:
  <pre> {@code
 static boolean bitEquals(double x, double y) {
   long xBits = Double.doubleToRawLongBits(x);
   long yBits = Double.doubleToRawLongBits(y);
   return xBits == yBits;
 }}</pre>

 @author Doug Lea
 @author Martin Buchholz
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AtomicDoubleArray -->
  <!-- start class com.google.common.util.concurrent.AtomicLongMap -->
  <class name="AtomicLongMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.AtomicLongMap&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an {@code AtomicLongMap}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.util.concurrent.AtomicLongMap&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Creates an {@code AtomicLongMap} with the same mappings as the specified {@code Map}.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key}, or zero if there is no value associated with
 {@code key}.]]>
      </doc>
    </method>
    <method name="incrementAndGet" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Increments by one the value currently associated with {@code key}, and returns the new value.]]>
      </doc>
    </method>
    <method name="decrementAndGet" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Decrements by one the value currently associated with {@code key}, and returns the new value.]]>
      </doc>
    </method>
    <method name="addAndGet" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Adds {@code delta} to the value currently associated with {@code key}, and returns the new
 value.]]>
      </doc>
    </method>
    <method name="getAndIncrement" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Increments by one the value currently associated with {@code key}, and returns the old value.]]>
      </doc>
    </method>
    <method name="getAndDecrement" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Decrements by one the value currently associated with {@code key}, and returns the old value.]]>
      </doc>
    </method>
    <method name="getAndAdd" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Adds {@code delta} to the value currently associated with {@code key}, and returns the old
 value.]]>
      </doc>
    </method>
    <method name="put" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="newValue" type="long"/>
      <doc>
      <![CDATA[Associates {@code newValue} with {@code key} in this map, and returns the value previously
 associated with {@code key}, or zero if there was no such value.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Copies all of the mappings from the specified map to this map. The effect of this call is
 equivalent to that of calling {@code put(k, v)} on this map once for each mapping from key
 {@code k} to value {@code v} in the specified map. The behavior of this operation is undefined
 if the specified map is modified while the operation is in progress.]]>
      </doc>
    </method>
    <method name="remove" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Removes and returns the value associated with {@code key}. If {@code key} is not
 in the map, this method has no effect and returns zero.]]>
      </doc>
    </method>
    <method name="removeAllZeros"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all mappings from this map whose values are zero.

 <p>This method is not atomic: the map may be visible in intermediate states, where some
 of the zero values have been removed and others have not.]]>
      </doc>
    </method>
    <method name="sum" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sum of all values in this map.

 <p>This method is not atomic: the sum may or may not include other concurrent operations.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a live, read-only view of the map backing this {@code AtomicLongMap}.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if this map contains a mapping for the specified key.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value mappings in this map. If the map contains more than
 {@code Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this map contains no key-value mappings.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all of the mappings from this map. The map will be empty after this call returns.

 <p>This method is not atomic: the map may not be empty after returning if there were concurrent
 writes.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A map containing {@code long} values that can be atomically updated. While writes to a
 traditional {@code Map} rely on {@code put(K, V)}, the typical mechanism for writing to this map
 is {@code addAndGet(K, long)}, which adds a {@code long} to the value currently associated with
 {@code K}. If a key has not yet been associated with a value, its implicit value is zero.

 <p>Most methods in this class treat absent values and zero values identically, as individually
 documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty},
 {@link #asMap}, and {@link #toString}.

 <p>Instances of this class may be used by multiple threads concurrently. All operations are
 atomic unless otherwise noted.

 <p><b>Note:</b> If your values are always positive and less than 2^31, you may wish to use a
 {@link com.google.common.collect.Multiset} such as
 {@link com.google.common.collect.ConcurrentHashMultiset} instead.

 <b>Warning:</b> Unlike {@code Multiset}, entries whose values are zero are not automatically
 removed from the map. Instead they must be removed manually with {@link #removeAllZeros}.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AtomicLongMap -->
  <!-- start class com.google.common.util.concurrent.Atomics -->
  <class name="Atomics" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReference" return="java.util.concurrent.atomic.AtomicReference&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an {@code AtomicReference} instance with no initial value.

 @return a new {@code AtomicReference} with no initial value]]>
      </doc>
    </method>
    <method name="newReference" return="java.util.concurrent.atomic.AtomicReference&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialValue" type="V"/>
      <doc>
      <![CDATA[Creates an {@code AtomicReference} instance with the given initial value.

 @param initialValue the initial value
 @return a new {@code AtomicReference} with the given initial value]]>
      </doc>
    </method>
    <method name="newReferenceArray" return="java.util.concurrent.atomic.AtomicReferenceArray&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Creates an {@code AtomicReferenceArray} instance of given length.

 @param length the length of the array
 @return a new {@code AtomicReferenceArray} with the given length]]>
      </doc>
    </method>
    <method name="newReferenceArray" return="java.util.concurrent.atomic.AtomicReferenceArray&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="E[]"/>
      <doc>
      <![CDATA[Creates an {@code AtomicReferenceArray} instance with the same length as,
 and all elements copied from, the given array.

 @param array the array to copy elements from
 @return a new {@code AtomicReferenceArray} copied from the given array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to classes in the
 {@code java.util.concurrent.atomic} package.

 @author Kurt Alfred Kluever
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Atomics -->
  <!-- start class com.google.common.util.concurrent.Callables -->
  <class name="Callables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="returning" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Creates a {@code Callable} which immediately returns a preset value each
 time it is called.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Callable} interface.

 @author Isaac Shum
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Callables -->
  <!-- start interface com.google.common.util.concurrent.CheckedFuture -->
  <interface name="CheckedFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Exception checking version of {@link Future#get()} that will translate
 {@link InterruptedException}, {@link CancellationException} and
 {@link ExecutionException} into application-specific exceptions.

 @return the result of executing the future.
 @throws X on interruption, cancellation or execution exceptions.]]>
      </doc>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Exception checking version of {@link Future#get(long, TimeUnit)} that will
 translate {@link InterruptedException}, {@link CancellationException} and
 {@link ExecutionException} into application-specific exceptions.  On
 timeout this method throws a normal {@link TimeoutException}.

 @return the result of executing the future.
 @throws TimeoutException if retrieving the result timed out.
 @throws X on interruption, cancellation or execution exceptions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code CheckedFuture} is a {@link ListenableFuture} that includes versions
 of the {@code get} methods that can throw a checked exception.  This makes it
 easier to create a future that executes logic which can throw an exception.

 <p>A common implementation is {@link Futures#immediateCheckedFuture}.

 <p>Implementations of this interface must adapt the exceptions thrown by
 {@code Future#get()}: {@link CancellationException},
 {@link ExecutionException} and {@link InterruptedException} into the type
 specified by the {@code E} type parameter.

 <p>This interface also extends the ListenableFuture interface to allow
 listeners to be added. This allows the future to be used as a normal
 {@link Future} or as an asynchronous callback mechanism as needed. This
 allows multiple callbacks to be registered for a particular task, and the
 future will guarantee execution of all listeners when the task completes.
 
 <p>For a simpler alternative to CheckedFuture, consider accessing Future 
 values with {@link Futures#get(Future, Class) Futures.get()}.

 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.CheckedFuture -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory -->
  <class name="CycleDetectingLockFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newInstance" return="com.google.common.util.concurrent.CycleDetectingLockFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="policy" type="com.google.common.util.concurrent.CycleDetectingLockFactory.Policy"/>
      <doc>
      <![CDATA[Creates a new factory with the specified policy.]]>
      </doc>
    </method>
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantLock(lockName, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantLock} with the given fairness policy. The
 {@code lockName} is used in the warning or exception output to help
 identify the locks involved in the detected deadlock.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantReadWriteLock(lockName, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantReadWriteLock} with the given fairness policy.
 The {@code lockName} is used in the warning or exception output to help
 identify the locks involved in the detected deadlock.]]>
      </doc>
    </method>
    <method name="newInstanceWithExplicitOrdering" return="com.google.common.util.concurrent.CycleDetectingLockFactory.WithExplicitOrdering&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumClass" type="java.lang.Class&lt;E&gt;"/>
      <param name="policy" type="com.google.common.util.concurrent.CycleDetectingLockFactory.Policy"/>
      <doc>
      <![CDATA[Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The {@code CycleDetectingLockFactory} creates {@link ReentrantLock}s and
 {@link ReentrantReadWriteLock}s that detect potential deadlock by checking
 for cycles in lock acquisition order.
 <p>
 Potential deadlocks detected when calling the {@code lock()},
 {@code lockInterruptibly()}, or {@code tryLock()} methods will result in the
 execution of the {@link Policy} specified when creating the factory. The
 currently available policies are:
 <ul>
 <li>DISABLED
 <li>WARN
 <li>THROW
 </ul>
 The locks created by a factory instance will detect lock acquisition cycles
 with locks created by other {@code CycleDetectingLockFactory} instances
 (except those with {@code Policy.DISABLED}). A lock's behavior when a cycle
 is detected, however, is defined by the {@code Policy} of the factory that
 created it. This allows detection of cycles across components while
 delegating control over lock behavior to individual components.
 <p>
 Applications are encouraged to use a {@code CycleDetectingLockFactory} to
 create any locks for which external/unmanaged code is executed while the lock
 is held. (See caveats under <strong>Performance</strong>).
 <p>
 <strong>Cycle Detection</strong>
 <p>
 Deadlocks can arise when locks are acquired in an order that forms a cycle.
 In a simple example involving two locks and two threads, deadlock occurs
 when one thread acquires Lock A, and then Lock B, while another thread
 acquires Lock B, and then Lock A:
 <pre>
 Thread1: acquire(LockA) --X acquire(LockB)
 Thread2: acquire(LockB) --X acquire(LockA)
 </pre>
 Neither thread will progress because each is waiting for the other. In more
 complex applications, cycles can arise from interactions among more than 2
 locks:
 <pre>
 Thread1: acquire(LockA) --X acquire(LockB)
 Thread2: acquire(LockB) --X acquire(LockC)
 ...
 ThreadN: acquire(LockN) --X acquire(LockA)
 </pre>
 The implementation detects cycles by constructing a directed graph in which
 each lock represents a node and each edge represents an acquisition ordering
 between two locks.
 <ul>
 <li>Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired
   locks when the Thread acquires its first hold (and releases its last
   remaining hold).
 <li>Before the lock is acquired, the lock is checked against the current set
   of acquired locks---to each of the acquired locks, an edge from the
   soon-to-be-acquired lock is either verified or created.
 <li>If a new edge needs to be created, the outgoing edges of the acquired
   locks are traversed to check for a cycle that reaches the lock to be
   acquired. If no cycle is detected, a new "safe" edge is created.
 <li>If a cycle is detected, an "unsafe" (cyclic) edge is created to represent
   a potential deadlock situation, and the appropriate Policy is executed.
 </ul>
 Note that detection of potential deadlock does not necessarily indicate that
 deadlock will happen, as it is possible that higher level application logic
 prevents the cyclic lock acquisition from occurring. One example of a false
 positive is:
 <pre>
 LockA -&gt; LockB -&gt; LockC
 LockA -&gt; LockC -&gt; LockB
 </pre>

 <strong>ReadWriteLocks</strong>
 <p>
 While {@code ReadWriteLock}s have different properties and can form cycles
 without potential deadlock, this class treats {@code ReadWriteLock}s as
 equivalent to traditional exclusive locks. Although this increases the false
 positives that the locks detect (i.e. cycles that will not actually result in
 deadlock), it simplifies the algorithm and implementation considerably. The
 assumption is that a user of this factory wishes to eliminate any cyclic
 acquisition ordering.
 <p>
 <strong>Explicit Lock Acquisition Ordering</strong>
 <p>
 The {@link CycleDetectingLockFactory.WithExplicitOrdering} class can be used
 to enforce an application-specific ordering in addition to performing general
 cycle detection.
 <p>
 <strong>Garbage Collection</strong>
 <p>
 In order to allow proper garbage collection of unused locks, the edges of
 the lock graph are weak references.
 <p>
 <strong>Performance</strong>
 <p>
 The extra bookkeeping done by cycle detecting locks comes at some cost to
 performance. Benchmarks (as of December 2011) show that:

 <ul>
 <li>for an unnested {@code lock()} and {@code unlock()}, a cycle detecting
   lock takes 38ns as opposed to the 24ns taken by a plain lock.
 <li>for nested locking, the cost increases with the depth of the nesting:
   <ul>
   <li> 2 levels: average of 64ns per lock()/unlock()
   <li> 3 levels: average of 77ns per lock()/unlock()
   <li> 4 levels: average of 99ns per lock()/unlock()
   <li> 5 levels: average of 103ns per lock()/unlock()
   <li>10 levels: average of 184ns per lock()/unlock()
   <li>20 levels: average of 393ns per lock()/unlock()
   </ul>
 </ul>

 As such, the CycleDetectingLockFactory may not be suitable for
 performance-critical applications which involve tightly-looped or
 deeply-nested locking algorithms.

 @author Darick Tong
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory.Policies -->
  <class name="CycleDetectingLockFactory.Policies" extends="java.lang.Enum&lt;com.google.common.util.concurrent.CycleDetectingLockFactory.Policies&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.CycleDetectingLockFactory.Policy"/>
    <method name="values" return="com.google.common.util.concurrent.CycleDetectingLockFactory.Policies[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.util.concurrent.CycleDetectingLockFactory.Policies"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Pre-defined {@link Policy} implementations.

 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory.Policies -->
  <!-- start interface com.google.common.util.concurrent.CycleDetectingLockFactory.Policy -->
  <interface name="CycleDetectingLockFactory.Policy"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handlePotentialDeadlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException"/>
      <doc>
      <![CDATA[Called when a potential deadlock is encountered. Implementations can
 throw the given {@code exception} and/or execute other desired logic.
 <p>
 Note that the method will be called even upon an invocation of
 {@code tryLock()}. Although {@code tryLock()} technically recovers from
 deadlock by eventually timing out, this behavior is chosen based on the
 assumption that it is the application's wish to prohibit any cyclical
 lock acquisitions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encapsulates the action to be taken when a potential deadlock is
 encountered. Clients can use one of the predefined {@link Policies} or
 specify a custom implementation. Implementations must be thread-safe.

 @since 13.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.CycleDetectingLockFactory.Policy -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException -->
  <class name="CycleDetectingLockFactory.PotentialDeadlockException" extends="com.google.common.util.concurrent.CycleDetectingLockFactory.ExampleStackTrace"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getConflictingStackTrace" return="com.google.common.util.concurrent.CycleDetectingLockFactory.ExampleStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Appends the chain of messages from the {@code conflictingStackTrace} to
 the original {@code message}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a detected cycle in lock acquisition ordering. The exception
 includes a causal chain of {@code ExampleStackTrace}s to illustrate the
 cycle, e.g.

 <pre>
 com....PotentialDeadlockException: Potential Deadlock from LockC -&gt; ReadWriteA
   at ...
   at ...
 Caused by: com...ExampleStackTrace: LockB -&gt; LockC
   at ...
   at ...
 Caused by: com...ExampleStackTrace: ReadWriteA -&gt; LockB
   at ...
   at ...
 </pre>

 Instances are logged for the {@code Policies.WARN}, and thrown for
 {@code Policies.THROW}.

 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory.WithExplicitOrdering -->
  <class name="CycleDetectingLockFactory.WithExplicitOrdering" extends="com.google.common.util.concurrent.CycleDetectingLockFactory"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantLock(rank, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantLock} with the given fairness policy and rank.
 The values returned by {@link Enum#getDeclaringClass()} and
 {@link Enum#name()} are used to describe the lock in warning or
 exception output.

 @throws IllegalStateException If the factory has already created a
    {@code Lock} with the specified rank.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantReadWriteLock(rank, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantReadWriteLock} with the given fairness policy
 and rank. The values returned by {@link Enum#getDeclaringClass()} and
 {@link Enum#name()} are used to describe the lock in warning or exception
 output.

 @throws IllegalStateException If the factory has already created a
    {@code Lock} with the specified rank.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code CycleDetectingLockFactory.WithExplicitOrdering} provides the
 additional enforcement of an application-specified ordering of lock
 acquisitions. The application defines the allowed ordering with an
 {@code Enum} whose values each correspond to a lock type. The order in
 which the values are declared dictates the allowed order of lock
 acquisition. In other words, locks corresponding to smaller values of
 {@link Enum#ordinal()} should only be acquired before locks with larger
 ordinals. Example:

 <pre>   {@code
 enum MyLockOrder {
   FIRST, SECOND, THIRD;
 }

 CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory =
   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(Policies.THROW);

 Lock lock1 = factory.newReentrantLock(MyLockOrder.FIRST);
 Lock lock2 = factory.newReentrantLock(MyLockOrder.SECOND);
 Lock lock3 = factory.newReentrantLock(MyLockOrder.THIRD);

 lock1.lock();
 lock3.lock();
 lock2.lock();  // will throw an IllegalStateException
 }</pre>

 As with all locks created by instances of {@code CycleDetectingLockFactory}
 explicitly ordered locks participate in general cycle detection with all
 other cycle detecting locks, and a lock's behavior when detecting a cyclic
 lock acquisition is defined by the {@code Policy} of the factory that
 created it.
 <p>
 Note, however, that although multiple locks can be created for a given Enum
 value, whether it be through separate factory instances or through multiple
 calls to the same factory, attempting to acquire multiple locks with the
 same Enum value (within the same thread) will result in an
 IllegalStateException regardless of the factory's policy. For example:

 <pre>   {@code
 CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory1 =
   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);
 CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory2 =
   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);

 Lock lockA = factory1.newReentrantLock(MyLockOrder.FIRST);
 Lock lockB = factory1.newReentrantLock(MyLockOrder.FIRST);
 Lock lockC = factory2.newReentrantLock(MyLockOrder.FIRST);

 lockA.lock();

 lockB.lock();  // will throw an IllegalStateException
 lockC.lock();  // will throw an IllegalStateException

 lockA.lock();  // reentrant acquisition is okay
 }</pre>

 It is the responsibility of the application to ensure that multiple lock
 instances with the same rank are never acquired in the same thread.

 @param <E> The Enum type representing the explicit lock ordering.
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory.WithExplicitOrdering -->
  <!-- start class com.google.common.util.concurrent.ExecutionError -->
  <class name="ExecutionError" extends="java.lang.Error"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExecutionError"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with {@code null} as its detail message.]]>
      </doc>
    </constructor>
    <constructor name="ExecutionError" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given detail message.]]>
      </doc>
    </constructor>
    <constructor name="ExecutionError" type="java.lang.String, java.lang.Error"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given detail message and cause.]]>
      </doc>
    </constructor>
    <constructor name="ExecutionError" type="java.lang.Error"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[{@link Error} variant of {@link java.util.concurrent.ExecutionException}. As
 with {@code ExecutionException}, the error's {@linkplain #getCause() cause}
 comes from a failed task, possibly run in another thread. That cause should
 itself be an {@code Error}; if not, use {@code ExecutionException} or {@link
 UncheckedExecutionException}. This allows the client code to continue to
 distinguish between exceptions and errors, even when they come from other
 threads.

 @author Chris Povirk
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ExecutionError -->
  <!-- start class com.google.common.util.concurrent.ExecutionList -->
  <class name="ExecutionList" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExecutionList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@link ExecutionList}.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Adds the {@code Runnable} and accompanying {@code Executor} to the list of
 listeners to execute. If execution has already begun, the listener is
 executed immediately.

 <p>Note: For fast, lightweight listeners that would be safe to execute in
 any thread, consider {@link MoreExecutors#sameThreadExecutor}. For heavier
 listeners, {@code sameThreadExecutor()} carries some caveats: First, the
 thread that the listener runs in depends on whether the {@code
 ExecutionList} has been executed at the time it is added. In particular,
 listeners may run in the thread that calls {@code add}. Second, the thread
 that calls {@link #execute} may be an internal implementation thread, such
 as an RPC network thread, and {@code sameThreadExecutor()} listeners may
 run in this thread. Finally, during the execution of a {@code
 sameThreadExecutor} listener, all other registered but unexecuted
 listeners are prevented from running, even if those listeners are to run
 in other executors.]]>
      </doc>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Runs this execution list, executing all existing pairs in the order they
 were added. However, note that listeners added after this point may be
 executed before those previously added, and note that the execution order
 of all listeners is ultimately chosen by the implementations of the
 supplied executors.

 <p>This method is idempotent. Calling it several times in parallel is
 semantically equivalent to calling it exactly once.

 @since 10.0 (present in 1.0 as {@code run})]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>A list of listeners, each with an associated {@code Executor}, that
 guarantees that every {@code Runnable} that is {@linkplain #add added} will
 be executed after {@link #execute()} is called. Any {@code Runnable} added
 after the call to {@code execute} is still guaranteed to execute. There is no
 guarantee, however, that listeners will be executed in the order that they
 are added.

 <p>Exceptions thrown by a listener will be propagated up to the executor.
 Any exception thrown during {@code Executor.execute} (e.g., a {@code
 RejectedExecutionException} or an exception thrown by {@linkplain
 MoreExecutors#sameThreadExecutor inline execution}) will be caught and
 logged.

 @author Nishant Thakkar
 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ExecutionList -->
  <!-- start class com.google.common.util.concurrent.FakeTimeLimiter -->
  <class name="FakeTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <constructor name="FakeTimeLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="amInterruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter implementation which actually does not attempt to limit time
 at all.  This may be desirable to use in some unit tests.  More importantly,
 attempting to debug a call which is time-limited would be extremely annoying,
 so this gives you a time-limiter you can easily swap in for your real
 time-limiter while you're debugging.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.FakeTimeLimiter -->
  <!-- start class com.google.common.util.concurrent.ForwardingBlockingQueue -->
  <class name="ForwardingBlockingQueue" extends="com.google.common.collect.ForwardingQueue&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
    <constructor name="ForwardingBlockingQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.BlockingQueue&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="maxElements" type="int"/>
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="remainingCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="take" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[A {@link BlockingQueue} which forwards all its method calls to another
 {@link BlockingQueue}. Subclasses should override one or more methods to
 modify the behavior of the backing collection as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Raimundo Mirisola

 @param <E> the type of elements held in this collection
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingBlockingQueue -->
  <!-- start class com.google.common.util.concurrent.ForwardingCheckedFuture -->
  <class name="ForwardingCheckedFuture" extends="com.google.common.util.concurrent.ForwardingListenableFuture&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"/>
    <constructor name="ForwardingCheckedFuture"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="checkedGet" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="delegate" return="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A future which forwards all its method calls to another future. Subclasses
 should override one or more methods to modify the behavior of the backing 
 future as desired per the <a href=
 "http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>Most subclasses can simply extend {@link SimpleForwardingCheckedFuture}.
 
 @param <V> The result type returned by this Future's {@code get} method
 @param <X> The type of the Exception thrown by the Future's 
            {@code checkedGet} method

 @author Anthony Zana
 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingCheckedFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingCheckedFuture.SimpleForwardingCheckedFuture -->
  <class name="ForwardingCheckedFuture.SimpleForwardingCheckedFuture" extends="com.google.common.util.concurrent.ForwardingCheckedFuture&lt;V, X&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingCheckedFuture.SimpleForwardingCheckedFuture" type="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingCheckedFuture} where subclasses
 can pass in an already constructed {@link CheckedFuture} as the delegate.
 
 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingCheckedFuture.SimpleForwardingCheckedFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingExecutorService -->
  <class name="ForwardingExecutorService" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <constructor name="ForwardingExecutorService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.ExecutorService"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAny" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="invokeAny" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdownNow" return="java.util.List&lt;java.lang.Runnable&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="T"/>
    </method>
    <doc>
    <![CDATA[An executor service which forwards all its method calls to another executor
 service. Subclasses should override one or more methods to modify the
 behavior of the backing executor service as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Kurt Alfred Kluever
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingExecutorService -->
  <!-- start class com.google.common.util.concurrent.ForwardingFuture -->
  <class name="ForwardingFuture" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <constructor name="ForwardingFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.Future&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[A {@link Future} which forwards all its method calls to another future.
 Subclasses should override one or more methods to modify the behavior of
 the backing future as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>Most subclasses can just use {@link SimpleForwardingFuture}.
 
 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture -->
  <class name="ForwardingFuture.SimpleForwardingFuture" extends="com.google.common.util.concurrent.ForwardingFuture&lt;V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingFuture.SimpleForwardingFuture" type="java.util.concurrent.Future&lt;V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="java.util.concurrent.Future&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingFuture} where subclasses
 can pass in an already constructed {@link Future} as the delegate.
 
 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingListenableFuture -->
  <class name="ForwardingListenableFuture" extends="com.google.common.util.concurrent.ForwardingFuture&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="ForwardingListenableFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <doc>
    <![CDATA[A {@link ListenableFuture} which forwards all its method calls to another
 future. Subclasses should override one or more methods to modify the behavior
 of the backing future as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>Most subclasses can just use {@link SimpleForwardingListenableFuture}.

 @param <V> The result type returned by this Future's {@code get} method
 
 @author Shardul Deo
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture -->
  <class name="ForwardingListenableFuture.SimpleForwardingListenableFuture" extends="com.google.common.util.concurrent.ForwardingListenableFuture&lt;V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingListenableFuture.SimpleForwardingListenableFuture" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingListenableFuture} where subclasses
 can pass in an already constructed {@link ListenableFuture} 
 as the delegate.
 
 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingListeningExecutorService -->
  <class name="ForwardingListeningExecutorService" extends="com.google.common.util.concurrent.ForwardingExecutorService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListeningExecutorService"/>
    <constructor name="ForwardingListeningExecutorService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.ListeningExecutorService"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="T"/>
    </method>
    <doc>
    <![CDATA[A listening executor service which forwards all its method calls to another
 listening executor service. Subclasses should override one or more methods to
 modify the behavior of the backing executor service as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Isaac Shum
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingListeningExecutorService -->
  <!-- start class com.google.common.util.concurrent.ForwardingService -->
  <class name="ForwardingService" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="ForwardingService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.Service"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="start" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="standardStartAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible default implementation of {@link #startAndWait()}, in terms of
 {@link #start}. If you override {@link #start}, you may wish to override
 {@link #startAndWait()} to forward to this implementation.
 @since 9.0]]>
      </doc>
    </method>
    <method name="standardStopAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible default implementation of {@link #stopAndWait()}, in terms of
 {@link #stop}. If you override {@link #stop}, you may wish to override
 {@link #stopAndWait()} to forward to this implementation.
 @since 9.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Service} that forwards all method calls to another service.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingService -->
  <!-- start interface com.google.common.util.concurrent.FutureCallback -->
  <interface name="FutureCallback"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onSuccess"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="V"/>
      <doc>
      <![CDATA[Invoked with the result of the {@code Future} computation when it is
 successful.]]>
      </doc>
    </method>
    <method name="onFailure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Invoked when a {@code Future} computation fails or is canceled.

 <p>If the future's {@link Future#get() get} method throws an {@link
 ExecutionException}, then the cause is passed to this method. Any other
 thrown object is passed unaltered.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback for accepting the results of a {@link java.util.concurrent.Future}
 computation asynchronously.

 <p>To attach to a {@link ListenableFuture} use {@link Futures#addCallback}.

 @author Anthony Zana
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.FutureCallback -->
  <!-- start class com.google.common.util.concurrent.Futures -->
  <class name="Futures" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="makeChecked" return="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <param name="mapper" type="com.google.common.base.Function&lt;java.lang.Exception, X&gt;"/>
      <doc>
      <![CDATA[Creates a {@link CheckedFuture} out of a normal {@link ListenableFuture}
 and a {@link Function} that maps from {@link Exception} instances into the
 appropriate checked type.

 <p>The given mapping function will be applied to an
 {@link InterruptedException}, a {@link CancellationException}, or an
 {@link ExecutionException} with the actual cause of the exception.
 See {@link Future#get()} for details on the exceptions thrown.

 @since 9.0 (source-compatible since 1.0)]]>
      </doc>
    </method>
    <method name="immediateFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFuture} which has its value set immediately upon
 construction. The getters just return the value. This {@code Future} can't
 be canceled or timed out and its {@code isDone()} method always returns
 {@code true}.]]>
      </doc>
    </method>
    <method name="immediateCheckedFuture" return="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns a {@code CheckedFuture} which has its value set immediately upon
 construction.

 <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
 method always returns {@code true}. Calling {@code get()} or {@code
 checkedGet()} will immediately return the provided value.]]>
      </doc>
    </method>
    <method name="immediateFailedFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns a {@code ListenableFuture} which has an exception set immediately
 upon construction.

 <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
 method always returns {@code true}. Calling {@code get()} will immediately
 throw the provided {@code Throwable} wrapped in an {@code
 ExecutionException}.

 @throws Error if the throwable is an {@link Error}.]]>
      </doc>
    </method>
    <method name="immediateFailedCheckedFuture" return="com.google.common.util.concurrent.CheckedFuture&lt;V, X&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="X extends java.lang.Exception"/>
      <doc>
      <![CDATA[Returns a {@code CheckedFuture} which has an exception set immediately upon
 construction.

 <p>The returned {@code Future} can't be cancelled, and its {@code isDone()}
 method always returns {@code true}. Calling {@code get()} will immediately
 throw the provided {@code Throwable} wrapped in an {@code
 ExecutionException}, and calling {@code checkedGet()} will throw the
 provided exception itself.

 @throws Error if the throwable is an {@link Error}.]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.util.concurrent.AsyncFunction&lt;? super I, ? extends O&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code ListenableFuture} whose result is asynchronously
 derived from the result of the given {@code Future}. More precisely, the
 returned {@code Future} takes its result from a {@code Future} produced by
 applying the given {@code AsyncFunction} to the result of the original
 {@code Future}. Example:

 <pre>   {@code
   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);
   AsyncFunction<RowKey, QueryResult> queryFunction =
       new AsyncFunction<RowKey, QueryResult>() {
         public ListenableFuture<QueryResult> apply(RowKey rowKey) {
           return dataService.read(rowKey);
         }
       };
   ListenableFuture<QueryResult> queryFuture =
       transform(rowKeyFuture, queryFunction);
 }</pre>

 Note: If the derived {@code Future} is slow or heavyweight to create
 (whether the {@code Future} itself is slow or heavyweight to complete is
 irrelevant), consider {@linkplain #transform(ListenableFuture,
 AsyncFunction, Executor) supplying an executor}. If you do not supply an
 executor, {@code transform} will use {@link
 MoreExecutors#sameThreadExecutor sameThreadExecutor}, which carries some
 caveats for heavier operations. For example, the call to {@code
 function.apply} may run on an unpredictable or undesirable thread:

 <ul>
 <li>If the input {@code Future} is done at the time {@code transform} is
 called, {@code transform} will call {@code function.apply} inline.
 <li>If the input {@code Future} is not yet done, {@code transform} will
 schedule {@code function.apply} to be run by the thread that completes the
 input {@code Future}, which may be an internal system thread such as an
 RPC network thread.
 </ul>

 Also note that, regardless of which thread executes {@code
 function.apply}, all other registered but unexecuted listeners are
 prevented from running during its execution, even if those listeners are
 to run in other executors.

 <p>The returned {@code Future} attempts to keep its cancellation state in
 sync with that of the input future and that of the future returned by the
 function. That is, if the returned {@code Future} is cancelled, it will
 attempt to cancel the other two, and if either of the other two is
 cancelled, the returned {@code Future} will receive a callback in which it
 will attempt to cancel itself.

 @param input The future to transform
 @param function A function to transform the result of the input future
     to the result of the output future
 @return A future that holds result of the function (if the input succeeded)
     or the original input's failure (if not)
 @since 11.0]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.util.concurrent.AsyncFunction&lt;? super I, ? extends O&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ListenableFuture} whose result is asynchronously
 derived from the result of the given {@code Future}. More precisely, the
 returned {@code Future} takes its result from a {@code Future} produced by
 applying the given {@code AsyncFunction} to the result of the original
 {@code Future}. Example:

 <pre>   {@code
   ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);
   AsyncFunction<RowKey, QueryResult> queryFunction =
       new AsyncFunction<RowKey, QueryResult>() {
         public ListenableFuture<QueryResult> apply(RowKey rowKey) {
           return dataService.read(rowKey);
         }
       };
   ListenableFuture<QueryResult> queryFuture =
       transform(rowKeyFuture, queryFunction, executor);
 }</pre>

 <p>The returned {@code Future} attempts to keep its cancellation state in
 sync with that of the input future and that of the future returned by the
 chain function. That is, if the returned {@code Future} is cancelled, it
 will attempt to cancel the other two, and if either of the other two is
 cancelled, the returned {@code Future} will receive a callback in which it
 will attempt to cancel itself.

 <p>When the execution of {@code function.apply} is fast and lightweight
 (though the {@code Future} it returns need not meet these criteria),
 consider {@linkplain #transform(ListenableFuture, AsyncFunction) omitting
 the executor} or explicitly specifying {@code sameThreadExecutor}.
 However, be aware of the caveats documented in the link above.

 @param input The future to transform
 @param function A function to transform the result of the input future
     to the result of the output future
 @param executor Executor to run the function in.
 @return A future that holds result of the function (if the input succeeded)
     or the original input's failure (if not)
 @since 11.0]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code ListenableFuture} whose result is the product of
 applying the given {@code Function} to the result of the given {@code
 Future}. Example:

 <pre>   {@code
   ListenableFuture<QueryResult> queryFuture = ...;
   Function<QueryResult, List<Row>> rowsFunction =
       new Function<QueryResult, List<Row>>() {
         public List<Row> apply(QueryResult queryResult) {
           return queryResult.getRows();
         }
       };
   ListenableFuture<List<Row>> rowsFuture =
       transform(queryFuture, rowsFunction);
 }</pre>

 Note: If the transformation is slow or heavyweight, consider {@linkplain
 #transform(ListenableFuture, Function, Executor) supplying an executor}.
 If you do not supply an executor, {@code transform} will use {@link
 MoreExecutors#sameThreadExecutor sameThreadExecutor}, which carries some
 caveats for heavier operations.  For example, the call to {@code
 function.apply} may run on an unpredictable or undesirable thread:

 <ul>
 <li>If the input {@code Future} is done at the time {@code transform} is
 called, {@code transform} will call {@code function.apply} inline.
 <li>If the input {@code Future} is not yet done, {@code transform} will
 schedule {@code function.apply} to be run by the thread that completes the
 input {@code Future}, which may be an internal system thread such as an
 RPC network thread.
 </ul>

 Also note that, regardless of which thread executes {@code
 function.apply}, all other registered but unexecuted listeners are
 prevented from running during its execution, even if those listeners are
 to run in other executors.

 <p>The returned {@code Future} attempts to keep its cancellation state in
 sync with that of the input future. That is, if the returned {@code Future}
 is cancelled, it will attempt to cancel the input, and if the input is
 cancelled, the returned {@code Future} will receive a callback in which it
 will attempt to cancel itself.

 <p>An example use of this method is to convert a serializable object
 returned from an RPC into a POJO.

 @param input The future to transform
 @param function A Function to transform the results of the provided future
     to the results of the returned future.  This will be run in the thread
     that notifies input it is complete.
 @return A future that holds result of the transformation.
 @since 9.0 (in 1.0 as {@code compose})]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ListenableFuture} whose result is the product of
 applying the given {@code Function} to the result of the given {@code
 Future}. Example:

 <pre>   {@code
   ListenableFuture<QueryResult> queryFuture = ...;
   Function<QueryResult, List<Row>> rowsFunction =
       new Function<QueryResult, List<Row>>() {
         public List<Row> apply(QueryResult queryResult) {
           return queryResult.getRows();
         }
       };
   ListenableFuture<List<Row>> rowsFuture =
       transform(queryFuture, rowsFunction, executor);
 }</pre>

 <p>The returned {@code Future} attempts to keep its cancellation state in
 sync with that of the input future. That is, if the returned {@code Future}
 is cancelled, it will attempt to cancel the input, and if the input is
 cancelled, the returned {@code Future} will receive a callback in which it
 will attempt to cancel itself.

 <p>An example use of this method is to convert a serializable object
 returned from an RPC into a POJO.

 <p>When the transformation is fast and lightweight, consider {@linkplain
 #transform(ListenableFuture, Function) omitting the executor} or
 explicitly specifying {@code sameThreadExecutor}. However, be aware of the
 caveats documented in the link above.

 @param input The future to transform
 @param function A Function to transform the results of the provided future
     to the results of the returned future.
 @param executor Executor to run the function in.
 @return A future that holds result of the transformation.
 @since 9.0 (in 2.0 as {@code compose})]]>
      </doc>
    </method>
    <method name="lazyTransform" return="java.util.concurrent.Future&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.util.concurrent.Future&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <doc>
      <![CDATA[Like {@link #transform(ListenableFuture, Function)} except that the
 transformation {@code function} is invoked on each call to
 {@link Future#get() get()} on the returned future.

 <p>The returned {@code Future} reflects the input's cancellation
 state directly, and any attempt to cancel the returned Future is likewise
 passed through to the input Future.

 <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get}
 only apply the timeout to the execution of the underlying {@code Future},
 <em>not</em> to the execution of the transformation function.

 <p>The primary audience of this method is callers of {@code transform}
 who don't have a {@code ListenableFuture} available and
 do not mind repeated, lazy function evaluation.

 @param input The future to transform
 @param function A Function to transform the results of the provided future
     to the results of the returned future.
 @return A future that returns the result of the transformation.
 @since 10.0]]>
      </doc>
    </method>
    <method name="dereference" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nested" type="com.google.common.util.concurrent.ListenableFuture&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code ListenableFuture} whose result is the product of
 calling {@code get()} on the {@code Future} nested within the given {@code
 Future}, effectively chaining the futures one after the other.  Example:

 <pre>   {@code
   SettableFuture<ListenableFuture<String>> nested = SettableFuture.create();
   ListenableFuture<String> dereferenced = dereference(nested);
 }</pre>

 <p>This call has the same cancellation and execution semantics as {@link
 #transform(ListenableFuture, AsyncFunction)}, in that the returned {@code
 Future} attempts to keep its cancellation state in sync with both the
 input {@code Future} and the nested {@code Future}.  The transformation
 is very lightweight and therefore takes place in the thread that called
 {@code dereference}.

 @param nested The nested future to transform.
 @return A future that holds result of the inner future.
 @since 13.0]]>
      </doc>
    </method>
    <method name="allAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="com.google.common.util.concurrent.ListenableFuture[]"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the
 values of all its input futures, if all succeed. If any input fails, the
 returned future fails.

 <p>The list of results is in the same order as the input list.

 <p>Canceling this future does not cancel any of the component futures;
 however, if any of the provided futures fails or is canceled, this one is,
 too.

 @param futures futures to combine
 @return a future that provides a list of the results of the component
         futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="allAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the
 values of all its input futures, if all succeed. If any input fails, the
 returned future fails.

 <p>The list of results is in the same order as the input list.

 <p>Canceling this future does not cancel any of the component futures;
 however, if any of the provided futures fails or is canceled, this one is,
 too.

 @param futures futures to combine
 @return a future that provides a list of the results of the component
         futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="successfulAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="com.google.common.util.concurrent.ListenableFuture[]"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the
 values of all its successful input futures. The list of results is in the
 same order as the input list, and if any of the provided futures fails or
 is canceled, its corresponding position will contain {@code null} (which is
 indistinguishable from the future having a successful value of
 {@code null}).

 @param futures futures to combine
 @return a future that provides a list of the results of the component
         futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="successfulAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the
 values of all its successful input futures. The list of results is in the
 same order as the input list, and if any of the provided futures fails or
 is canceled, its corresponding position will contain {@code null} (which is
 indistinguishable from the future having a successful value of
 {@code null}).

 @param futures futures to combine
 @return a future that provides a list of the results of the component
         futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="addCallback"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <param name="callback" type="com.google.common.util.concurrent.FutureCallback&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Registers separate success and failure callbacks to be run when the {@code
 Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()
 complete} or, if the computation is already complete, immediately.

 <p>There is no guaranteed ordering of execution of callbacks, but any
 callback added through this method is guaranteed to be called once the
 computation is complete.

 Example: <pre> {@code
 ListenableFuture<QueryResult> future = ...;
 addCallback(future,
     new FutureCallback<QueryResult> {
       public void onSuccess(QueryResult result) {
         storeInCache(result);
       }
       public void onFailure(Throwable t) {
         reportError(t);
       }
     });}</pre>

 Note: If the callback is slow or heavyweight, consider {@linkplain
 #addCallback(ListenableFuture, FutureCallback, Executor) supplying an
 executor}. If you do not supply an executor, {@code addCallback} will use
 {@link MoreExecutors#sameThreadExecutor sameThreadExecutor}, which carries
 some caveats for heavier operations. For example, the callback may run on
 an unpredictable or undesirable thread:

 <ul>
 <li>If the input {@code Future} is done at the time {@code addCallback} is
 called, {@code addCallback} will execute the callback inline.
 <li>If the input {@code Future} is not yet done, {@code addCallback} will
 schedule the callback to be run by the thread that completes the input
 {@code Future}, which may be an internal system thread such as an RPC
 network thread.
 </ul>

 Also note that, regardless of which thread executes the callback, all
 other registered but unexecuted listeners are prevented from running
 during its execution, even if those listeners are to run in other
 executors.

 <p>For a more general interface to attach a completion listener to a
 {@code Future}, see {@link ListenableFuture#addListener addListener}.

 @param future The future attach the callback to.
 @param callback The callback to invoke when {@code future} is completed.
 @since 10.0]]>
      </doc>
    </method>
    <method name="addCallback"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <param name="callback" type="com.google.common.util.concurrent.FutureCallback&lt;? super V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers separate success and failure callbacks to be run when the {@code
 Future}'s computation is {@linkplain java.util.concurrent.Future#isDone()
 complete} or, if the computation is already complete, immediately.

 <p>The callback is run in {@code executor}.
 There is no guaranteed ordering of execution of callbacks, but any
 callback added through this method is guaranteed to be called once the
 computation is complete.

 Example: <pre> {@code
 ListenableFuture<QueryResult> future = ...;
 Executor e = ...
 addCallback(future, e,
     new FutureCallback<QueryResult> {
       public void onSuccess(QueryResult result) {
         storeInCache(result);
       }
       public void onFailure(Throwable t) {
         reportError(t);
       }
     });}</pre>

 When the callback is fast and lightweight, consider {@linkplain
 #addCallback(ListenableFuture, FutureCallback) omitting the executor} or
 explicitly specifying {@code sameThreadExecutor}. However, be aware of the
 caveats documented in the link above.

 <p>For a more general interface to attach a completion listener to a
 {@code Future}, see {@link ListenableFuture#addListener addListener}.

 @param future The future attach the callback to.
 @param callback The callback to invoke when {@code future} is completed.
 @param executor The executor to run {@code callback} when the future
    completes.
 @since 10.0]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="exceptionClass" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns the result of {@link Future#get()}, converting most exceptions to a
 new instance of the given checked exception type. This reduces boilerplate
 for a common use of {@code Future} in which it is unnecessary to
 programmatically distinguish between exception types or to extract other
 information from the exception instance.

 <p>Exceptions from {@code Future.get} are treated as follows:
 <ul>
 <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an
     {@code X} if the cause is a checked exception, an {@link
     UncheckedExecutionException} if the cause is a {@code
     RuntimeException}, or an {@link ExecutionError} if the cause is an
     {@code Error}.
 <li>Any {@link InterruptedException} is wrapped in an {@code X} (after
     restoring the interrupt).
 <li>Any {@link CancellationException} is propagated untouched, as is any
     other {@link RuntimeException} (though {@code get} implementations are
     discouraged from throwing such exceptions).
 </ul>

 The overall principle is to continue to treat every checked exception as a
 checked exception, every unchecked exception as an unchecked exception, and
 every error as an error. In addition, the cause of any {@code
 ExecutionException} is wrapped in order to ensure that the new stack trace
 matches that of the current thread.

 <p>Instances of {@code exceptionClass} are created by choosing an arbitrary
 public constructor that accepts zero or more arguments, all of type {@code
 String} or {@code Throwable} (preferring constructors with at least one
 {@code String}) and calling the constructor via reflection. If the
 exception did not already have a cause, one is set by calling {@link
 Throwable#initCause(Throwable)} on it. If no such constructor exists, an
 {@code IllegalArgumentException} is thrown.

 @throws X if {@code get} throws any checked exception except for an {@code
         ExecutionException} whose cause is not itself a checked exception
 @throws UncheckedExecutionException if {@code get} throws an {@code
         ExecutionException} with a {@code RuntimeException} as its cause
 @throws ExecutionError if {@code get} throws an {@code ExecutionException}
         with an {@code Error} as its cause
 @throws CancellationException if {@code get} throws a {@code
         CancellationException}
 @throws IllegalArgumentException if {@code exceptionClass} extends {@code
         RuntimeException} or does not have a suitable constructor
 @since 10.0]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="exceptionClass" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns the result of {@link Future#get(long, TimeUnit)}, converting most
 exceptions to a new instance of the given checked exception type. This
 reduces boilerplate for a common use of {@code Future} in which it is
 unnecessary to programmatically distinguish between exception types or to
 extract other information from the exception instance.

 <p>Exceptions from {@code Future.get} are treated as follows:
 <ul>
 <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an
     {@code X} if the cause is a checked exception, an {@link
     UncheckedExecutionException} if the cause is a {@code
     RuntimeException}, or an {@link ExecutionError} if the cause is an
     {@code Error}.
 <li>Any {@link InterruptedException} is wrapped in an {@code X} (after
     restoring the interrupt).
 <li>Any {@link TimeoutException} is wrapped in an {@code X}.
 <li>Any {@link CancellationException} is propagated untouched, as is any
     other {@link RuntimeException} (though {@code get} implementations are
     discouraged from throwing such exceptions).
 </ul>

 The overall principle is to continue to treat every checked exception as a
 checked exception, every unchecked exception as an unchecked exception, and
 every error as an error. In addition, the cause of any {@code
 ExecutionException} is wrapped in order to ensure that the new stack trace
 matches that of the current thread.

 <p>Instances of {@code exceptionClass} are created by choosing an arbitrary
 public constructor that accepts zero or more arguments, all of type {@code
 String} or {@code Throwable} (preferring constructors with at least one
 {@code String}) and calling the constructor via reflection. If the
 exception did not already have a cause, one is set by calling {@link
 Throwable#initCause(Throwable)} on it. If no such constructor exists, an
 {@code IllegalArgumentException} is thrown.

 @throws X if {@code get} throws any checked exception except for an {@code
         ExecutionException} whose cause is not itself a checked exception
 @throws UncheckedExecutionException if {@code get} throws an {@code
         ExecutionException} with a {@code RuntimeException} as its cause
 @throws ExecutionError if {@code get} throws an {@code ExecutionException}
         with an {@code Error} as its cause
 @throws CancellationException if {@code get} throws a {@code
         CancellationException}
 @throws IllegalArgumentException if {@code exceptionClass} extends {@code
         RuntimeException} or does not have a suitable constructor
 @since 10.0]]>
      </doc>
    </method>
    <method name="getUnchecked" return="V"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns the result of calling {@link Future#get()} uninterruptibly on a
 task known not to throw a checked exception. This makes {@code Future} more
 suitable for lightweight, fast-running tasks that, barring bugs in the
 code, will not fail. This gives it exception-handling behavior similar to
 that of {@code ForkJoinTask.join}.

 <p>Exceptions from {@code Future.get} are treated as follows:
 <ul>
 <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an
     {@link UncheckedExecutionException} (if the cause is an {@code
     Exception}) or {@link ExecutionError} (if the cause is an {@code
     Error}).
 <li>Any {@link InterruptedException} causes a retry of the {@code get}
     call. The interrupt is restored before {@code getUnchecked} returns.
 <li>Any {@link CancellationException} is propagated untouched. So is any
     other {@link RuntimeException} ({@code get} implementations are
     discouraged from throwing such exceptions).
 </ul>

 The overall principle is to eliminate all checked exceptions: to loop to
 avoid {@code InterruptedException}, to pass through {@code
 CancellationException}, and to wrap any exception from the underlying
 computation in an {@code UncheckedExecutionException} or {@code
 ExecutionError}.

 <p>For an uninterruptible {@code get} that preserves other exceptions, see
 {@link Uninterruptibles#getUninterruptibly(Future)}.

 @throws UncheckedExecutionException if {@code get} throws an {@code
         ExecutionException} with an {@code Exception} as its cause
 @throws ExecutionError if {@code get} throws an {@code ExecutionException}
         with an {@code Error} as its cause
 @throws CancellationException if {@code get} throws a {@code
         CancellationException}
 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Future} interface.

 <p>Many of these methods use the {@link ListenableFuture} API; consult the
 Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained">
 {@code ListenableFuture}</a>.

 @author Kevin Bourrillion
 @author Nishant Thakkar
 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Futures -->
  <!-- start class com.google.common.util.concurrent.JdkFutureAdapters -->
  <class name="JdkFutureAdapters" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="listenInPoolThread" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <doc>
      <![CDATA[Assigns a thread to the given {@link Future} to provide {@link
 ListenableFuture} functionality.

 <p><b>Warning:</b> If the input future does not already implement {@code
 ListenableFuture}, the returned future will emulate {@link
 ListenableFuture#addListener} by taking a thread from an internal,
 unbounded pool at the first call to {@code addListener} and holding it
 until the future is {@linkplain Future#isDone() done}.

 <p>Prefer to create {@code ListenableFuture} instances with {@link
 SettableFuture}, {@link MoreExecutors#listeningDecorator(
 java.util.concurrent.ExecutorService)}, {@link ListenableFutureTask},
 {@link AbstractFuture}, and other utilities over creating plain {@code
 Future} instances to be upgraded to {@code ListenableFuture} after the
 fact.]]>
      </doc>
    </method>
    <method name="listenInPoolThread" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Submits a blocking task for the given {@link Future} to provide {@link
 ListenableFuture} functionality.

 <p><b>Warning:</b> If the input future does not already implement {@code
 ListenableFuture}, the returned future will emulate {@link
 ListenableFuture#addListener} by submitting a task to the given executor at
 at the first call to {@code addListener}. The task must be started by the
 executor promptly, or else the returned {@code ListenableFuture} may fail
 to work.  The task's execution consists of blocking until the input future
 is {@linkplain Future#isDone() done}, so each call to this method may
 claim and hold a thread for an arbitrary length of time. Use of bounded
 executors or other executors that may fail to execute a task promptly may
 result in deadlocks.

 <p>Prefer to create {@code ListenableFuture} instances with {@link
 SettableFuture}, {@link MoreExecutors#listeningDecorator(
 java.util.concurrent.ExecutorService)}, {@link ListenableFutureTask},
 {@link AbstractFuture}, and other utilities over creating plain {@code
 Future} instances to be upgraded to {@code ListenableFuture} after the
 fact.

 @since 12.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities necessary for working with libraries that supply plain {@link
 Future} instances. Note that, whenver possible, it is strongly preferred to
 modify those libraries to return {@code ListenableFuture} directly.

 @author Sven Mawson
 @since 10.0 (replacing {@code Futures.makeListenable}, which
     existed in 1.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.JdkFutureAdapters -->
  <!-- start interface com.google.common.util.concurrent.ListenableFuture -->
  <interface name="ListenableFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers a listener to be {@linkplain Executor#execute(Runnable) run} on
 the given executor.  The listener will run when the {@code Future}'s
 computation is {@linkplain Future#isDone() complete} or, if the computation
 is already complete, immediately.

 <p>There is no guaranteed ordering of execution of listeners, but any
 listener added through this method is guaranteed to be called once the
 computation is complete.

 <p>Exceptions thrown by a listener will be propagated up to the executor.
 Any exception thrown during {@code Executor.execute} (e.g., a {@code
 RejectedExecutionException} or an exception thrown by {@linkplain
 MoreExecutors#sameThreadExecutor inline execution}) will be caught and
 logged.

 <p>Note: For fast, lightweight listeners that would be safe to execute in
 any thread, consider {@link MoreExecutors#sameThreadExecutor}. For heavier
 listeners, {@code sameThreadExecutor()} carries some caveats.  For
 example, the listener may run on an unpredictable or undesirable thread:

 <ul>
 <li>If the input {@code Future} is done at the time {@code addListener} is
 called, {@code addListener} will execute the listener inline.
 <li>If the input {@code Future} is not yet done, {@code addListener} will
 schedule the listener to be run by the thread that completes the input
 {@code Future}, which may be an internal system thread such as an RPC
 network thread.
 </ul>

 Also note that, regardless of which thread executes the listener, all
 other registered but unexecuted listeners are prevented from running
 during its execution, even if those listeners are to run in other
 executors.

 <p>This is the most general listener interface. For common operations
 performed using listeners, see {@link
 com.google.common.util.concurrent.Futures}. For a simplified but general
 listener interface, see {@link
 com.google.common.util.concurrent.Futures#addCallback addCallback()}.

 @param listener the listener to run when the computation is complete
 @param executor the executor to run the listener in
 @throws NullPointerException if the executor or listener was null
 @throws RejectedExecutionException if we tried to execute the listener
         immediately but the executor rejected it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Future} that accepts completion listeners.  Each listener has an
 associated executor, and it is invoked using this executor once the future's
 computation is {@linkplain Future#isDone() complete}.  If the computation has
 already completed when the listener is added, the listener will execute
 immediately.
 
 <p>See the Guava User Guide article on <a href=
 "http://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained">
 {@code ListenableFuture}</a>.

 <h3>Purpose</h3>

 Most commonly, {@code ListenableFuture} is used as an input to another
 derived {@code Future}, as in {@link Futures#allAsList(Iterable)
 Futures.allAsList}. Many such methods are impossible to implement efficiently
 without listener support.

 <p>It is possible to call {@link #addListener addListener} directly, but this
 is uncommon because the {@code Runnable} interface does not provide direct
 access to the {@code Future} result. (Users who want such access may prefer
 {@link Futures#addCallback Futures.addCallback}.) Still, direct {@code
 addListener} calls are occasionally useful:<pre>   {@code
   final String name = ...;
   inFlight.add(name);
   ListenableFuture<Result> future = service.query(name);
   future.addListener(new Runnable() {
     public void run() {
       processedCount.incrementAndGet();
       inFlight.remove(name);
       lastProcessed.set(name);
       logger.info("Done with {0}", name);
     }
   }, executor);}</pre>

 <h3>How to get an instance</h3>

 Developers are encouraged to return {@code ListenableFuture} from their
 methods so that users can take advantages of the utilities built atop the
 class. The way that they will create {@code ListenableFuture} instances
 depends on how they currently create {@code Future} instances:
 <ul>
 <li>If they are returned from an {@code ExecutorService}, convert that
 service to a {@link ListeningExecutorService}, usually by calling {@link
 MoreExecutors#listeningDecorator(ExecutorService)
 MoreExecutors.listeningDecorator}. (Custom executors may find it more
 convenient to use {@link ListenableFutureTask} directly.)
 <li>If they are manually filled in by a call to {@link FutureTask#set} or a
 similar method, create a {@link SettableFuture} instead. (Users with more
 complex needs may prefer {@link AbstractFuture}.)
 </ul>

 Occasionally, an API will return a plain {@code Future} and it will be
 impossible to change the return type. For this case, we provide a more
 expensive workaround in {@code JdkFutureAdapters}. However, when possible, it
 is more efficient and reliable to create a {@code ListenableFuture} directly.

 @author Sven Mawson
 @author Nishant Thakkar
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ListenableFutureTask -->
  <class name="ListenableFutureTask" extends="java.util.concurrent.FutureTask&lt;V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <method name="create" return="com.google.common.util.concurrent.ListenableFutureTask&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;V&gt;"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the
 given {@code Callable}.

 @param callable the callable task
 @since 10.0]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.util.concurrent.ListenableFutureTask&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="result" type="V"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the
 given {@code Runnable}, and arrange that {@code get} will return the
 given result on successful completion.

 @param runnable the runnable task
 @param result the result to return on successful completion. If you don't
     need a particular result, consider using constructions of the form:
     {@code ListenableFuture<?> f = ListenableFutureTask.create(runnable,
     null)}
 @since 10.0]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Internal implementation detail used to invoke the listeners.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link FutureTask} that also implements the {@link ListenableFuture}
 interface.  Unlike {@code FutureTask}, {@code ListenableFutureTask} does not
 provide an overrideable {@link FutureTask#done() done()} method.  For similar
 functionality, call {@link #addListener}.
 
 <p>

 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ListenableFutureTask -->
  <!-- start interface com.google.common.util.concurrent.ListeningExecutorService -->
  <interface name="ListeningExecutorService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <doc>
      <![CDATA[@return a {@code ListenableFuture} representing pending completion of the task
 @throws RejectedExecutionException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[@return a {@code ListenableFuture} representing pending completion of the task
 @throws RejectedExecutionException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="T"/>
      <doc>
      <![CDATA[@return a {@code ListenableFuture} representing pending completion of the task
 @throws RejectedExecutionException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>All elements in the returned list must be {@link ListenableFuture} instances.

 @return A list of {@code ListenableFuture} instances representing the tasks, in the same
         sequential order as produced by the iterator for the given task list, each of which has
         completed.
 @throws RejectedExecutionException {@inheritDoc}
 @throws NullPointerException if any task is null]]>
      </doc>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>All elements in the returned list must be {@link ListenableFuture} instances.

 @return a list of {@code ListenableFuture} instances representing the tasks, in the same
         sequential order as produced by the iterator for the given task list. If the operation
         did not time out, each task will have completed. If it did time out, some of these
         tasks will not have completed.
 @throws RejectedExecutionException {@inheritDoc}
 @throws NullPointerException if any task is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link ExecutorService} that returns {@link ListenableFuture} instances. To create an instance
 from an existing {@link ExecutorService}, call
 {@link MoreExecutors#listeningDecorator(ExecutorService)}.

 @author Chris Povirk
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListeningExecutorService -->
  <!-- start interface com.google.common.util.concurrent.ListeningScheduledExecutorService -->
  <interface name="ListeningScheduledExecutorService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ScheduledExecutorService"/>
    <implements name="com.google.common.util.concurrent.ListeningExecutorService"/>
    <doc>
    <![CDATA[A {@link ScheduledExecutorService} that returns {@link ListenableFuture}
 instances from its {@code ExecutorService} methods.  Futures returned by the
 {@code schedule*} methods, by contrast, need not implement {@code
 ListenableFuture}.  (To create an instance from an existing {@link
 ScheduledExecutorService}, call {@link
 MoreExecutors#listeningDecorator(ScheduledExecutorService)}.

 <p>TODO(cpovirk): make at least the one-time schedule() methods return a
 ListenableFuture, too? But then we'll need ListenableScheduledFuture...

 @author Chris Povirk
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListeningScheduledExecutorService -->
  <!-- start class com.google.common.util.concurrent.Monitor -->
  <class name="Monitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Monitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code
 Monitor(false)}.]]>
      </doc>
    </constructor>
    <constructor name="Monitor" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a monitor with the given ordering policy.

 @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but
        fast) one]]>
      </doc>
    </constructor>
    <method name="enter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enters this monitor. Blocks indefinitely.]]>
      </doc>
    </method>
    <method name="enterInterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks indefinitely, but may be interrupted.]]>
      </doc>
    </method>
    <method name="enter" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks at most the given time.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks at most the given time, and may be interrupted.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="tryEnter" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enters this monitor if it is possible to do so immediately. Does not block.

 <p><b>Note:</b> This method disregards the fairness setting of this monitor.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterWhen"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.]]>
      </doc>
    </method>
    <method name="enterWhenUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks indefinitely.]]>
      </doc>
    </method>
    <method name="enterWhen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks at most the given time, including both
 the time to acquire the lock and the time to wait for the guard to be satisfied, and may be
 interrupted.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterWhenUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks at most the given time, including
 both the time to acquire the lock and the time to wait for the guard to be satisfied.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but
 does not wait for the guard to be satisfied.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterIfInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does
 not wait for the guard to be satisfied, and may be interrupted.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the
 lock, but does not wait for the guard to be satisfied.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterIfInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the
 lock, but does not wait for the guard to be satisfied, and may be interrupted.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="tryEnterIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not
 block acquiring the lock and does not wait for the guard to be satisfied.

 <p><b>Note:</b> This method disregards the fairness setting of this monitor.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be
 called only by a thread currently occupying this monitor.]]>
      </doc>
    </method>
    <method name="waitForUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread
 currently occupying this monitor.]]>
      </doc>
    </method>
    <method name="waitFor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted.
 May be called only by a thread currently occupying this monitor.

 @return whether the guard is now satisfied]]>
      </doc>
    </method>
    <method name="waitForUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits at most the given time. May be called only by a
 thread currently occupying this monitor.

 @return whether the guard is now satisfied]]>
      </doc>
    </method>
    <method name="leave"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Leaves this monitor. May be called only by a thread currently occupying this monitor.]]>
      </doc>
    </method>
    <method name="isFair" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this monitor is using a fair ordering policy.]]>
      </doc>
    </method>
    <method name="isOccupied" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this monitor is occupied by any thread. This method is designed for use in
 monitoring of the system state, not for synchronization control.]]>
      </doc>
    </method>
    <method name="isOccupiedByCurrentThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the current thread is occupying this monitor (has entered more times than it
 has left).]]>
      </doc>
    </method>
    <method name="getOccupiedDepth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times the current thread has entered this monitor in excess of the number
 of times it has left. Returns 0 if the current thread is not occupying this monitor.]]>
      </doc>
    </method>
    <method name="getQueueLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an estimate of the number of threads waiting to enter this monitor. The value is only
 an estimate because the number of threads may change dynamically while this method traverses
 internal data structures. This method is designed for use in monitoring of the system state,
 not for synchronization control.]]>
      </doc>
    </method>
    <method name="hasQueuedThreads" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether any threads are waiting to enter this monitor. Note that because cancellations
 may occur at any time, a {@code true} return does not guarantee that any other thread will ever
 enter this monitor. This method is designed primarily for use in monitoring of the system
 state.]]>
      </doc>
    </method>
    <method name="hasQueuedThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
      <doc>
      <![CDATA[Queries whether the given thread is waiting to enter this monitor. Note that because
 cancellations may occur at any time, a {@code true} return does not guarantee that this thread
 will ever enter this monitor. This method is designed primarily for use in monitoring of the
 system state.]]>
      </doc>
    </method>
    <method name="hasWaiters" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Queries whether any threads are waiting for the given guard to become satisfied. Note that
 because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee
 that the guard becoming satisfied in the future will awaken any threads. This method is
 designed primarily for use in monitoring of the system state.]]>
      </doc>
    </method>
    <method name="getWaitQueueLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Returns an estimate of the number of threads waiting for the given guard to become satisfied.
 Note that because timeouts and interrupts may occur at any time, the estimate serves only as an
 upper bound on the actual number of waiters. This method is designed for use in monitoring of
 the system state, not for synchronization control.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A synchronization abstraction supporting waiting on arbitrary boolean conditions.

 <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}
 is less error-prone and more readable than code using {@code ReentrantLock}, without significant
 performance loss. {@code Monitor} even has the potential for performance gain by optimizing the
 evaluation and signaling of conditions.  Signaling is entirely
 <a href="http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling">
 implicit</a>.
 By eliminating explicit signaling, this class can guarantee that only one thread is awakened
 when a condition becomes true (no "signaling storms" due to use of {@link
 java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost
 (no "hangs" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal
 Condition.signal}).

 <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet
 <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also
 reentrant, so a thread may enter a monitor any number of times, and then must leave the same
 number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization
 semantics as the built-in Java language synchronization primitives.

 <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be
 followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the
 monitor cleanly: <pre>   {@code

   monitor.enter();
   try {
     // do things while occupying the monitor
   } finally {
     monitor.leave();
   }}</pre>

 A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear as
 the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that the
 current thread leaves the monitor cleanly: <pre>   {@code

   if (monitor.tryEnter()) {
     try {
       // do things while occupying the monitor
     } finally {
       monitor.leave();
     }
   } else {
     // do other things since the monitor was not available
   }}</pre>

 <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>
 
 <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},
 {@link ReentrantLock}, and {@code Monitor}.
 
 <h3>{@code synchronized}</h3>
 
 <p>This version is the fewest lines of code, largely because the synchronization mechanism used
 is built into the language and runtime. But the programmer has to remember to avoid a couple of
 common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and
 {@code notifyAll()} must be used instead of {@code notify()} because there are two different
 logical conditions being awaited. <pre>   {@code

   public class SafeBox<V> {
     private V value;

     public synchronized V get() throws InterruptedException {
       while (value == null) {
         wait();
       }
       V result = value;
       value = null;
       notifyAll();
       return result;
     }

     public synchronized void set(V newValue) throws InterruptedException {
       while (value != null) {
         wait();
       }
       value = newValue;
       notifyAll();
     }
   }}</pre>
 
 <h3>{@code ReentrantLock}</h3>
 
 <p>This version is much more verbose than the {@code synchronized} version, and still suffers
 from the need for the programmer to remember to use {@code while} instead of {@code if}.
 However, one advantage is that we can introduce two separate {@code Condition} objects, which
 allows us to use {@code signal()} instead of {@code signalAll()}, which may be a performance
 benefit. <pre>   {@code

   public class SafeBox<V> {
     private final ReentrantLock lock = new ReentrantLock();
     private final Condition valuePresent = lock.newCondition();
     private final Condition valueAbsent = lock.newCondition();
     private V value;

     public V get() throws InterruptedException {
       lock.lock();
       try {
         while (value == null) {
           valuePresent.await();
         }
         V result = value;
         value = null;
         valueAbsent.signal();
         return result;
       } finally {
         lock.unlock();
       }
     }

     public void set(V newValue) throws InterruptedException {
       lock.lock();
       try {
         while (value != null) {
           valueAbsent.await();
         }
         value = newValue;
         valuePresent.signal();
       } finally {
         lock.unlock();
       }
     }
   }}</pre>
 
 <h3>{@code Monitor}</h3>
 
 <p>This version adds some verbosity around the {@code Guard} objects, but removes that same
 verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the
 same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.
 Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to
 remember to use {@code while} instead of {@code if}. <pre>   {@code

   public class SafeBox<V> {
     private final Monitor monitor = new Monitor();
     private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {
       public boolean isSatisfied() {
         return value != null;
       }
     };
     private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {
       public boolean isSatisfied() {
         return value == null;
       }
     };
     private V value;

     public V get() throws InterruptedException {
       monitor.enterWhen(valuePresent);
       try {
         V result = value;
         value = null;
         return result;
       } finally {
         monitor.leave();
       }
     }

     public void set(V newValue) throws InterruptedException {
       monitor.enterWhen(valueAbsent);
       try {
         value = newValue;
       } finally {
         monitor.leave();
       }
     }
   }}</pre>
 
 @author Justin T. Sampson
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Monitor -->
  <!-- start class com.google.common.util.concurrent.Monitor.Guard -->
  <class name="Monitor.Guard" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Monitor.Guard" type="com.google.common.util.concurrent.Monitor"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="isSatisfied" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Evaluates this guard's boolean condition. This method is always called with the associated
 monitor already occupied. Implementations of this method must depend only on state protected
 by the associated monitor, and must not modify that state.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A boolean condition for which a thread may wait. A {@code Guard} is associated with a single
 {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying
 the monitor, so code should not be written to rely on how often a guard might or might not be
 checked.
 
 <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is
 associated with, an {@link IllegalMonitorStateException} is thrown.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Monitor.Guard -->
  <!-- start class com.google.common.util.concurrent.MoreExecutors -->
  <class name="MoreExecutors" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits
 when the application is complete.  It does so by using daemon threads and
 adding a shutdown hook to wait for their completion.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @param terminationTimeout how long to wait for the executor to
        finish before terminating the JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ScheduledThreadPoolExecutor into a
 ScheduledExecutorService that exits when the application is complete.  It
 does so by using daemon threads and adding a shutdown hook to wait for
 their completion.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @param terminationTimeout how long to wait for the executor to
        finish before terminating the JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="addDelayedShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Add a shutdown hook to wait for thread completion in the given
 {@link ExecutorService service}.  This is useful if the given service uses
 daemon threads, and we want to keep the JVM from exiting immediately on
 shutdown, instead giving these daemon threads a chance to terminate
 normally.
 @param service ExecutorService which uses daemon threads
 @param terminationTimeout how long to wait for the executor to finish
        before terminating the JVM
 @param timeUnit unit of time for the time parameter]]>
      </doc>
    </method>
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits
 when the application is complete.  It does so by using daemon threads and
 adding a shutdown hook to wait for their completion.

 <p>This method waits 120 seconds before continuing with JVM termination,
 even if the executor has not finished its work.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into a ScheduledExecutorService that
 exits when the application is complete.  It does so by using daemon threads
 and adding a shutdown hook to wait for their completion.

 <p>This method waits 120 seconds before continuing with JVM termination,
 even if the executor has not finished its work.

 <p>This is mainly for fixed thread pools.
 See {@link Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the
        application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="sameThreadExecutor" return="com.google.common.util.concurrent.ListeningExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an executor service that runs each task in the thread
 that invokes {@code execute/submit}, as in {@link CallerRunsPolicy}  This
 applies both to individually submitted tasks and to collections of tasks
 submitted via {@code invokeAll} or {@code invokeAny}.  In the latter case,
 tasks will run serially on the calling thread.  Tasks are run to
 completion before a {@code Future} is returned to the caller (unless the
 executor has been shutdown).

 <p>Although all tasks are immediately executed in the thread that
 submitted the task, this {@code ExecutorService} imposes a small
 locking overhead on each task submission in order to implement shutdown
 and termination behavior.

 <p>The implementation deviates from the {@code ExecutorService}
 specification with regards to the {@code shutdownNow} method.  First,
 "best-effort" with regards to canceling running tasks is implemented
 as "no-effort".  No interrupts or other attempts are made to stop
 threads executing tasks.  Second, the returned list will always be empty,
 as any submitted task is considered to have started execution.
 This applies also to tasks given to {@code invokeAll} or {@code invokeAny}
 which are pending serial execution, even the subset of the tasks that
 have not yet started execution.  It is unclear from the
 {@code ExecutorService} specification if these should be included, and
 it's much easier to implement the interpretation that they not be.
 Finally, a call to {@code shutdown} or {@code shutdownNow} may result
 in concurrent calls to {@code invokeAll/invokeAny} throwing
 RejectedExecutionException, although a subset of the tasks may already
 have been executed.

 @since 10.0 (<a href="http://code.google.com/p/guava-libraries/wiki/Compatibility"
        >mostly source-compatible</a> since 3.0)]]>
      </doc>
    </method>
    <method name="listeningDecorator" return="com.google.common.util.concurrent.ListeningExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="java.util.concurrent.ExecutorService"/>
      <doc>
      <![CDATA[Creates an {@link ExecutorService} whose {@code submit} and {@code
 invokeAll} methods submit {@link ListenableFutureTask} instances to the
 given delegate executor. Those methods, as well as {@code execute} and
 {@code invokeAny}, are implemented in terms of calls to {@code
 delegate.execute}. All other methods are forwarded unchanged to the
 delegate. This implies that the returned {@code ListeningExecutorService}
 never calls the delegate's {@code submit}, {@code invokeAll}, and {@code
 invokeAny} methods, so any special handling of tasks must be implemented in
 the delegate's {@code execute} method or by wrapping the returned {@code
 ListeningExecutorService}.

 <p>If the delegate executor was already an instance of {@code
 ListeningExecutorService}, it is returned untouched, and the rest of this
 documentation does not apply.

 @since 10.0]]>
      </doc>
    </method>
    <method name="listeningDecorator" return="com.google.common.util.concurrent.ListeningScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code
 invokeAll} methods submit {@link ListenableFutureTask} instances to the
 given delegate executor. Those methods, as well as {@code execute} and
 {@code invokeAny}, are implemented in terms of calls to {@code
 delegate.execute}. All other methods are forwarded unchanged to the
 delegate. This implies that the returned {@code
 SchedulingListeningExecutorService} never calls the delegate's {@code
 submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special
 handling of tasks must be implemented in the delegate's {@code execute}
 method or by wrapping the returned {@code
 SchedulingListeningExecutorService}.

 <p>If the delegate executor was already an instance of {@code
 ListeningScheduledExecutorService}, it is returned untouched, and the rest
 of this documentation does not apply.

 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory and utility methods for {@link java.util.concurrent.Executor}, {@link
 ExecutorService}, and {@link ThreadFactory}.

 @author Eric Fellheimer
 @author Kyle Littlefield
 @author Justin Mahoney
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.MoreExecutors -->
  <!-- start class com.google.common.util.concurrent.RateLimiter -->
  <class name="RateLimiter" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.RateLimiter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permitsPerSecond" type="double"/>
      <doc>
      <![CDATA[Creates a {@code RateLimiter} with the specified stable throughput, given as
 "permits per second" (commonly referred to as <i>QPS</i>, queries per second).

 <p>The returned {@code RateLimiter} ensures that on average no more than {@code
 permitsPerSecond} are issued during any given second, with sustained requests
 being smoothly spread over each second. When the incoming request rate exceeds
 {@code permitsPerSecond} the rate limiter will release one permit every {@code
 (1.0 / permitsPerSecond)} seconds. When the rate limiter is unused,
 bursts of up to {@code permitsPerSecond} permits will be allowed, with subsequent
 requests being smoothly limited at the stable rate of {@code permitsPerSecond}.

 @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in
        how many permits become available per second.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.util.concurrent.RateLimiter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permitsPerSecond" type="double"/>
      <param name="warmupPeriod" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Creates a {@code RateLimiter} with the specified stable throughput, given as
 "permits per second" (commonly referred to as <i>QPS</i>, queries per second), and a
 <i>warmup period</i>, during which the {@code RateLimiter} smoothly ramps up its rate,
 until it reaches its maximum rate at the end of the period (as long as there are enough
 requests to saturate it). Similarly, if the {@code RateLimiter} is left <i>unused</i> for
 a duration of {@code warmupPeriod}, it will gradually return to its "cold" state,
 i.e. it will go through the same warming up process as when it was first created.

 <p>The returned {@code RateLimiter} is intended for cases where the resource that actually
 fulfils the requests (e.g., a remote server) needs "warmup" time, rather than
 being immediately accessed at the stable (maximum) rate.

 <p>The returned {@code RateLimiter} starts in a "cold" state (i.e. the warmup period
 will follow), and if it is left unused for long enough, it will return to that state.

 @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in
        how many permits become available per second
 @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its
        rate, before reaching its stable (maximum) rate
 @param unit the time unit of the warmupPeriod argument]]>
      </doc>
    </method>
    <method name="setRate"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="permitsPerSecond" type="double"/>
      <doc>
      <![CDATA[Updates the stable rate of this {@code RateLimiter}, that is, the
 {@code permitsPerSecond} argument provided in the factory method that
 constructed the {@code RateLimiter}. Currently throttled threads will <b>not</b>
 be awakened as a result of this invocation, thus they do not observe the new rate;
 only subsequent requests will.

 <p>Note though that, since each request repays (by waiting, if necessary) the cost
 of the <i>previous</i> request, this means that the very next request
 after an invocation to {@code setRate} will not be affected by the new rate;
 it will pay the cost of the previous request, which is in terms of the previous rate.

 <p>The behavior of the {@code RateLimiter} is not modified in any other way,
 e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds,
 it still has a warmup period of 20 seconds after this method invocation.

 @param permitsPerSecond the new stable rate of this {@code RateLimiter}.]]>
      </doc>
    </method>
    <method name="getRate" return="double"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the stable rate (as {@code permits per seconds}) with which this
 {@code RateLimiter} is configured with. The initial value of this is the same as
 the {@code permitsPerSecond} argument passed in the factory method that produced
 this {@code RateLimiter}, and it is only updated after invocations
 to {@linkplain #setRate}.]]>
      </doc>
    </method>
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Acquires a permit from this {@code RateLimiter}, blocking until the request can be granted.

 <p>This method is equivalent to {@code acquire(1)}.]]>
      </doc>
    </method>
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permits" type="int"/>
      <doc>
      <![CDATA[Acquires the given number of permits from this {@code RateLimiter}, blocking until the
 request be granted.

 @param permits the number of permits to acquire]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Acquires a permit from this {@code RateLimiter} if it can be obtained
 without exceeding the specified {@code timeout}, or returns {@code false}
 immediately (without waiting) if the permit would not have been granted
 before the timeout expired.

 <p>This method is equivalent to {@code tryAcquire(1, timeout, unit)}.

 @param timeout the maximum time to wait for the permit
 @param unit the time unit of the timeout argument
 @return {@code true} if the permit was acquired, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Acquires the given number of permits from this {@code RateLimiter} if it can be obtained
 without exceeding the specified {@code timeout}, or returns {@code false}
 immediately (without waiting) if the permits would not have been granted
 before the timeout expired.

 @param permits the number of permits to acquire
 @param timeout the maximum time to wait for the permits
 @param unit the time unit of the timeout argument
 @return {@code true} if the permits were acquired, {@code false} otherwise]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A rate limiter. Conceptually, a rate limiter distributes permits at a
 configurable rate. Each {@link #acquire()} blocks if necessary until a permit is
 available, and then takes it. Once acquired, permits need not be released.

 <p>Rate limiters are often used to restrict the rate at which some
 physical or logical resource is accessed. This is in contrast to {@link
 java.util.concurrent.Semaphore} which restricts the number of concurrent
 accesses instead of the rate (note though that concurrency and rate are closely related,
 e.g. see <a href="http://en.wikipedia.org/wiki/Little's_law">Little's Law</a>).

 <p>A {@code RateLimiter} is defined primarily by the rate at which permits
 are issued. Absent additional configuration, permits will be distributed at a
 fixed rate, defined in terms of permits per second. Permits will be distributed
 smoothly, with the delay between individual permits being adjusted to ensure
 that the configured rate is maintained.

 <p>It is possible to configure a {@code RateLimiter} to have a warmup
 period during which time the permits issued each second steadily increases until
 it hits the stable rate.

 <p>As an example, imagine that we have a list of tasks to execute, but we don't want to
 submit more than 2 per second:
<pre>  {@code
  final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is "2 permits per second"
  void submitTasks(List<Runnable> tasks, Executor executor) {
    for (Runnable task : tasks) {
      rateLimiter.acquire(); // may wait
      executor.execute(task);
    }
  }
}</pre>

 <p>As another example, imagine that we produce a stream of data, and we want to cap it
 at 5kb per second. This could be accomplished by requiring a permit per byte, and specifying
 a rate of 5000 permits per second:
<pre>  {@code
  final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second
  void submitPacket(byte[] packet) {
    rateLimiter.acquire(packet.length);
    networkService.send(packet);
  }
}</pre>

 <p>It is important to note that the number of permits requested <i>never</i>
 affect the throttling of the request itself (an invocation to {@code acquire(1)}
 and an invocation to {@code acquire(1000)} will result in exactly the same throttling, if any),
 but it affects the throttling of the <i>next</i> request. I.e., if an expensive task
 arrives at an idle RateLimiter, it will be granted immediately, but it is the <i>next</i>
 request that will experience extra throttling, thus paying for the cost of the expensive
 task.

 <p>Note: {@code RateLimiter} does not provide fairness guarantees.

 @author Dimitris Andreou
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.RateLimiter -->
  <!-- start interface com.google.common.util.concurrent.Service -->
  <interface name="Service"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service state is {@link State#NEW}, this initiates service startup and returns
 immediately. If the service has already been started, this method returns immediately without
 taking action. A stopped service may not be restarted.

 @return a future for the startup result, regardless of whether this call initiated startup.
         Calling {@link ListenableFuture#get} will block until the service has finished
         starting, and returns one of {@link State#RUNNING}, {@link State#STOPPING} or
         {@link State#TERMINATED}. If the service fails to start, {@link ListenableFuture#get}
         will throw an {@link ExecutionException}, and the service's state will be
         {@link State#FAILED}. If it has already finished starting, {@link ListenableFuture#get}
         returns immediately. Cancelling this future has no effect on the service.]]>
      </doc>
    </method>
    <method name="startAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service startup (if necessary), returning once the service has finished starting.
 Unlike calling {@code start().get()}, this method throws no checked exceptions, and it cannot
 be {@linkplain Thread#interrupt interrupted}.

 @throws UncheckedExecutionException if startup failed
 @return the state of the service when startup finished.]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this service is {@linkplain State#RUNNING running}.]]>
      </doc>
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lifecycle state of the service.]]>
      </doc>
    </method>
    <method name="stop" return="com.google.common.util.concurrent.ListenableFuture&lt;com.google.common.util.concurrent.Service.State&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service is {@linkplain State#STARTING starting} or {@linkplain State#RUNNING running},
 this initiates service shutdown and returns immediately. If the service is
 {@linkplain State#NEW new}, it is {@linkplain State#TERMINATED terminated} without having been
 started nor stopped. If the service has already been stopped, this method returns immediately
 without taking action.

 @return a future for the shutdown result, regardless of whether this call initiated shutdown.
         Calling {@link ListenableFuture#get} will block until the service has finished shutting
         down, and either returns {@link State#TERMINATED} or throws an
         {@link ExecutionException}. If it has already finished stopping,
         {@link ListenableFuture#get} returns immediately. Cancelling this future has no effect
         on the service.]]>
      </doc>
    </method>
    <method name="stopAndWait" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service shutdown (if necessary), returning once the service has finished stopping. If
 this is {@link State#STARTING}, startup will be cancelled. If this is {@link State#NEW}, it is
 {@link State#TERMINATED terminated} without having been started nor stopped. Unlike calling
 {@code stop().get()}, this method throws no checked exceptions.

 @throws UncheckedExecutionException if the service has failed or fails during shutdown
 @return the state of the service when shutdown finished.]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given
 executor.  The listener will have the corresponding transition method called whenever the
 service changes state. The listener will not have previous state changes replayed, so it is
 suggested that listeners are added before the service starts.

 <p>There is no guaranteed ordering of execution of listeners, but any listener added through
 this method is guaranteed to be called whenever there is a state change.

 <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown
 during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception
 thrown by {@linkplain MoreExecutors#sameThreadExecutor inline execution}) will be caught and
 logged.

 @param listener the listener to run when the service changes state is complete
 @param executor the executor in which the the listeners callback methods will be run. For fast,
     lightweight listeners that would be safe to execute in any thread, consider
     {@link MoreExecutors#sameThreadExecutor}.
 @since 13.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object with an operational state, plus asynchronous {@link #start()} and {@link #stop()}
 lifecycle methods to transition between states. Example services include webservers, RPC servers
 and timers.

 <p>The normal lifecycle of a service is:
 <ul>
   <li>{@linkplain State#NEW NEW} -&gt;
   <li>{@linkplain State#STARTING STARTING} -&gt;
   <li>{@linkplain State#RUNNING RUNNING} -&gt;
   <li>{@linkplain State#STOPPING STOPPING} -&gt;
   <li>{@linkplain State#TERMINATED TERMINATED}
 </ul>

 <p>There are deviations from this if there are failures or if {@link Service#stop} is called
 before the {@link Service} reaches the {@linkplain State#RUNNING RUNNING} state. The set of legal
 transitions form a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>,
 therefore every method of the listener will be called at most once. N.B. The {@link State#FAILED}
 and {@link State#TERMINATED} states are terminal states, once a service enters either of these
 states it cannot ever leave them.

 <p>Implementors of this interface are strongly encouraged to extend one of the abstract classes
 in this package which implement this interface and make the threading and state management
 easier.

 @author Jesse Wilson
 @author Luke Sandberg
 @since 9.0 (in 1.0 as {@code com.google.common.base.Service})]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.Service -->
  <!-- start interface com.google.common.util.concurrent.Service.Listener -->
  <interface name="Service.Listener"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="starting"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when the service transitions from {@linkplain State#NEW NEW} to
 {@linkplain State#STARTING STARTING}. This occurs when {@link Service#start} or
 {@link Service#startAndWait} is called the first time.]]>
      </doc>
    </method>
    <method name="running"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when the service transitions from {@linkplain State#STARTING STARTING} to
 {@linkplain State#RUNNING RUNNING}. This occurs when a service has successfully started.]]>
      </doc>
    </method>
    <method name="stopping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.util.concurrent.Service.State"/>
      <doc>
      <![CDATA[Called when the service transitions to the {@linkplain State#STOPPING STOPPING} state. The
 only valid values for {@code from} are {@linkplain State#STARTING STARTING} or
 {@linkplain State#RUNNING RUNNING}.  This occurs when {@link Service#stop} is called.

 @param from The previous state that is being transitioned from.]]>
      </doc>
    </method>
    <method name="terminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.util.concurrent.Service.State"/>
      <doc>
      <![CDATA[Called when the service transitions to the {@linkplain State#TERMINATED TERMINATED} state.
 The {@linkplain State#TERMINATED TERMINATED} state is a terminal state in the transition
 diagram.  Therefore, if this method is called, no other methods will be called on the
 {@link Listener}.

 @param from The previous state that is being transitioned from.  The only valid values for
     this are {@linkplain State#NEW NEW}, {@linkplain State#RUNNING RUNNING} or
     {@linkplain State#STOPPING STOPPING}.]]>
      </doc>
    </method>
    <method name="failed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.util.concurrent.Service.State"/>
      <param name="failure" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Called when the service transitions to the {@linkplain State#FAILED FAILED} state. The
 {@linkplain State#FAILED FAILED} state is a terminal state in the transition diagram.
 Therefore, if this method is called, no other methods will be called on the {@link Listener}.

 @param from The previous state that is being transitioned from.  Failure can occur in any
     state with the exception of {@linkplain State#NEW NEW} or
     {@linkplain State#TERMINATED TERMINATED}.
 @param failure The exception that caused the failure.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A listener for the various state changes that a {@link Service} goes through in its lifecycle.

 @author Luke Sandberg
 @since 13.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.Service.Listener -->
  <!-- start class com.google.common.util.concurrent.Service.State -->
  <class name="Service.State" extends="java.lang.Enum&lt;com.google.common.util.concurrent.Service.State&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.util.concurrent.Service.State[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The lifecycle states of a service.

 @since 9.0 (in 1.0 as {@code com.google.common.base.Service.State})]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Service.State -->
  <!-- start class com.google.common.util.concurrent.SettableFuture -->
  <class name="SettableFuture" extends="com.google.common.util.concurrent.AbstractFuture&lt;V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.SettableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code SettableFuture} in the default state.]]>
      </doc>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the value of this future.  This method will return {@code true} if
 the value was successfully set, or {@code false} if the future has already
 been set or cancelled.

 @param value the value the future should hold.
 @return true if the value was successfully set.]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Sets the future to having failed with the given exception. This exception
 will be wrapped in an {@code ExecutionException} and thrown from the {@code
 get} methods. This method will return {@code true} if the exception was
 successfully set, or {@code false} if the future has already been set or
 cancelled.

 @param throwable the exception the future should hold.
 @return true if the exception was successfully set.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link ListenableFuture} whose result may be set by a {@link #set(Object)}
 or {@link #setException(Throwable)} call. It may also be cancelled.

 @author Sven Mawson
 @since 9.0 (in 1.0 as {@code ValueFuture})]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.SettableFuture -->
  <!-- start class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <class name="SimpleTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <constructor name="SimpleTimeLimiter" type="java.util.concurrent.ExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TimeLimiter instance using the given executor service to
 execute proxied method calls.
 <p>
 <b>Warning:</b> using a bounded executor
 may be counterproductive!  If the thread pool fills up, any time callers
 spend waiting for a thread may count toward their time limit, and in
 this case the call may even time out before the target method is ever
 invoked.

 @param executor the ExecutorService that will execute the method calls on
     the target objects; for example, a {@link
     Executors#newCachedThreadPool()}.]]>
      </doc>
    </constructor>
    <constructor name="SimpleTimeLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TimeLimiter instance using a {@link
 Executors#newCachedThreadPool()} to execute proxied method calls.

 <p><b>Warning:</b> using a bounded executor may be counterproductive! If
 the thread pool fills up, any time callers spend waiting for a thread may
 count toward their time limit, and in this case the call may even time out
 before the target method is ever invoked.]]>
      </doc>
    </constructor>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="amInterruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter that runs method calls in the background using an
 {@link ExecutorService}.  If the time limit expires for a given method call,
 the thread running the call will be interrupted.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <!-- start class com.google.common.util.concurrent.Striped -->
  <class name="Striped" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="L"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the stripe that corresponds to the passed key. It is always guaranteed that if
 {@code key1.equals(key2)}, then {@code get(key1) == get(key2)}.

 @param key an arbitrary, non-null key
 @return the stripe that the passed key corresponds to]]>
      </doc>
    </method>
    <method name="getAt" return="L"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the stripe at the specified index. Valid indexes are 0, inclusively, to
 {@code size()}, exclusively.

 @param index the index of the stripe to return; must be in {@code [0...size())}
 @return the stripe at the specified index]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of stripes in this instance.]]>
      </doc>
    </method>
    <method name="bulkGet" return="java.lang.Iterable&lt;L&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the stripes that correspond to the passed objects, in ascending (as per
 {@link #getAt(int)}) order. Thus, threads that use the stripes in the order returned
 by this method are guaranteed to not deadlock each other.

 <p>It should be noted that using a {@code Striped<L>} with relatively few stripes, and
 {@code bulkGet(keys)} with a relative large number of keys can cause an excessive number
 of shared stripes (much like the birthday paradox, where much fewer than anticipated birthdays
 are needed for a pair of them to match). Please consider carefully the implications of the
 number of stripes, the intended concurrency level, and the typical number of keys used in a
 {@code bulkGet(keys)} operation. See <a href="http://www.mathpages.com/home/kmath199.htm">Balls
 in Bins model</a> for mathematical formulas that can be used to estimate the probability of
 collisions.

 @param keys arbitrary non-null keys
 @return the stripes corresponding to the objects (one per each object, derived by delegating
         to {@link #get(Object)}; may contain duplicates), in an increasing index order.]]>
      </doc>
    </method>
    <method name="lock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.Lock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Lock>} with eagerly initialized, strongly referenced locks, with the
 specified fairness. Every lock is reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<Lock>}]]>
      </doc>
    </method>
    <method name="lazyWeakLock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.Lock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Lock>} with lazily initialized, weakly referenced locks, with the
 specified fairness. Every lock is reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<Lock>}]]>
      </doc>
    </method>
    <method name="semaphore" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.Semaphore&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <param name="permits" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Semaphore>} with eagerly initialized, strongly referenced semaphores,
 with the specified number of permits and fairness.

 @param stripes the minimum number of stripes (semaphores) required
 @param permits the number of permits in each semaphore
 @return a new {@code Striped<Semaphore>}]]>
      </doc>
    </method>
    <method name="lazyWeakSemaphore" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.Semaphore&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <param name="permits" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Semaphore>} with lazily initialized, weakly referenced semaphores,
 with the specified number of permits and fairness.

 @param stripes the minimum number of stripes (semaphores) required
 @param permits the number of permits in each semaphore
 @return a new {@code Striped<Semaphore>}]]>
      </doc>
    </method>
    <method name="readWriteLock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.ReadWriteLock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<ReadWriteLock>} with eagerly initialized, strongly referenced
 read-write locks, with the specified fairness. Every lock is reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<ReadWriteLock>}]]>
      </doc>
    </method>
    <method name="lazyWeakReadWriteLock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.ReadWriteLock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<ReadWriteLock>} with lazily initialized, weakly referenced
 read-write locks, with the specified fairness. Every lock is reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<ReadWriteLock>}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A striped {@code Lock/Semaphore/ReadWriteLock}. This offers the underlying lock striping
 similar to that of {@code ConcurrentHashMap} in a reusable form, and extends it for
 semaphores and read-write locks. Conceptually, lock striping is the technique of dividing a lock
 into many <i>stripes</i>, increasing the granularity of a single lock and allowing independent
 operations to lock different stripes and proceed concurrently, instead of creating contention
 for a single lock.

 <p>The guarantee provided by this class is that equal keys lead to the same lock (or semaphore),
 i.e. {@code if (key1.equals(key2))} then {@code striped.get(key1) == striped.get(key2)}
 (assuming {@link Object#hashCode()} is correctly implemented for the keys). Note
 that if {@code key1} is <strong>not</strong> equal to {@code key2}, it is <strong>not</strong>
 guaranteed that {@code striped.get(key1) != striped.get(key2)}; the elements might nevertheless
 be mapped to the same lock. The lower the number of stripes, the higher the probability of this
 happening.

 <p>There are three flavors of this class: {@code Striped<Lock>}, {@code Striped<Semaphore>},
 and {@code Striped<ReadWriteLock>}. For each type, two implementations are offered:
 {@linkplain #lock(int) strong} and {@linkplain #lazyWeakLock(int) weak}
 {@code Striped<Lock>}, {@linkplain #semaphore(int, int) strong} and {@linkplain
 #lazyWeakSemaphore(int, int) weak} {@code Striped<Semaphore>}, and {@linkplain
 #readWriteLock(int) strong} and {@linkplain #lazyWeakReadWriteLock(int) weak}
 {@code Striped<ReadWriteLock>}. <i>Strong</i> means that all stripes (locks/semaphores) are
 initialized eagerly, and are not reclaimed unless {@code Striped} itself is reclaimable.
 <i>Weak</i> means that locks/semaphores are created lazily, and they are allowed to be reclaimed
 if nobody is holding on to them. This is useful, for example, if one wants to create a {@code
 Striped<Lock>} of many locks, but worries that in most cases only a small portion of these
 would be in use.

 <p>Prior to this class, one might be tempted to use {@code Map<K, Lock>}, where {@code K}
 represents the task. This maximizes concurrency by having each unique key mapped to a unique
 lock, but also maximizes memory footprint. On the other extreme, one could use a single lock
 for all tasks, which minimizes memory footprint but also minimizes concurrency. Instead of
 choosing either of these extremes, {@code Striped} allows the user to trade between required
 concurrency and memory footprint. For example, if a set of tasks are CPU-bound, one could easily
 create a very compact {@code Striped<Lock>} of {@code availableProcessors() * 4} stripes,
 instead of possibly thousands of locks which could be created in a {@code Map<K, Lock>}
 structure.

 @author Dimitris Andreou
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Striped -->
  <!-- start class com.google.common.util.concurrent.ThreadFactoryBuilder -->
  <class name="ThreadFactoryBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThreadFactoryBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link ThreadFactory} builder.]]>
      </doc>
    </constructor>
    <method name="setNameFormat" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nameFormat" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the naming format to use when naming threads ({@link Thread#setName})
 which are created with this ThreadFactory.

 @param nameFormat a {@link String#format(String, Object...)}-compatible
     format String, to which a unique integer (0, 1, etc.) will be supplied
     as the single parameter. This integer will be unique to the built
     instance of the ThreadFactory and will be assigned sequentially.
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setDaemon" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemon" type="boolean"/>
      <doc>
      <![CDATA[Sets daemon or not for new threads created with this ThreadFactory.

 @param daemon whether or not new Threads created with this ThreadFactory
     will be daemon threads
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setPriority" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="int"/>
      <doc>
      <![CDATA[Sets the priority for new threads created with this ThreadFactory.

 @param priority the priority for new Threads created with this
     ThreadFactory
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setUncaughtExceptionHandler" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uncaughtExceptionHandler" type="java.lang.Thread.UncaughtExceptionHandler"/>
      <doc>
      <![CDATA[Sets the {@link UncaughtExceptionHandler} for new threads created with this
 ThreadFactory.

 @param uncaughtExceptionHandler the uncaught exception handler for new
     Threads created with this ThreadFactory
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setThreadFactory" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingThreadFactory" type="java.util.concurrent.ThreadFactory"/>
      <doc>
      <![CDATA[Sets the backing {@link ThreadFactory} for new threads created with this
 ThreadFactory. Threads will be created by invoking #newThread(Runnable) on
 this backing {@link ThreadFactory}.

 @param backingThreadFactory the backing {@link ThreadFactory} which will
     be delegated to during thread creation.
 @return this for the builder pattern

 @see MoreExecutors]]>
      </doc>
    </method>
    <method name="build" return="java.util.concurrent.ThreadFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread factory using the options supplied during the building
 process. After building, it is still possible to change the options used to
 build the ThreadFactory and/or build again. State is not shared amongst
 built instances.

 @return the fully constructed {@link ThreadFactory}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A ThreadFactory builder, providing any combination of these features:
 <ul>
 <li> whether threads should be marked as {@linkplain Thread#setDaemon daemon}
 threads
 <li> a {@linkplain ThreadFactoryBuilder#setNameFormat naming format}
 <li> a {@linkplain Thread#setPriority thread priority}
 <li> an {@linkplain Thread#setUncaughtExceptionHandler uncaught exception
 handler}
 <li> a {@linkplain ThreadFactory#newThread backing thread factory}
 </ul>
 If no backing thread factory is provided, a default backing thread factory is
 used as if by calling {@code setThreadFactory(}{@link
 Executors#defaultThreadFactory()}{@code )}.

 @author Kurt Alfred Kluever
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ThreadFactoryBuilder -->
  <!-- start interface com.google.common.util.concurrent.TimeLimiter -->
  <interface name="TimeLimiter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns an instance of {@code interfaceType} that delegates all method
 calls to the {@code target} object, enforcing the specified time limit on
 each call.  This time-limited delegation is also performed for calls to
 {@link Object#equals}, {@link Object#hashCode}, and
 {@link Object#toString}.
 <p>
 If the target method call finishes before the limit is reached, the return
 value or exception is propagated to the caller exactly as-is. If, on the
 other hand, the time limit is reached, the proxy will attempt to abort the
 call to the target, and will throw an {@link UncheckedTimeoutException} to
 the caller.
 <p>
 It is important to note that the primary purpose of the proxy object is to
 return control to the caller when the timeout elapses; aborting the target
 method call is of secondary concern.  The particular nature and strength
 of the guarantees made by the proxy is implementation-dependent.  However,
 it is important that each of the methods on the target object behaves
 appropriately when its thread is interrupted.

 @param target the object to proxy
 @param interfaceType the interface you wish the returned proxy to
     implement
 @param timeoutDuration with timeoutUnit, the maximum length of time that
     callers are willing to wait on each method call to the proxy
 @param timeoutUnit with timeoutDuration, the maximum length of time that
     callers are willing to wait on each method call to the proxy
 @return a time-limiting proxy
 @throws IllegalArgumentException if {@code interfaceType} is a regular
     class, enum, or annotation type, rather than an interface]]>
      </doc>
    </method>
    <method name="callWithTimeout" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="interruptible" type="boolean"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Invokes a specified Callable, timing out after the specified time limit.
 If the target method call finished before the limit is reached, the return
 value or exception is propagated to the caller exactly as-is.  If, on the
 other hand, the time limit is reached, we attempt to abort the call to the
 target, and throw an {@link UncheckedTimeoutException} to the caller.
 <p>
 <b>Warning:</b> The future of this method is in doubt.  It may be nuked, or
 changed significantly.

 @param callable the Callable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @param interruptible whether to respond to thread interruption by aborting
     the operation and throwing InterruptedException; if false, the
     operation is allowed to complete or time out, and the current thread's
     interrupt status is re-asserted.
 @return the result returned by the Callable
 @throws InterruptedException if {@code interruptible} is true and our
     thread is interrupted during execution
 @throws UncheckedTimeoutException if the time limit is reached
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Produces proxies that impose a time limit on method
 calls to the proxied object.  For example, to return the value of
 {@code target.someMethod()}, but substitute {@code DEFAULT_VALUE} if this
 method call takes over 50 ms, you can use this code:
 <pre>
   TimeLimiter limiter = . . .;
   TargetType proxy = limiter.newProxy(
       target, TargetType.class, 50, TimeUnit.MILLISECONDS);
   try {
     return proxy.someMethod();
   } catch (UncheckedTimeoutException e) {
     return DEFAULT_VALUE;
   }
 </pre>
 Please see {@code SimpleTimeLimiterTest} for more usage examples.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.TimeLimiter -->
  <!-- start class com.google.common.util.concurrent.UncaughtExceptionHandlers -->
  <class name="UncaughtExceptionHandlers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="systemExit" return="java.lang.Thread.UncaughtExceptionHandler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an exception handler that exits the system. This is particularly useful for the main
 thread, which may start up other, non-daemon threads, but fail to fully initialize the
 application successfully.

 <p>Example usage:
 <pre>public static void main(String[] args) {
   Thread.currentThread().setUncaughtExceptionHandler(UncaughtExceptionHandlers.systemExit());
   ...
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories for {@link UncaughtExceptionHandler} instances.

 @author Gregory Kick
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncaughtExceptionHandlers -->
  <!-- start class com.google.common.util.concurrent.UncheckedExecutionException -->
  <class name="UncheckedExecutionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedExecutionException"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with {@code null} as its detail message.]]>
      </doc>
    </constructor>
    <constructor name="UncheckedExecutionException" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given detail message.]]>
      </doc>
    </constructor>
    <constructor name="UncheckedExecutionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given detail message and cause.]]>
      </doc>
    </constructor>
    <constructor name="UncheckedExecutionException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Unchecked variant of {@link java.util.concurrent.ExecutionException}. As with
 {@code ExecutionException}, the exception's {@linkplain #getCause() cause}
 comes from a failed task, possibly run in another thread.

 <p>{@code UncheckedExecutionException} is intended as an alternative to
 {@code ExecutionException} when the exception thrown by a task is an
 unchecked exception. However, it may also wrap a checked exception in some
 cases.

 <p>When wrapping an {@code Error} from another thread, prefer {@link
 ExecutionError}. When wrapping a checked exception, prefer {@code
 ExecutionException}.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncheckedExecutionException -->
  <!-- start class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <class name="UncheckedTimeoutException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedTimeoutException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Unchecked version of {@link java.util.concurrent.TimeoutException}.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <!-- start class com.google.common.util.concurrent.Uninterruptibles -->
  <class name="Uninterruptibles" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="awaitUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="latch" type="java.util.concurrent.CountDownLatch"/>
      <doc>
      <![CDATA[Invokes {@code latch.}{@link CountDownLatch#await() await()}
 uninterruptibly.]]>
      </doc>
    </method>
    <method name="awaitUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="latch" type="java.util.concurrent.CountDownLatch"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes
 {@code latch.}{@link CountDownLatch#await(long, TimeUnit)
 await(timeout, unit)} uninterruptibly.]]>
      </doc>
    </method>
    <method name="joinUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toJoin" type="java.lang.Thread"/>
      <doc>
      <![CDATA[Invokes {@code toJoin.}{@link Thread#join() join()} uninterruptibly.]]>
      </doc>
    </method>
    <method name="getUninterruptibly" return="V"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Invokes {@code future.}{@link Future#get() get()} uninterruptibly.
 To get uninterruptibility and remove checked exceptions, see
 {@link Futures#getUnchecked}.

 <p>If instead, you wish to treat {@link InterruptedException} uniformly
 with other exceptions, see {@link Futures#get(Future, Class) Futures.get}
 or {@link Futures#makeChecked}.]]>
      </doc>
    </method>
    <method name="getUninterruptibly" return="V"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Invokes
 {@code future.}{@link Future#get(long, TimeUnit) get(timeout, unit)}
 uninterruptibly.

 <p>If instead, you wish to treat {@link InterruptedException} uniformly
 with other exceptions, see {@link Futures#get(Future, Class) Futures.get}
 or {@link Futures#makeChecked}.]]>
      </doc>
    </method>
    <method name="joinUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toJoin" type="java.lang.Thread"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes
 {@code unit.}{@link TimeUnit#timedJoin(Thread, long)
 timedJoin(toJoin, timeout)} uninterruptibly.]]>
      </doc>
    </method>
    <method name="takeUninterruptibly" return="E"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queue" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <doc>
      <![CDATA[Invokes {@code queue.}{@link BlockingQueue#take() take()} uninterruptibly.]]>
      </doc>
    </method>
    <method name="putUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queue" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Invokes {@code queue.}{@link BlockingQueue#put(Object) put(element)}
 uninterruptibly.]]>
      </doc>
    </method>
    <method name="sleepUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sleepFor" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)}
 uninterruptibly.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for treating interruptible operations as uninterruptible.
 In all cases, if a thread is interrupted during such a call, the call
 continues to block until the result is available or the timeout elapses,
 and only then re-interrupts the thread.

 @author Anthony Zana
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Uninterruptibles -->
</package>

</api>
