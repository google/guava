<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>com.google.common.eventbus (Guava: Google Core Libraries for Java 29.0-jre API)</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.google.common.eventbus (Guava: Google Core Libraries for Java 29.0-jre API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/common/escape/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../com/google/common/graph/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/common/eventbus/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<p><a href="https://errorprone.info/api/latest/com/google/errorprone/annotations/CheckReturnValue.html?is-external=true" title="class or interface in com.google.errorprone.annotations">@CheckReturnValue</a>
 <a href="https://static.javadoc.io/com.google.code.findbugs/jsr305/3.0.1/javax/annotation/ParametersAreNonnullByDefault.html?is-external=true" title="class or interface in javax.annotation">@ParametersAreNonnullByDefault</a>
</p>
<h1 title="Package" class="title">Package&nbsp;com.google.common.eventbus</h1>
<div class="docSummary">
<div class="block">The EventBus allows publish-subscribe-style communication between components without requiring
 the components to explicitly register with one another (and thus be aware of each other).</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/SubscriberExceptionHandler.html" title="interface in com.google.common.eventbus">SubscriberExceptionHandler</a></td>
<td class="colLast">
<div class="block">Handler for exceptions thrown by event subscribers.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/AsyncEventBus.html" title="class in com.google.common.eventbus">AsyncEventBus</a></td>
<td class="colLast">
<div class="block">An <a href="../../../../com/google/common/eventbus/EventBus.html" title="class in com.google.common.eventbus"><code>EventBus</code></a> that takes the Executor of your choice and uses it to dispatch events,
 allowing dispatch to occur asynchronously.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/DeadEvent.html" title="class in com.google.common.eventbus">DeadEvent</a></td>
<td class="colLast">
<div class="block">Wraps an event that was posted, but which had no subscribers and thus could not be delivered.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/EventBus.html" title="class in com.google.common.eventbus">EventBus</a></td>
<td class="colLast">
<div class="block">Dispatches events to listeners, and provides ways for listeners to register themselves.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/SubscriberExceptionContext.html" title="class in com.google.common.eventbus">SubscriberExceptionContext</a></td>
<td class="colLast">
<div class="block">Context for an exception thrown by a subscriber.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Annotation Types Summary table, listing annotation types, and an explanation">
<caption><span>Annotation Types Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Annotation Type</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/AllowConcurrentEvents.html" title="annotation in com.google.common.eventbus">AllowConcurrentEvents</a></td>
<td class="colLast">
<div class="block">Marks an event subscriber method as being thread-safe.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/google/common/eventbus/Subscribe.html" title="annotation in com.google.common.eventbus">Subscribe</a></td>
<td class="colLast">
<div class="block">Marks a method as an event subscriber.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package com.google.common.eventbus Description">Package com.google.common.eventbus Description</h2>
<div class="block">The EventBus allows publish-subscribe-style communication between components without requiring
 the components to explicitly register with one another (and thus be aware of each other). It is
 designed exclusively to replace traditional Java in-process event distribution using explicit
 registration. It is <em>not</em> a general-purpose publish-subscribe system, nor is it intended
 for interprocess communication.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/EventBusExplained"><code>EventBus</code></a>.

 <h2>One-Minute Guide</h2>

 <p>Converting an existing EventListener-based system to use the EventBus is easy.

 <h3>For Listeners</h3>

 <p>To listen for a specific flavor of event (say, a CustomerChangeEvent)...

 <ul>
   <li><strong>...in traditional Java events:</strong> implement an interface defined with the
       event &mdash; such as CustomerChangeEventListener.
   <li><strong>...with EventBus:</strong> create a method that accepts CustomerChangeEvent as its
       sole argument, and mark it with the <a href="../../../../com/google/common/eventbus/Subscribe.html" title="annotation in com.google.common.eventbus"><code>Subscribe</code></a>
       annotation.
 </ul>

 <p>To register your listener methods with the event producers...

 <ul>
   <li><strong>...in traditional Java events:</strong> pass your object to each producer's <code>registerCustomerChangeEventListener</code> method. These methods are rarely defined in common
       interfaces, so in addition to knowing every possible producer, you must also know its type.
   <li><strong>...with EventBus:</strong> pass your object to the <a href="../../../../com/google/common/eventbus/EventBus.html#register-java.lang.Object-"><code>EventBus.register(Object)</code></a> method on an EventBus. You'll need to
       make sure that your object shares an EventBus instance with the event producers.
 </ul>

 <p>To listen for a common event supertype (such as EventObject or Object)...

 <ul>
   <li><strong>...in traditional Java events:</strong> not easy.
   <li><strong>...with EventBus:</strong> events are automatically dispatched to listeners of any
       supertype, allowing listeners for interface types or "wildcard listeners" for Object.
 </ul>

 <p>To listen for and detect events that were dispatched without listeners...

 <ul>
   <li><strong>...in traditional Java events:</strong> add code to each event-dispatching method
       (perhaps using AOP).
   <li><strong>...with EventBus:</strong> subscribe to <a href="../../../../com/google/common/eventbus/DeadEvent.html" title="class in com.google.common.eventbus"><code>DeadEvent</code></a>. The EventBus will notify you of any events that were
       posted but not delivered. (Handy for debugging.)
 </ul>

 <h3>For Producers</h3>

 <p>To keep track of listeners to your events...

 <ul>
   <li><strong>...in traditional Java events:</strong> write code to manage a list of listeners to
       your object, including synchronization, or use a utility class like EventListenerList.
   <li><strong>...with EventBus:</strong> EventBus does this for you.
 </ul>

 <p>To dispatch an event to listeners...

 <ul>
   <li><strong>...in traditional Java events:</strong> write a method to dispatch events to each
       event listener, including error isolation and (if desired) asynchronicity.
   <li><strong>...with EventBus:</strong> pass the event object to an EventBus's <a href="../../../../com/google/common/eventbus/EventBus.html#post-java.lang.Object-"><code>EventBus.post(Object)</code></a> method.
 </ul>

 <h2>Glossary</h2>

 <p>The EventBus system and code use the following terms to discuss event distribution:

 <dl>
   <dt>Event
   <dd>Any object that may be <em>posted</em> to a bus.
   <dt>Subscribing
   <dd>The act of registering a <em>listener</em> with an EventBus, so that its <em>subscriber
       methods</em> will receive events.
   <dt>Listener
   <dd>An object that wishes to receive events, by exposing <em>subscriber methods</em>.
   <dt>Subscriber method
   <dd>A public method that the EventBus should use to deliver <em>posted</em> events. Subscriber
       methods are marked by the <a href="../../../../com/google/common/eventbus/Subscribe.html" title="annotation in com.google.common.eventbus"><code>Subscribe</code></a> annotation.
   <dt>Posting an event
   <dd>Making the event available to any <em>listeners</em> through the EventBus.
 </dl>

 <h2>FAQ</h2>

 <h3>Why must I create my own Event Bus, rather than using a singleton?</h3>

 <p>The Event Bus doesn't specify how you use it; there's nothing stopping your application from
 having separate EventBus instances for each component, or using separate instances to separate
 events by context or topic. This also makes it trivial to set up and tear down EventBus objects
 in your tests.

 <p>Of course, if you'd like to have a process-wide EventBus singleton, there's nothing stopping
 you from doing it that way. Simply have your container (such as Guice) create the EventBus as a
 singleton at global scope (or stash it in a static field, if you're into that sort of thing).

 <p>In short, the EventBus is not a singleton because we'd rather not make that decision for you.
 Use it how you like.

 <h3>Why use an annotation to mark subscriber methods, rather than requiring the listener to
 implement an interface?</h3>

 <p>We feel that the Event Bus's <code>@Subscribe</code> annotation conveys your intentions just as
 explicitly as implementing an interface (or perhaps more so), while leaving you free to place
 event subscriber methods wherever you wish and give them intention-revealing names.

 <p>Traditional Java Events use a listener interface which typically sports only a handful of
 methods -- typically one. This has a number of disadvantages:

 <ul>
   <li>Any one class can only implement a single response to a given event.
   <li>Listener interface methods may conflict.
   <li>The method must be named after the event (e.g. <code>handleChangeEvent</code>), rather than its
       purpose (e.g. <code>recordChangeInJournal</code>).
   <li>Each event usually has its own interface, without a common parent interface for a family of
       events (e.g. all UI events).
 </ul>

 <p>The difficulties in implementing this cleanly has given rise to a pattern, particularly common
 in Swing apps, of using tiny anonymous classes to implement event listener interfaces.

 <p>Compare these two cases:

 <pre><code>
 class ChangeRecorder {
   void setCustomer(Customer cust) {
     cust.addChangeListener(new ChangeListener() {
       void customerChanged(ChangeEvent e) {
         recordChange(e.getChange());
       }
     };
   }
 }

 // Class is typically registered by the container.
 class EventBusChangeRecorder {
  }{@code @Subscribe void recordCustomerChange(ChangeEvent e) {
     recordChange(e.getChange());
   }
 }
 </code></pre>

 <p>The intent is actually clearer in the second case: there's less noise code, and the event
 subscriber has a clear and meaningful name.

 <h3>What about a generic <code>Subscriber&lt;T&gt;</code> interface?</h3>

 <p>Some have proposed a generic <code>Subscriber&lt;T&gt;</code> interface for EventBus listeners. This runs
 into issues with Java's use of type erasure, not to mention problems in usability.

 <p>Let's say the interface looked something like the following:

 <pre><code>
 interface Subscriber&lt;T&gt; {
   void handleEvent(T event);
 }
 </code></pre>

 <p>Due to erasure, no single class can implement a generic interface more than once with
 different type parameters. This is a giant step backwards from traditional Java Events, where
 even if <code>actionPerformed</code> and <code>keyPressed</code> aren't very meaningful names, at least you
 can implement both methods!

 <h3>Doesn't EventBus destroy static typing and eliminate automated refactoring support?</h3>

 <p>Some have freaked out about EventBus's <code>register(Object)</code> and <code>post(Object)</code>
 methods' use of the <code>Object</code> type.

 <p><code>Object</code> is used here for a good reason: the Event Bus library places no restrictions on
 the types of either your event listeners (as in <code>register(Object)</code>) or the events
 themselves (in <code>post(Object)</code>).

 <p>Event subscriber methods, on the other hand, must explicitly declare their argument type --
 the type of event desired (or one of its supertypes). Thus, searching for references to an event
 class will instantly find all subscriber methods for that event, and renaming the type will
 affect all subscriber methods within view of your IDE (and any code that creates the event).

 <p>It's true that you can rename your <code>@Subscribed</code> event subscriber methods at will; Event
 Bus will not stop this or do anything to propagate the rename because, to Event Bus, the names of
 your subscriber methods are irrelevant. Test code that calls the methods directly, of course,
 will be affected by your renaming -- but that's what your refactoring tools are for.

 <h3>What happens if I <code>register</code> a listener without any subscriber methods?</h3>

 <p>Nothing at all.

 <p>The Event Bus was designed to integrate with containers and module systems, with Guice as the
 prototypical example. In these cases, it's convenient to have the container/factory/environment
 pass <i>every</i> created object to an EventBus's <code>register(Object)</code> method.

 <p>This way, any object created by the container/factory/environment can hook into the system's
 event model simply by exposing subscriber methods.

 <h3>What Event Bus problems can be detected at compile time?</h3>

 <p>Any problem that can be unambiguously detected by Java's type system. For example, defining a
 subscriber method for a nonexistent event type.

 <h3>What Event Bus problems can be detected immediately at registration?</h3>

 <p>Immediately upon invoking <code>register(Object)</code>, the listener being registered is checked
 for the <i>well-formedness</i> of its subscriber methods. Specifically, any methods marked with
 <code>@Subscribe</code> must take only a single argument.

 <p>Any violations of this rule will cause an <code>IllegalArgumentException</code> to be thrown.

 <p>(This check could be moved to compile-time using APT, a solution we're researching.)

 <h3>What Event Bus problems may only be detected later, at runtime?</h3>

 <p>If a component posts events with no registered listeners, it <i>may</i> indicate an error
 (typically an indication that you missed a <code>@Subscribe</code> annotation, or that the listening
 component is not loaded).

 <p>(Note that this is <i>not necessarily</i> indicative of a problem. There are many cases where
 an application will deliberately ignore a posted event, particularly if the event is coming from
 code you don't control.)

 <p>To handle such events, register a subscriber method for the <code>DeadEvent</code> class. Whenever
 EventBus receives an event with no registered subscribers, it will turn it into a <code>DeadEvent</code> and pass it your way -- allowing you to log it or otherwise recover.

 <h3>How do I test event listeners and their subscriber methods?</h3>

 <p>Because subscriber methods on your listener classes are normal methods, you can simply call
 them from your test code to simulate the EventBus.</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../com/google/common/escape/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../com/google/common/graph/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/google/common/eventbus/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2010&#x2013;2020. All rights reserved.</small></p>
</body>
</html>
