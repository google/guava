<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Guava 999.0.0-HEAD-android-SNAPSHOT"
  jdversion="1.1.1">

<package name="com.google.common.annotations">
  <!-- start class com.google.common.annotations.Beta -->
  <class name="Beta"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Signifies that a public API (public class, method or field) is subject to incompatible changes,
 or even removal, in a future release. An API bearing this annotation is exempt from any
 compatibility guarantees made by its containing library. Note that the presence of this
 annotation implies nothing about the quality or performance of the API in question, only the fact
 that it is not "API-frozen."

 <p>It is generally safe for <i>applications</i> to depend on beta APIs, at the cost of some extra
 work during upgrades. However it is generally inadvisable for <i>libraries</i> (which get
 included on users' CLASSPATHs, outside the library developers' control) to do so.

 @author Kevin Bourrillion]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.Beta -->
  <!-- start class com.google.common.annotations.GwtCompatible -->
  <class name="GwtCompatible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[The presence of this annotation on a type indicates that the type may be used with <a
 href="https://www.gwtproject.org/">GWT</a> or <a href="https://github.com/google/j2cl">J2CL</a>.

 <p>Note that a {@code GwtCompatible} type may have some {@link GwtIncompatible} methods.

 @author Charles Fry
 @author Hayward Chan]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.GwtCompatible -->
  <!-- start class com.google.common.annotations.GwtIncompatible -->
  <class name="GwtIncompatible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[The presence of this annotation on an API indicates that the method may <em>not</em> be used with
 the <a href="http://www.gwtproject.org/">Google Web Toolkit</a> (GWT).

 <p>This annotation behaves identically to <a href=
 "http://www.gwtproject.org/javadoc/latest/com/google/gwt/core/shared/GwtIncompatible.html">the
 {@code @GwtIncompatible} annotation in GWT itself</a>.

 @author Charles Fry]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.GwtIncompatible -->
  <!-- start class com.google.common.annotations.J2ktIncompatible -->
  <class name="J2ktIncompatible"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[The presence of this annotation on an API indicates that the method may <em>not</em> be used with
 J2kt.

 @since 32.0.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.J2ktIncompatible -->
  <!-- start class com.google.common.annotations.VisibleForTesting -->
  <class name="VisibleForTesting"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates a program element that exists, or is more widely visible than otherwise necessary, only
 for use in test code.

 <p><b>Do not use this interface</b> for public or protected declarations: it is a fig leaf for
 bad design, and it does not prevent anyone from using the declaration---and experience has shown
 that they will. If the method breaks the encapsulation of its class, then its internal
 representation will be hard to change. Instead, use <a
 href="http://errorprone.info/bugpattern/RestrictedApi">RestrictedApiChecker</a>, which enforces
 fine-grained visibility policies.

 @author Johannes Henkel]]>
    </doc>
  </class>
  <!-- end class com.google.common.annotations.VisibleForTesting -->
</package>
<package name="com.google.common.base">
  <!-- start class com.google.common.base.Ascii -->
  <class name="Ascii" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toLowerCase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a copy of the input string in which all {@linkplain #isUpperCase(char) uppercase ASCII
 characters} have been converted to lowercase. All other characters are copied without
 modification.]]>
      </doc>
    </method>
    <method name="toLowerCase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a copy of the input character sequence in which all {@linkplain #isUpperCase(char)
 uppercase ASCII characters} have been converted to lowercase. All other characters are copied
 without modification.

 @since 14.0]]>
      </doc>
    </method>
    <method name="toLowerCase" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[If the argument is an {@linkplain #isUpperCase(char) uppercase ASCII character}, returns the
 lowercase equivalent. Otherwise returns the argument.]]>
      </doc>
    </method>
    <method name="toUpperCase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a copy of the input string in which all {@linkplain #isLowerCase(char) lowercase ASCII
 characters} have been converted to uppercase. All other characters are copied without
 modification.]]>
      </doc>
    </method>
    <method name="toUpperCase" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a copy of the input character sequence in which all {@linkplain #isLowerCase(char)
 lowercase ASCII characters} have been converted to uppercase. All other characters are copied
 without modification.

 @since 14.0]]>
      </doc>
    </method>
    <method name="toUpperCase" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[If the argument is a {@linkplain #isLowerCase(char) lowercase ASCII character}, returns the
 uppercase equivalent. Otherwise returns the argument.]]>
      </doc>
    </method>
    <method name="isLowerCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Indicates whether {@code c} is one of the twenty-six lowercase ASCII alphabetic characters
 between {@code 'a'} and {@code 'z'} inclusive. All others (including non-ASCII characters)
 return {@code false}.]]>
      </doc>
    </method>
    <method name="isUpperCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Indicates whether {@code c} is one of the twenty-six uppercase ASCII alphabetic characters
 between {@code 'A'} and {@code 'Z'} inclusive. All others (including non-ASCII characters)
 return {@code false}.]]>
      </doc>
    </method>
    <method name="truncate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="maxLength" type="int"/>
      <param name="truncationIndicator" type="java.lang.String"/>
      <doc>
      <![CDATA[Truncates the given character sequence to the given maximum length. If the length of the
 sequence is greater than {@code maxLength}, the returned string will be exactly {@code
 maxLength} chars in length and will end with the given {@code truncationIndicator}. Otherwise,
 the sequence will be returned as a string with no changes to the content.

 <p>Examples:

 {@snippet :
 Ascii.truncate("foobar", 7, "..."); // returns "foobar"
 Ascii.truncate("foobar", 5, "..."); // returns "fo..."
 }

 <p><b>Note:</b> This method <i>may</i> work with certain non-ASCII text but is not safe for use
 with arbitrary Unicode text. It is mostly intended for use with text that is known to be safe
 for use with it (such as all-ASCII text) and for simple debugging text. When using this method,
 consider the following:

 <ul>
   <li>it may split surrogate pairs
   <li>it may split characters and combining characters
   <li>it does not consider word boundaries
   <li>if truncating for display to users, there are other considerations that must be taken
       into account
   <li>the appropriate truncation indicator may be locale-dependent
   <li>it is safe to use non-ASCII characters in the truncation indicator
 </ul>

 @throws IllegalArgumentException if {@code maxLength} is less than the length of {@code
     truncationIndicator}
 @since 16.0]]>
      </doc>
    </method>
    <method name="equalsIgnoreCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s1" type="java.lang.CharSequence"/>
      <param name="s2" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Indicates whether the contents of the given character sequences {@code s1} and {@code s2} are
 equal, ignoring the case of any ASCII alphabetic characters between {@code 'a'} and {@code 'z'}
 or {@code 'A'} and {@code 'Z'} inclusive.

 <p>This method is significantly faster than {@link String#equalsIgnoreCase} and should be used
 in preference if at least one of the parameters is known to contain only ASCII characters.

 <p>Note however that this method does not always behave identically to expressions such as:

 <ul>
   <li>{@code string.toUpperCase().equals("UPPER CASE ASCII")}
   <li>{@code string.toLowerCase().equals("lower case ascii")}
 </ul>

 <p>due to case-folding of some non-ASCII characters (which does not occur in {@link
 String#equalsIgnoreCase}). However in almost all cases that ASCII strings are used, the author
 probably wanted the behavior provided by this method rather than the subtle and sometimes
 surprising behavior of {@code toUpperCase()} and {@code toLowerCase()}.

 @since 16.0]]>
      </doc>
    </method>
    <field name="NUL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Null ('\0'): The all-zeros character which may serve to accomplish time fill and media fill.
 Normally used as a C string terminator.

 <p>Although RFC 20 names this as "Null", note that it is distinct from the C/C++ "NULL"
 pointer.

 @since 8.0]]>
      </doc>
    </field>
    <field name="SOH" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start of Heading: A communication control character used at the beginning of a sequence of
 characters which constitute a machine-sensible address or routing information. Such a sequence
 is referred to as the "heading." An STX character has the effect of terminating a heading.

 @since 8.0]]>
      </doc>
    </field>
    <field name="STX" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start of Text: A communication control character which precedes a sequence of characters that
 is to be treated as an entity and entirely transmitted through to the ultimate destination.
 Such a sequence is referred to as "text." STX may be used to terminate a sequence of characters
 started by SOH.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ETX" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Text: A communication control character used to terminate a sequence of characters
 started with STX and transmitted as an entity.

 @since 8.0]]>
      </doc>
    </field>
    <field name="EOT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Transmission: A communication control character used to indicate the conclusion of a
 transmission, which may have contained one or more texts and any associated headings.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ENQ" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enquiry: A communication control character used in data communication systems as a request for
 a response from a remote station. It may be used as a "Who Are You" (WRU) to obtain
 identification, or may be used to obtain station status, or both.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ACK" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Acknowledge: A communication control character transmitted by a receiver as an affirmative
 response to a sender.

 @since 8.0]]>
      </doc>
    </field>
    <field name="BEL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bell ('\a'): A character for use when there is a need to call for human attention. It may
 control alarm or attention devices.

 @since 8.0]]>
      </doc>
    </field>
    <field name="BS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Backspace ('\b'): A format effector which controls the movement of the printing position one
 printing space backward on the same printing line. (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="HT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Horizontal Tabulation ('\t'): A format effector which controls the movement of the printing
 position to the next in a series of predetermined positions along the printing line.
 (Applicable also to display devices and the skip function on punched cards.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="LF" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Line Feed ('\n'): A format effector which controls the movement of the printing position to the
 next printing line. (Applicable also to display devices.) Where appropriate, this character may
 have the meaning "New Line" (NL), a format effector which controls the movement of the printing
 point to the first printing position on the next printing line. Use of this convention requires
 agreement between sender and recipient of data.

 @since 8.0]]>
      </doc>
    </field>
    <field name="NL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Alternate name for {@link #LF}. ({@code LF} is preferred.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="VT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vertical Tabulation ('\v'): A format effector which controls the movement of the printing
 position to the next in a series of predetermined printing lines. (Applicable also to display
 devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="FF" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Form Feed ('\f'): A format effector which controls the movement of the printing position to the
 first pre-determined printing line on the next form or page. (Applicable also to display
 devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="CR" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Carriage Return ('\r'): A format effector which controls the movement of the printing position
 to the first printing position on the same printing line. (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SO" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shift Out: A control character indicating that the code combinations which follow shall be
 interpreted as outside of the character set of the standard code table until a Shift In
 character is reached.

 @since 8.0]]>
      </doc>
    </field>
    <field name="SI" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shift In: A control character indicating that the code combinations which follow shall be
 interpreted according to the standard code table.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DLE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Data Link Escape: A communication control character which will change the meaning of a limited
 number of contiguously following characters. It is used exclusively to provide supplementary
 controls in data communication networks.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC1" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 1. Characters for the control of ancillary devices associated with data
 processing or telecommunication systems, more especially switching devices "on" or "off." (If a
 single "stop" control is required to interrupt or turn off ancillary devices, DC4 is the
 preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="XON" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Transmission On: Although originally defined as DC1, this ASCII control character is now better
 known as the XON code used for software flow control in serial communications. The main use is
 restarting the transmission after the communication has been stopped by the XOFF control code.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC2" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 2. Characters for the control of ancillary devices associated with data
 processing or telecommunication systems, more especially switching devices "on" or "off." (If a
 single "stop" control is required to interrupt or turn off ancillary devices, DC4 is the
 preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC3" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 3. Characters for the control of ancillary devices associated with data
 processing or telecommunication systems, more especially switching devices "on" or "off." (If a
 single "stop" control is required to interrupt or turn off ancillary devices, DC4 is the
 preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="XOFF" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Transmission off. See {@link #XON} for explanation.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DC4" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Device Control 4. Characters for the control of ancillary devices associated with data
 processing or telecommunication systems, more especially switching devices "on" or "off." (If a
 single "stop" control is required to interrupt or turn off ancillary devices, DC4 is the
 preferred assignment.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="NAK" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Negative Acknowledge: A communication control character transmitted by a receiver as a negative
 response to the sender.

 @since 8.0]]>
      </doc>
    </field>
    <field name="SYN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Synchronous Idle: A communication control character used by a synchronous transmission system
 in the absence of any other character to provide a signal from which synchronism may be
 achieved or retained.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ETB" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Transmission Block: A communication control character used to indicate the end of a
 block of data for communication purposes. ETB is used for blocking data where the block
 structure is not necessarily related to the processing format.

 @since 8.0]]>
      </doc>
    </field>
    <field name="CAN" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Cancel: A control character used to indicate that the data with which it is sent is in error or
 is to be disregarded.

 @since 8.0]]>
      </doc>
    </field>
    <field name="EM" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[End of Medium: A control character associated with the sent data which may be used to identify
 the physical end of the medium, or the end of the used, or wanted, portion of information
 recorded on a medium. (The position of this character does not necessarily correspond to the
 physical end of the medium.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SUB" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Substitute: A character that may be substituted for a character which is determined to be
 invalid or in error.

 @since 8.0]]>
      </doc>
    </field>
    <field name="ESC" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Escape: A control character intended to provide code extension (supplementary characters) in
 general information interchange. The Escape character itself is a prefix affecting the
 interpretation of a limited number of contiguously following characters.

 @since 8.0]]>
      </doc>
    </field>
    <field name="FS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[File Separator: These four information separators may be used within data in optional fashion,
 except that their hierarchical relationship shall be: FS is the most inclusive, then GS, then
 RS, and US is least inclusive. (The content and length of a File, Group, Record, or Unit are
 not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="GS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Group Separator: These four information separators may be used within data in optional fashion,
 except that their hierarchical relationship shall be: FS is the most inclusive, then GS, then
 RS, and US is least inclusive. (The content and length of a File, Group, Record, or Unit are
 not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="RS" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Record Separator: These four information separators may be used within data in optional
 fashion, except that their hierarchical relationship shall be: FS is the most inclusive, then
 GS, then RS, and US is least inclusive. (The content and length of a File, Group, Record, or
 Unit are not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="US" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unit Separator: These four information separators may be used within data in optional fashion,
 except that their hierarchical relationship shall be: FS is the most inclusive, then GS, then
 RS, and US is least inclusive. (The content and length of a File, Group, Record, or Unit are
 not specified.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SP" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Space: A normally non-printing graphic character used to separate words. It is also a format
 effector which controls the movement of the printing position, one printing position forward.
 (Applicable also to display devices.)

 @since 8.0]]>
      </doc>
    </field>
    <field name="SPACE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Alternate name for {@link #SP}.

 @since 8.0]]>
      </doc>
    </field>
    <field name="DEL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Delete: This character is used primarily to "erase" or "obliterate" erroneous or unwanted
 characters in perforated tape.

 @since 8.0]]>
      </doc>
    </field>
    <field name="MIN" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The minimum value of an ASCII character.

 @since 9.0 (was type {@code int} before 12.0)]]>
      </doc>
    </field>
    <field name="MAX" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The maximum value of an ASCII character.

 @since 9.0 (was type {@code int} before 12.0)]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static methods pertaining to ASCII characters (those in the range of values {@code 0x00} through
 {@code 0x7F}), and to strings containing such characters.

 <p>ASCII utilities also exist in other classes of this package:

 <ul>
   <!-- TODO(kevinb): how can we make this not produce a warning when building gwt javadoc? -->
   <li>{@link StandardCharsets#US_ASCII} specifies the {@code Charset} of ASCII characters.
   <li>{@link CharMatcher#ascii} matches ASCII characters and provides text processing methods
       which operate only on the ASCII characters of a string.
 </ul>

 @author Catherine Berry
 @author Gregory Kick
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Ascii -->
  <!-- start class com.google.common.base.CaseFormat -->
  <class name="CaseFormat" extends="java.lang.Enum&lt;com.google.common.base.CaseFormat&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.base.CaseFormat[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.base.CaseFormat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="to" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="com.google.common.base.CaseFormat"/>
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Converts the specified {@code String str} from this format to the specified {@code format}. A
 "best effort" approach is taken; if {@code str} does not conform to the assumed format, then
 the behavior of this method is undefined but we make a reasonable effort at converting anyway.]]>
      </doc>
    </method>
    <method name="converterTo" return="com.google.common.base.Converter&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetFormat" type="com.google.common.base.CaseFormat"/>
      <doc>
      <![CDATA[Returns a serializable {@code Converter} that converts strings from this format to {@code
 targetFormat}.

 @since 16.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class for converting between various ASCII case formats. Behavior is undefined for
 non-ASCII input.

 @author Mike Bostock
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CaseFormat -->
  <!-- start class com.google.common.base.CharMatcher -->
  <class name="CharMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Predicate&lt;java.lang.Character&gt;"/>
    <constructor name="CharMatcher"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses. When subclassing, you may want to override {@code
 toString()} to provide a useful description.]]>
      </doc>
    </constructor>
    <method name="any" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches any character.

 @since 19.0 (since 1.0 as constant {@code ANY})]]>
      </doc>
    </method>
    <method name="none" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Matches no characters.

 @since 19.0 (since 1.0 as constant {@code NONE})]]>
      </doc>
    </method>
    <method name="whitespace" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is whitespace according to the latest Unicode standard, as
 illustrated <a
 href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bwhitespace%7D">here</a>.
 This is not the same definition used by other Java APIs. (See a <a
 href="https://docs.google.com/spreadsheets/d/1kq4ECwPjHX9B8QUCTPclgsDCXYaj7T-FlT4tB5q3ahk/edit">comparison
 of several definitions of "whitespace"</a>.)

 <p>All Unicode White_Space characters are on the BMP and thus supported by this API.

 <p><b>Note:</b> as the Unicode definition evolves, we will modify this matcher to keep it up to
 date.

 @since 19.0 (since 1.0 as constant {@code WHITESPACE})]]>
      </doc>
    </method>
    <method name="breakingWhitespace" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is a breaking whitespace (that is, a whitespace which can be
 interpreted as a break between words for formatting purposes). See {@link #whitespace()} for a
 discussion of that term.

 @since 19.0 (since 2.0 as constant {@code BREAKING_WHITESPACE})]]>
      </doc>
    </method>
    <method name="ascii" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is ASCII, meaning that its code point is less than 128.

 @since 19.0 (since 1.0 as constant {@code ASCII})]]>
      </doc>
    </method>
    <method name="digit" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Many digits are supplementary characters; see the class documentation.">
      <doc>
      <![CDATA[Determines whether a character is a BMP digit according to <a
 href="http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7Bdigit%7D">Unicode</a>. If
 you only care to match ASCII digits, you can use {@code inRange('0', '9')}.

 @deprecated Many digits are supplementary characters; see the class documentation.
 @since 19.0 (since 1.0 as constant {@code DIGIT})]]>
      </doc>
    </method>
    <method name="javaDigit" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Many digits are supplementary characters; see the class documentation.">
      <doc>
      <![CDATA[Determines whether a character is a BMP digit according to {@linkplain Character#isDigit(char)
 Java's definition}. If you only care to match ASCII digits, you can use {@code inRange('0',
 '9')}.

 @deprecated Many digits are supplementary characters; see the class documentation.
 @since 19.0 (since 1.0 as constant {@code JAVA_DIGIT})]]>
      </doc>
    </method>
    <method name="javaLetter" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Most letters are supplementary characters; see the class documentation.">
      <doc>
      <![CDATA[Determines whether a character is a BMP letter according to {@linkplain
 Character#isLetter(char) Java's definition}. If you only care to match letters of the Latin
 alphabet, you can use {@code inRange('a', 'z').or(inRange('A', 'Z'))}.

 @deprecated Most letters are supplementary characters; see the class documentation.
 @since 19.0 (since 1.0 as constant {@code JAVA_LETTER})]]>
      </doc>
    </method>
    <method name="javaLetterOrDigit" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Most letters and digits are supplementary characters; see the class documentation.">
      <doc>
      <![CDATA[Determines whether a character is a BMP letter or digit according to {@linkplain
 Character#isLetterOrDigit(char) Java's definition}.

 @deprecated Most letters and digits are supplementary characters; see the class documentation.
 @since 19.0 (since 1.0 as constant {@code JAVA_LETTER_OR_DIGIT}).]]>
      </doc>
    </method>
    <method name="javaUpperCase" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Some uppercase characters are supplementary characters; see the class
     documentation.">
      <doc>
      <![CDATA[Determines whether a BMP character is upper case according to {@linkplain
 Character#isUpperCase(char) Java's definition}.

 @deprecated Some uppercase characters are supplementary characters; see the class
     documentation.
 @since 19.0 (since 1.0 as constant {@code JAVA_UPPER_CASE})]]>
      </doc>
    </method>
    <method name="javaLowerCase" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Some lowercase characters are supplementary characters; see the class
     documentation.">
      <doc>
      <![CDATA[Determines whether a BMP character is lower case according to {@linkplain
 Character#isLowerCase(char) Java's definition}.

 @deprecated Some lowercase characters are supplementary characters; see the class
     documentation.
 @since 19.0 (since 1.0 as constant {@code JAVA_LOWER_CASE})]]>
      </doc>
    </method>
    <method name="javaIsoControl" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether a character is an ISO control character as specified by {@link
 Character#isISOControl(char)}.

 <p>All ISO control codes are on the BMP and thus supported by this API.

 @since 19.0 (since 1.0 as constant {@code JAVA_ISO_CONTROL})]]>
      </doc>
    </method>
    <method name="invisible" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Most invisible characters are supplementary characters; see the class
     documentation.">
      <doc>
      <![CDATA[Determines whether a character is invisible; that is, if its Unicode category is any of
 SPACE_SEPARATOR, LINE_SEPARATOR, PARAGRAPH_SEPARATOR, CONTROL, FORMAT, SURROGATE, and
 PRIVATE_USE according to ICU4J.

 <p>See also the Unicode Default_Ignorable_Code_Point property (available via ICU).

 @deprecated Most invisible characters are supplementary characters; see the class
     documentation.
 @since 19.0 (since 1.0 as constant {@code INVISIBLE})]]>
      </doc>
    </method>
    <method name="singleWidth" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Many such characters are supplementary characters; see the class documentation.">
      <doc>
      <![CDATA[Determines whether a character is single-width (not double-width). When in doubt, this matcher
 errs on the side of returning {@code false} (that is, it tends to assume a character is
 double-width).

 <p><b>Note:</b> as the reference file evolves, we will modify this matcher to keep it up to
 date.

 <p>See also <a href="http://www.unicode.org/reports/tr11/">UAX #11 East Asian Width</a>.

 @deprecated Many such characters are supplementary characters; see the class documentation.
 @since 19.0 (since 1.0 as constant {@code SINGLE_WIDTH})]]>
      </doc>
    </method>
    <method name="is" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches only one specified BMP character.]]>
      </doc>
    </method>
    <method name="isNot" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="match" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character except the BMP character specified.

 <p>To negate another {@code CharMatcher}, use {@link #negate()}.]]>
      </doc>
    </method>
    <method name="anyOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any BMP character present in the given character
 sequence. Returns a bogus matcher if the sequence contains supplementary characters.]]>
      </doc>
    </method>
    <method name="noneOf" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any BMP character not present in the given
 character sequence. Returns a bogus matcher if the sequence contains supplementary characters.]]>
      </doc>
    </method>
    <method name="inRange" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startInclusive" type="char"/>
      <param name="endInclusive" type="char"/>
      <doc>
      <![CDATA[Returns a {@code char} matcher that matches any character in a given BMP range (both endpoints
 are inclusive). For example, to match any lowercase letter of the English alphabet, use {@code
 CharMatcher.inRange('a', 'z')}.

 @throws IllegalArgumentException if {@code endInclusive < startInclusive}]]>
      </doc>
    </method>
    <method name="forPredicate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super java.lang.Character&gt;"/>
      <doc>
      <![CDATA[Returns a matcher with identical behavior to the given {@link Character}-based predicate, but
 which operates on primitive {@code char} instances instead.]]>
      </doc>
    </method>
    <method name="matches" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Determines a true or false value for the given character.]]>
      </doc>
    </method>
    <method name="negate" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher that matches any character not matched by this matcher.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by both this matcher and {@code other}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a matcher that matches any character matched by either this matcher or {@code other}.]]>
      </doc>
    </method>
    <method name="precomputed" return="com.google.common.base.CharMatcher"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code char} matcher functionally equivalent to this one, but which may be faster to
 query than the original; your mileage may vary. Precomputation takes time and requires more
 memory, so it is only likely to be worthwhile if the precomputed matcher is queried very often.

 <p>This method has no effect (returns {@code this}) when called in GWT: it's unclear whether a
 precomputed matcher is faster, but it certainly would consume more memory (which doesn't seem
 like a worthwhile tradeoff in a browser).]]>
      </doc>
    </method>
    <method name="matchesAnyOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains at least one matching BMP character.
 Equivalent to {@code !matchesNoneOf(sequence)}.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code true} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches at least one character in the sequence
 @since 8.0]]>
      </doc>
    </method>
    <method name="matchesAllOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains only matching BMP characters.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code false} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches every character in the sequence, including when
     the sequence is empty]]>
      </doc>
    </method>
    <method name="matchesNoneOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns {@code true} if a character sequence contains no matching BMP characters. Equivalent to
 {@code !matchesAnyOf(sequence)}.

 <p>The default implementation iterates over the sequence, invoking {@link #matches} for each
 character, until this returns {@code true} or the end is reached.

 @param sequence the character sequence to examine, possibly empty
 @return {@code true} if this matcher matches no characters in the sequence, including when the
     sequence is empty]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the first matching BMP character in a character sequence, or {@code -1} if
 no matching character is present.

 <p>The default implementation iterates over the sequence in forward order calling {@link
 #matches} for each character.

 @param sequence the character sequence to examine from the beginning
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="indexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first matching BMP character in a character sequence, starting from a
 given position, or {@code -1} if no character matches after that position.

 <p>The default implementation iterates over the sequence in forward order, beginning at {@code
 start}, calling {@link #matches} for each character.

 @param sequence the character sequence to examine
 @param start the first index to examine; must be nonnegative and no greater than {@code
     sequence.length()}
 @return the index of the first matching character, guaranteed to be no less than {@code start},
     or {@code -1} if no character matches
 @throws IndexOutOfBoundsException if start is negative or greater than {@code
     sequence.length()}]]>
      </doc>
    </method>
    <method name="lastIndexIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the index of the last matching BMP character in a character sequence, or {@code -1} if
 no matching character is present.

 <p>The default implementation iterates over the sequence in reverse order calling {@link
 #matches} for each character.

 @param sequence the character sequence to examine from the end
 @return an index, or {@code -1} if no character matches]]>
      </doc>
    </method>
    <method name="countIn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the number of matching {@code char}s found in a character sequence.

 <p>Counts 2 per supplementary character, such as for {@link #whitespace}().{@link #negate}().]]>
      </doc>
    </method>
    <method name="removeFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all non-matching characters of a character sequence, in order. For
 example:

 {@snippet :
 CharMatcher.is('a').removeFrom("bazaar")
 }

 ... returns {@code "bzr"}.]]>
      </doc>
    </method>
    <method name="retainFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string containing all matching BMP characters of a character sequence, in order. For
 example:

 {@snippet :
 CharMatcher.is('a').retainFrom("bazaar")
 }

 ... returns {@code "aaa"}.]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each matching BMP character
 replaced by a given replacement character. For example:

 {@snippet :
 CharMatcher.is('a').replaceFrom("radar", 'o')
 }

 ... returns {@code "rodor"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching
 character, then iterates the remainder of the sequence calling {@link #matches(char)} for each
 character.

 @param sequence the character sequence to replace matching characters in
 @param replacement the character to append to the result string in place of each matching
     character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="replaceFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each matching BMP character
 replaced by a given replacement sequence. For example:

 {@snippet :
 CharMatcher.is('a').replaceFrom("yaha", "oo")
 }

 ... returns {@code "yoohoo"}.

 <p><b>Note:</b> If the replacement is a fixed string with only one character, you are better
 off calling {@link #replaceFrom(CharSequence, char)} directly.

 @param sequence the character sequence to replace matching characters in
 @param replacement the characters to append to the result string in place of each matching
     character in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all matching BMP characters from
 the beginning and from the end of the string. For example:

 {@snippet :
 CharMatcher.anyOf("ab").trimFrom("abacatbab")
 }

 ... returns {@code "cat"}.

 <p>Note that:

 {@snippet :
 CharMatcher.inRange('\0', ' ').trimFrom(str)
 }

 ... is equivalent to {@link String#trim()}.]]>
      </doc>
    </method>
    <method name="trimLeadingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all matching BMP characters from
 the beginning of the string. For example:

 {@snippet :
 CharMatcher.anyOf("ab").trimLeadingFrom("abacatbab")
 }

 ... returns {@code "catbab"}.]]>
      </doc>
    </method>
    <method name="trimTrailingFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a substring of the input character sequence that omits all matching BMP characters from
 the end of the string. For example:

 {@snippet :
 CharMatcher.anyOf("ab").trimTrailingFrom("abacatbab")
 }

 ... returns {@code "abacat"}.]]>
      </doc>
    </method>
    <method name="collapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Returns a string copy of the input character sequence, with each group of consecutive matching
 BMP characters replaced by a single replacement character. For example:

 {@snippet :
 CharMatcher.anyOf("eko").collapseFrom("bookkeeper", '-')
 }

 ... returns {@code "b-p-r"}.

 <p>The default implementation uses {@link #indexIn(CharSequence)} to find the first matching
 character, then iterates the remainder of the sequence calling {@link #matches(char)} for each
 character.

 @param sequence the character sequence to replace matching groups of characters in
 @param replacement the character to append to the result string in place of each group of
     matching characters in {@code sequence}
 @return the new string]]>
      </doc>
    </method>
    <method name="trimAndCollapseFrom" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <param name="replacement" type="char"/>
      <doc>
      <![CDATA[Collapses groups of matching characters exactly as {@link #collapseFrom} does, except that
 groups of matching BMP characters at the start or end of the sequence are removed without
 replacement.]]>
      </doc>
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Provided only to satisfy the {@link Predicate} interface; use {@link #matches}
     instead.">
      <param name="character" type="java.lang.Character"/>
      <doc>
      <![CDATA[@deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #matches}
     instead.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this {@code CharMatcher}, such as {@code
 CharMatcher.or(WHITESPACE, JAVA_DIGIT)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Determines a true or false value for any Java {@code char} value, just as {@link Predicate} does
 for any {@link Object}. Also offers basic text processing methods based on this function.
 Implementations are strongly encouraged to be side-effect-free and immutable.

 <p>Throughout the documentation of this class, the phrase "matching character" is used to mean
 "any {@code char} value {@code c} for which {@code this.matches(c)} returns {@code true}".

 <p><b>Warning:</b> This class deals only with {@code char} values, that is, <a
 href="http://www.unicode.org/glossary/#BMP_character">BMP characters</a>. It does not understand
 <a href="http://www.unicode.org/glossary/#supplementary_code_point">supplementary Unicode code
 points</a> in the range {@code 0x10000} to {@code 0x10FFFF} which includes the majority of
 assigned characters, including important CJK characters and emoji.

 <p>Supplementary characters are <a
 href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#supplementary">encoded
 into a {@code String} using surrogate pairs</a>, and a {@code CharMatcher} treats these just as
 two separate characters. {@link #countIn} counts each supplementary character as 2 {@code char}s.

 <p>For up-to-date Unicode character properties (digit, letter, etc.) and support for
 supplementary code points, use ICU4J UCharacter and UnicodeSet (freeze() after building). For
 basic text processing based on UnicodeSet use the ICU4J UnicodeSetSpanner.

 <p>Example usages:

 <pre>
   String trimmed = {@link #whitespace() whitespace()}.{@link #trimFrom trimFrom}(userInput);
   if ({@link #ascii() ascii()}.{@link #matchesAllOf matchesAllOf}(s)) { ... }</pre>

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/StringsExplained#charmatcher">{@code CharMatcher}
 </a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.CharMatcher -->
  <!-- start class com.google.common.base.Charsets -->
  <class name="Charsets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="US_ASCII" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Use {@link StandardCharsets#US_ASCII} instead.">
      <doc>
      <![CDATA[US-ASCII: seven-bit ASCII, the Basic Latin block of the Unicode character set (ISO646-US).

 @deprecated Use {@link StandardCharsets#US_ASCII} instead.]]>
      </doc>
    </field>
    <field name="ISO_8859_1" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Use {@link StandardCharsets#ISO_8859_1} instead.">
      <doc>
      <![CDATA[ISO-8859-1: ISO Latin Alphabet Number 1 (ISO-LATIN-1).

 @deprecated Use {@link StandardCharsets#ISO_8859_1} instead.]]>
      </doc>
    </field>
    <field name="UTF_8" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Use {@link StandardCharsets#UTF_8} instead.">
      <doc>
      <![CDATA[UTF-8: eight-bit UCS Transformation Format.

 @deprecated Use {@link StandardCharsets#UTF_8} instead.]]>
      </doc>
    </field>
    <field name="UTF_16BE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Use {@link StandardCharsets#UTF_16BE} instead.">
      <doc>
      <![CDATA[UTF-16BE: sixteen-bit UCS Transformation Format, big-endian byte order.

 @deprecated Use {@link StandardCharsets#UTF_16BE} instead.]]>
      </doc>
    </field>
    <field name="UTF_16LE" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Use {@link StandardCharsets#UTF_16LE} instead.">
      <doc>
      <![CDATA[UTF-16LE: sixteen-bit UCS Transformation Format, little-endian byte order.

 @deprecated Use {@link StandardCharsets#UTF_16LE} instead.]]>
      </doc>
    </field>
    <field name="UTF_16" type="java.nio.charset.Charset"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Use {@link StandardCharsets#UTF_16} instead.">
      <doc>
      <![CDATA[UTF-16: sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order
 mark.

 @deprecated Use {@link StandardCharsets#UTF_16} instead.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Contains constant definitions for the six standard {@link Charset} instances, which are
 guaranteed to be supported by all Java platform implementations.

 <p>Assuming you're free to choose, note that <b>{@link #UTF_8} is widely preferred</b>.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/StringsExplained#charsets">{@code Charsets}</a>.

 @author Mike Bostock
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Charsets -->
  <!-- start class com.google.common.base.Converter -->
  <class name="Converter" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Function&lt;A, B&gt;"/>
    <constructor name="Converter"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="doForward" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="a" type="A"/>
      <doc>
      <![CDATA[Returns a representation of {@code a} as an instance of type {@code B}. If {@code a} cannot be
 converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown.

 @param a the instance to convert; will never be null
 @return the converted instance; <b>must not</b> be null]]>
      </doc>
    </method>
    <method name="doBackward" return="A"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="B"/>
      <doc>
      <![CDATA[Returns a representation of {@code b} as an instance of type {@code A}. If {@code b} cannot be
 converted, an unchecked exception (such as {@link IllegalArgumentException}) should be thrown.

 @param b the instance to convert; will never be null
 @return the converted instance; <b>must not</b> be null
 @throws UnsupportedOperationException if backward conversion is not implemented; this should be
     very rare. Note that if backward conversion is not only unimplemented but
     unimplement<i>able</i> (for example, consider a {@code Converter<Chicken, ChickenNugget>}),
     then this is not logically a {@code Converter} at all, and should just implement {@link
     Function}.]]>
      </doc>
    </method>
    <method name="convert" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="A"/>
      <doc>
      <![CDATA[Returns a representation of {@code a} as an instance of type {@code B}.

 @return the converted value; is null <i>if and only if</i> {@code a} is null]]>
      </doc>
    </method>
    <method name="convertAll" return="java.lang.Iterable&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIterable" type="java.lang.Iterable&lt;? extends A&gt;"/>
      <doc>
      <![CDATA[Returns an iterable that applies {@code convert} to each element of {@code fromIterable}. The
 conversion is done lazily.

 <p>The returned iterable's iterator supports {@code remove()} if the input iterator does. After
 a successful {@code remove()} call, {@code fromIterable} no longer contains the corresponding
 element.]]>
      </doc>
    </method>
    <method name="reverse" return="com.google.common.base.Converter&lt;B, A&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reversed view of this converter, which converts {@code this.convert(a)} back to a
 value roughly equivalent to {@code a}.

 <p>The returned converter is serializable if {@code this} converter is.

 <p><b>Note:</b> you should not override this method. It is non-final for legacy reasons.]]>
      </doc>
    </method>
    <method name="andThen" return="com.google.common.base.Converter&lt;A, C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="secondConverter" type="com.google.common.base.Converter&lt;B, C&gt;"/>
      <doc>
      <![CDATA[Returns a converter whose {@code convert} method applies {@code secondConverter} to the result
 of this converter. Its {@code reverse} method applies the converters in reverse order.

 <p>The returned converter is serializable if {@code this} converter and {@code secondConverter}
 are.]]>
      </doc>
    </method>
    <method name="apply" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Provided to satisfy the {@code Function} interface; use {@link #convert} instead.">
      <param name="a" type="A"/>
      <doc>
      <![CDATA[@deprecated Provided to satisfy the {@code Function} interface; use {@link #convert} instead.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[<i>May</i> return {@code true} if {@code object} is a {@code Converter} that behaves
 identically to this converter.

 <p><b>Warning: do not depend</b> on the behavior of this method.

 <p>Historically, {@code Converter} instances in this library have implemented this method to
 recognize certain cases where distinct {@code Converter} instances would in fact behave
 identically. However, this is not true of {@code Converter} implementations in general. It is
 best not to depend on it.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.base.Converter&lt;A, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forwardFunction" type="com.google.common.base.Function&lt;? super A, ? extends B&gt;"/>
      <param name="backwardFunction" type="com.google.common.base.Function&lt;? super B, ? extends A&gt;"/>
      <doc>
      <![CDATA[Returns a converter based on separate forward and backward functions. This is useful if the
 function instances already exist, or so that you can supply lambda expressions. If those
 circumstances don't apply, you probably don't need to use this; subclass {@code Converter} and
 implement its {@link #doForward} and {@link #doBackward} methods directly.

 <p>These functions will never be passed {@code null} and must not under any circumstances
 return {@code null}. If a value cannot be converted, the function should throw an unchecked
 exception (typically, but not necessarily, {@link IllegalArgumentException}).

 <p>The returned converter is serializable if both provided functions are.

 @since 17.0]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Converter&lt;T, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable converter that always converts or reverses an object to itself.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function from {@code A} to {@code B} with an associated <i>reverse</i> function from {@code B}
 to {@code A}; used for converting back and forth between <i>different representations of the same
 information</i>.

 <h3>Invertibility</h3>

 <p>The reverse operation <b>may</b> be a strict <i>inverse</i> (meaning that {@code
 converter.reverse().convert(converter.convert(a)).equals(a)} is always true). However, it is very
 common (perhaps <i>more</i> common) for round-trip conversion to be <i>lossy</i>. Consider an
 example round-trip using {@link com.google.common.primitives.Doubles#stringConverter}:

 <ol>
   <li>{@code stringConverter().convert("1.00")} returns the {@code Double} value {@code 1.0}
   <li>{@code stringConverter().reverse().convert(1.0)} returns the string {@code "1.0"} --
       <i>not</i> the same string ({@code "1.00"}) we started with
 </ol>

 <p>Note that it should still be the case that the round-tripped and original objects are
 <i>similar</i>.

 <h3>Nullability</h3>

 <p>A converter always converts {@code null} to {@code null} and non-null references to non-null
 references. It would not make sense to consider {@code null} and a non-null reference to be
 "different representations of the same information", since one is distinguishable from
 <i>missing</i> information and the other is not. The {@link #convert} method handles this null
 behavior for all converters; implementations of {@link #doForward} and {@link #doBackward} are
 guaranteed to never be passed {@code null}, and must never return {@code null}.

 <h3>Common ways to use</h3>

 <p>Getting a converter:

 <ul>
   <li>Use a provided converter implementation, such as {@link Enums#stringConverter}, {@link
       com.google.common.primitives.Ints#stringConverter Ints.stringConverter} or the {@linkplain
       #reverse reverse} views of these.
   <li>Convert between specific preset values using {@link
       com.google.common.collect.Maps#asConverter Maps.asConverter}. For example, use this to
       create a "fake" converter for a unit test. It is unnecessary (and confusing) to <i>mock</i>
       the {@code Converter} type using a mocking framework.
   <li>Pass two lambda expressions or method references to the {@link #from from} factory method.
   <li>Extend this class and implement its {@link #doForward} and {@link #doBackward} methods.
 </ul>

 <p>Using a converter:

 <ul>
   <li>Convert one instance in the "forward" direction using {@code converter.convert(a)}.
   <li>Convert multiple instances "forward" using {@code converter.convertAll(as)}.
   <li>Convert in the "backward" direction using {@code converter.reverse().convert(b)} or {@code
       converter.reverse().convertAll(bs)}.
   <li>Use {@code converter} or {@code converter.reverse()} anywhere a {@link
       java.util.function.Function} is accepted (for example {@link java.util.stream.Stream#map
       Stream.map}).
   <li><b>Do not</b> call {@link #doForward} or {@link #doBackward} directly; these exist only to
       be overridden.
 </ul>

 <h3>Example</h3>

 {@snippet :
 return Converter.from(
     Integer::toHexString,
     s -> parseUnsignedInt(s, 16));
 }

 <p>An alternative using a subclass:

 {@snippet :
 return new Converter<Integer, String>() {
   @Override
   protected String doForward(Integer i) {
     return Integer.toHexString(i);
   }

   @Override
   protected Integer doBackward(String s) {
     return parseUnsignedInt(s, 16);
   }
 }
 }

 @author Mike Ward
 @author Kurt Alfred Kluever
 @author Gregory Kick
 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Converter -->
  <!-- start class com.google.common.base.Defaults -->
  <class name="Defaults" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="defaultValue" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the default value of {@code type} as defined by JLS --- {@code 0} for numbers, {@code
 false} for {@code boolean} and {@code '\0'} for {@code char}. For non-primitive types and
 {@code void}, {@code null} is returned.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides default values for all Java types, as defined by the JLS.

 @author Ben Yu
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Defaults -->
  <!-- start class com.google.common.base.Enums -->
  <class name="Enums" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumValue" type="java.lang.Enum&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the {@link Field} in which {@code enumValue} is defined. For example, to get the {@code
 Description} annotation on the {@code GOLF} constant of enum {@code Sport}, use {@code
 Enums.getField(Sport.GOLF).getAnnotation(Description.class)}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="getIfPresent" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an optional enum constant for the given type, using {@link Enum#valueOf}. If the
 constant does not exist, {@link Optional#absent} is returned. A common use case is for parsing
 user input or falling back to a default enum constant. For example, {@code
 Enums.getIfPresent(Country.class, countryInput).or(Country.DEFAULT);}

 @since 12.0]]>
      </doc>
    </method>
    <method name="stringConverter" return="com.google.common.base.Converter&lt;java.lang.String, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumClass" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a serializable converter that converts between strings and {@code enum} values of type
 {@code enumClass} using {@link Enum#valueOf(Class, String)} and {@link Enum#name()}. The
 converter will throw an {@code IllegalArgumentException} if the argument is not the name of any
 enum constant in the specified enum.

 @since 16.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Enum} instances.

 @author Steve McKay
 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Enums -->
  <!-- start class com.google.common.base.Equivalence -->
  <class name="Equivalence" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Equivalence"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="equivalent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="T"/>
      <param name="b" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if the given objects are considered equivalent.

 <p>This method describes an <i>equivalence relation</i> on object references, meaning that for
 all references {@code x}, {@code y}, and {@code z} (any of which may be null):

 <ul>
   <li>{@code equivalent(x, x)} is true (<i>reflexive</i> property)
   <li>{@code equivalent(x, y)} and {@code equivalent(y, x)} each return the same result
       (<i>symmetric</i> property)
   <li>If {@code equivalent(x, y)} and {@code equivalent(y, z)} are both true, then {@code
       equivalent(x, z)} is also true (<i>transitive</i> property)
 </ul>

 <p>Note that all calls to {@code equivalent(x, y)} are expected to return the same result as
 long as neither {@code x} nor {@code y} is modified.]]>
      </doc>
    </method>
    <method name="doEquivalent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="a" type="T"/>
      <param name="b" type="T"/>
      <doc>
      <![CDATA[@since 10.0 (previously, subclasses would override equivalent())]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[<i>May</i> return {@code true} if {@code object} is a {@code Equivalence} that behaves
 identically to this equivalence.

 <p><b>Warning: do not depend</b> on the behavior of this method.

 <p>Historically, {@code Equivalence} instances in this library have implemented this method to
 recognize certain cases where distinct {@code Equivalence} instances would in fact behave
 identically. However, as code migrates to {@code java.util.function}, that behavior will
 disappear. It is best not to depend on it.]]>
      </doc>
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns a hash code for {@code t}.

 <p>The {@code hash} has the following properties:

 <ul>
   <li>It is <i>consistent</i>: for any reference {@code x}, multiple invocations of {@code
       hash(x}} consistently return the same value provided {@code x} remains unchanged
       according to the definition of the equivalence. The hash need not remain consistent from
       one execution of an application to another execution of the same application.
   <li>It is <i>distributable across equivalence</i>: for any references {@code x} and {@code
       y}, if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i>
       necessary that the hash be distributable across <i>inequivalence</i>. If {@code
       equivalence(x, y)} is false, {@code hash(x) == hash(y)} may still be true.
   <li>{@code hash(null)} is {@code 0}.
 </ul>]]>
      </doc>
    </method>
    <method name="doHash" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Implemented by the user to return a hash code for {@code t}, subject to the requirements
 specified in {@link #hash}.

 <p>This method should not be called except by {@link #hash}. When {@link #hash} calls this
 method, {@code t} is guaranteed to be non-null.

 @since 10.0 (previously, subclasses would override hash())]]>
      </doc>
    </method>
    <method name="onResultOf" return="com.google.common.base.Equivalence&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a new equivalence relation for {@code F} which evaluates equivalence by first applying
 {@code function} to the argument, then evaluating using {@code this}. That is, for any pair of
 non-null objects {@code x} and {@code y}, {@code equivalence.onResultOf(function).equivalent(a,
 b)} is true if and only if {@code equivalence.equivalent(function.apply(a), function.apply(b))}
 is true.

 <p>For example:

 {@snippet :
 Equivalence<Person> SAME_AGE = Equivalence.equals().onResultOf(GET_PERSON_AGE);
 }

 <p>{@code function} will never be invoked with a null value.

 <p>Note that {@code function} must be consistent according to {@code this} equivalence
 relation. That is, invoking {@link Function#apply} multiple times for a given value must return
 equivalent results. For example, {@code
 Equivalence.identity().onResultOf(Functions.toStringFunction())} is broken because it's not
 guaranteed that {@link Object#toString}) always returns the same string instance.

 @since 10.0]]>
      </doc>
    </method>
    <method name="wrap" return="com.google.common.base.Equivalence.Wrapper&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="S extends T"/>
      <doc>
      <![CDATA[Returns a wrapper of {@code reference} that implements {@link Wrapper#equals(Object)
 Object.equals()} such that {@code wrap(a).equals(wrap(b))} if and only if {@code equivalent(a,
 b)}.

 <p>The returned object is serializable if both this {@code Equivalence} and {@code reference}
 are serializable (including when {@code reference} is null).

 @since 10.0]]>
      </doc>
    </method>
    <method name="pairwise" return="com.google.common.base.Equivalence&lt;java.lang.Iterable&lt;S&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence over iterables based on the equivalence of their elements. More
 specifically, two iterables are considered equivalent if they both contain the same number of
 elements, and each pair of corresponding elements is equivalent according to {@code this}. Null
 iterables are equivalent to one another.

 <p>Note that this method performs a similar function for equivalences as {@link
 com.google.common.collect.Ordering#lexicographical} does for orderings.

 <p>The returned object is serializable if this object is serializable.

 @since 10.0]]>
      </doc>
    </method>
    <method name="equivalentTo" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to true if and only if the input is equivalent to {@code
 target} according to this equivalence relation.

 @since 10.0]]>
      </doc>
    </method>
    <method name="equals" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence that delegates to {@link Object#equals} and {@link Object#hashCode}.
 {@link Equivalence#equivalent} returns {@code true} if both values are null, or if neither
 value is null and {@link Object#equals} returns {@code true}. {@link Equivalence#hash} returns
 {@code 0} if passed a null value.

 @since 13.0
 @since 8.0 (in Equivalences with null-friendly behavior)
 @since 4.0 (in Equivalences)]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Equivalence&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an equivalence that uses {@code ==} to compare values and {@link
 System#identityHashCode(Object)} to compute the hash code. {@link Equivalence#equivalent}
 returns {@code true} if {@code a == b}, including in the case that a and b are both null.

 @since 13.0
 @since 4.0 (in Equivalences)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A strategy for determining whether two instances are considered equivalent, and for computing
 hash codes in a manner consistent with that equivalence. Two examples of equivalences are the
 {@linkplain #identity() identity equivalence} and the {@linkplain #equals "equals" equivalence}.

 <p><b>For users targeting Android API level 24 or higher:</b> This class will eventually
 implement {@code BiPredicate<T, T>} (as it does in the main Guava artifact), but we currently
 target a lower API level. In the meantime, if you have support for method references you can use
 an equivalence as a bi-predicate like this: {@code myEquivalence::equivalent}.

 @author Bob Lee
 @author Ben Yu
 @author Gregory Kick
 @since 10.0 (<a href="https://github.com/google/guava/wiki/Compatibility">mostly
     source-compatible</a> since 4.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Equivalence -->
  <!-- start class com.google.common.base.Equivalence.Wrapper -->
  <class name="Equivalence.Wrapper" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="get" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the (possibly null) reference wrapped by this instance.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@link Equivalence#equivalent(Object, Object)} applied to the wrapped
 references is {@code true} and both wrappers use the {@link Object#equals(Object) same}
 equivalence.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the result of {@link Equivalence#hash(Object)} applied to the wrapped reference.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this equivalence wrapper. The form of this string
 representation is not specified.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an {@link
 Equivalence}.

 <p>For example, given an {@link Equivalence} for {@link String strings} named {@code equiv}
 that tests equivalence using their lengths:

 {@snippet :
 equiv.wrap("a").equals(equiv.wrap("b")) // true
 equiv.wrap("a").equals(equiv.wrap("hello")) // false
 }

 <p>Note in particular that an equivalence wrapper is never equal to the object it wraps.

 {@snippet :
 equiv.wrap(obj).equals(obj) // always false
 }

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Equivalence.Wrapper -->
  <!-- start class com.google.common.base.FinalizablePhantomReference -->
  <class name="FinalizablePhantomReference" extends="java.lang.ref.PhantomReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizablePhantomReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable phantom reference.

 @param referent to phantom reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Phantom reference with a {@code finalizeReferent()} method which a background thread invokes
 after the garbage collector reclaims the referent. This is a simpler alternative to using a
 {@link ReferenceQueue}.

 <p>Unlike a normal phantom reference, this reference will be cleared automatically.

 @author Bob Lee
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizablePhantomReference -->
  <!-- start interface com.google.common.base.FinalizableReference -->
  <interface name="FinalizableReference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="finalizeReferent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoked on a background thread after the referent has been garbage collected unless security
 restrictions prevented starting a background thread, in which case this method is invoked when
 new references are created.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implemented by references that have code to run after garbage collection of their referents.

 @see FinalizableReferenceQueue
 @author Bob Lee
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.FinalizableReference -->
  <!-- start class com.google.common.base.FinalizableReferenceQueue -->
  <class name="FinalizableReferenceQueue" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="FinalizableReferenceQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new queue.]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A reference queue with an associated background thread that dequeues references and invokes
 {@link FinalizableReference#finalizeReferent()} on them. Java 9+ users should prefer {@link
 java.lang.ref.Cleaner Cleaner}; see example <a href="#cleaner">below</a>.

 <p>Keep a strong reference to this object until all of the associated referents have been
 finalized. If this object is garbage collected earlier, the backing thread will not invoke {@code
 finalizeReferent()} on the remaining references.

 <p>As an example of how this is used, imagine you have a class {@code MyServer} that creates a
 {@link java.net.ServerSocket ServerSocket}, and you would like to ensure that the {@code
 ServerSocket} is closed even if the {@code MyServer} object is garbage-collected without calling
 its {@code close} method. You <em>could</em> use a finalizer to accomplish this, but that has a
 number of well-known problems. Here is how you might use this class instead:

 {@snippet :
 public class MyServer implements Closeable {
   private static final FinalizableReferenceQueue frq = new FinalizableReferenceQueue();
   // You might also share this between several objects.

   private static final Set<Reference<?>> references = Sets.newConcurrentHashSet();
   // This ensures that the FinalizablePhantomReference itself is not garbage-collected.

   private final ServerSocket serverSocket;

   private MyServer(...) {
     ...
     this.serverSocket = new ServerSocket(...);
     ...
   }

   public static MyServer create(...) {
     MyServer myServer = new MyServer(...);
     ServerSocket serverSocket = myServer.serverSocket;
     Reference<?> reference = new FinalizablePhantomReference<MyServer>(myServer, frq) {
       @Override
       public void finalizeReferent() {
         references.remove(this):
         if (!serverSocket.isClosed()) {
           ...log a message about how nobody called close()...
           try {
             serverSocket.close();
           } catch (IOException e) {
             ...
           }
         }
       }
     };
     references.add(reference);
     return myServer;
   }

   @Override
   public void close() throws IOException {
     serverSocket.close();
   }
 }
 }

 <p id="cleaner">Here is how you might achieve the same thing using {@link java.lang.ref.Cleaner
 Cleaner}, if you are using a Java version where that is available:

 {@snippet :
 public class MyServer implements Closeable {
   private static final Cleaner cleaner = Cleaner.create();
   // You might also share this between several objects.

   private final ServerSocket serverSocket;
   private final Cleaner.Cleanable cleanable;

   public MyServer(...) {
     ...
     this.serverSocket = new ServerSocket(...);
     this.cleanable = cleaner.register(this, closeServerSocketRunnable(serverSocket));
     ...
   }

   private static Runnable closeServerSocketRunnable(ServerSocket serverSocket) {
     return () -> {
       if (!serverSocket.isClosed()) {
         ...log a message about how nobody called close()...
         try {
           serverSocket.close();
         } catch (IOException e) {
           ...
         }
       }
     };
   }

   @Override
   public void close() throws IOException {
     serverSocket.close();
     cleanable.clean();
   }
 }
 }

 <p>Some care is needed when using {@code Cleaner} to ensure that the callback passed to {@code
 register} does not have a reference to the object (in this case, {@code MyServer}) that may be
 garbage-collected. That's why we are careful to make a {@code Runnable} that does not have a
 reference to any {@code MyServer} instance.

 @author Bob Lee
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableReferenceQueue -->
  <!-- start class com.google.common.base.FinalizableSoftReference -->
  <class name="FinalizableSoftReference" extends="java.lang.ref.SoftReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizableSoftReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable soft reference.

 @param referent to softly reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Soft reference with a {@code finalizeReferent()} method which a background thread invokes after
 the garbage collector reclaims the referent. This is a simpler alternative to using a {@link
 ReferenceQueue}.

 @author Bob Lee
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableSoftReference -->
  <!-- start class com.google.common.base.FinalizableWeakReference -->
  <class name="FinalizableWeakReference" extends="java.lang.ref.WeakReference&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.FinalizableReference"/>
    <constructor name="FinalizableWeakReference" type="T, com.google.common.base.FinalizableReferenceQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new finalizable weak reference.

 @param referent to weakly reference
 @param queue that should finalize the referent]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Weak reference with a {@code finalizeReferent()} method which a background thread invokes after
 the garbage collector reclaims the referent. This is a simpler alternative to using a {@link
 ReferenceQueue}.

 @author Bob Lee
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.FinalizableWeakReference -->
  <!-- start interface com.google.common.base.Function -->
  <interface name="Function"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="T extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="F extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the result of applying this function to {@code input}. This method is <i>generally
 expected</i>, but not absolutely required, to have the following properties:

 <ul>
   <li>Its execution does not cause any observable side effects.
   <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equals
       Objects.equals}{@code (a, b)} implies that {@code Objects.equals(function.apply(a),
       function.apply(b))}.
 </ul>

 @throws NullPointerException if {@code input} is null and this function does not accept null
     arguments]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[<i>May</i> return {@code true} if {@code obj} is a {@code Function} that behaves identically to
 this function.

 <p><b>Warning: do not depend</b> on the behavior of this method.

 <p>Historically, {@code Function} instances in this library have implemented this method to
 recognize certain cases where distinct {@code Function} instances would in fact behave
 identically. However, as code migrates to {@code java.util.function}, that behavior will
 disappear. It is best not to depend on it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Determines an output value based on an input value; a pre-Java-8 version of {@link
 java.util.function.Function java.util.function.Function}.

 <p>The {@link Functions} class provides common functions and related utilities.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/FunctionalExplained">the use of {@code Function}</a>.

 <h3>For Java 8+ users</h3>

 <p>This interface is now a legacy type. Use {@code java.util.function.Function} (or the
 appropriate primitive specialization such as {@code ToIntFunction}) instead whenever possible.
 Otherwise, at least reduce <i>explicit</i> dependencies on this type by using lambda expressions
 or method references instead of classes, leaving your code easier to migrate in the future.

 <p>To use an existing function (say, named {@code function}) in a context where the <i>other
 type</i> of function is expected, use the method reference {@code function::apply}. A future
 version of {@code com.google.common.base.Function} will be made to <i>extend</i> {@code
 java.util.function.Function}, making conversion code necessary only in one direction. At that
 time, this interface will be officially discouraged.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Function -->
  <!-- start class com.google.common.base.Functions -->
  <class name="Functions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toStringFunction" return="com.google.common.base.Function&lt;java.lang.Object, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A function equivalent to the method reference {@code Object::toString}. The function simply
 invokes {@code toString} on its argument and returns the result. It throws a {@link
 NullPointerException} on null input.

 <p><b>Warning:</b> The returned function may not be <i>consistent with equals</i> (as
 documented at {@link Function#apply}). For example, this function yields different results for
 the two equal instances {@code ImmutableSet.of(1, 2)} and {@code ImmutableSet.of(2, 1)}.

 <p><b>Warning:</b> as with all function types in this package, avoid depending on the specific
 {@code equals}, {@code hashCode} or {@code toString} behavior of the returned function. A
 future migration to {@code java.util.function} will not preserve this behavior.

 <p>As discussed above, prefer to use the method reference {@code Object::toString} instead,
 though note that it is not serializable unless you explicitly make it {@link Serializable},
 typically by writing {@code (Function<Object, String> & Serializable) Object::toString}.

 <p>For more important information about the transition from Guava's {@link Function} class to
 the JDK {@link java.util.function.Function} class, see {@link Function}.]]>
      </doc>
    </method>
    <method name="identity" return="com.google.common.base.Function&lt;E, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the identity function.

 <p><b>Discouraged:</b> Prefer using a lambda like {@code v -> v}, which is shorter and often
 more readable.]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.base.Function&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a function which performs a map lookup. The returned function throws an {@link
 IllegalArgumentException} if given a key that does not exist in the map. See also {@link
 #forMap(Map, Object)}, which returns a default value in this case.

 <p>Note: if {@code map} is a {@link com.google.common.collect.BiMap BiMap} (or can be one), you
 can use {@link com.google.common.collect.Maps#asConverter Maps.asConverter} instead to get a
 function that also supports reverse conversion.

 <p>If you are okay with {@code null} being returned for an unrecognized key (instead of an
 exception being thrown), you can use the method reference {@code map::get} instead. Note that
 it is not serializable unless you explicitly make it {@link Serializable}, typically by writing
 {@code (Function<K, V> & Serializable) map::get}.]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.base.Function&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <param name="defaultValue" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a function which performs a map lookup with a default value. The function created by
 this method returns {@code defaultValue} for all inputs that do not belong to the map's key
 set. See also {@link #forMap(Map)}, which throws an exception in this case.

 <p>Prefer to write the lambda expression {@code k -> map.getOrDefault(k, defaultValue)}
 instead. Note that it is not serializable unless you explicitly make it {@link Serializable},
 typically by writing {@code (Function<K, V> & Serializable) k -> map.getOrDefault(k,
 defaultValue)}.

 @param map source map that determines the function behavior
 @param defaultValue the value to return for inputs that aren't map keys
 @return function that returns {@code map.get(a)} when {@code a} is a key, or {@code
     defaultValue} otherwise]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.base.Function&lt;A, C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="g" type="com.google.common.base.Function&lt;B, C&gt;"/>
      <param name="f" type="com.google.common.base.Function&lt;A, ? extends B&gt;"/>
      <doc>
      <![CDATA[Returns the composition of two functions. For {@code f: A->B} and {@code g: B->C}, composition
 is defined as the function h such that {@code h(a) == g(f(a))} for each {@code a}.

 <p><b>JRE users and Android users who opt in to library desugaring:</b> use {@code
 g.compose(f)} or (probably clearer) {@code f.andThen(g)} instead. Note that it is not
 serializable.

 @param g the second function to apply
 @param f the first function to apply
 @return the composition of {@code f} and {@code g}
 @see <a href="//en.wikipedia.org/wiki/Function_composition">function composition</a>]]>
      </doc>
    </method>
    <method name="forPredicate" return="com.google.common.base.Function&lt;T, java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a function that returns the same boolean output as the given predicate for all inputs.

 <p>The returned function is <i>consistent with equals</i> (as documented at {@link
 Function#apply}) if and only if {@code predicate} is itself consistent with equals.

 <p>Prefer to use the method reference {@code predicate::test} instead. Note that it is not
 serializable unless you explicitly make it {@link Serializable}, typically by writing {@code
 (Function<T, Boolean> & Serializable) predicate::test}.]]>
      </doc>
    </method>
    <method name="constant" return="com.google.common.base.Function&lt;java.lang.Object, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a function that ignores its input and always returns {@code value}.

 <p>Prefer to use the lambda expression {@code o -> value} instead. Note that it is not
 serializable unless you explicitly make it {@link Serializable}, typically by writing {@code
 (Function<Object, E> & Serializable) o -> value}.

 @param value the constant value for the function to return
 @return a function that always returns {@code value}]]>
      </doc>
    </method>
    <method name="forSupplier" return="com.google.common.base.Function&lt;F, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a function that ignores its input and returns the result of {@code supplier.get()}.

 <p>Prefer to use the lambda expression {@code o -> supplier.get()} instead. Note that it is not
 serializable unless you explicitly make it {@link Serializable}, typically by writing {@code
 (Function<F, T> & Serializable) o -> supplier.get()}.

 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code com.google.common.base.Function} instances; see that
 class for information about migrating to {@code java.util.function}.

 <p>All methods return serializable functions as long as they're given serializable parameters.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/FunctionalExplained">the use of {@code Function}</a>.

 @author Mike Bostock
 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Functions -->
  <!-- start class com.google.common.base.Joiner -->
  <class name="Joiner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="on" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a joiner which automatically places {@code separator} between consecutive elements.]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a joiner which automatically places {@code separator} between consecutive elements.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.util.Iterator&lt;?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="first" type="Object"/>
      <param name="second" type="Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends to {@code appendable} the string representation of each of the remaining arguments.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="parts" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Appends the string representation of each of {@code parts}, using the previously configured
 separator between each, to {@code builder}. Identical to {@link #appendTo(Appendable,
 Iterable)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="first" type="Object"/>
      <param name="second" type="Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Appends to {@code builder} the string representation of each of the remaining arguments.
 Identical to {@link #appendTo(Appendable, Object, Object, Object...)}, except that it does not
 throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.

 @since 11.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="parts" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each of {@code parts}, using the
 previously configured separator between each.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="Object"/>
      <param name="second" type="Object"/>
      <param name="rest" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each argument, using the previously
 configured separator between each.]]>
      </doc>
    </method>
    <method name="useForNull" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullText" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a joiner with the same behavior as this one, except automatically substituting {@code
 nullText} for any provided null elements.]]>
      </doc>
    </method>
    <method name="skipNulls" return="com.google.common.base.Joiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a joiner with the same behavior as this joiner, except automatically skipping over any
 provided null elements.]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Joiner.MapJoiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValueSeparator" type="char"/>
      <doc>
      <![CDATA[Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as
 this {@code Joiner} otherwise.

 @since 20.0]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Joiner.MapJoiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValueSeparator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code MapJoiner} using the given key-value separator, and the same configuration as
 this {@code Joiner} otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object which joins pieces of text (specified as an array, {@link Iterable}, varargs or even a
 {@link Map}) with a separator. It either appends the results to an {@link Appendable} or returns
 them as a {@link String}. Example:

 {@snippet :
 Joiner joiner = Joiner.on("; ").skipNulls();
  . . .
 return joiner.join("Harry", null, "Ron", "Hermione");
 }

 <p>This returns the string {@code "Harry; Ron; Hermione"}. Note that all input elements are
 converted to strings using {@link Object#toString()} before being appended.

 <p>If neither {@link #skipNulls()} nor {@link #useForNull(String)} is specified, the joining
 methods will throw {@link NullPointerException} if any given element is null.

 <p><b>Warning: joiner instances are always immutable</b>; a configuration method such as {@code
 useForNull} has no effect on the instance it is invoked on! You must store and use the new joiner
 instance returned by the method. This makes joiners thread-safe, and safe to store as {@code
 static final} constants.

 {@snippet :
 // Bad! Do not do this!
 Joiner joiner = Joiner.on(',');
 joiner.skipNulls(); // does nothing!
 return joiner.join("wrong", null, "wrong");
 }

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/StringsExplained#joiner">{@code Joiner}</a>.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Joiner -->
  <!-- start class com.google.common.base.Joiner.MapJoiner -->
  <class name="Joiner.MapJoiner" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each entry of {@code map}, using the previously
 configured separator and key-value separator, to {@code appendable}.]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each entry of {@code map}, using the previously
 configured separator and key-value separator, to {@code builder}. Identical to {@link
 #appendTo(Appendable, Map)}, except that it does not throw {@link IOException}.]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code appendable}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="appendTo" return="A extends java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="A extends java.lang.Appendable"/>
      <param name="parts" type="java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code appendable}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code builder}. Identical to {@link
 #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="appendTo" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
      <param name="entries" type="java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Appends the string representation of each entry in {@code entries}, using the previously
 configured separator and key-value separator, to {@code builder}. Identical to {@link
 #appendTo(Appendable, Iterable)}, except that it does not throw {@link IOException}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each entry of {@code map}, using the
 previously configured separator and key-value separator.]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each entry in {@code entries}, using
 the previously configured separator and key-value separator.

 @since 10.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.util.Iterator&lt;? extends java.util.Map.Entry&lt;?, ?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a string containing the string representation of each entry in {@code entries}, using
 the previously configured separator and key-value separator.

 @since 11.0]]>
      </doc>
    </method>
    <method name="useForNull" return="com.google.common.base.Joiner.MapJoiner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullText" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a map joiner with the same behavior as this one, except automatically substituting
 {@code nullText} for any provided null keys or values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that joins map entries in the same manner as {@code Joiner} joins iterables and
 arrays. Like {@code Joiner}, it is thread-safe and immutable.

 <p>In addition to operating on {@code Map} instances, {@code MapJoiner} can operate on {@code
 Multimap} entries in two distinct modes:

 <ul>
   <li>To output a separate entry for each key-value pair, pass {@code multimap.entries()} to a
       {@code MapJoiner} method that accepts entries as input, and receive output of the form
       {@code key1=A&key1=B&key2=C}.
   <li>To output a single entry for each key, pass {@code multimap.asMap()} to a {@code
       MapJoiner} method that accepts a map as input, and receive output of the form {@code
       key1=[A, B]&key2=C}.
 </ul>

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Joiner.MapJoiner -->
  <!-- start class com.google.common.base.MoreObjects -->
  <class name="MoreObjects" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="firstNonNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="T"/>
      <param name="second" type="T"/>
      <doc>
      <![CDATA[Returns the first of two given parameters that is not {@code null}, if either is, or otherwise
 throws a {@link NullPointerException}.

 <p>To find the first non-null element in an iterable, use {@code Iterables.find(iterable,
 Predicates.notNull())}. For varargs, use {@code Iterables.find(Arrays.asList(a, b, c, ...),
 Predicates.notNull())}, static importing as necessary.

 <p><b>Note:</b> if {@code first} is represented as an {@link Optional}, this can be
 accomplished with {@link Optional#or(Object) first.or(second)}. That approach also allows for
 lazy evaluation of the fallback instance, using {@link Optional#or(Supplier)
 first.or(supplier)}.

 <p><b>Java 9 users:</b> use {@code java.util.Objects.requireNonNullElse(first, second)}
 instead.

 @return {@code first} if it is non-null; otherwise {@code second} if it is non-null
 @throws NullPointerException if both {@code first} and {@code second} are null
 @since 18.0 (since 3.0 as {@code Objects.firstNonNull()}).]]>
      </doc>
    </method>
    <method name="toStringHelper" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="self" type="java.lang.Object"/>
      <doc>
      <![CDATA[Creates an instance of {@link ToStringHelper}.

 <p>This is helpful for implementing {@link Object#toString()}. Specification by example:

 {@snippet :
 // Returns "ClassName{}"
 MoreObjects.toStringHelper(this)
     .toString();

 // Returns "ClassName{x=1}"
 MoreObjects.toStringHelper(this)
     .add("x", 1)
     .toString();

 // Returns "MyObject{x=1}"
 MoreObjects.toStringHelper("MyObject")
     .add("x", 1)
     .toString();

 // Returns "ClassName{x=1, y=foo}"
 MoreObjects.toStringHelper(this)
     .add("x", 1)
     .add("y", "foo")
     .toString();

 // Returns "ClassName{x=1}"
 MoreObjects.toStringHelper(this)
     .omitNullValues()
     .add("x", 1)
     .add("y", null)
     .toString();
 }

 <p>Note that in GWT, class names are often obfuscated.

 @param self the object to generate the string for (typically {@code this}), used only for its
     class name
 @since 18.0 (since 2.0 as {@code Objects.toStringHelper()}).]]>
      </doc>
    </method>
    <method name="toStringHelper" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Creates an instance of {@link ToStringHelper} in the same manner as {@link
 #toStringHelper(Object)}, but using the simple name of {@code clazz} instead of using an
 instance's {@link Object#getClass()}.

 <p>Note that in GWT, class names are often obfuscated.

 @param clazz the {@link Class} of the instance
 @since 18.0 (since 7.0 as {@code Objects.toStringHelper()}).]]>
      </doc>
    </method>
    <method name="toStringHelper" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates an instance of {@link ToStringHelper} in the same manner as {@link
 #toStringHelper(Object)}, but using {@code className} instead of using an instance's {@link
 Object#getClass()}.

 @param className the name of the instance type
 @since 18.0 (since 7.0 as {@code Objects.toStringHelper()}).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper functions that operate on any {@code Object}, and are not already provided in {@link
 java.util.Objects}.

 <p>See the Guava User Guide on <a
 href="https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained">writing {@code Object}
 methods with {@code MoreObjects}</a>.

 @author Laurence Gonsalves
 @since 18.0 (since 2.0 as {@code Objects})]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.MoreObjects -->
  <!-- start class com.google.common.base.MoreObjects.ToStringHelper -->
  <class name="MoreObjects.ToStringHelper" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="omitNullValues" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the {@link ToStringHelper} so {@link #toString()} will ignore properties with null
 value. The order of calling this method, relative to the {@code add()}/{@code addValue()}
 methods, is not significant.

 @since 18.0 (since 12.0 as {@code Objects.ToStringHelper.omitNullValues()}).]]>
      </doc>
    </method>
    <method name="omitEmptyValues" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures the {@link ToStringHelper} so {@link #toString()} will ignore properties with
 empty values. The order of calling this method, relative to the {@code add()}/{@code
 addValue()} methods, is not significant.

 <p><b>Note:</b> in general, code should assume that the string form returned by {@code
 ToStringHelper} for a given object may change. In particular, the list of types which are
 checked for emptiness is subject to change. We currently check {@code CharSequence}s, {@code
 Collection}s, {@code Map}s, optionals (including Guava's), and arrays.

 @since 33.4.0]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value} format. If {@code value}
 is {@code null}, the string {@code "null"} is used, unless {@link #omitNullValues()} is
 called, in which case this name/value pair will not be added.]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value} format.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value} format.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value} format.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value} format.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value} format.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Adds a name/value pair to the formatted output in {@code name=value} format.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.add()}).]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, Object)} instead and give value a
 readable name.]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, boolean)} instead and give value a
 readable name.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, char)} instead and give value a
 readable name.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, double)} instead and give value a
 readable name.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, float)} instead and give value a
 readable name.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, int)} instead and give value a
 readable name.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).]]>
      </doc>
    </method>
    <method name="addValue" return="com.google.common.base.MoreObjects.ToStringHelper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Adds an unnamed value to the formatted output.

 <p>It is strongly encouraged to use {@link #add(String, long)} instead and give value a
 readable name.

 @since 18.0 (since 11.0 as {@code Objects.ToStringHelper.addValue()}).]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string in the format specified by {@link MoreObjects#toStringHelper(Object)}.

 <p>After calling this method, you can keep adding more properties to later call toString()
 again and get a more complete representation of the same object; but properties cannot be
 removed, so this only allows limited reuse of the helper instance. The helper allows
 duplication of properties (multiple name/value pairs with the same name can be added).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Support class for {@link MoreObjects#toStringHelper}.

 @author Jason Lee
 @since 18.0 (since 2.0 as {@code Objects.ToStringHelper}).]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.MoreObjects.ToStringHelper -->
  <!-- start class com.google.common.base.Objects -->
  <class name="Objects" extends="com.google.common.base.ExtraObjectsMethodsForWeb"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="Object"/>
      <param name="b" type="Object"/>
      <doc>
      <![CDATA[Determines whether two possibly-null objects are equal. Returns:

 <ul>
   <li>{@code true} if {@code a} and {@code b} are both null.
   <li>{@code true} if {@code a} and {@code b} are both non-null and they are equal according to
       {@link Object#equals(Object)}.
   <li>{@code false} in all other situations.
 </ul>

 <p>This assumes that any non-null objects passed to this function conform to the {@code
 equals()} contract.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 java.util.Objects#equals} instead.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objects" type="Object"/>
      <doc>
      <![CDATA[Generates a hash code for multiple values. The hash code is generated by calling {@link
 Arrays#hashCode(Object[])}. Note that array arguments to this method, with the exception of a
 single Object array, do not get any special handling; their hash codes are based on identity
 and not contents.

 <p>This is useful for implementing {@link Object#hashCode()}. For example, in an object that
 has three properties, {@code x}, {@code y}, and {@code z}, one could write:

 {@snippet :
 public int hashCode() {
   return Objects.hashCode(getX(), getY(), getZ());
 }
 }

 <p><b>Warning:</b> When a single object is supplied, the returned hash code does not equal the
 hash code of that object.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 java.util.Objects#hash} instead.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper functions that can operate on any {@code Object}.

 <p>See the Guava User Guide on <a
 href="https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained">writing {@code Object}
 methods with {@code Objects}</a>.

 @author Laurence Gonsalves
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Objects -->
  <!-- start class com.google.common.base.Optional -->
  <class name="Optional" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="absent" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code Optional} instance with no contained reference.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method is equivalent to Java 8's
 {@code Optional.empty}.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <doc>
      <![CDATA[Returns an {@code Optional} instance containing the given non-null reference. To have {@code
 null} treated as {@link #absent}, use {@link #fromNullable} instead.

 <p><b>Comparison to {@code java.util.Optional}:</b> no differences.

 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="fromNullable" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nullableReference" type="T"/>
      <doc>
      <![CDATA[If {@code nullableReference} is non-null, returns an {@code Optional} instance containing that
 reference; otherwise returns {@link Optional#absent}.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method is equivalent to Java 8's
 {@code Optional.ofNullable}.]]>
      </doc>
    </method>
    <method name="fromJavaUtil" return="Optional"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaUtilOptional" type="Optional"/>
      <doc>
      <![CDATA[Returns the equivalent {@code com.google.common.base.Optional} value to the given {@code
 java.util.Optional}, or {@code null} if the argument is null.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toJavaUtil" return="Optional"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="googleOptional" type="Optional"/>
      <doc>
      <![CDATA[Returns the equivalent {@code java.util.Optional} value to the given {@code
 com.google.common.base.Optional}, or {@code null} if the argument is null.

 <p>If {@code googleOptional} is known to be non-null, use {@code googleOptional.toJavaUtil()}
 instead.

 <p>Unfortunately, the method reference {@code Optional::toJavaUtil} will not work, because it
 could refer to either the static or instance version of this method. Write out the lambda
 expression {@code o -> Optional.toJavaUtil(o)} instead.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toJavaUtil" return="java.util.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the equivalent {@code java.util.Optional} value to this optional.

 <p>Unfortunately, the method reference {@code Optional::toJavaUtil} will not work, because it
 could refer to either the static or instance version of this method. Write out the lambda
 expression {@code o -> o.toJavaUtil()} instead.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="isPresent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this holder contains a (non-null) instance.

 <p><b>Comparison to {@code java.util.Optional}:</b> no differences.]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contained instance, which must be present. If the instance might be absent, use
 {@link #or(Object)} or {@link #orNull} instead.

 <p><b>Comparison to {@code java.util.Optional}:</b> when the value is absent, this method
 throws {@link IllegalStateException}, whereas the {@code java.util} counterpart throws {@link
 java.util.NoSuchElementException NoSuchElementException}.

 @throws IllegalStateException if the instance is absent ({@link #isPresent} returns {@code
     false}); depending on this <i>specific</i> exception type (over the more general {@link
     RuntimeException}) is discouraged]]>
      </doc>
    </method>
    <method name="or" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the contained instance if it is present; {@code defaultValue} otherwise. If no default
 value should be required because the instance is known to be present, use {@link #get()}
 instead. For a default value of {@code null}, use {@link #orNull}.

 <p>Note about generics: The signature {@code public T or(T defaultValue)} is overly
 restrictive. However, the ideal signature, {@code public <S super T> S or(S)}, is not legal
 Java. As a result, some sensible operations involving subtypes are compile errors:

 {@snippet :
 Optional<Integer> optionalInt = getSomeOptionalInt();
 Number value = optionalInt.or(0.5); // error

 FluentIterable<? extends Number> numbers = getSomeNumbers();
 Optional<? extends Number> first = numbers.first();
 Number value = first.or(0.5); // error
 }

 <p>As a workaround, it is always safe to cast an {@code Optional<? extends T>} to {@code
 Optional<T>}. Casting either of the above example {@code Optional} instances to {@code
 Optional<Number>} (where {@code Number} is the desired output type) solves the problem:

 {@snippet :
 Optional<Number> optionalInt = (Optional) getSomeOptionalInt();
 Number value = optionalInt.or(0.5); // fine

 FluentIterable<? extends Number> numbers = getSomeNumbers();
 Optional<Number> first = (Optional) numbers.first();
 Number value = first.or(0.5); // fine
 }

 <p><b>Comparison to {@code java.util.Optional}:</b> this method is similar to Java 8's {@code
 Optional.orElse}, but will not accept {@code null} as a {@code defaultValue} ({@link #orNull}
 must be used instead). As a result, the value returned by this method is guaranteed non-null,
 which is not the case for the {@code java.util} equivalent.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="secondChoice" type="com.google.common.base.Optional&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns this {@code Optional} if it has a value present; {@code secondChoice} otherwise.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method has no equivalent in Java 8's
 {@code Optional} class; write {@code thisOptional.isPresent() ? thisOptional : secondChoice}
 instead.]]>
      </doc>
    </method>
    <method name="or" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.base.Supplier&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns the contained instance if it is present; {@code supplier.get()} otherwise.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method is similar to Java 8's {@code
 Optional.orElseGet}, except when {@code supplier} returns {@code null}. In this case this
 method throws an exception, whereas the Java 8+ method returns the {@code null} to the caller.

 @throws NullPointerException if this optional's value is absent and the supplier returns {@code
     null}]]>
      </doc>
    </method>
    <method name="orNull" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contained instance if it is present; {@code null} otherwise. If the instance is
 known to be present, use {@link #get()} instead.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method is equivalent to Java 8's
 {@code Optional.orElse(null)}.]]>
      </doc>
    </method>
    <method name="asSet" return="java.util.Set&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable singleton {@link Set} whose only element is the contained instance if it
 is present; an empty immutable {@link Set} otherwise.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method has no equivalent in Java 8's
 {@code Optional} class. However, this common usage:

 {@snippet :
 for (Foo foo : possibleFoo.asSet()) {
   doSomethingWith(foo);
 }
 }

 ... can be replaced with:

 {@snippet :
 possibleFoo.ifPresent(foo -> doSomethingWith(foo));
 }

 <p><b>Java 9 users:</b> some use cases can be written with calls to {@code optional.stream()}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.base.Optional&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super T, V&gt;"/>
      <doc>
      <![CDATA[If the instance is present, it is transformed with the given {@link Function}; otherwise,
 {@link Optional#absent} is returned.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method is similar to Java 8's {@code
 Optional.map}, except when {@code function} returns {@code null}. In this case this method
 throws an exception, whereas the Java 8+ method returns {@code Optional.absent()}.

 @throws NullPointerException if the function returns {@code null}
 @since 12.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is an {@code Optional} instance, and either the
 contained references are {@linkplain Object#equals equal} to each other or both are absent.
 Note that {@code Optional} instances of differing parameterized types can be equal.

 <p><b>Comparison to {@code java.util.Optional}:</b> no differences.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code for this instance.

 <p><b>Comparison to {@code java.util.Optional}:</b> this class leaves the specific choice of
 hash code unspecified, unlike the Java 8+ equivalent.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this instance.

 <p><b>Comparison to {@code java.util.Optional}:</b> this class leaves the specific string
 representation unspecified, unlike the Java 8+ equivalent.]]>
      </doc>
    </method>
    <method name="presentInstances" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optionals" type="java.lang.Iterable&lt;? extends com.google.common.base.Optional&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns the value of each present instance from the supplied {@code optionals}, in order,
 skipping over occurrences of {@link Optional#absent}. Iterators are unmodifiable and are
 evaluated lazily.

 <p><b>Comparison to {@code java.util.Optional}:</b> this method has no equivalent in Java 8's
 {@code Optional} class; use {@code
 optionals.stream().filter(Optional::isPresent).map(Optional::get)} instead.

 <p><b>Java 9 users:</b> use {@code optionals.stream().flatMap(Optional::stream)} instead.

 @since 11.0 (generics widened in 13.0)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable object that may contain a non-null reference to another object. Each instance of
 this type either contains a non-null reference, or contains nothing (in which case we say that
 the reference is "absent"); it is never said to "contain {@code null}".

 <p>A non-null {@code Optional<T>} reference can be used as a replacement for a nullable {@code T}
 reference. It allows you to represent "a {@code T} that must be present" and a "a {@code T} that
 might be absent" as two distinct types in your program, which can aid clarity.

 <p>Some uses of this class include

 <ul>
   <li>As a method return type, as an alternative to returning {@code null} to indicate that no
       value was available
   <li>To distinguish between "unknown" (for example, not present in a map) and "known to have no
       value" (present in the map, with value {@code Optional.absent()})
   <li>To wrap nullable references for storage in a collection that does not support {@code null}
       (though there are <a
       href="https://github.com/google/guava/wiki/LivingWithNullHostileCollections">several other
       approaches to this</a> that should be considered first)
 </ul>

 <p>A common alternative to using this class is to find or create a suitable <a
 href="http://en.wikipedia.org/wiki/Null_Object_pattern">null object</a> for the type in question.

 <p>This class is not intended as a direct analogue of any existing "option" or "maybe" construct
 from other programming environments, though it may bear some similarities.

 <p>An instance of this class is serializable if its reference is absent or is a serializable
 object.

 <p><b>Comparison to {@code java.util.Optional} (JDK 8 and higher):</b> A new {@code Optional}
 class was added for Java 8. The two classes are extremely similar, but incompatible (they cannot
 share a common supertype). <i>All</i> known differences are listed either here or with the
 relevant methods below.

 <ul>
   <li>This class is serializable; {@code java.util.Optional} is not.
   <li>{@code java.util.Optional} has the additional methods {@code ifPresent}, {@code filter},
       {@code flatMap}, and {@code orElseThrow}.
   <li>{@code java.util} offers the primitive-specialized versions {@code OptionalInt}, {@code
       OptionalLong} and {@code OptionalDouble}, the use of which is recommended; Guava does not
       have these.
 </ul>

 <p><b>There are no plans to deprecate this class in the foreseeable future.</b> However, we do
 gently recommend that you prefer the new, standard Java class whenever possible.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained#optional">using {@code
 Optional}</a>.

 @param <T> the type of instance that can be contained. {@code Optional} is naturally covariant on
     this type, so it is safe to cast an {@code Optional<T>} to {@code Optional<S>} for any
     supertype {@code S} of {@code T}.
 @author Kurt Alfred Kluever
 @author Kevin Bourrillion
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Optional -->
  <!-- start class com.google.common.base.Preconditions -->
  <class name="Preconditions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 @param expression a boolean expression
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will be converted to a
     string using {@link String#valueOf(Object)}
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="Object..."/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the check fail. The
     message is formed by replacing each {@code %s} placeholder in the template with an
     argument. These are matched by position - the first {@code %s} gets {@code
     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
     square braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message template. Arguments
     are converted to strings using {@link String#valueOf(Object)}.
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <param name="p4" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the calling method.

 <p>See {@link #checkArgument(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 @param expression a boolean expression
 @throws IllegalStateException if {@code expression} is false
 @see Verify#verify Verify.verify()]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will be converted to a
     string using {@link String#valueOf(Object)}
 @throws IllegalStateException if {@code expression} is false
 @see Verify#verify Verify.verify()]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="String"/>
      <param name="errorMessageArgs" type="Object..."/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the check fail. The
     message is formed by replacing each {@code %s} placeholder in the template with an
     argument. These are matched by position - the first {@code %s} gets {@code
     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
     square braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message template. Arguments
     are converted to strings using {@link String#valueOf(Object)}.
 @throws IllegalStateException if {@code expression} is false
 @see Verify#verify Verify.verify()]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <param name="p4" type="Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling instance, but not
 involving any parameters to the calling method.

 <p>See {@link #checkState(boolean, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 @param reference an object reference
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null
 @see Verify#verifyNotNull Verify.verifyNotNull()]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessage" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 @param reference an object reference
 @param errorMessage the exception message to use if the check fails; will be converted to a
     string using {@link String#valueOf(Object)}
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null
 @see Verify#verifyNotNull Verify.verifyNotNull()]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="Object..."/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 @param reference an object reference
 @param errorMessageTemplate a template for the exception message should the check fail. The
     message is formed by replacing each {@code %s} placeholder in the template with an
     argument. These are matched by position - the first {@code %s} gets {@code
     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
     square braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message template. Arguments
     are converted to strings using {@link String#valueOf(Object)}.
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null
 @see Verify#verifyNotNull Verify.verifyNotNull()]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <param name="p4" type="Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling method is not null.

 <p>See {@link #checkNotNull(Object, String, Object...)} for details.

 @since 20.0 (varargs overload since 2.0)]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
 {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
 {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
 size {@code size}. A position index may range from zero to {@code size}, inclusive.

 <p><b>Java 9 users:</b> consider using {@link java.util.Objects#checkIndex(index, size)}
 instead. However, note that {@code checkIndex()} throws {@code IndexOutOfBoundsException} when
 {@code size} is negative, while this method throws {@code IllegalArgumentException}.

 @param index a user-supplied index identifying a position in an array, list or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
 size {@code size}. A position index may range from zero to {@code size}, inclusive.

 @param index a user-supplied index identifying a position in an array, list or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndexes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code start} and {@code end} specify valid <i>positions</i> in an array, list or
 string of size {@code size}, and are in order. A position index may range from zero to {@code
 size}, inclusive.

 @param start a user-supplied index identifying a starting position in an array, list or string
 @param end a user-supplied index identifying an ending position in an array, list or string
 @param size the size of that array, list or string
 @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},
     or if {@code end} is less than {@code start}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static convenience methods that help a method or constructor check whether it was invoked
 correctly (that is, whether its <i>preconditions</i> were met).

 <p>If the precondition is not met, the {@code Preconditions} method throws an unchecked exception
 of a specified type, which helps the method in which the exception was thrown communicate that
 its caller has made a mistake. This allows constructs such as

 {@snippet :
 public static double sqrt(double value) {
   if (value < 0) {
     throw new IllegalArgumentException("input is negative: " + value);
   }
   // calculate square root
 }
 }

 <p>to be replaced with the more compact

 {@snippet :
 public static double sqrt(double value) {
   checkArgument(value >= 0, "input is negative: %s", value);
   // calculate square root
 }
 }

 <p>so that a hypothetical bad caller of this method, such as:

 {@snippet :
 void exampleBadCaller() {
   double d = sqrt(-1.0);
 }
 }

 <p>would be flagged as having called {@code sqrt()} with an illegal argument.

 <h3>Performance</h3>

 <p>Avoid passing message arguments that are expensive to compute; your code will always compute
 them, even though they usually won't be needed. If you have such arguments, use the conventional
 if/throw idiom instead.

 <p>Depending on your message arguments, memory may be allocated for boxing and varargs array
 creation. However, the methods of this class have a large number of overloads that prevent such
 allocations in many common cases.

 <p>The message string is not formatted unless the exception will be thrown, so the cost of the
 string formatting itself should not be a concern.

 <p>As with any performance concerns, you should consider profiling your code (in a production
 environment if possible) before spending a lot of effort on tweaking a particular element.

 <h3>Other types of preconditions</h3>

 <p>Not every type of precondition failure is supported by these methods. Continue to throw
 standard JDK exceptions such as {@link java.util.NoSuchElementException} or {@link
 UnsupportedOperationException} in the situations they are intended for.

 <h3>Non-preconditions</h3>

 <p>It is of course possible to use the methods of this class to check for invalid conditions
 which are <i>not the caller's fault</i>. Doing so is <b>not recommended</b> because it is
 misleading to future readers of the code and of stack traces. See <a
 href="https://github.com/google/guava/wiki/ConditionalFailuresExplained">Conditional failures
 explained</a> in the Guava User Guide for more advice. Notably, {@link Verify} offers assertions
 similar to those in this class for non-precondition checks.

 <h3>{@code java.util.Objects.requireNonNull()}</h3>

 <p>Projects which use {@code com.google.common} should generally avoid the use of {@link
 java.util.Objects#requireNonNull(Object)}. Instead, use whichever of {@link
 #checkNotNull(Object)} or {@link Verify#verifyNotNull(Object)} is appropriate to the situation.
 (The same goes for the message-accepting overloads.)

 <h3>Only {@code %s} is supported</h3>

 <p>{@code Preconditions} uses {@link Strings#lenientFormat} to format error message template
 strings. This only supports the {@code "%s"} specifier, not the full range of {@link
 java.util.Formatter} specifiers. However, note that if the number of arguments does not match the
 number of occurrences of {@code "%s"} in the format string, {@code Preconditions} will still
 behave as expected, and will still include all argument values in the error message; the message
 will simply not be formatted exactly as intended.

 <h3>More information</h3>

 <p>See the Guava User Guide on <a
 href="https://github.com/google/guava/wiki/PreconditionsExplained">using {@code
 Preconditions}</a>.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Preconditions -->
  <!-- start interface com.google.common.base.Predicate -->
  <interface name="Predicate"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the result of applying this predicate to {@code input} (Java 8+ users, see notes in the
 class documentation above). This method is <i>generally expected</i>, but not absolutely
 required, to have the following properties:

 <ul>
   <li>Its execution does not cause any observable side effects.
   <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equal
       Objects.equal}{@code (a, b)} implies that {@code predicate.apply(a) ==
       predicate.apply(b))}.
 </ul>

 @throws NullPointerException if {@code input} is null and this predicate does not accept null
     arguments]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Indicates whether another object is equal to this predicate.

 <p><b>Warning: do not depend</b> on the behavior of this method.

 <p>Historically, {@code Predicate} instances in this library have implemented this method to
 recognize certain cases where distinct {@code Predicate} instances would in fact behave
 identically. However, as code migrates to {@code java.util.function}, that behavior will
 disappear. It is best not to depend on it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Determines a true or false value for a given input; a pre-Java-8 version of {@link
 java.util.function.Predicate java.util.function.Predicate}.

 <p>The {@link Predicates} class provides common predicates and related utilities.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/FunctionalExplained">the use of {@code Predicate}</a>.

 <h3>For Java 8+ users</h3>

 <p>This interface is now a legacy type. Use {@code java.util.function.Predicate} (or the
 appropriate primitive specialization such as {@code IntPredicate}) instead whenever possible.
 Otherwise, at least reduce <i>explicit</i> dependencies on this type by using lambda expressions
 or method references instead of classes, leaving your code easier to migrate in the future.

 <p>To use a reference of this type (say, named {@code guavaPredicate}) in a context where {@code
 java.util.function.Predicate} is expected, use the method reference {@code
 guavaPredicate::apply}. For the other direction, use {@code javaUtilPredicate::test}. A future
 version of this interface will be made to <i>extend</i> {@code java.util.function.Predicate}, so
 that conversion will be necessary in only one direction. At that time, this interface will be
 officially discouraged.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Predicate -->
  <!-- start class com.google.common.base.Predicates -->
  <class name="Predicates" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="alwaysTrue" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that always evaluates to {@code true}.

 <p><b>Discouraged:</b> Prefer using {@code x -> true}, but note that lambdas do not have
 human-readable {@link #toString()} representations and are not serializable.]]>
      </doc>
    </method>
    <method name="alwaysFalse" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that always evaluates to {@code false}.

 <p><b>Discouraged:</b> Prefer using {@code x -> false}, but note that lambdas do not have
 human-readable {@link #toString()} representations and are not serializable.]]>
      </doc>
    </method>
    <method name="isNull" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference being tested is
 null.

 <p><b>Discouraged:</b> Prefer using either {@code x -> x == null} or {@code Objects::isNull},
 but note that lambdas and method references do not have human-readable {@link #toString()}
 representations and are not serializable.]]>
      </doc>
    </method>
    <method name="notNull" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference being tested is not
 null.

 <p><b>Discouraged:</b> Prefer using either {@code x -> x != null} or {@code Objects::nonNull},
 but note that lambdas and method references do not have human-readable {@link #toString()}
 representations and are not serializable.]]>
      </doc>
    </method>
    <method name="not" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the given predicate evaluates to {@code
 false}.

 <p><b>Discouraged:</b> Prefer using {@code predicate.negate()}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="java.lang.Iterable&lt;? extends com.google.common.base.Predicate&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if each of its components evaluates to
 {@code true}. The components are evaluated in order, and evaluation will be "short-circuited"
 as soon as a false predicate is found. It defensively copies the iterable passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code components} is empty, the
 returned predicate will always evaluate to {@code true}.

 <p><b>Discouraged:</b> Prefer using {@code first.and(second).and(third).and(...)}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="com.google.common.base.Predicate[]"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if each of its components evaluates to
 {@code true}. The components are evaluated in order, and evaluation will be "short-circuited"
 as soon as a false predicate is found. It defensively copies the array passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code components} is empty, the
 returned predicate will always evaluate to {@code true}.

 <p><b>Discouraged:</b> Prefer using {@code first.and(second).and(third).and(...)}.]]>
      </doc>
    </method>
    <method name="and" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="second" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if both of its components evaluate to {@code
 true}. The components are evaluated in order, and evaluation will be "short-circuited" as soon
 as a false predicate is found.

 <p><b>Discouraged:</b> Prefer using {@code first.and(second)}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="java.lang.Iterable&lt;? extends com.google.common.base.Predicate&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if any one of its components evaluates to
 {@code true}. The components are evaluated in order, and evaluation will be "short-circuited"
 as soon as a true predicate is found. It defensively copies the iterable passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code components} is empty, the
 returned predicate will always evaluate to {@code false}.

 <p><b>Discouraged:</b> Prefer using {@code first.or(second).or(third).or(...)}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="components" type="com.google.common.base.Predicate[]"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if any one of its components evaluates to
 {@code true}. The components are evaluated in order, and evaluation will be "short-circuited"
 as soon as a true predicate is found. It defensively copies the array passed in, so future
 changes to it won't alter the behavior of this predicate. If {@code components} is empty, the
 returned predicate will always evaluate to {@code false}.

 <p><b>Discouraged:</b> Prefer using {@code first.or(second).or(third).or(...)}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="second" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if either of its components evaluates to
 {@code true}. The components are evaluated in order, and evaluation will be "short-circuited"
 as soon as a true predicate is found.

 <p><b>Discouraged:</b> Prefer using {@code first.or(second)}.]]>
      </doc>
    </method>
    <method name="equalTo" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object being tested {@code equals()}
 the given target or both are null.

 <p><b>Discouraged:</b> Prefer using {@code x -> Objects.equals(x, target)}, but note that
 lambdas do not have human-readable {@link #toString()} representations and are not
 serializable.]]>
      </doc>
    </method>
    <method name="instanceOf" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object being tested is an instance of
 the given class. If the object being tested is {@code null} this predicate evaluates to {@code
 false}.

 <p>If you want to filter an {@code Iterable} to narrow its type, consider using {@link
 com.google.common.collect.Iterables#filter(Iterable, Class)} in preference.

 <p><b>Warning:</b> contrary to the typical assumptions about predicates (as documented at
 {@link Predicate#apply}), the returned predicate may not be <i>consistent with equals</i>. For
 example, {@code instanceOf(ArrayList.class)} will yield different results for the two equal
 instances {@code Lists.newArrayList(1)} and {@code Arrays.asList(1)}.

 <p><b>Discouraged:</b> Prefer using {@code clazz::isInstance} or {@code x -> x instanceof
 Clazz}, but note that lambdas do not have human-readable {@link #toString()} representations
 and are not serializable.]]>
      </doc>
    </method>
    <method name="subtypeOf" return="com.google.common.base.Predicate&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the class being tested is assignable to
 (is a subtype of) {@code clazz}. Example:

 {@snippet :
 List<Class<?>> classes = Arrays.asList(
     Object.class, String.class, Number.class, Long.class);
 return Iterables.filter(classes, subtypeOf(Number.class));
 }

 The code above returns an iterable containing {@code Number.class} and {@code Long.class}.

 <p><b>Discouraged:</b> Prefer using {@code clazz::isAssignableFrom} or {@code x ->
 clazz.isAssignableFrom(x)}, but note that lambdas do not have human-readable {@link
 #toString()} representations and are not serializable.

 @since 20.0 (since 10.0 under the incorrect name {@code assignableFrom})]]>
      </doc>
    </method>
    <method name="in" return="com.google.common.base.Predicate&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.util.Collection&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the object reference being tested is a
 member of the given collection. It does not defensively copy the collection passed in, so
 future changes to it will alter the behavior of the predicate.

 <p>This method can technically accept any {@code Collection<?>}, but using a typed collection
 helps prevent bugs. This approach doesn't block any potential users since it is always possible
 to use {@code Predicates.<Object>in()}.

 <p>You may prefer to use a method reference (e.g., {@code target::contains}) instead of this
 method. However, there are some subtle considerations:

 <ul>
   <li>The {@link Predicate} returned by this method is {@link Serializable}.
   <li>The {@link Predicate} returned by this method catches {@link ClassCastException} and
       {@link NullPointerException}.
   <li>Code that chains multiple predicates together (especially negations) may be more readable
       using this method. For example, {@code not(in(target))} is generally more readable than
       {@code not(target::contains)}.
   <li>This method's name conflicts with Kotlin's {@code in} operator.
 </ul>

 <p><b>Discouraged:</b> Prefer using either {@code target::contains} or {@code x ->
 target.contains(x)}, but note that lambdas do not have human-readable {@link #toString()}
 representations and are not serializable.

 @param target the collection that may contain the function input]]>
      </doc>
    </method>
    <method name="compose" return="com.google.common.base.Predicate&lt;A&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;B&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;A, ? extends B&gt;"/>
      <doc>
      <![CDATA[Returns the composition of a function and a predicate. For every {@code x}, the generated
 predicate returns {@code predicate(function(x))}.

 @return the composition of the provided function and predicate]]>
      </doc>
    </method>
    <method name="containsPattern" return="com.google.common.base.Predicate&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the {@code CharSequence} being tested
 contains any match for the given regular expression pattern. The test used is equivalent to
 {@code Pattern.compile(pattern).matcher(arg).find()}

 @throws IllegalArgumentException if the pattern is invalid
 @since 3.0]]>
      </doc>
    </method>
    <method name="contains" return="com.google.common.base.Predicate&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Returns a predicate that evaluates to {@code true} if the {@code CharSequence} being tested
 contains any match for the given regular expression pattern. The test used is equivalent to
 {@code pattern.matcher(arg).find()}

 @since 3.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code Predicate} instances.

 <p>All methods return serializable predicates as long as they're given serializable parameters.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/FunctionalExplained">the use of {@code Predicate}</a>.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Predicates -->
  <!-- start class com.google.common.base.Splitter -->
  <class name="Splitter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given single-character separator. For example, {@code
 Splitter.on(',').split("foo,,bar")} returns an iterable containing {@code ["foo", "", "bar"]}.

 @param separator the character to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorMatcher" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that considers any single character matched by the given {@code CharMatcher}
 to be a separator. For example, {@code
 Splitter.on(CharMatcher.anyOf(";,")).split("foo,;bar,quux")} returns an iterable containing
 {@code ["foo", "", "bar", "quux"]}.

 @param separatorMatcher a {@link CharMatcher} that determines whether a character is a
     separator
 @return a splitter, with default settings, that uses this matcher]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that uses the given fixed string as a separator. For example, {@code
 Splitter.on(", ").split("foo, bar,baz")} returns an iterable containing {@code ["foo",
 "bar,baz"]}.

 @param separator the literal, nonempty string to recognize as a separator
 @return a splitter, with default settings, that recognizes that separator]]>
      </doc>
    </method>
    <method name="on" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching {@code pattern} to be a separator.
 For example, {@code Splitter.on(Pattern.compile("\r?\n")).split(entireFile)} splits a string
 into lines whether it uses DOS-style or UNIX-style line terminators.

 @param separatorPattern the pattern that determines whether a subsequence is a separator. This
     pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws IllegalArgumentException if {@code separatorPattern} matches the empty string]]>
      </doc>
    </method>
    <method name="onPattern" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separatorPattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a splitter that considers any subsequence matching a given pattern (regular expression)
 to be a separator. For example, {@code Splitter.onPattern("\r?\n").split(entireFile)} splits a
 string into lines whether it uses DOS-style or UNIX-style line terminators. This is equivalent
 to {@code Splitter.on(Pattern.compile(pattern))}.

 @param separatorPattern the pattern that determines whether a subsequence is a separator. This
     pattern may not match the empty string.
 @return a splitter, with default settings, that uses this pattern
 @throws IllegalArgumentException if {@code separatorPattern} matches the empty string or is a
     malformed expression]]>
      </doc>
    </method>
    <method name="fixedLength" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a splitter that divides strings into pieces of the given length. For example, {@code
 Splitter.fixedLength(2).split("abcde")} returns an iterable containing {@code ["ab", "cd",
 "e"]}. The last piece can be smaller than {@code length} but will never be empty.

 <p><b>Note:</b> if {@link #fixedLength} is used in conjunction with {@link #limit}, the final
 split piece <i>may be longer than the specified fixed length</i>. This is because the splitter
 will <i>stop splitting when the limit is reached</i>, and just return the final piece as-is.

 <p><b>Exception:</b> for consistency with separator-based splitters, {@code split("")} does not
 yield an empty iterable, but an iterable containing {@code ""}. This is the only case in which
 {@code Iterables.size(split(input))} does not equal {@code IntMath.divide(input.length(),
 length, CEILING)}. To avoid this behavior, use {@code omitEmptyStrings}.

 @param length the desired length of pieces after splitting, a positive integer
 @return a splitter, with default settings, that can split into fixed sized pieces
 @throws IllegalArgumentException if {@code length} is zero or negative]]>
      </doc>
    </method>
    <method name="omitEmptyStrings" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but automatically omits
 empty strings from the results. For example, {@code
 Splitter.on(',').omitEmptyStrings().split(",a,,,b,c,,")} returns an iterable containing only
 {@code ["a", "b", "c"]}.

 <p>If either {@code trimResults} option is also specified when creating a splitter, that
 splitter always trims results first before checking for emptiness. So, for example, {@code
 Splitter.on(':').omitEmptyStrings().trimResults().split(": : : ")} returns an empty iterable.

 <p>Note that it is ordinarily not possible for {@link #split(CharSequence)} to return an empty
 iterable, but when using this option, it can (if the input sequence consists of nothing but
 separators).

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="limit" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxItems" type="int"/>
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter but stops splitting after
 it reaches the limit. The limit defines the maximum number of items returned by the iterator,
 or the maximum size of the list returned by {@link #splitToList}.

 <p>For example, {@code Splitter.on(',').limit(3).split("a,b,c,d")} returns an iterable
 containing {@code ["a", "b", "c,d"]}. When omitting empty strings, the omitted strings do not
 count. Hence, {@code Splitter.on(',').limit(3).omitEmptyStrings().split("a,,,b,,,c,d")} returns
 an iterable containing {@code ["a", "b", "c,d"]}. When trim is requested, all entries are
 trimmed, including the last. Hence {@code Splitter.on(',').limit(3).trimResults().split(" a , b
 , c , d ")} results in {@code ["a", "b", "c , d"]}.

 @param maxItems the maximum number of items returned
 @return a splitter with the desired configuration
 @since 9.0]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but automatically
 removes leading and trailing {@linkplain CharMatcher#whitespace whitespace} from each returned
 substring; equivalent to {@code trimResults(CharMatcher.whitespace())}. For example, {@code
 Splitter.on(',').trimResults().split(" a, b ,c ")} returns an iterable containing {@code ["a",
 "b", "c"]}.

 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="trimResults" return="com.google.common.base.Splitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trimmer" type="com.google.common.base.CharMatcher"/>
      <doc>
      <![CDATA[Returns a splitter that behaves equivalently to {@code this} splitter, but removes all leading
 or trailing characters matching the given {@code CharMatcher} from each returned substring. For
 example, {@code Splitter.on(',').trimResults(CharMatcher.is('_')).split("_a ,_b_ ,c__")}
 returns an iterable containing {@code ["a ", "b_ ", "c"]}.

 @param trimmer a {@link CharMatcher} that determines whether a character should be removed from
     the beginning/end of a subsequence
 @return a splitter with the desired configuration]]>
      </doc>
    </method>
    <method name="split" return="java.lang.Iterable&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits {@code sequence} into string components and makes them available through an {@link
 Iterator}, which may be lazily evaluated. If you want an eagerly computed {@link List}, use
 {@link #splitToList(CharSequence)}.

 @param sequence the sequence of characters to split
 @return an iteration over the segments split from the parameter]]>
      </doc>
    </method>
    <method name="splitToList" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits {@code sequence} into string components and returns them as an immutable list. If you
 want an {@link Iterable} which may be lazily evaluated, use {@link #split(CharSequence)}.

 @param sequence the sequence of characters to split
 @return an immutable list of the segments split from the parameter
 @since 15.0]]>
      </doc>
    </method>
    <method name="splitToStream" return="java.util.stream.Stream&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits {@code sequence} into string components and makes them available through an {@link
 Stream}, which may be lazily evaluated. If you want an eagerly computed {@link List}, use
 {@link #splitToList(CharSequence)}.

 @param sequence the sequence of characters to split
 @return a stream over the segments split from the parameter
 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Splitter.MapSplitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries
 into keys and values using the specified separator.

 @since 10.0]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Splitter.MapSplitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries
 into keys and values using the specified separator.

 @since 14.0]]>
      </doc>
    </method>
    <method name="withKeyValueSeparator" return="com.google.common.base.Splitter.MapSplitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValueSplitter" type="com.google.common.base.Splitter"/>
      <doc>
      <![CDATA[Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries
 into keys and values using the specified key-value splitter.

 <p>Note: Any configuration option configured on this splitter, such as {@link #trimResults},
 does not change the behavior of the {@code keyValueSplitter}.

 <p>Example:

 {@snippet :
 String toSplit = " x -> y, z-> a ";
 Splitter outerSplitter = Splitter.on(',').trimResults();
 MapSplitter mapSplitter = outerSplitter.withKeyValueSeparator(Splitter.on("->"));
 Map<String, String> result = mapSplitter.split(toSplit);
 assertThat(result).isEqualTo(ImmutableMap.of("x ", " y", "z", " a"));
 }

 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Extracts non-overlapping substrings from an input string, typically by recognizing appearances of
 a <i>separator</i> sequence. This separator can be specified as a single {@linkplain #on(char)
 character}, fixed {@linkplain #on(String) string}, {@linkplain #onPattern regular expression} or
 {@link #on(CharMatcher) CharMatcher} instance. Or, instead of using a separator at all, a
 splitter can extract adjacent substrings of a given {@linkplain #fixedLength fixed length}.

 <p>For example, this expression:

 {@snippet :
 Splitter.on(',').split("foo,bar,qux")
 }

 ... produces an {@code Iterable} containing {@code "foo"}, {@code "bar"} and {@code "qux"}, in
 that order.

 <p>By default, {@code Splitter}'s behavior is simplistic and unassuming. The following
 expression:

 {@snippet :
 Splitter.on(',').split(" foo,,,  bar ,")
 }

 ... yields the substrings {@code [" foo", "", "", " bar ", ""]}. If this is not the desired
 behavior, use configuration methods to obtain a <i>new</i> splitter instance with modified
 behavior:

 {@snippet :
 private static final Splitter MY_SPLITTER = Splitter.on(',')
     .trimResults()
     .omitEmptyStrings();
 }

 <p>Now {@code MY_SPLITTER.split("foo,,, bar ,")} returns just {@code ["foo", "bar"]}. Note that
 the order in which these configuration methods are called is never significant.

 <p><b>Warning:</b> Splitter instances are immutable. Invoking a configuration method has no
 effect on the receiving instance; you must store and use the new splitter instance it returns
 instead.

 {@snippet :
 // Do NOT do this
 Splitter splitter = Splitter.on('/');
 splitter.trimResults(); // does nothing!
 return splitter.split("wrong / wrong / wrong");
 }

 <p>For separator-based splitters that do not use {@code omitEmptyStrings}, an input string
 containing {@code n} occurrences of the separator naturally yields an iterable of size {@code n +
 1}. So if the separator does not occur anywhere in the input, a single substring is returned
 containing the entire input. Consequently, all splitters split the empty string to {@code [""]}
 (note: even fixed-length splitters).

 <p>Splitter instances are thread-safe immutable, and are therefore safe to store as {@code static
 final} constants.

 <p>The {@link Joiner} class provides the inverse operation to splitting, but note that a
 round-trip between the two should be assumed to be lossy.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/StringsExplained#splitter">{@code Splitter}</a>.

 @author Julien Silland
 @author Jesse Wilson
 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Splitter -->
  <!-- start class com.google.common.base.Splitter.MapSplitter -->
  <class name="Splitter.MapSplitter" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="split" return="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Splits {@code sequence} into substrings, splits each substring into an entry, and returns an
 unmodifiable map with each of the entries. For example, {@code
 Splitter.on(';').trimResults().withKeyValueSeparator("=>").split("a=>b ; c=>b")} will return
 a mapping from {@code "a"} to {@code "b"} and {@code "c"} to {@code "b"}.

 <p>The returned map preserves the order of the entries from {@code sequence}.

 @throws IllegalArgumentException if the specified sequence does not split into valid map
     entries, or if there are duplicate keys]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that splits strings into maps as {@code Splitter} splits iterables and lists. Like
 {@code Splitter}, it is thread-safe and immutable. The common way to build instances is by
 providing an additional {@linkplain Splitter#withKeyValueSeparator key-value separator} to
 {@link Splitter}.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Splitter.MapSplitter -->
  <!-- start class com.google.common.base.StandardSystemProperty -->
  <class name="StandardSystemProperty" extends="java.lang.Enum&lt;com.google.common.base.StandardSystemProperty&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.base.StandardSystemProperty[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.base.StandardSystemProperty"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="key" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to look up this system property.]]>
      </doc>
    </method>
    <method name="value" return="String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current value for this system property by delegating to {@link
 System#getProperty(String)}.

 <p>The value returned by this method is non-null except in rare circumstances:

 <ul>
   <li>{@link #JAVA_EXT_DIRS} was deprecated in Java 8 and removed in Java 9. We have not
       confirmed whether it is available under older versions.
   <li>{@link #JAVA_COMPILER}, while still listed as required as of Java 15, is typically not
       available even under older version.
   <li>Any property may be cleared through APIs like {@link System#clearProperty}.
   <li>Unusual environments like GWT may have their own special handling of system properties.
 </ul>

 <p>Note that {@code StandardSystemProperty} does not provide constants for more recently added
 properties, including:

 <ul>
   <li>{@code java.vendor.version} (added in Java 11, listed as optional as of Java 13)
   <li>{@code jdk.module.*} (added in Java 9, optional)
 </ul>]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this system property.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a {@linkplain System#getProperties() standard system property}.

 @author Kurt Alfred Kluever
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.StandardSystemProperty -->
  <!-- start class com.google.common.base.Stopwatch -->
  <class name="Stopwatch" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createUnstarted" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates (but does not start) a new stopwatch using {@link System#nanoTime} as its time source.

 @since 15.0]]>
      </doc>
    </method>
    <method name="createUnstarted" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticker" type="com.google.common.base.Ticker"/>
      <doc>
      <![CDATA[Creates (but does not start) a new stopwatch, using the specified time source.

 @since 15.0]]>
      </doc>
    </method>
    <method name="createStarted" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates (and starts) a new stopwatch using {@link System#nanoTime} as its time source.

 @since 15.0]]>
      </doc>
    </method>
    <method name="createStarted" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticker" type="com.google.common.base.Ticker"/>
      <doc>
      <![CDATA[Creates (and starts) a new stopwatch, using the specified time source.

 @since 15.0]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if {@link #start()} has been called on this stopwatch, and {@link #stop()}
 has not been called since the last call to {@code start()}.]]>
      </doc>
    </method>
    <method name="start" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts the stopwatch.

 @return this {@code Stopwatch} instance
 @throws IllegalStateException if the stopwatch is already running.]]>
      </doc>
    </method>
    <method name="stop" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the stopwatch. Future reads will return the fixed duration that had elapsed up to this
 point.

 @return this {@code Stopwatch} instance
 @throws IllegalStateException if the stopwatch is already stopped.]]>
      </doc>
    </method>
    <method name="reset" return="com.google.common.base.Stopwatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the elapsed time for this stopwatch to zero, and places it in a stopped state.

 @return this {@code Stopwatch} instance]]>
      </doc>
    </method>
    <method name="elapsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desiredUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns the current elapsed time shown on this stopwatch, expressed in the desired time unit,
 with any fraction rounded down.

 <p><b>Note:</b> the overhead of measurement can be more than a microsecond, so it is generally
 not useful to specify {@link TimeUnit#NANOSECONDS} precision here.

 <p>It is generally not a good idea to use an ambiguous, unitless {@code long} to represent
 elapsed time. Therefore, we recommend using {@link #elapsed()} instead, which returns a
 strongly-typed {@code Duration} instance.

 @since 14.0 (since 10.0 as {@code elapsedTime()})]]>
      </doc>
    </method>
    <method name="elapsed" return="java.time.Duration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current elapsed time shown on this stopwatch as a {@link Duration}. Unlike {@link
 #elapsed(TimeUnit)}, this method does not lose any precision due to rounding.

 <p><b>Warning:</b> do not call this method from Android code unless you are on Android API
 level 26+ or you <a
 href="https://developer.android.com/studio/write/java11-default-support-table">opt in to
 library desugaring</a>.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the current elapsed time.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that accurately measures <i>elapsed time</i>: the measured duration between two
 successive readings of "now" in the same process.

 <p>In contrast, <i>wall time</i> is a reading of "now" as given by a method like
 {@link System#currentTimeMillis()}, best represented as an {@link java.time.Instant}. Such values
 <i>can</i> be subtracted to obtain a {@code Duration} (such as by {@code Duration.between}), but
 doing so does <i>not</i> give a reliable measurement of elapsed time, because wall time readings
 are inherently approximate, routinely affected by periodic clock corrections. Because this class
 (by default) uses {@link System#nanoTime}, it is unaffected by these changes.

 <p>Use this class instead of direct calls to {@link System#nanoTime} for two reasons:

 <ul>
   <li>The raw {@code long} values returned by {@code nanoTime} are meaningless and unsafe to use
       in any other way than how {@code Stopwatch} uses them.
   <li>An alternative source of nanosecond ticks can be substituted, for example for testing or
       performance reasons, without affecting most of your code.
 </ul>

 <p>The one downside of {@code Stopwatch} relative to {@link System#nanoTime()} is that {@code
 Stopwatch} requires object allocation and additional method calls, which can reduce the accuracy
 of the elapsed times reported. {@code Stopwatch} is still suitable for logging and metrics where
 reasonably accurate values are sufficient. If the uncommon case that you need to maximize
 accuracy, use {@code System.nanoTime()} directly instead.

 <p>Basic usage:

 {@snippet :
 Stopwatch stopwatch = Stopwatch.createStarted();
 doSomething();
 stopwatch.stop(); // optional

 Duration duration = stopwatch.elapsed();

 log.info("time: " + stopwatch); // formatted string like "12.3 ms"
 }

 <p>The state-changing methods are not idempotent; it is an error to start or stop a stopwatch
 that is already in the desired state.

 <p>When testing code that uses this class, use {@link #createUnstarted(Ticker)} or {@link
 #createStarted(Ticker)} to supply a fake or mock ticker. This allows you to simulate any valid
 behavior of the stopwatch.

 <p><b>Note:</b> This class is not thread-safe.

 <p><b>Warning for Android users:</b> a stopwatch with default behavior may not continue to keep
 time while the device is asleep. Instead, create one like this:

 {@snippet :
 Stopwatch.createStarted(
      new Ticker() {
        public long read() {
          return android.os.SystemClock.elapsedRealtimeNanos();
        }
      });
 }

 @author Kevin Bourrillion
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Stopwatch -->
  <!-- start class com.google.common.base.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nullToEmpty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="String"/>
      <doc>
      <![CDATA[Returns the given string if it is non-null; the empty string otherwise.

 @param string the string to test and possibly return
 @return {@code string} itself if it is non-null; {@code ""} if it is null]]>
      </doc>
    </method>
    <method name="emptyToNull" return="String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="String"/>
      <doc>
      <![CDATA[Returns the given string if it is nonempty; {@code null} otherwise.

 @param string the string to test and possibly return
 @return {@code string} itself if it is nonempty; {@code null} if it is empty or null]]>
      </doc>
    </method>
    <method name="isNullOrEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="String"/>
      <doc>
      <![CDATA[Returns {@code true} if the given string is null or is the empty string.

 <p>Consider normalizing your string references with {@link #nullToEmpty}. If you do, you can
 use {@link String#isEmpty()} instead of this method, and you won't need special null-safe forms
 of methods like {@link String#toUpperCase} either. Or, if you'd like to normalize "in the other
 direction," converting empty strings to {@code null}, you can use {@link #emptyToNull}.

 @param string a string reference to check
 @return {@code true} if the string is null or is the empty string]]>
      </doc>
    </method>
    <method name="padStart" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="minLength" type="int"/>
      <param name="padChar" type="char"/>
      <doc>
      <![CDATA[Returns a string, of length at least {@code minLength}, consisting of {@code string} prepended
 with as many copies of {@code padChar} as are necessary to reach that length. For example,

 <ul>
   <li>{@code padStart("7", 3, '0')} returns {@code "007"}
   <li>{@code padStart("2010", 3, '0')} returns {@code "2010"}
 </ul>

 <p>See {@link java.util.Formatter} for a richer set of formatting capabilities.

 @param string the string which should appear at the end of the result
 @param minLength the minimum length the resulting string must have. Can be zero or negative, in
     which case the input string is always returned.
 @param padChar the character to insert at the beginning of the result until the minimum length
     is reached
 @return the padded string]]>
      </doc>
    </method>
    <method name="padEnd" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="minLength" type="int"/>
      <param name="padChar" type="char"/>
      <doc>
      <![CDATA[Returns a string, of length at least {@code minLength}, consisting of {@code string} appended
 with as many copies of {@code padChar} as are necessary to reach that length. For example,

 <ul>
   <li>{@code padEnd("4.", 5, '0')} returns {@code "4.000"}
   <li>{@code padEnd("2010", 3, '!')} returns {@code "2010"}
 </ul>

 <p>See {@link java.util.Formatter} for a richer set of formatting capabilities.

 @param string the string which should appear at the beginning of the result
 @param minLength the minimum length the resulting string must have. Can be zero or negative, in
     which case the input string is always returned.
 @param padChar the character to append to the end of the result until the minimum length is
     reached
 @return the padded string]]>
      </doc>
    </method>
    <method name="repeat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Returns a string consisting of a specific number of concatenated copies of an input string. For
 example, {@code repeat("hey", 3)} returns the string {@code "heyheyhey"}.

 @param string any non-null string
 @param count the number of times to repeat it; a nonnegative integer
 @return a string containing {@code string} repeated {@code count} times (the empty string if
     {@code count} is zero)
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="commonPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.CharSequence"/>
      <param name="b" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the longest string {@code prefix} such that {@code a.toString().startsWith(prefix) &&
 b.toString().startsWith(prefix)}, taking care not to split surrogate pairs. If {@code a} and
 {@code b} have no common prefix, returns the empty string.

 @since 11.0]]>
      </doc>
    </method>
    <method name="commonSuffix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.CharSequence"/>
      <param name="b" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the longest string {@code suffix} such that {@code a.toString().endsWith(suffix) &&
 b.toString().endsWith(suffix)}, taking care not to split surrogate pairs. If {@code a} and
 {@code b} have no common suffix, returns the empty string.

 @since 11.0]]>
      </doc>
    </method>
    <method name="lenientFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="template" type="String"/>
      <param name="args" type="Object"/>
      <doc>
      <![CDATA[Returns the given {@code template} string with each occurrence of {@code "%s"} replaced with
 the corresponding argument value from {@code args}; or, if the placeholder and argument counts
 do not match, returns a best-effort form of that string. Will not throw an exception under
 normal conditions.

 <p><b>Note:</b> For most string-formatting needs, use {@link String#format String.format},
 {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the
 full range of <a
 href="https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax">format
 specifiers</a>, and alert you to usage errors by throwing {@link
 java.util.IllegalFormatException}.

 <p>In certain cases, such as outputting debugging information or constructing a message to be
 used for another unchecked exception, an exception during string formatting would serve little
 purpose except to supplant the real information you were trying to provide. These are the cases
 this method is made for; it instead generates a best-effort string with all supplied argument
 values present. This method is also useful in environments such as GWT where {@code
 String.format} is not available. As an example, method implementations of the {@link
 Preconditions} class use this formatter, for both of the reasons just discussed.

 <p><b>Warning:</b> Only the exact two-character placeholder sequence {@code "%s"} is
 recognized.

 @param template a string containing zero or more {@code "%s"} placeholder sequences. {@code
     null} is treated as the four-character string {@code "null"}.
 @param args the arguments to be substituted into the message template. The first argument
     specified is substituted for the first occurrence of {@code "%s"} in the template, and so
     forth. A {@code null} argument is converted to the four-character string {@code "null"};
     non-null values are converted to strings using {@link Object#toString()}.
 @since 25.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code String} or {@code CharSequence} instances.

 @author Kevin Bourrillion
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Strings -->
  <!-- start interface com.google.common.base.Supplier -->
  <interface name="Supplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves an instance of the appropriate type. The returned object may or may not be a new
 instance, depending on the implementation.

 @return an instance of the appropriate type]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[<i>May</i> return {@code true} if {@code object} is a {@code Supplier} that behaves identically
 to this supplier.

 <p><b>Warning: do not depend</b> on the behavior of this method.

 <p>Historically, {@code Supplier} instances in this library have implemented this method to
 recognize certain cases where distinct {@code Supplier} instances would in fact behave
 identically. However, as code migrates to {@code java.util.function}, that behavior will
 disappear. It is best not to depend on it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that can supply objects of a single type; a pre-Java-8 version of {@link
 java.util.function.Supplier java.util.function.Supplier}. Semantically, this could be a factory,
 generator, builder, closure, or something else entirely. No guarantees are implied by this
 interface.

 <p>The {@link Suppliers} class provides common suppliers and related utilities.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/FunctionalExplained">the use of functional types</a>.

 <h3>For Java 8+ users</h3>

 <p>This interface is now a legacy type. Use {@code java.util.function.Supplier} (or the
 appropriate primitive specialization such as {@code IntSupplier}) instead whenever possible.
 Otherwise, at least reduce <i>explicit</i> dependencies on this type by using lambda expressions
 or method references instead of classes, leaving your code easier to migrate in the future.

 <p>To use an existing supplier instance (say, named {@code supplier}) in a context where the
 <i>other type</i> of supplier is expected, use the method reference {@code supplier::get}. A
 future version of {@code com.google.common.base.Supplier} will be made to <i>extend</i> {@code
 java.util.function.Supplier}, making conversion code necessary only in one direction. At that
 time, this interface will be officially discouraged.

 @author Harry Heymann
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.base.Supplier -->
  <!-- start class com.google.common.base.Suppliers -->
  <class name="Suppliers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compose" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super F, T&gt;"/>
      <param name="supplier" type="com.google.common.base.Supplier&lt;F&gt;"/>
      <doc>
      <![CDATA[Returns a new supplier which is the composition of the provided function and supplier. In other
 words, the new supplier's value will be computed by retrieving the value from {@code supplier},
 and then applying {@code function} to that value. Note that the resulting supplier will not
 call {@code supplier} or invoke {@code function} until it is called.]]>
      </doc>
    </method>
    <method name="memoize" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a supplier which caches the instance retrieved during the first call to {@code get()}
 and returns that value on subsequent calls to {@code get()}. See: <a
 href="http://en.wikipedia.org/wiki/Memoization">memoization</a>

 <p>The returned supplier is thread-safe. The delegate's {@code get()} method will be invoked at
 most once unless the underlying {@code get()} throws an exception. The supplier's serialized
 form does not contain the cached value, which will be recalculated when {@code get()} is called
 on the deserialized instance.

 <p>When the underlying delegate throws an exception then this memoizing supplier will keep
 delegating calls until it returns valid data.

 <p>If {@code delegate} is an instance created by an earlier call to {@code memoize}, it is
 returned directly.]]>
      </doc>
    </method>
    <method name="memoizeWithExpiration" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns a supplier that caches the instance supplied by the delegate and removes the cached
 value after the specified time has passed. Subsequent calls to {@code get()} return the cached
 value if the expiration time has not passed. After the expiration time, a new value is
 retrieved, cached, and returned. See: <a
 href="http://en.wikipedia.org/wiki/Memoization">memoization</a>

 <p>The returned supplier is thread-safe. The supplier's serialized form does not contain the
 cached value, which will be recalculated when {@code get()} is called on the reserialized
 instance. The actual memoization does not happen when the underlying delegate throws an
 exception.

 <p>When the underlying delegate throws an exception then this memoizing supplier will keep
 delegating calls until it returns valid data.

 @param duration the length of time after a value is created that it should stop being returned
     by subsequent {@code get()} calls
 @param unit the unit that {@code duration} is expressed in
 @throws IllegalArgumentException if {@code duration} is not positive
 @since 2.0]]>
      </doc>
    </method>
    <method name="memoizeWithExpiration" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <param name="duration" type="java.time.Duration"/>
      <doc>
      <![CDATA[Returns a supplier that caches the instance supplied by the delegate and removes the cached
 value after the specified time has passed. Subsequent calls to {@code get()} return the cached
 value if the expiration time has not passed. After the expiration time, a new value is
 retrieved, cached, and returned. See: <a
 href="http://en.wikipedia.org/wiki/Memoization">memoization</a>

 <p>The returned supplier is thread-safe. The supplier's serialized form does not contain the
 cached value, which will be recalculated when {@code get()} is called on the reserialized
 instance. The actual memoization does not happen when the underlying delegate throws an
 exception.

 <p>When the underlying delegate throws an exception then this memoizing supplier will keep
 delegating calls until it returns valid data.

 @param duration the length of time after a value is created that it should stop being returned
     by subsequent {@code get()} calls
 @throws IllegalArgumentException if {@code duration} is not positive
 @since 33.1.0]]>
      </doc>
    </method>
    <method name="ofInstance" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a supplier that always supplies {@code instance}.

 <p><b>Discouraged:</b> Prefer using {@code () -> instance}, but note that lambdas do not have
 human-readable {@link #toString()} representations and are not serializable. If you need a
 supplier that is serializable, use {@code (Supplier<T> & Serializable) () -> instance}.]]>
      </doc>
    </method>
    <method name="synchronizedSupplier" return="com.google.common.base.Supplier&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.base.Supplier&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a supplier whose {@code get()} method synchronizes on {@code delegate} before calling
 it, making it thread-safe.]]>
      </doc>
    </method>
    <method name="supplierFunction" return="com.google.common.base.Function&lt;com.google.common.base.Supplier&lt;T&gt;, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a function that accepts a supplier and returns the result of invoking {@link
 Supplier#get} on that supplier.

 <p>Prefer to use the method reference {@code Supplier::get} instead, though note that it is not
 serializable unless you explicitly make it {@link Serializable}, typically by writing {@code
 (Function<Supplier<T>, T> & Serializable) Supplier::get}.

 @since 8.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Useful suppliers.

 <p>All methods return serializable suppliers as long as they're given serializable parameters.

 @author Laurence Gonsalves
 @author Harry Heymann
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Suppliers -->
  <!-- start class com.google.common.base.Throwables -->
  <class name="Throwables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="throwIfInstanceOf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Throws {@code throwable} if it is an instance of {@code declaredType}. Example usage:

 <pre>
 for (Foo foo : foos) {
   try {
     foo.bar();
   } catch (BarException | RuntimeException | Error t) {
     failure = t;
   }
 }
 if (failure != null) {
   throwIfInstanceOf(failure, BarException.class);
   throwIfUnchecked(failure);
   throw new AssertionError(failure);
 }
 </pre>

 @since 20.0]]>
      </doc>
    </method>
    <method name="propagateIfInstanceOf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #throwIfInstanceOf}, which has the same behavior but rejects {@code
     null}.">
      <param name="throwable" type="Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@code
 declaredType}. Example usage:

 <pre>
 try {
   someMethodThatCouldThrowAnything();
 } catch (IKnowWhatToDoWithThisException e) {
   handle(e);
 } catch (Throwable t) {
   Throwables.propagateIfInstanceOf(t, IOException.class);
   Throwables.propagateIfInstanceOf(t, SQLException.class);
   throw Throwables.propagate(t);
 }
 </pre>

 @deprecated Use {@link #throwIfInstanceOf}, which has the same behavior but rejects {@code
     null}.]]>
      </doc>
    </method>
    <method name="throwIfUnchecked"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Throws {@code throwable} if it is a {@link RuntimeException} or {@link Error}. Example usage:

 <pre>
 for (Foo foo : foos) {
   try {
     foo.bar();
   } catch (RuntimeException | Error t) {
     failure = t;
   }
 }
 if (failure != null) {
   throwIfUnchecked(failure);
   throw new AssertionError(failure);
 }
 </pre>

 @since 20.0]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #throwIfUnchecked}, which has the same behavior but rejects {@code
     null}.">
      <param name="throwable" type="Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link
 RuntimeException} or {@link Error}.

 @deprecated Use {@link #throwIfUnchecked}, which has the same behavior but rejects {@code
     null}.]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use a combination of {@link #throwIfInstanceOf} and {@link #throwIfUnchecked},
     which togther provide the same behavior except that they reject {@code null}.">
      <param name="throwable" type="Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link
 RuntimeException}, {@link Error}, or {@code declaredType}.

 <p><b>Discouraged</b> in favor of calling {@link #throwIfInstanceOf} and {@link
 #throwIfUnchecked}.

 @param throwable the Throwable to possibly propagate
 @param declaredType the single checked exception type declared by the calling method
 @deprecated Use a combination of {@link #throwIfInstanceOf} and {@link #throwIfUnchecked},
     which togther provide the same behavior except that they reject {@code null}.]]>
      </doc>
    </method>
    <method name="propagateIfPossible"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use a combination of two calls to {@link #throwIfInstanceOf} and one call to {@link
     #throwIfUnchecked}, which togther provide the same behavior except that they reject {@code
     null}.">
      <param name="throwable" type="Throwable"/>
      <param name="declaredType1" type="java.lang.Class&lt;X1&gt;"/>
      <param name="declaredType2" type="java.lang.Class&lt;X2&gt;"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} exactly as-is, if and only if it is an instance of {@link
 RuntimeException}, {@link Error}, {@code declaredType1}, or {@code declaredType2}.

 @param throwable the Throwable to possibly propagate
 @param declaredType1 any checked exception type declared by the calling method
 @param declaredType2 any other checked exception type declared by the calling method
 @deprecated Use a combination of two calls to {@link #throwIfInstanceOf} and one call to {@link
     #throwIfUnchecked}, which togther provide the same behavior except that they reject {@code
     null}.]]>
      </doc>
    </method>
    <method name="propagate" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="To preserve behavior, use {@code throw e} or {@code throw new RuntimeException(e)}
     directly, or use a combination of {@link #throwIfUnchecked} and {@code throw new
     RuntimeException(e)}. But consider whether users would be better off if your API threw a
     different type of exception. For background on the deprecation, read lEsS_tHaNa
     href=quote_cHaRhttps://github.com/google/guava/wiki/Why-we-deprecated-Throwables.propagatequote_cHaR>Why we
     deprecated {@code Throwables.propagate}lEsS_tHaN/a>.">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Propagates {@code throwable} as-is if it is an instance of {@link RuntimeException} or {@link
 Error}, or else as a last resort, wraps it in a {@code RuntimeException} and then propagates.

 <p>This method always throws an exception. The {@code RuntimeException} return type allows
 client code to signal to the compiler that statements after the call are unreachable. Example
 usage:

 <pre>
 T doSomething() {
   try {
     return someMethodThatCouldThrowAnything();
   } catch (IKnowWhatToDoWithThisException e) {
     return handle(e);
   } catch (Throwable t) {
     throw Throwables.propagate(t);
   }
 }
 </pre>

 @param throwable the Throwable to propagate
 @return nothing will ever be returned; this return type is only for your convenience, as
     illustrated in the example above
 @deprecated To preserve behavior, use {@code throw e} or {@code throw new RuntimeException(e)}
     directly, or use a combination of {@link #throwIfUnchecked} and {@code throw new
     RuntimeException(e)}. But consider whether users would be better off if your API threw a
     different type of exception. For background on the deprecation, read <a
     href="https://github.com/google/guava/wiki/Why-we-deprecated-Throwables.propagate">Why we
     deprecated {@code Throwables.propagate}</a>.]]>
      </doc>
    </method>
    <method name="getRootCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns the innermost cause of {@code throwable}. The first throwable in a chain provides
 context from when the error or exception was initially detected. Example usage:

 <pre>
 assertEquals("Unable to assign a customer id", Throwables.getRootCause(e).getMessage());
 </pre>

 @throws IllegalArgumentException if there is a loop in the causal chain]]>
      </doc>
    </method>
    <method name="getCausalChain" return="java.util.List&lt;java.lang.Throwable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Gets a {@code Throwable} cause chain as a list. The first entry in the list will be {@code
 throwable} followed by its cause hierarchy. Note that this is a snapshot of the cause chain and
 will not reflect any subsequent changes to the cause chain.

 <p>Here's an example of how it can be used to find specific types of exceptions in the cause
 chain:

 <pre>
 Iterables.filter(Throwables.getCausalChain(e), IOException.class));
 </pre>

 @param throwable the non-null {@code Throwable} to extract causes from
 @return an unmodifiable list containing the cause chain starting with {@code throwable}
 @throws IllegalArgumentException if there is a loop in the causal chain]]>
      </doc>
    </method>
    <method name="getCauseAs" return="X"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="expectedCauseType" type="java.lang.Class&lt;X&gt;"/>
      <doc>
      <![CDATA[Returns {@code throwable}'s cause, cast to {@code expectedCauseType}.

 <p>Prefer this method instead of manually casting an exception's cause. For example, {@code
 (IOException) e.getCause()} throws a {@link ClassCastException} that discards the original
 exception {@code e} if the cause is not an {@link IOException}, but {@code
 Throwables.getCauseAs(e, IOException.class)} keeps {@code e} as the {@link
 ClassCastException}'s cause.

 @throws ClassCastException if the cause cannot be cast to the expected type. The {@code
     ClassCastException}'s cause is {@code throwable}.
 @since 22.0]]>
      </doc>
    </method>
    <method name="getStackTraceAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns a string containing the result of {@link Throwable#toString() toString()}, followed by
 the full, recursive stack trace of {@code throwable}. Note that you probably should not be
 parsing the resulting string; if you need programmatic access to the stack frames, you can call
 {@link Throwable#getStackTrace()}.]]>
      </doc>
    </method>
    <method name="lazyStackTrace" return="java.util.List&lt;java.lang.StackTraceElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This method is equivalent to {@link Throwable#getStackTrace()} on JDK versions past
     JDK 8 and on all Android versions. Use {@link Throwable#getStackTrace()} directly, or where
     possible use the {@code java.lang.StackWalker.walk} method introduced in JDK 9.">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns the stack trace of {@code throwable}, possibly providing slower iteration over the full
 trace but faster iteration over parts of the trace. Here, "slower" and "faster" are defined in
 comparison to the normal way to access the stack trace, {@link Throwable#getStackTrace()
 throwable.getStackTrace()}. Note, however, that this method's special implementation is not
 available for all platforms and configurations. If that implementation is unavailable, this
 method falls back to {@code getStackTrace}. Callers that require the special implementation can
 check its availability with {@link #lazyStackTraceIsLazy()}.

 <p>The expected (but not guaranteed) performance of the special implementation differs from
 {@code getStackTrace} in one main way: The {@code lazyStackTrace} call itself returns quickly
 by delaying the per-stack-frame work until each element is accessed. Roughly speaking:

 <ul>
   <li>{@code getStackTrace} takes {@code stackSize} time to return but then negligible time to
       retrieve each element of the returned list.
   <li>{@code lazyStackTrace} takes negligible time to return but then {@code 1/stackSize} time
       to retrieve each element of the returned list (probably slightly more than {@code
       1/stackSize}).
 </ul>

 <p>Note: The special implementation does not respect calls to {@link Throwable#setStackTrace
 throwable.setStackTrace}. Instead, it always reflects the original stack trace from the
 exception's creation.

 @since 19.0
 @deprecated This method is equivalent to {@link Throwable#getStackTrace()} on JDK versions past
     JDK 8 and on all Android versions. Use {@link Throwable#getStackTrace()} directly, or where
     possible use the {@code java.lang.StackWalker.walk} method introduced in JDK 9.]]>
      </doc>
    </method>
    <method name="lazyStackTraceIsLazy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This method always returns false on JDK versions past JDK 8 and on all Android
     versions.">
      <doc>
      <![CDATA[Returns whether {@link #lazyStackTrace} will use the special implementation described in its
 documentation.

 @since 19.0
 @deprecated This method always returns false on JDK versions past JDK 8 and on all Android
     versions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to instances of {@link Throwable}.

 <p>See the Guava User Guide entry on <a
 href="https://github.com/google/guava/wiki/ThrowablesExplained">Throwables</a>.

 @author Kevin Bourrillion
 @author Ben Yu
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Throwables -->
  <!-- start class com.google.common.base.Ticker -->
  <class name="Ticker" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Ticker"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="read" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of nanoseconds elapsed since this ticker's fixed point of reference.]]>
      </doc>
    </method>
    <method name="systemTicker" return="com.google.common.base.Ticker"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A ticker that reads the current time using {@link System#nanoTime}.

 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A time source; returns a time value representing the number of nanoseconds elapsed since some
 fixed but arbitrary point in time. Note that most users should use {@link Stopwatch} instead of
 interacting with this class directly.

 <p><b>Warning:</b> this interface can only be used to measure elapsed time, not wall time.

 @author Kevin Bourrillion
 @since 10.0 (<a href="https://github.com/google/guava/wiki/Compatibility">mostly
     source-compatible</a> since 9.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Ticker -->
  <!-- start class com.google.common.base.Utf8 -->
  <class name="Utf8" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="encodedLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns the number of bytes in the UTF-8-encoded form of {@code sequence}. For a string, this
 method is equivalent to {@code string.getBytes(UTF_8).length}, but is more efficient in both
 time and space.

 @throws IllegalArgumentException if {@code sequence} contains ill-formed UTF-16 (unpaired
     surrogates)]]>
      </doc>
    </method>
    <method name="isWellFormed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code bytes} is a <i>well-formed</i> UTF-8 byte sequence according to
 Unicode 6.0. Note that this is a stronger criterion than simply whether the bytes can be
 decoded. For example, some versions of the JDK decoder will accept "non-shortest form" byte
 sequences, but encoding never reproduces these. Such byte sequences are <i>not</i> considered
 well-formed.

 <p>This method returns {@code true} if and only if {@code Arrays.equals(bytes, new
 String(bytes, UTF_8).getBytes(UTF_8))} does, but is more efficient in both time and space.]]>
      </doc>
    </method>
    <method name="isWellFormed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Returns whether the given byte array slice is a well-formed UTF-8 byte sequence, as defined by
 {@link #isWellFormed(byte[])}. Note that this can be false even when {@code
 isWellFormed(bytes)} is true.

 @param bytes the input buffer
 @param off the offset in the buffer of the first byte to read
 @param len the number of bytes to read from the buffer]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level, high-performance utility methods related to the {@linkplain Charsets#UTF_8 UTF-8}
 character encoding. UTF-8 is defined in section D92 of <a
 href="http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf">The Unicode Standard Core
 Specification, Chapter 3</a>.

 <p>The variant of UTF-8 implemented by this class is the restricted definition of UTF-8
 introduced in Unicode 3.1. One implication of this is that it rejects <a
 href="http://www.unicode.org/versions/corrigendum1.html">"non-shortest form"</a> byte sequences,
 even though the JDK decoder may accept them.

 @author Martin Buchholz
 @author Clément Roux
 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Utf8 -->
  <!-- start class com.google.common.base.Verify -->
  <class name="Verify" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with no
 message otherwise.

 @throws VerifyException if {@code expression} is {@code false}
 @see Preconditions#checkState Preconditions.checkState()]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="Object..."/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the check fail. The
     message is formed by replacing each {@code %s} placeholder in the template with an
     argument. These are matched by position - the first {@code %s} gets {@code
     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
     square braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message template. Arguments
     are converted to strings using {@link String#valueOf(Object)}.
 @throws VerifyException if {@code expression} is {@code false}
 @see Preconditions#checkState Preconditions.checkState()]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="char"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="long"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="char"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="int"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="long"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verify"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="p1" type="Object"/>
      <param name="p2" type="Object"/>
      <param name="p3" type="Object"/>
      <param name="p4" type="Object"/>
      <doc>
      <![CDATA[Ensures that {@code expression} is {@code true}, throwing a {@code VerifyException} with a
 custom message otherwise.

 <p>See {@link #verify(boolean, String, Object...)} for details.

 @since 23.1 (varargs overload since 17.0)]]>
      </doc>
    </method>
    <method name="verifyNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <doc>
      <![CDATA[Ensures that {@code reference} is non-null, throwing a {@code VerifyException} with a default
 message otherwise.

 @return {@code reference}, guaranteed to be non-null, for convenience
 @throws VerifyException if {@code reference} is {@code null}
 @see Preconditions#checkNotNull Preconditions.checkNotNull()]]>
      </doc>
    </method>
    <method name="verifyNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="Object..."/>
      <doc>
      <![CDATA[Ensures that {@code reference} is non-null, throwing a {@code VerifyException} with a custom
 message otherwise.

 @param errorMessageTemplate a template for the exception message should the check fail. The
     message is formed by replacing each {@code %s} placeholder in the template with an
     argument. These are matched by position - the first {@code %s} gets {@code
     errorMessageArgs[0]}, etc. Unmatched arguments will be appended to the formatted message in
     square braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message template. Arguments
     are converted to strings using {@link String#valueOf(Object)}.
 @return {@code reference}, guaranteed to be non-null, for convenience
 @throws VerifyException if {@code reference} is {@code null}
 @see Preconditions#checkNotNull Preconditions.checkNotNull()]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static convenience methods that serve the same purpose as Java language <a
 href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html">assertions</a>,
 except that they are always enabled. These methods should be used instead of Java assertions
 whenever there is a chance the check may fail "in real life". Example:

 {@snippet :
 Bill bill = remoteService.getLastUnpaidBill();

 // In case bug 12345 happens again we'd rather just die
 Verify.verify(bill.status() == Status.UNPAID,
     "Unexpected bill status: %s", bill.status());
 }

 <h3>Comparison to alternatives</h3>

 <p><b>Note:</b> In some cases the differences explained below can be subtle. When it's unclear
 which approach to use, <b>don't worry</b> too much about it; just pick something that seems
 reasonable and it will be fine.

 <ul>
   <li>If checking whether the <i>caller</i> has violated your method or constructor's contract
       (such as by passing an invalid argument), use the utilities of the {@link Preconditions}
       class instead.
   <li>If checking an <i>impossible</i> condition (which <i>cannot</i> happen unless your own
       class or its <i>trusted</i> dependencies is badly broken), this is what ordinary Java
       assertions are for. Note that assertions are not enabled by default; they are essentially
       considered "compiled comments."
   <li>An explicit {@code if/throw} (as illustrated below) is always acceptable; we still
       recommend using our {@link VerifyException} exception type. Throwing a plain {@link
       RuntimeException} is frowned upon.
   <li>Use of {@link java.util.Objects#requireNonNull(Object)} is generally discouraged, since
       {@link #verifyNotNull(Object)} and {@link Preconditions#checkNotNull(Object)} perform the
       same function with more clarity.
 </ul>

 <h3>Warning about performance</h3>

 <p>Remember that parameter values for message construction must all be computed eagerly, and
 autoboxing and varargs array creation may happen as well, even when the verification succeeds and
 the message ends up unneeded. Performance-sensitive verification checks should continue to use
 usual form:

 {@snippet :
 Bill bill = remoteService.getLastUnpaidBill();
 if (bill.status() != Status.UNPAID) {
   throw new VerifyException("Unexpected bill status: " + bill.status());
 }
 }

 <h3>Only {@code %s} is supported</h3>

 <p>As with {@link Preconditions}, {@code Verify} uses {@link Strings#lenientFormat} to format
 error message template strings. This only supports the {@code "%s"} specifier, not the full range
 of {@link java.util.Formatter} specifiers. However, note that if the number of arguments does not
 match the number of occurrences of {@code "%s"} in the format string, {@code Verify} will still
 behave as expected, and will still include all argument values in the error message; the message
 will simply not be formatted exactly as intended.

 <h3>More information</h3>

 See <a href="https://github.com/google/guava/wiki/ConditionalFailuresExplained">Conditional
 failures explained</a> in the Guava User Guide for advice on when this class should be used.

 @since 17.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.Verify -->
  <!-- start class com.google.common.base.VerifyException -->
  <class name="VerifyException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VerifyException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a {@code VerifyException} with no message.]]>
      </doc>
    </constructor>
    <constructor name="VerifyException" type="String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a {@code VerifyException} with the message {@code message}.]]>
      </doc>
    </constructor>
    <constructor name="VerifyException" type="Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a {@code VerifyException} with the cause {@code cause} and a message that is {@code
 null} if {@code cause} is null, and {@code cause.toString()} otherwise.

 @since 19.0]]>
      </doc>
    </constructor>
    <constructor name="VerifyException" type="String, Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a {@code VerifyException} with the message {@code message} and the cause {@code
 cause}.

 @since 19.0]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception thrown upon the failure of a <a
 href="https://github.com/google/guava/wiki/ConditionalFailuresExplained">verification check</a>,
 including those performed by the convenience methods of the {@link Verify} class.

 @since 17.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.base.VerifyException -->
</package>
<package name="com.google.common.cache">
  <!-- start class com.google.common.cache.AbstractCache -->
  <class name="AbstractCache" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.Cache&lt;K, V&gt;"/>
    <constructor name="AbstractCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="valueLoader" type="java.util.concurrent.Callable&lt;? extends V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends java.lang.Object&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation of {@code getAllPresent} lacks any insight into the internal cache data
 structure, and is thus forced to return the query keys instead of the cached keys. This is only
 possible with an unsafe cast which requires {@code keys} to actually be of type {@code K}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends java.lang.Object&gt;"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Cache} interface to minimize the
 effort required to implement this interface.

 <p>To implement a cache, the programmer needs only to extend this class and provide an
 implementation for the {@link #put} and {@link #getIfPresent} methods. {@link #getAllPresent} is
 implemented in terms of {@link #getIfPresent}; {@link #putAll} is implemented in terms of {@link
 #put}, {@link #invalidateAll(Iterable)} is implemented in terms of {@link #invalidate}. The
 method {@link #cleanUp} is a no-op. All other methods throw an {@link
 UnsupportedOperationException}.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.AbstractCache -->
  <!-- start class com.google.common.cache.AbstractCache.SimpleStatsCounter -->
  <class name="AbstractCache.SimpleStatsCounter" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.AbstractCache.StatsCounter"/>
    <constructor name="SimpleStatsCounter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an instance with all counts initialized to zero.]]>
      </doc>
    </constructor>
    <method name="recordHits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="recordMisses"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="recordLoadSuccess"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
    </method>
    <method name="recordLoadException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
    </method>
    <method name="recordEviction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="snapshot" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incrementBy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.cache.AbstractCache.StatsCounter"/>
      <doc>
      <![CDATA[Increments all counters by the values in {@code other}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A thread-safe {@link StatsCounter} implementation for use by {@link Cache} implementors.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.AbstractCache.SimpleStatsCounter -->
  <!-- start interface com.google.common.cache.AbstractCache.StatsCounter -->
  <interface name="AbstractCache.StatsCounter"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="recordHits"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Records cache hits. This should be called when a cache request returns a cached value.

 @param count the number of hits to record
 @since 11.0]]>
      </doc>
    </method>
    <method name="recordMisses"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Records cache misses. This should be called when a cache request returns a value that was not
 found in the cache. This method should be called by the loading thread, as well as by threads
 blocking on the load. Multiple concurrent calls to {@link Cache} lookup methods with the same
 key on an absent value should result in a single call to either {@code recordLoadSuccess} or
 {@code recordLoadException} and multiple calls to this method, despite all being served by
 the results of a single load operation.

 @param count the number of misses to record
 @since 11.0]]>
      </doc>
    </method>
    <method name="recordLoadSuccess"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
      <doc>
      <![CDATA[Records the successful load of a new entry. This should be called when a cache request causes
 an entry to be loaded, and the loading completes successfully. In contrast to {@link
 #recordMisses}, this method should only be called by the loading thread.

 @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
     value]]>
      </doc>
    </method>
    <method name="recordLoadException"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loadTime" type="long"/>
      <doc>
      <![CDATA[Records the failed load of a new entry. This should be called when a cache request causes an
 entry to be loaded, but an exception is thrown while loading the entry. In contrast to {@link
 #recordMisses}, this method should only be called by the loading thread.

 @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
     value prior to an exception being thrown]]>
      </doc>
    </method>
    <method name="recordEviction"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Records the eviction of an entry from the cache. This should only been called when an entry
 is evicted due to the cache's eviction strategy, and not as a result of manual {@linkplain
 Cache#invalidate invalidations}.]]>
      </doc>
    </method>
    <method name="snapshot" return="com.google.common.cache.CacheStats"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a snapshot of this counter's values. Note that this may be an inconsistent view, as
 it may be interleaved with update operations.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Accumulates statistics during the operation of a {@link Cache} for presentation by {@link
 Cache#stats}. This is solely intended for consumption by {@code Cache} implementors.

 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.AbstractCache.StatsCounter -->
  <!-- start class com.google.common.cache.AbstractLoadingCache -->
  <class name="AbstractLoadingCache" extends="com.google.common.cache.AbstractCache&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache&lt;K, V&gt;"/>
    <constructor name="AbstractLoadingCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="getUnchecked" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Cache} interface to minimize the
 effort required to implement this interface.

 <p>To implement a cache, the programmer needs only to extend this class and provide an
 implementation for the {@link #get(Object)} and {@link #getIfPresent} methods. {@link
 #getUnchecked}, {@link #get(Object, Callable)}, and {@link #getAll} are implemented in terms of
 {@code get}; {@link #getAllPresent} is implemented in terms of {@code getIfPresent}; {@link
 #putAll} is implemented in terms of {@link #put}, {@link #invalidateAll(Iterable)} is implemented
 in terms of {@link #invalidate}. The method {@link #cleanUp} is a no-op. All other methods throw
 an {@link UnsupportedOperationException}.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.AbstractLoadingCache -->
  <!-- start interface com.google.common.cache.Cache -->
  <interface name="Cache"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getIfPresent" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, or {@code null} if there is no
 cached value for {@code key}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="loader" type="java.util.concurrent.Callable&lt;? extends V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, obtaining that value from {@code
 loader} if necessary. The method improves upon the conventional "if cached, return; otherwise
 create, cache and return" pattern. For further improvements, use {@link LoadingCache} and its
 {@link LoadingCache#get(Object) get(K)} method instead of this one.

 <p>Among the improvements that this method and {@code LoadingCache.get(K)} both provide are:

 <ul>
   <li>{@linkplain LoadingCache#get(Object) awaiting the result of a pending load} rather than
       starting a redundant one
   <li>eliminating the error-prone caching boilerplate
   <li>tracking load {@linkplain #stats statistics}
 </ul>

 <p>Among the further improvements that {@code LoadingCache} can provide but this method cannot:

 <ul>
   <li>consolidation of the loader logic to {@linkplain CacheBuilder#build(CacheLoader) a single
       authoritative location}
   <li>{@linkplain LoadingCache#refresh refreshing of entries}, including {@linkplain
       CacheBuilder#refreshAfterWrite automated refreshing}
   <li>{@linkplain LoadingCache#getAll bulk loading requests}, including {@linkplain
       CacheLoader#loadAll bulk loading implementations}
 </ul>

 <p><b>Warning:</b> For any given key, every {@code loader} used with it should compute the same
 value. Otherwise, a call that passes one {@code loader} may return the result of another call
 with a differently behaving {@code loader}. For example, a call that requests a short timeout
 for an RPC may wait for a similar call that requests a long timeout, or a call by an
 unprivileged user may return a resource accessible only to a privileged user making a similar
 call. To prevent this problem, create a key object that includes all values that affect the
 result of the query. Or use {@code LoadingCache.get(K)}, which lacks the ability to refer to
 state other than that in the key.

 <p><b>Warning:</b> as with {@link CacheLoader#load}, {@code loader} <b>must not</b> return
 {@code null}; it may either return a non-null value or throw an exception.

 <p>No observable state associated with this cache is modified until loading completes.

 @throws ExecutionException if a checked exception was thrown while loading the value
 @throws UncheckedExecutionException if an unchecked exception was thrown while loading the
     value
 @throws ExecutionError if an error was thrown while loading the value
 @since 11.0]]>
      </doc>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Returns a map of the values associated with {@code keys} in this cache. The returned map will
 only contain entries which are already present in the cache.

 @since 11.0]]>
      </doc>
    </method>
    <method name="put"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code value} with {@code key} in this cache. If the cache previously contained a
 value associated with {@code key}, the old value is replaced by {@code value}.

 <p>Prefer {@link #get(Object, Callable)} when using the conventional "if cached, return;
 otherwise create, cache and return" pattern.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Copies all of the mappings from the specified map to the cache. The effect of this call is
 equivalent to that of calling {@code put(k, v)} on this map once for each mapping from key
 {@code k} to value {@code v} in the specified map. The behavior of this operation is undefined
 if the specified map is modified while the operation is in progress.

 @since 12.0]]>
      </doc>
    </method>
    <method name="invalidate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Discards any cached value for key {@code key}.]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Discards any cached values for keys {@code keys}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Discards all entries in the cache.]]>
      </doc>
    </method>
    <method name="size" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the approximate number of entries in this cache.]]>
      </doc>
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a current snapshot of this cache's cumulative statistics, or a set of default values if
 the cache is not recording statistics. All statistics begin at zero and never decrease over the
 lifetime of the cache.

 <p><b>Warning:</b> this cache may not be recording statistical data. For example, a cache
 created using {@link CacheBuilder} only does so if the {@link CacheBuilder#recordStats} method
 was called. If statistics are not being recorded, a {@code CacheStats} instance with zero for
 all values is returned.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to
 the map directly affect the cache.

 <p>Iterators from the returned map are at least <i>weakly consistent</i>: they are safe for
 concurrent use, but if the cache is modified (including by eviction) after the iterator is
 created, it is undefined which of the changes (if any) will be reflected in that iterator.

 <p><b>Warning to users of Java 8+:</b> do not call any of the new <i>default methods</i> that
 have been newly added to {@link ConcurrentMap}! These are marked with "Since: 1.8" in the
 {@code ConcurrentMap} documentation. They will not function correctly and it is impossible for
 Guava to fix them until Guava is ready to <i>require</i> Java 8 for all users.]]>
      </doc>
    </method>
    <method name="cleanUp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Performs any pending maintenance operations needed by the cache. Exactly which activities are
 performed -- if any -- is implementation-dependent.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A semi-persistent mapping from keys to values. Cache entries are manually added using {@link
 #get(Object, Callable)} or {@link #put(Object, Object)}, and are stored in the cache until either
 evicted or manually invalidated. The common way to build instances is using {@link CacheBuilder}.

 <p>Implementations of this interface are expected to be thread-safe, and can be safely accessed
 by multiple concurrent threads.

 @param <K> the type of the cache's keys, which are not permitted to be null
 @param <V> the type of the cache's values, which are not permitted to be null
 @author Charles Fry
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.Cache -->
  <!-- start class com.google.common.cache.CacheBuilder -->
  <class name="CacheBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="com.google.common.cache.CacheBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@code CacheBuilder} instance with default settings, including strong keys,
 strong values, and no automatic eviction of any kind.

 <p>Note that while this return type is {@code CacheBuilder<Object, Object>}, type parameters on
 the {@link #build} methods allow you to create a cache of any key and value type desired.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spec" type="com.google.common.cache.CacheBuilderSpec"/>
      <doc>
      <![CDATA[Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spec" type="java.lang.String"/>
      <doc>
      <![CDATA[Constructs a new {@code CacheBuilder} instance with the settings specified in {@code spec}.
 This is especially useful for command-line configuration of a {@code CacheBuilder}.

 @param spec a String in the format specified by {@link CacheBuilderSpec}
 @since 12.0]]>
      </doc>
    </method>
    <method name="initialCapacity" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Sets the minimum total size for the internal hash tables. For example, if the initial capacity
 is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each
 having a hash table of size eight. Providing a large enough estimate at construction time
 avoids the need for expensive resizing operations later, but setting this value unnecessarily
 high wastes memory.

 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code initialCapacity} is negative
 @throws IllegalStateException if an initial capacity was already set]]>
      </doc>
    </method>
    <method name="concurrencyLevel" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="concurrencyLevel" type="int"/>
      <doc>
      <![CDATA[Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The
 table is internally partitioned to try to permit the indicated number of concurrent updates
 without contention. Because assignment of entries to these partitions is not necessarily
 uniform, the actual concurrency observed may vary. Ideally, you should choose a value to
 accommodate as many threads as will ever concurrently modify the table. Using a significantly
 higher value than you need can waste space and time, and a significantly lower value can lead
 to thread contention. But overestimates and underestimates within an order of magnitude do not
 usually have much noticeable impact. A value of one permits only one thread to modify the cache
 at a time, but since read operations and cache loading computations can proceed concurrently,
 this still yields higher concurrency than full synchronization.

 <p>Defaults to 4. <b>Note:</b>The default may change in the future. If you care about this
 value, you should always choose it explicitly.

 <p>The current implementation uses the concurrency level to create a fixed number of hashtable
 segments, each governed by its own write lock. The segment lock is taken once for each explicit
 write, and twice for each cache loading computation (once prior to loading the new value, and
 once after loading completes). Much internal cache management is performed at the segment
 granularity. For example, access queues and write queues are kept per segment when they are
 required by the selected eviction algorithm. As such, when writing unit tests it is not
 uncommon to specify {@code concurrencyLevel(1)} in order to achieve more deterministic eviction
 behavior.

 <p>Note that future implementations may abandon segment locking in favor of more advanced
 concurrency controls.

 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive
 @throws IllegalStateException if a concurrency level was already set]]>
      </doc>
    </method>
    <method name="maximumSize" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maximumSize" type="long"/>
      <doc>
      <![CDATA[Specifies the maximum number of entries the cache may contain.

 <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in
 the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each
 resulting segment inside the cache <i>independently</i> limits its own size to approximately
 {@code maximumSize / concurrencyLevel}.

 <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.
 For example, the cache may evict an entry because it hasn't been used recently or very often.

 <p>If {@code maximumSize} is zero, elements will be evicted immediately after being loaded into
 cache. This can be useful in testing, or to disable caching temporarily.

 <p>This feature cannot be used in conjunction with {@link #maximumWeight}.

 @param maximumSize the maximum size of the cache
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code maximumSize} is negative
 @throws IllegalStateException if a maximum size or weight was already set]]>
      </doc>
    </method>
    <method name="maximumWeight" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maximumWeight" type="long"/>
      <doc>
      <![CDATA[Specifies the maximum weight of entries the cache may contain. Weight is determined using the
 {@link Weigher} specified with {@link #weigher}, and use of this method requires a
 corresponding call to {@link #weigher} prior to calling {@link #build}.

 <p>Note that the cache <b>may evict an entry before this limit is exceeded</b>. For example, in
 the current implementation, when {@code concurrencyLevel} is greater than {@code 1}, each
 resulting segment inside the cache <i>independently</i> limits its own weight to approximately
 {@code maximumWeight / concurrencyLevel}.

 <p>When eviction is necessary, the cache evicts entries that are less likely to be used again.
 For example, the cache may evict an entry because it hasn't been used recently or very often.

 <p>If {@code maximumWeight} is zero, elements will be evicted immediately after being loaded
 into cache. This can be useful in testing, or to disable caching temporarily.

 <p>Note that weight is only used to determine whether the cache is over capacity; it has no
 effect on selecting which entry should be evicted next.

 <p>This feature cannot be used in conjunction with {@link #maximumSize}.

 @param maximumWeight the maximum total weight of entries the cache may contain
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code maximumWeight} is negative
 @throws IllegalStateException if a maximum weight or size was already set
 @since 11.0]]>
      </doc>
    </method>
    <method name="weigher" return="com.google.common.cache.CacheBuilder&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="weigher" type="com.google.common.cache.Weigher&lt;? super K1, ? super V1&gt;"/>
      <doc>
      <![CDATA[Specifies the weigher to use in determining the weight of entries. Entry weight is taken into
 consideration by {@link #maximumWeight(long)} when determining which entries to evict, and use
 of this method requires a corresponding call to {@link #maximumWeight(long)} prior to calling
 {@link #build}. Weights are measured and recorded when entries are inserted into the cache, and
 are thus effectively static during the lifetime of a cache entry.

 <p>When the weight of an entry is zero it will not be considered for size-based eviction
 (though it still may be evicted by other means).

 <p><b>Important note:</b> Instead of returning <em>this</em> as a {@code CacheBuilder}
 instance, this method returns {@code CacheBuilder<K1, V1>}. From this point on, either the
 original reference or the returned reference may be used to complete configuration and build
 the cache, but only the "generic" one is type-safe. That is, it will properly prevent you from
 building caches whose key or value types are incompatible with the types accepted by the
 weigher already provided; the {@code CacheBuilder} type cannot do this. For best results,
 simply use the standard method-chaining idiom, as illustrated in the documentation at top,
 configuring a {@code CacheBuilder} and building your {@link Cache} all in a single statement.

 <p><b>Warning:</b> if you ignore the above advice, and use this {@code CacheBuilder} to build a
 cache whose key or value type is incompatible with the weigher, you will likely experience a
 {@link ClassCastException} at some <i>undefined</i> point in the future.

 @param weigher the weigher to use in calculating the weight of cache entries
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalStateException if a weigher was already set or {@link #maximumSize(long)} was
     previously called
 @since 11.0]]>
      </doc>
    </method>
    <method name="weakKeys" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each key (not value) stored in the cache should be wrapped in a {@link
 WeakReference} (by default, strong references are used).

 <p><b>Warning:</b> when this method is used, the resulting cache will use identity ({@code ==})
 comparison to determine equality of keys. Its {@link Cache#asMap} view will therefore
 technically violate the {@link Map} specification (in the same way that {@link IdentityHashMap}
 does).

 <p>Entries with keys that have been garbage collected may be counted in {@link Cache#size}, but
 will never be visible to read or write operations; such entries are cleaned up as part of the
 routine maintenance described in the class javadoc.

 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalStateException if the key strength was already set]]>
      </doc>
    </method>
    <method name="weakValues" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the cache should be wrapped in a {@link
 WeakReference} (by default, strong references are used).

 <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor
 candidate for caching; consider {@link #softValues} instead.

 <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})
 comparison to determine equality of values.

 <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},
 but will never be visible to read or write operations; such entries are cleaned up as part of
 the routine maintenance described in the class javadoc.

 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalStateException if the value strength was already set]]>
      </doc>
    </method>
    <method name="softValues" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the cache should be wrapped in a {@link
 SoftReference} (by default, strong references are used). Softly-referenced objects will be
 garbage-collected in a <i>globally</i> least-recently-used manner, in response to memory
 demand.

 <p><b>Warning:</b> in most circumstances it is better to set a per-cache {@linkplain
 #maximumSize(long) maximum size} instead of using soft references. You should only use this
 method if you are well familiar with the practical consequences of soft references.

 <p><b>Note:</b> when this method is used, the resulting cache will use identity ({@code ==})
 comparison to determine equality of values.

 <p>Entries with values that have been garbage collected may be counted in {@link Cache#size},
 but will never be visible to read or write operations; such entries are cleaned up as part of
 the routine maintenance described in the class javadoc.

 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalStateException if the value strength was already set]]>
      </doc>
    </method>
    <method name="expireAfterWrite" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="java.time.Duration"/>
      <doc>
      <![CDATA[Specifies that each entry should be automatically removed from the cache once a fixed duration
 has elapsed after the entry's creation, or the most recent replacement of its value.

 <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)
 maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be
 useful in testing, or to disable caching temporarily without a code change.

 <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or
 write operations. Expired entries are cleaned up as part of the routine maintenance described
 in the class javadoc.

 @param duration the length of time after an entry is created that it should be automatically
     removed
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if {@link #expireAfterWrite} was already set
 @throws ArithmeticException for durations greater than +/- approximately 292 years
 @since 33.3.0 (but since 25.0 in the JRE <a
     href="https://github.com/google/guava#guava-google-core-libraries-for-java">flavor</a>)]]>
      </doc>
    </method>
    <method name="expireAfterWrite" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Specifies that each entry should be automatically removed from the cache once a fixed duration
 has elapsed after the entry's creation, or the most recent replacement of its value.

 <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)
 maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be
 useful in testing, or to disable caching temporarily without a code change.

 <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or
 write operations. Expired entries are cleaned up as part of the routine maintenance described
 in the class javadoc.

 <p>If you can represent the duration as a {@link Duration} (which should be preferred when
 feasible), use {@link #expireAfterWrite(Duration)} instead.

 @param duration the length of time after an entry is created that it should be automatically
     removed
 @param unit the unit that {@code duration} is expressed in
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if {@link #expireAfterWrite} was already set]]>
      </doc>
    </method>
    <method name="expireAfterAccess" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="java.time.Duration"/>
      <doc>
      <![CDATA[Specifies that each entry should be automatically removed from the cache once a fixed duration
 has elapsed after the entry's creation, the most recent replacement of its value, or its last
 access. Access time is reset by all cache read and write operations (including {@code
 Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by {@code
 containsKey(Object)}, nor by operations on the collection-views of {@link Cache#asMap}}. So,
 for example, iterating through {@code Cache.asMap().entrySet()} does not reset access time for
 the entries you retrieve.

 <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)
 maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be
 useful in testing, or to disable caching temporarily without a code change.

 <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or
 write operations. Expired entries are cleaned up as part of the routine maintenance described
 in the class javadoc.

 @param duration the length of time after an entry is last accessed that it should be
     automatically removed
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if {@link #expireAfterAccess} was already set
 @throws ArithmeticException for durations greater than +/- approximately 292 years
 @since 33.3.0 (but since 25.0 in the JRE <a
     href="https://github.com/google/guava#guava-google-core-libraries-for-java">flavor</a>)]]>
      </doc>
    </method>
    <method name="expireAfterAccess" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Specifies that each entry should be automatically removed from the cache once a fixed duration
 has elapsed after the entry's creation, the most recent replacement of its value, or its last
 access. Access time is reset by all cache read and write operations (including {@code
 Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by {@code
 containsKey(Object)}, nor by operations on the collection-views of {@link Cache#asMap}. So, for
 example, iterating through {@code Cache.asMap().entrySet()} does not reset access time for the
 entries you retrieve.

 <p>When {@code duration} is zero, this method hands off to {@link #maximumSize(long)
 maximumSize}{@code (0)}, ignoring any otherwise-specified maximum size or weight. This can be
 useful in testing, or to disable caching temporarily without a code change.

 <p>Expired entries may be counted in {@link Cache#size}, but will never be visible to read or
 write operations. Expired entries are cleaned up as part of the routine maintenance described
 in the class javadoc.

 <p>If you can represent the duration as a {@link Duration} (which should be preferred when
 feasible), use {@link #expireAfterAccess(Duration)} instead.

 @param duration the length of time after an entry is last accessed that it should be
     automatically removed
 @param unit the unit that {@code duration} is expressed in
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if {@link #expireAfterAccess} was already set]]>
      </doc>
    </method>
    <method name="refreshAfterWrite" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="java.time.Duration"/>
      <doc>
      <![CDATA[Specifies that active entries are eligible for automatic refresh once a fixed duration has
 elapsed after the entry's creation, or the most recent replacement of its value. The semantics
 of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling {@link
 CacheLoader#reload}.

 <p>As the default implementation of {@link CacheLoader#reload} is synchronous, it is
 recommended that users of this method override {@link CacheLoader#reload} with an asynchronous
 implementation; otherwise refreshes will be performed during unrelated cache read and write
 operations.

 <p>Currently automatic refreshes are performed when the first stale request for an entry
 occurs. The request triggering refresh will make a synchronous call to {@link
 CacheLoader#reload}
 to obtain a future of the new value. If the returned future is already complete, it is returned
 immediately. Otherwise, the old value is returned.

 <p><b>Note:</b> <i>all exceptions thrown during refresh will be logged and then swallowed</i>.

 @param duration the length of time after an entry is created that it should be considered
     stale, and thus eligible for refresh
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if {@link #refreshAfterWrite} was already set
 @throws ArithmeticException for durations greater than +/- approximately 292 years
 @since 33.3.0 (but since 25.0 in the JRE <a
     href="https://github.com/google/guava#guava-google-core-libraries-for-java">flavor</a>)]]>
      </doc>
    </method>
    <method name="refreshAfterWrite" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="duration" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Specifies that active entries are eligible for automatic refresh once a fixed duration has
 elapsed after the entry's creation, or the most recent replacement of its value. The semantics
 of refreshes are specified in {@link LoadingCache#refresh}, and are performed by calling {@link
 CacheLoader#reload}.

 <p>As the default implementation of {@link CacheLoader#reload} is synchronous, it is
 recommended that users of this method override {@link CacheLoader#reload} with an asynchronous
 implementation; otherwise refreshes will be performed during unrelated cache read and write
 operations.

 <p>Currently automatic refreshes are performed when the first stale request for an entry
 occurs. The request triggering refresh will make a synchronous call to {@link
 CacheLoader#reload}
 and immediately return the new value if the returned future is complete, and the old value
 otherwise.

 <p><b>Note:</b> <i>all exceptions thrown during refresh will be logged and then swallowed</i>.

 <p>If you can represent the duration as a {@link Duration} (which should be preferred when
 feasible), use {@link #refreshAfterWrite(Duration)} instead.

 @param duration the length of time after an entry is created that it should be considered
     stale, and thus eligible for refresh
 @param unit the unit that {@code duration} is expressed in
 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalArgumentException if {@code duration} is negative
 @throws IllegalStateException if {@link #refreshAfterWrite} was already set
 @since 11.0]]>
      </doc>
    </method>
    <method name="ticker" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticker" type="com.google.common.base.Ticker"/>
      <doc>
      <![CDATA[Specifies a nanosecond-precision time source for this cache. By default, {@link
 System#nanoTime} is used.

 <p>The primary intent of this method is to facilitate testing of caches with a fake or mock
 time source.

 @return this {@code CacheBuilder} instance (for chaining)
 @throws IllegalStateException if a ticker was already set]]>
      </doc>
    </method>
    <method name="removalListener" return="com.google.common.cache.CacheBuilder&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.cache.RemovalListener&lt;? super K1, ? super V1&gt;"/>
      <doc>
      <![CDATA[Specifies a listener instance that caches should notify each time an entry is removed for any
 {@linkplain RemovalCause reason}. Each cache created by this builder will invoke this listener
 as part of the routine maintenance described in the class documentation above.

 <p><b>Warning:</b> after invoking this method, do not continue to use <i>this</i> cache builder
 reference; instead use the reference this method <i>returns</i>. At runtime, these point to the
 same instance, but only the returned reference has the correct generic type information to
 ensure type safety. For best results, use the standard method-chaining idiom illustrated in the
 class documentation above, configuring a builder and building your cache in a single statement.
 Failure to heed this advice can result in a {@link ClassCastException} being thrown by a cache
 operation at some <i>undefined</i> point in the future.

 <p><b>Warning:</b> any exception thrown by {@code listener} will <i>not</i> be propagated to
 the {@code Cache} user, only logged via a {@link Logger}.

 @return the cache builder reference that should be used instead of {@code this} for any
     remaining configuration and cache building
 @throws IllegalStateException if a removal listener was already set]]>
      </doc>
    </method>
    <method name="recordStats" return="com.google.common.cache.CacheBuilder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enable the accumulation of {@link CacheStats} during the operation of the cache. Without this
 {@link Cache#stats} will return zero for all statistics. Note that recording stats requires
 bookkeeping to be performed with each operation, and thus imposes a performance penalty on
 cache operation.

 @return this {@code CacheBuilder} instance (for chaining)
 @since 12.0 (previously, stats collection was automatic)]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.cache.LoadingCache&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="com.google.common.cache.CacheLoader&lt;? super K1, V1&gt;"/>
      <doc>
      <![CDATA[Builds a cache, which either returns an already-loaded value for a given key or atomically
 computes or retrieves it using the supplied {@code CacheLoader}. If another thread is currently
 loading the value for this key, simply waits for that thread to finish and returns its loaded
 value. Note that multiple threads can concurrently load values for distinct keys.

 <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be
 invoked again to create multiple independent caches.

 @param loader the cache loader used to obtain new values
 @return a cache having the requested features]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.cache.Cache&lt;K1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a cache which does not automatically load values when keys are requested.

 <p>Consider {@link #build(CacheLoader)} instead, if it is feasible to implement a {@code
 CacheLoader}.

 <p>This method does not alter the state of this {@code CacheBuilder} instance, so it can be
 invoked again to create multiple independent caches.

 @return a cache having the requested features
 @since 11.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this CacheBuilder instance. The exact form of the returned
 string is not specified.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder of {@link LoadingCache} and {@link Cache} instances.

 <h2>Prefer <a href="https://github.com/ben-manes/caffeine/wiki">Caffeine</a> over Guava's caching
 API</h2>

 <p>The successor to Guava's caching API is <a
 href="https://github.com/ben-manes/caffeine/wiki">Caffeine</a>. Its API is designed to make it a
 nearly drop-in replacement. Note that it is not available for Android or GWT/J2CL and that it may
 have <a href="https://github.com/ben-manes/caffeine/wiki/Guava">different (usually better)
 behavior</a> when multiple threads attempt concurrent mutations. Its equivalent to {@code
 CacheBuilder} is its <a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/Caffeine.html">{@code
 Caffeine}</a> class. Caffeine offers better performance, more features (including asynchronous
 loading), and fewer <a
 href="https://github.com/google/guava/issues?q=is%3Aopen+is%3Aissue+label%3Apackage%3Dcache+label%3Atype%3Ddefect">bugs</a>.

 <p>Caffeine defines its own interfaces (<a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/Cache.html">{@code
 Cache}</a>, <a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/LoadingCache.html">{@code
 LoadingCache}</a>, <a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/CacheLoader.html">{@code
 CacheLoader}</a>, etc.), so you can use Caffeine without needing to use any Guava types.
 Caffeine's types are better than Guava's, especially for <a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/AsyncLoadingCache.html">their
 deep support for asynchronous operations</a>. But if you want to migrate to Caffeine with minimal
 code changes, you can use <a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/guava/latest/com.github.benmanes.caffeine.guava/com/github/benmanes/caffeine/guava/CaffeinatedGuava.html">its
 {@code CaffeinatedGuava} adapter class</a>, which lets you build a Guava {@code Cache} or a Guava
 {@code LoadingCache} backed by a Guava {@code CacheLoader}.

 <p>Caffeine's API for asynchronous operations uses {@code CompletableFuture}: <a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/AsyncLoadingCache.html#get(K)">{@code
 AsyncLoadingCache.get}</a> returns a {@code CompletableFuture}, and implementations of <a
 href="https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/AsyncCacheLoader.html#asyncLoad(K,java.util.concurrent.Executor)">{@code
 AsyncCacheLoader.asyncLoad}</a> must return a {@code CompletableFuture}. Users of Guava's {@link
 com.google.common.util.concurrent.ListenableFuture} can adapt between the two {@code Future}
 types by using <a href="https://github.com/lukas-krecan/future-converter#java8-guava">{@code
 net.javacrumbs.futureconverter.java8guava.FutureConverter}</a>.

 <h2>More on {@code CacheBuilder}</h2>

 {@code CacheBuilder} builds caches with any combination of the following features:

 <ul>
   <li>automatic loading of entries into the cache
   <li>least-recently-used eviction when a maximum size is exceeded (note that the cache is
       divided into segments, each of which does LRU internally)
   <li>time-based expiration of entries, measured since last access or last write
   <li>keys automatically wrapped in {@code WeakReference}
   <li>values automatically wrapped in {@code WeakReference} or {@code SoftReference}
   <li>notification of evicted (or otherwise removed) entries
   <li>accumulation of cache access statistics
 </ul>

 <p>These features are all optional; caches can be created using all or none of them. By default,
 cache instances created by {@code CacheBuilder} will not perform any type of eviction.

 <p>Usage example:

 {@snippet :
 LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder()
     .maximumSize(10000)
     .expireAfterWrite(Duration.ofMinutes(10))
     .removalListener(MY_LISTENER)
     .build(
         new CacheLoader<Key, Graph>() {
           public Graph load(Key key) throws AnyException {
             return createExpensiveGraph(key);
           }
         });
 }

 <p>Or equivalently,

 {@snippet :
 // In real life this would come from a command-line flag or config file
 String spec = "maximumSize=10000,expireAfterWrite=10m";

 LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec)
     .removalListener(MY_LISTENER)
     .build(
         new CacheLoader<Key, Graph>() {
           public Graph load(Key key) throws AnyException {
             return createExpensiveGraph(key);
           }
         });
 }

 <p>The returned cache implements all optional operations of the {@link LoadingCache} and {@link
 Cache} interfaces. The {@code asMap} view (and its collection views) have <i>weakly consistent
 iterators</i>. This means that they are safe for concurrent use, but if other threads modify the
 cache after the iterator is created, it is undefined which of these changes, if any, are
 reflected in that iterator. These iterators never throw {@link ConcurrentModificationException}.

 <p><b>Note:</b> by default, the returned cache uses equality comparisons (the {@link
 Object#equals equals} method) to determine equality for keys or values. However, if {@link
 #weakKeys} was specified, the cache uses identity ({@code ==}) comparisons instead for keys.
 Likewise, if {@link #weakValues} or {@link #softValues} was specified, the cache uses identity
 comparisons for values.

 <p>Entries are automatically evicted from the cache when any of {@link #maximumSize(long)
 maximumSize}, {@link #maximumWeight(long) maximumWeight}, {@link #expireAfterWrite
 expireAfterWrite}, {@link #expireAfterAccess expireAfterAccess}, {@link #weakKeys weakKeys},
 {@link #weakValues weakValues}, or {@link #softValues softValues} are requested.

 <p>If {@link #maximumSize(long) maximumSize} or {@link #maximumWeight(long) maximumWeight} is
 requested entries may be evicted on each cache modification.

 <p>If {@link #expireAfterWrite expireAfterWrite} or {@link #expireAfterAccess expireAfterAccess}
 is requested entries may be evicted on each cache modification, on occasional cache accesses, or
 on calls to {@link Cache#cleanUp}. Expired entries may be counted by {@link Cache#size}, but will
 never be visible to read or write operations.

 <p>If {@link #weakKeys weakKeys}, {@link #weakValues weakValues}, or {@link #softValues
 softValues} are requested, it is possible for a key or value present in the cache to be reclaimed
 by the garbage collector. Entries with reclaimed keys or values may be removed from the cache on
 each cache modification, on occasional cache accesses, or on calls to {@link Cache#cleanUp}; such
 entries may be counted in {@link Cache#size}, but will never be visible to read or write
 operations.

 <p>Certain cache configurations will result in the accrual of periodic maintenance tasks which
 will be performed during write operations, or during occasional read operations in the absence of
 writes. The {@link Cache#cleanUp} method of the returned cache will also perform maintenance, but
 calling it should not be necessary with a high throughput cache. Only caches built with {@link
 #removalListener removalListener}, {@link #expireAfterWrite expireAfterWrite}, {@link
 #expireAfterAccess expireAfterAccess}, {@link #weakKeys weakKeys}, {@link #weakValues
 weakValues}, or {@link #softValues softValues} perform periodic maintenance.

 <p>The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches
 retain all the configuration properties of the original cache. Note that the serialized form does
 <i>not</i> include cache contents, but only configuration.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/CachesExplained">caching</a> for a higher-level
 explanation.

 @param <K> the most general key type this builder will be able to create caches for. This is
     normally {@code Object} unless it is constrained by using a method like {@link
     #removalListener}. Cache keys may not be null.
 @param <V> the most general value type this builder will be able to create caches for. This is
     normally {@code Object} unless it is constrained by using a method like {@link
     #removalListener}. Cache values may not be null.
 @author Charles Fry
 @author Kevin Bourrillion
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheBuilder -->
  <!-- start class com.google.common.cache.CacheBuilderSpec -->
  <class name="CacheBuilderSpec" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="parse" return="com.google.common.cache.CacheBuilderSpec"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cacheBuilderSpecification" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a CacheBuilderSpec from a string.

 @param cacheBuilderSpecification the string form]]>
      </doc>
    </method>
    <method name="disableCaching" return="com.google.common.cache.CacheBuilderSpec"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a CacheBuilderSpec that will prevent caching.]]>
      </doc>
    </method>
    <method name="toParsableString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string that can be used to parse an equivalent {@code CacheBuilderSpec}. The order
 and form of this representation is not guaranteed, except that reparsing its output will
 produce a {@code CacheBuilderSpec} equal to this instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this CacheBuilderSpec instance. The form of this
 representation is not guaranteed.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <doc>
    <![CDATA[A specification of a {@link CacheBuilder} configuration.

 <p>{@code CacheBuilderSpec} supports parsing configuration off of a string, which makes it
 especially useful for command-line configuration of a {@code CacheBuilder}.

 <p>The string syntax is a series of comma-separated keys or key-value pairs, each corresponding
 to a {@code CacheBuilder} method.

 <ul>
   <li>{@code concurrencyLevel=[integer]}: sets {@link CacheBuilder#concurrencyLevel}.
   <li>{@code initialCapacity=[integer]}: sets {@link CacheBuilder#initialCapacity}.
   <li>{@code maximumSize=[long]}: sets {@link CacheBuilder#maximumSize}.
   <li>{@code maximumWeight=[long]}: sets {@link CacheBuilder#maximumWeight}.
   <li>{@code expireAfterAccess=[duration]}: sets {@link CacheBuilder#expireAfterAccess}.
   <li>{@code expireAfterWrite=[duration]}: sets {@link CacheBuilder#expireAfterWrite}.
   <li>{@code refreshAfterWrite=[duration]}: sets {@link CacheBuilder#refreshAfterWrite}.
   <li>{@code weakKeys}: sets {@link CacheBuilder#weakKeys}.
   <li>{@code softValues}: sets {@link CacheBuilder#softValues}.
   <li>{@code weakValues}: sets {@link CacheBuilder#weakValues}.
   <li>{@code recordStats}: sets {@link CacheBuilder#recordStats}.
 </ul>

 <p>The set of supported keys will grow as {@code CacheBuilder} evolves, but existing keys will
 never be removed.

 <p>Durations are represented by an integer, followed by one of "d", "h", "m", or "s",
 representing days, hours, minutes, or seconds respectively. (There is currently no syntax to
 request expiration in milliseconds, microseconds, or nanoseconds.)

 <p>Whitespace before and after commas and equal signs is ignored. Keys may not be repeated; it is
 also illegal to use the following pairs of keys in a single value:

 <ul>
   <li>{@code maximumSize} and {@code maximumWeight}
   <li>{@code softValues} and {@code weakValues}
 </ul>

 <p>{@code CacheBuilderSpec} does not support configuring {@code CacheBuilder} methods with
 non-value parameters. These must be configured in code.

 <p>A new {@code CacheBuilder} can be instantiated from a {@code CacheBuilderSpec} using {@link
 CacheBuilder#from(CacheBuilderSpec)} or {@link CacheBuilder#from(String)}.

 @author Adam Winer
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheBuilderSpec -->
  <!-- start class com.google.common.cache.CacheLoader -->
  <class name="CacheLoader" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CacheLoader"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="load" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes or retrieves the value corresponding to {@code key}.

 @param key the non-null key whose value should be loaded
 @return the value associated with {@code key}; <b>must not be null</b>
 @throws Exception if unable to load the result
 @throws InterruptedException if this method is interrupted. {@code InterruptedException} is
     treated like any other {@code Exception} in all respects except that, when it is caught,
     the thread's interrupt status is set]]>
      </doc>
    </method>
    <method name="reload" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="oldValue" type="V"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes or retrieves a replacement value corresponding to an already-cached {@code key}. This
 method is called when an existing cache entry is refreshed by {@link
 CacheBuilder#refreshAfterWrite}, or through a call to {@link LoadingCache#refresh}.

 <p>This implementation synchronously delegates to {@link #load}. It is recommended that it be
 overridden with an asynchronous implementation when using {@link
 CacheBuilder#refreshAfterWrite}.

 <p><b>Note:</b> <i>all exceptions thrown by this method will be logged and then swallowed</i>.

 @param key the non-null key whose value should be loaded
 @param oldValue the non-null old value corresponding to {@code key}
 @return the future new value associated with {@code key}; <b>must not be null, must not return
     null</b>
 @throws Exception if unable to reload the result
 @throws InterruptedException if this method is interrupted. {@code InterruptedException} is
     treated like any other {@code Exception} in all respects except that, when it is caught,
     the thread's interrupt status is set
 @since 11.0]]>
      </doc>
    </method>
    <method name="loadAll" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes or retrieves the values corresponding to {@code keys}. This method is called by {@link
 LoadingCache#getAll}.

 <p>If the returned map doesn't contain all requested {@code keys} then the entries it does
 contain will be cached, but {@code getAll} will throw an exception. If the returned map
 contains extra keys not present in {@code keys} then all returned entries will be cached, but
 only the entries for {@code keys} will be returned from {@code getAll}.

 <p>This method should be overridden when bulk retrieval is significantly more efficient than
 many individual lookups. Note that {@link LoadingCache#getAll} will defer to individual calls
 to {@link LoadingCache#get} if this method is not overridden.

 @param keys the unique, non-null keys whose values should be loaded
 @return a map from each key in {@code keys} to the value associated with that key; <b>may not
     contain null values</b>
 @throws Exception if unable to load the result
 @throws InterruptedException if this method is interrupted. {@code InterruptedException} is
     treated like any other {@code Exception} in all respects except that, when it is caught,
     the thread's interrupt status is set
 @since 11.0]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheLoader&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a cache loader that uses {@code function} to load keys, and without supporting either
 reloading or bulk loading. This is most useful when you can pass a lambda expression. Otherwise
 it is useful mostly when you already have an existing function instance.

 <p>The returned object is serializable if {@code function} is serializable.

 @param function the function to be used for loading values; must never return {@code null}
 @return a cache loader that loads values by passing each key to {@code function}]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.cache.CacheLoader&lt;java.lang.Object, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supplier" type="com.google.common.base.Supplier&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a cache loader based on an <i>existing</i> supplier instance. Note that there's no need
 to create a <i>new</i> supplier just to pass it in here; just subclass {@code CacheLoader} and
 implement {@link #load load} instead.

 <p>The returned object is serializable if {@code supplier} is serializable.

 @param supplier the supplier to be used for loading values; must never return {@code null}
 @return a cache loader that loads values by calling {@link Supplier#get}, irrespective of the
     key]]>
      </doc>
    </method>
    <method name="asyncReloading" return="com.google.common.cache.CacheLoader&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="com.google.common.cache.CacheLoader&lt;K, V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a {@code CacheLoader} which wraps {@code loader}, executing calls to {@link
 CacheLoader#reload} using {@code executor}.

 <p>This method is useful only when {@code loader.reload} has a synchronous implementation, such
 as {@linkplain #reload the default implementation}.

 @since 17.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Computes or retrieves values, based on a key, for use in populating a {@link LoadingCache}.

 <p>Most implementations will only need to implement {@link #load}. Other methods may be
 overridden as desired.

 <p>Usage example:

 {@snippet :
 CacheLoader<Key, Graph> loader = new CacheLoader<Key, Graph>() {
   public Graph load(Key key) throws AnyException {
     return createExpensiveGraph(key);
   }
 };
 LoadingCache<Key, Graph> cache = CacheBuilder.newBuilder().build(loader);
 }

 <p>Since this example doesn't support reloading or bulk loading, if you're able to use lambda
 expressions it can be specified even more easily:

 {@snippet :
 CacheLoader<Key, Graph> loader = CacheLoader.from(key -> createExpensiveGraph(key));
 }

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheLoader -->
  <!-- start class com.google.common.cache.CacheLoader.InvalidCacheLoadException -->
  <class name="CacheLoader.InvalidCacheLoadException" extends="java.lang.RuntimeException"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidCacheLoadException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown to indicate that an invalid response was returned from a call to {@link CacheLoader}.

 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheLoader.InvalidCacheLoadException -->
  <!-- start class com.google.common.cache.CacheLoader.UnsupportedLoadingOperationException -->
  <class name="CacheLoader.UnsupportedLoadingOperationException" extends="java.lang.UnsupportedOperationException"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Exception thrown by {@code loadAll()} to indicate that it is not supported.

 @since 19.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheLoader.UnsupportedLoadingOperationException -->
  <!-- start class com.google.common.cache.CacheStats -->
  <class name="CacheStats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CacheStats" type="long, long, long, long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@code CacheStats} instance.

 <p>Five parameters of the same type in a row is a bad thing, but this class is not constructed
 by end users and is too fine-grained for a builder.]]>
      </doc>
    </constructor>
    <method name="requestCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have returned either a cached or
 uncached value. This is defined as {@code hitCount + missCount}.

 <p><b>Note:</b> the values of the metrics are undefined in case of overflow (though it is
 guaranteed not to throw an exception). If you require specific handling, we recommend
 implementing your own stats collector.]]>
      </doc>
    </method>
    <method name="hitCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have returned a cached value.]]>
      </doc>
    </method>
    <method name="hitRate" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ratio of cache requests which were hits. This is defined as {@code hitCount /
 requestCount}, or {@code 1.0} when {@code requestCount == 0}. Note that {@code hitRate +
 missRate =~ 1.0}.]]>
      </doc>
    </method>
    <method name="missCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have returned an uncached (newly
 loaded) value, or null. Multiple concurrent calls to {@link Cache} lookup methods on an absent
 value can result in multiple misses, all returning the results of a single cache load
 operation.]]>
      </doc>
    </method>
    <method name="missRate" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ratio of cache requests which were misses. This is defined as {@code missCount /
 requestCount}, or {@code 0.0} when {@code requestCount == 0}. Note that {@code hitRate +
 missRate =~ 1.0}. Cache misses include all requests which weren't cache hits, including
 requests which resulted in either successful or failed loading attempts, and requests which
 waited for other threads to finish loading. It is thus the case that {@code missCount >=
 loadSuccessCount + loadExceptionCount}. Multiple concurrent misses for the same key will result
 in a single load operation.]]>
      </doc>
    </method>
    <method name="loadCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of times that {@link Cache} lookup methods attempted to load new
 values. This includes both successful load operations and those that threw exceptions. This is
 defined as {@code loadSuccessCount + loadExceptionCount}.

 <p><b>Note:</b> the values of the metrics are undefined in case of overflow (though it is
 guaranteed not to throw an exception). If you require specific handling, we recommend
 implementing your own stats collector.]]>
      </doc>
    </method>
    <method name="loadSuccessCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods have successfully loaded a new value.
 This is usually incremented in conjunction with {@link #missCount}, though {@code missCount} is
 also incremented when an exception is encountered during cache loading (see {@link
 #loadExceptionCount}). Multiple concurrent misses for the same key will result in a single load
 operation. This may be incremented not in conjunction with {@code missCount} if the load occurs
 as a result of a refresh or if the cache loader returned more items than was requested. {@code
 missCount} may also be incremented not in conjunction with this (nor {@link
 #loadExceptionCount}) on calls to {@code getIfPresent}.]]>
      </doc>
    </method>
    <method name="loadExceptionCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times {@link Cache} lookup methods threw an exception while loading a new
 value. This is usually incremented in conjunction with {@code missCount}, though {@code
 missCount} is also incremented when cache loading completes successfully (see {@link
 #loadSuccessCount}). Multiple concurrent misses for the same key will result in a single load
 operation. This may be incremented not in conjunction with {@code missCount} if the load occurs
 as a result of a refresh or if the cache loader returned more items than was requested. {@code
 missCount} may also be incremented not in conjunction with this (nor {@link #loadSuccessCount})
 on calls to {@code getIfPresent}.]]>
      </doc>
    </method>
    <method name="loadExceptionRate" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ratio of cache loading attempts which threw exceptions. This is defined as {@code
 loadExceptionCount / (loadSuccessCount + loadExceptionCount)}, or {@code 0.0} when {@code
 loadSuccessCount + loadExceptionCount == 0}.

 <p><b>Note:</b> the values of the metrics are undefined in case of overflow (though it is
 guaranteed not to throw an exception). If you require specific handling, we recommend
 implementing your own stats collector.]]>
      </doc>
    </method>
    <method name="totalLoadTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of nanoseconds the cache has spent loading new values. This can be
 used to calculate the miss penalty. This value is increased every time {@code loadSuccessCount}
 or {@code loadExceptionCount} is incremented.]]>
      </doc>
    </method>
    <method name="averageLoadPenalty" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the average time spent loading new values. This is defined as {@code totalLoadTime /
 (loadSuccessCount + loadExceptionCount)}.

 <p><b>Note:</b> the values of the metrics are undefined in case of overflow (though it is
 guaranteed not to throw an exception). If you require specific handling, we recommend
 implementing your own stats collector.]]>
      </doc>
    </method>
    <method name="evictionCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times an entry has been evicted. This count does not include manual
 {@linkplain Cache#invalidate invalidations}.]]>
      </doc>
    </method>
    <method name="minus" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.cache.CacheStats"/>
      <doc>
      <![CDATA[Returns a new {@code CacheStats} representing the difference between this {@code CacheStats}
 and {@code other}. Negative values, which aren't supported by {@code CacheStats} will be
 rounded up to zero.]]>
      </doc>
    </method>
    <method name="plus" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.cache.CacheStats"/>
      <doc>
      <![CDATA[Returns a new {@code CacheStats} representing the sum of this {@code CacheStats} and {@code
 other}.

 <p><b>Note:</b> the values of the metrics are undefined in case of overflow (though it is
 guaranteed not to throw an exception). If you require specific handling, we recommend
 implementing your own stats collector.

 @since 11.0]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Statistics about the performance of a {@link Cache}. Instances of this class are immutable.

 <p>Cache statistics are incremented according to the following rules:

 <ul>
   <li>When a cache lookup encounters an existing cache entry {@code hitCount} is incremented.
   <li>When a cache lookup first encounters a missing cache entry, a new entry is loaded.
       <ul>
         <li>After successfully loading an entry {@code missCount} and {@code loadSuccessCount}
             are incremented, and the total loading time, in nanoseconds, is added to {@code
             totalLoadTime}.
         <li>When an exception is thrown while loading an entry, {@code missCount} and {@code
             loadExceptionCount} are incremented, and the total loading time, in nanoseconds, is
             added to {@code totalLoadTime}.
         <li>Cache lookups that encounter a missing cache entry that is still loading will wait
             for loading to complete (whether successful or not) and then increment {@code
             missCount}.
       </ul>
   <li>When an entry is evicted from the cache, {@code evictionCount} is incremented.
   <li>No stats are modified when a cache entry is invalidated or manually removed.
   <li>No stats are modified by operations invoked on the {@linkplain Cache#asMap asMap} view of
       the cache.
 </ul>

 <p>A lookup is specifically defined as an invocation of one of the methods {@link
 LoadingCache#get(Object)}, {@link LoadingCache#getUnchecked(Object)}, {@link Cache#get(Object,
 Callable)}, or {@link LoadingCache#getAll(Iterable)}.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.CacheStats -->
  <!-- start class com.google.common.cache.ForwardingCache -->
  <class name="ForwardingCache" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.Cache&lt;K, V&gt;"/>
    <constructor name="ForwardingCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.cache.Cache&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="valueLoader" type="java.util.concurrent.Callable&lt;? extends V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends java.lang.Object&gt;"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends java.lang.Object&gt;"/>
      <doc>
      <![CDATA[@since 11.0]]>
      </doc>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A cache which forwards all its method calls to another cache. Subclasses should override one or
 more methods to modify the behavior of the backing cache as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingCache -->
  <!-- start class com.google.common.cache.ForwardingCache.SimpleForwardingCache -->
  <class name="ForwardingCache.SimpleForwardingCache" extends="com.google.common.cache.ForwardingCache&lt;K, V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimpleForwardingCache" type="com.google.common.cache.Cache&lt;K, V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.cache.Cache&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingCache} where subclasses can pass in an already
 constructed {@link Cache} as the delegate.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingCache.SimpleForwardingCache -->
  <!-- start class com.google.common.cache.ForwardingLoadingCache -->
  <class name="ForwardingLoadingCache" extends="com.google.common.cache.ForwardingCache&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache&lt;K, V&gt;"/>
    <constructor name="ForwardingLoadingCache"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.cache.LoadingCache&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <doc>
    <![CDATA[A cache which forwards all its method calls to another cache. Subclasses should override one or
 more methods to modify the behavior of the backing cache as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>Note that {@link #get}, {@link #getUnchecked}, and {@link #apply} all expose the same
 underlying functionality, so should probably be overridden as a group.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingLoadingCache -->
  <!-- start class com.google.common.cache.ForwardingLoadingCache.SimpleForwardingLoadingCache -->
  <class name="ForwardingLoadingCache.SimpleForwardingLoadingCache" extends="com.google.common.cache.ForwardingLoadingCache&lt;K, V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimpleForwardingLoadingCache" type="com.google.common.cache.LoadingCache&lt;K, V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.cache.LoadingCache&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingLoadingCache} where subclasses can pass in an already
 constructed {@link LoadingCache} as the delegate.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.ForwardingLoadingCache.SimpleForwardingLoadingCache -->
  <!-- start interface com.google.common.cache.LoadingCache -->
  <interface name="LoadingCache"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.Cache&lt;K, V&gt;"/>
    <implements name="com.google.common.base.Function&lt;K, V&gt;"/>
    <method name="get" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, first loading that value if
 necessary. No observable state associated with this cache is modified until loading completes.

 <p>If another call to {@link #get} or {@link #getUnchecked} is currently loading the value for
 {@code key}, simply waits for that thread to finish and returns its loaded value. Note that
 multiple threads can concurrently load values for distinct keys.

 <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#load} to load new values
 into the cache. Newly loaded values are added to the cache using {@code
 Cache.asMap().putIfAbsent} after loading has completed; if another value was associated with
 {@code key} while the new value was loading then a removal notification will be sent for the
 new value.

 <p>If the cache loader associated with this cache is known not to throw checked exceptions,
 then prefer {@link #getUnchecked} over this method.

 @throws ExecutionException if a checked exception was thrown while loading the value. ({@code
     ExecutionException} is thrown <a
     href="https://github.com/google/guava/wiki/CachesExplained#interruption">even if
     computation was interrupted by an {@code InterruptedException}</a>.)
 @throws UncheckedExecutionException if an unchecked exception was thrown while loading the
     value
 @throws ExecutionError if an error was thrown while loading the value]]>
      </doc>
    </method>
    <method name="getUnchecked" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key} in this cache, first loading that value if
 necessary. No observable state associated with this cache is modified until loading completes.
 Unlike {@link #get}, this method does not throw a checked exception, and thus should only be
 used in situations where checked exceptions are not thrown by the cache loader.

 <p>If another call to {@link #get} or {@link #getUnchecked} is currently loading the value for
 {@code key}, simply waits for that thread to finish and returns its loaded value. Note that
 multiple threads can concurrently load values for distinct keys.

 <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#load} to load new values
 into the cache. Newly loaded values are added to the cache using {@code
 Cache.asMap().putIfAbsent} after loading has completed; if another value was associated with
 {@code key} while the new value was loading then a removal notification will be sent for the
 new value.

 <p><b>Warning:</b> this method silently converts checked exceptions to unchecked exceptions,
 and should not be used with cache loaders which throw checked exceptions. In such cases use
 {@link #get} instead.

 @throws UncheckedExecutionException if an exception was thrown while loading the value. (As
     explained in the last paragraph above, this should be an unchecked exception only.)
 @throws ExecutionError if an error was thrown while loading the value]]>
      </doc>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends K&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns a map of the values associated with {@code keys}, creating or retrieving those values
 if necessary. The returned map contains entries that were already cached, combined with newly
 loaded entries; it will never contain null keys or values.

 <p>Caches loaded by a {@link CacheLoader} will issue a single request to {@link
 CacheLoader#loadAll} for all keys which are not already present in the cache. All entries
 returned by {@link CacheLoader#loadAll} will be stored in the cache, over-writing any
 previously cached values. This method will throw an exception if {@link CacheLoader#loadAll}
 returns {@code null}, returns a map containing null keys or values, or fails to return an entry
 for each requested key.

 <p>Note that duplicate elements in {@code keys}, as determined by {@link Object#equals}, will
 be ignored.

 @throws ExecutionException if a checked exception was thrown while loading the value. ({@code
     ExecutionException} is thrown <a
     href="https://github.com/google/guava/wiki/CachesExplained#interruption">even if
     computation was interrupted by an {@code InterruptedException}</a>.)
 @throws UncheckedExecutionException if an unchecked exception was thrown while loading the
     values
 @throws ExecutionError if an error was thrown while loading the values
 @since 11.0]]>
      </doc>
    </method>
    <method name="apply" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Provided to satisfy the {@code Function} interface; use {@link #get} or {@link
     #getUnchecked} instead.">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[@deprecated Provided to satisfy the {@code Function} interface; use {@link #get} or {@link
     #getUnchecked} instead.
 @throws UncheckedExecutionException if an exception was thrown while loading the value. (As
     described in the documentation for {@link #getUnchecked}, {@code LoadingCache} should be
     used as a {@code Function} only with cache loaders that throw only unchecked exceptions.)]]>
      </doc>
    </method>
    <method name="refresh"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Loads a new value for {@code key}, possibly asynchronously. While the new value is loading the
 previous value (if any) will continue to be returned by {@code get(key)} unless it is evicted.
 If the new value is loaded successfully it will replace the previous value in the cache; if an
 exception is thrown while refreshing the previous value will remain, <i>and the exception will
 be logged (using {@link java.util.logging.Logger}) and swallowed</i>.

 <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#reload} if the cache
 currently contains a value for {@code key}, and {@link CacheLoader#load} otherwise. Loading is
 asynchronous only if {@link CacheLoader#reload} was overridden with an asynchronous
 implementation.

 <p>Returns without doing anything if another thread is currently loading the value for {@code
 key}. If the cache loader associated with this cache performs refresh asynchronously then this
 method may return before refresh completes.

 @since 11.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note that although the view <i>is</i> modifiable, no method on the returned map will ever
 cause entries to be automatically loaded.</b>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A semi-persistent mapping from keys to values. Values are automatically loaded by the cache, and
 are stored in the cache until either evicted or manually invalidated. The common way to build
 instances is using {@link CacheBuilder}.

 <p>Implementations of this interface are expected to be thread-safe, and can be safely accessed
 by multiple concurrent threads.

 <p>When evaluated as a {@link Function}, a cache yields the same result as invoking {@link
 #getUnchecked}.

 @param <K> the type of the cache's keys, which are not permitted to be null
 @param <V> the type of the cache's values, which are not permitted to be null
 @author Charles Fry
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.LoadingCache -->
  <!-- start class com.google.common.cache.RemovalCause -->
  <class name="RemovalCause" extends="java.lang.Enum&lt;com.google.common.cache.RemovalCause&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.cache.RemovalCause[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.cache.RemovalCause"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The reason why a cached entry was removed.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.RemovalCause -->
  <!-- start interface com.google.common.cache.RemovalListener -->
  <interface name="RemovalListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onRemoval"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="com.google.common.cache.RemovalNotification&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Notifies the listener that a removal occurred at some point in the past.

 <p>This does not always signify that the key is now absent from the cache, as it may have
 already been re-added.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that can receive a notification when an entry is removed from a cache. The removal
 resulting in notification could have occurred to an entry being manually removed or replaced, or
 due to eviction resulting from timed expiration, exceeding a maximum size, or garbage collection.

 <p>An instance may be called concurrently by multiple threads to process different entries.
 Implementations of this interface should avoid performing blocking calls or synchronizing on
 shared resources.

 @param <K> the most general type of keys this listener can listen for; for example {@code Object}
     if any key is acceptable
 @param <V> the most general type of values this listener can listen for; for example {@code
     Object} if any key is acceptable
 @author Charles Fry
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.RemovalListener -->
  <!-- start class com.google.common.cache.RemovalListeners -->
  <class name="RemovalListeners" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="asynchronous" return="com.google.common.cache.RemovalListener&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.cache.RemovalListener&lt;K, V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a {@code RemovalListener} which processes all eviction notifications using {@code
 executor}.

 @param listener the backing listener
 @param executor the executor with which removal notifications are asynchronously executed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection of common removal listeners.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.RemovalListeners -->
  <!-- start class com.google.common.cache.RemovalNotification -->
  <class name="RemovalNotification" extends="java.util.AbstractMap.SimpleImmutableEntry&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.cache.RemovalNotification&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <param name="cause" type="com.google.common.cache.RemovalCause"/>
      <doc>
      <![CDATA[Creates a new {@code RemovalNotification} for the given {@code key}/{@code value} pair, with
 the given {@code cause} for the removal. The {@code key} and/or {@code value} may be {@code
 null} if they were already garbage collected.

 @since 19.0]]>
      </doc>
    </method>
    <method name="getCause" return="com.google.common.cache.RemovalCause"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the cause for which the entry was removed.]]>
      </doc>
    </method>
    <method name="wasEvicted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there was an automatic removal due to eviction (the cause is neither
 {@link RemovalCause#EXPLICIT} nor {@link RemovalCause#REPLACED}).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A notification of the removal of a single entry. The key and/or value may be null if they were
 already garbage collected.

 <p>Like other {@code Entry} instances associated with {@code CacheBuilder}, this class holds
 strong references to the key and value, regardless of the type of references the cache may be
 using.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.cache.RemovalNotification -->
  <!-- start interface com.google.common.cache.Weigher -->
  <interface name="Weigher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="weigh" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns the weight of a cache entry. There is no unit for entry weights; rather they are simply
 relative to each other.

 @return the weight of the entry; must be non-negative]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Calculates the weights of cache entries.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.cache.Weigher -->
</package>
<package name="com.google.common.collect">
  <!-- start class com.google.common.collect.AbstractIterator -->
  <class name="AbstractIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="computeNext" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element. <b>Note:</b> the implementation must call {@link #endOfData()} when
 there are no elements left in the iteration. Failure to do so could result in an infinite loop.

 <p>The initial invocation of {@link #hasNext()} or {@link #next()} calls this method, as does
 the first invocation of {@code hasNext} or {@code next} following each successful call to
 {@code next}. Once the implementation either invokes {@code endOfData} or throws an exception,
 {@code computeNext} is guaranteed to never be called again.

 <p>If this method throws an exception, it will propagate outward to the {@code hasNext} or
 {@code next} invocation that invoked this method. Any further attempts to use the iterator will
 result in an {@link IllegalStateException}.

 <p>The implementation of this method may not invoke the {@code hasNext}, {@code next}, or
 {@link #peek()} methods on this instance; if it does, an {@code IllegalStateException} will
 result.

 @return the next element if there was one. If {@code endOfData} was called during execution,
     the return value will be ignored.
 @throws RuntimeException if any unrecoverable error happens. This exception will propagate
     outward to the {@code hasNext()}, {@code next()}, or {@code peek()} invocation that invoked
     this method. Any further attempts to use the iterator will result in an {@link
     IllegalStateException}.]]>
      </doc>
    </method>
    <method name="endOfData" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementations of {@link #computeNext} <b>must</b> invoke this method when there are no
 elements left in the iteration.

 @return {@code null}; a convenience so your {@code computeNext} implementation can use the
     simple statement {@code return endOfData();}]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element in the iteration without advancing the iteration, according to the
 contract of {@link PeekingIterator#peek()}.

 <p>Implementations of {@code AbstractIterator} that wish to expose this functionality should
 implement {@code PeekingIterator}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Iterator} interface, to make this
 interface easier to implement for certain types of data sources.

 <p>{@code Iterator} requires its implementations to support querying the end-of-data status
 without changing the iterator's state, using the {@link #hasNext} method. But many data sources,
 such as {@link java.io.Reader#read()}, do not expose this information; the only way to discover
 whether there is any data left is by trying to retrieve it. These types of data sources are
 ordinarily difficult to write iterators for. But using this class, one must implement only the
 {@link #computeNext} method, and invoke the {@link #endOfData} method when appropriate.

 <p>Another example is an iterator that skips over null elements in a backing iterator. This could
 be implemented as:

 {@snippet :
 public static Iterator<String> skipNulls(final Iterator<String> in) {
   return new AbstractIterator<String>() {
     protected String computeNext() {
       while (in.hasNext()) {
         String s = in.next();
         if (s != null) {
           return s;
         }
       }
       return endOfData();
     }
   };
 }
 }

 <p>This class supports iterators that include null elements.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AbstractIterator -->
  <!-- start class com.google.common.collect.AbstractSequentialIterator -->
  <class name="AbstractSequentialIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractSequentialIterator" type="T"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new iterator with the given first element, or, if {@code firstOrNull} is null,
 creates a new empty iterator.]]>
      </doc>
    </constructor>
    <method name="computeNext" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="previous" type="T"/>
      <doc>
      <![CDATA[Returns the element that follows {@code previous}, or returns {@code null} if no elements
 remain. This method is invoked during each call to {@link #next()} in order to compute the
 result of a <i>future</i> call to {@code next()}.]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of the {@code Iterator} interface for sequences
 whose next element can always be derived from the previous element. Null elements are not
 supported, nor is the {@link #remove()} method.

 <p>Example:

 {@snippet :
 Iterator<Integer> powersOfTwo =
     new AbstractSequentialIterator<Integer>(1) {
       protected Integer computeNext(Integer previous) {
         return (previous == 1 << 30) ? null : previous * 2;
       }
     };
 }

 @author Chris Povirk
 @since 12.0 (in Guava as {@code AbstractLinkedIterator} since 8.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.AbstractSequentialIterator -->
  <!-- start class com.google.common.collect.ArrayListMultimap -->
  <class name="ArrayListMultimap" extends="com.google.common.collect.AbstractListMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code ArrayListMultimap} with the default initial capacities.

 <p>You may also consider the equivalent {@code
 MultimapBuilder.hashKeys().arrayListValues().build()}, which provides more control over the
 underlying data structure.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code ArrayListMultimap} with enough capacity to hold the specified
 numbers of keys and values without resizing.

 <p>You may also consider the equivalent {@code
 MultimapBuilder.hashKeys(expectedKeys).arrayListValues(expectedValuesPerKey).build()}, which
 provides more control over the underlying data structure.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is
     negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs an {@code ArrayListMultimap} with the same mappings as the specified multimap.

 <p>You may also consider the equivalent {@code
 MultimapBuilder.hashKeys().arrayListValues().build(multimap)}, which provides more control over
 the underlying data structure.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="trimToSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="For a {@link ListMultimap} that automatically trims to size, use {@link
     ImmutableListMultimap}. If you need a mutable collection, remove the {@code trimToSize}
     call, or switch to a {@code HashMaplEsS_tHaNK, ArrayListlEsS_tHaNV>>}.">
      <doc>
      <![CDATA[Reduces the memory used by this {@code ArrayListMultimap}, if feasible.

 @deprecated For a {@link ListMultimap} that automatically trims to size, use {@link
     ImmutableListMultimap}. If you need a mutable collection, remove the {@code trimToSize}
     call, or switch to a {@code HashMap<K, ArrayList<V>>}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} that uses an {@code ArrayList} to store the values for a given
 key. A {@link HashMap} associates each key with an {@link ArrayList} of values.

 <p>When iterating through the collections supplied by this class, the ordering of values for a
 given key agrees with the order in which the values were added.

 <p>This multimap allows duplicate key-value pairs. After adding a new key-value pair equal to an
 existing key-value pair, the {@code ArrayListMultimap} will contain entries for both the new
 value and the old value.

 <p>Keys and values may be null. All optional multimap methods are supported, and all returned
 views are modifiable.

 <p>The lists returned by {@link #get}, {@link #removeAll}, and {@link #replaceValues} all
 implement {@link java.util.RandomAccess}.

 <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent
 read operations will work correctly. To allow concurrent update operations, wrap your multimap
 with a call to {@link Multimaps#synchronizedListMultimap}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ArrayListMultimap -->
  <!-- start class com.google.common.collect.ArrayTable -->
  <class name="ArrayTable" extends="com.google.common.collect.AbstractTable&lt;R, C, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Table&lt;R, C, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.ArrayTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKeys" type="java.lang.Iterable&lt;? extends R&gt;"/>
      <param name="columnKeys" type="java.lang.Iterable&lt;? extends C&gt;"/>
      <doc>
      <![CDATA[Creates an {@code ArrayTable} filled with {@code null}.

 @param rowKeys row keys that may be stored in the generated table
 @param columnKeys column keys that may be stored in the generated table
 @throws NullPointerException if any of the provided keys is null
 @throws IllegalArgumentException if {@code rowKeys} or {@code columnKeys} contains duplicates
     or if exactly one of {@code rowKeys} or {@code columnKeys} is empty.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ArrayTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;R, C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates an {@code ArrayTable} with the mappings in the provided table.

 <p>If {@code table} includes a mapping with row key {@code r} and a separate mapping with
 column key {@code c}, the returned table contains a mapping with row key {@code r} and column
 key {@code c}. If that row key / column key pair in not in {@code table}, the pair maps to
 {@code null} in the generated table.

 <p>The returned table allows subsequent {@code put} calls with the row keys in {@code
 table.rowKeySet()} and the column keys in {@code table.columnKeySet()}. Calling {@link #put}
 with other keys leads to an {@code IllegalArgumentException}.

 <p>The ordering of {@code table.rowKeySet()} and {@code table.columnKeySet()} determines the
 row and column iteration ordering of the returned table.

 @throws NullPointerException if {@code table} has a null key]]>
      </doc>
    </method>
    <method name="rowKeyList" return="com.google.common.collect.ImmutableList&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns, as an immutable list, the row keys provided when the table was constructed, including
 those that are mapped to null values only.]]>
      </doc>
    </method>
    <method name="columnKeyList" return="com.google.common.collect.ImmutableList&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns, as an immutable list, the column keys provided when the table was constructed,
 including those that are mapped to null values only.]]>
      </doc>
    </method>
    <method name="at" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowIndex" type="int"/>
      <param name="columnIndex" type="int"/>
      <doc>
      <![CDATA[Returns the value corresponding to the specified row and column indices. The same value is
 returned by {@code get(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex))}, but this
 method runs more quickly.

 @param rowIndex position of the row key in {@link #rowKeyList()}
 @param columnIndex position of the row key in {@link #columnKeyList()}
 @return the value with the specified row and column
 @throws IndexOutOfBoundsException if either index is negative, {@code rowIndex} is greater than
     or equal to the number of allowed row keys, or {@code columnIndex} is greater than or equal
     to the number of allowed column keys]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowIndex" type="int"/>
      <param name="columnIndex" type="int"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code value} with the specified row and column indices. The logic {@code
 put(rowKeyList().get(rowIndex), columnKeyList().get(columnIndex), value)} has the same
 behavior, but this method runs more quickly.

 @param rowIndex position of the row key in {@link #rowKeyList()}
 @param columnIndex position of the row key in {@link #columnKeyList()}
 @param value value to store in the table
 @return the previous value with the specified row and column
 @throws IndexOutOfBoundsException if either index is negative, {@code rowIndex} is greater than
     or equal to the number of allowed row keys, or {@code columnIndex} is greater than or equal
     to the number of allowed column keys]]>
      </doc>
    </method>
    <method name="toArray" return="V[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueClass" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a two-dimensional array with the table contents. The row and column indices correspond
 to the positions of the row and column in the iterables provided during table construction. If
 the table lacks a mapping for a given row and column, the corresponding array element is null.

 <p>Subsequent table changes will not modify the array, and vice versa.

 @param valueClass class of values stored in the returned array]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #eraseAll}">
      <doc>
      <![CDATA[Not supported. Use {@link #eraseAll} instead.

 @throws UnsupportedOperationException always
 @deprecated Use {@link #eraseAll}]]>
      </doc>
    </method>
    <method name="eraseAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Associates the value {@code null} with every pair of allowed row and column keys.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the provided keys are among the keys provided when the table was
 constructed.]]>
      </doc>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the provided column key is among the column keys provided when the
 table was constructed.]]>
      </doc>
    </method>
    <method name="containsRow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the provided row key is among the row keys provided when the table was
 constructed.]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if {@code rowKeyList().size == 0} or {@code columnKeyList().size() == 0}.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws IllegalArgumentException if {@code rowKey} is not in {@link #rowKeySet()} or {@code
     columnKey} is not in {@link #columnKeySet()}.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If {@code table} is an {@code ArrayTable}, its null values will be stored in this table,
 possibly replacing values that were previously non-null.

 @throws NullPointerException if {@code table} has a null key
 @throws IllegalArgumentException if any of the provided table's row keys or column keys is not
     in {@link #rowKeySet()} or {@link #columnKeySet()}]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #erase}">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Not supported. Use {@link #erase} instead.

 @throws UnsupportedOperationException always
 @deprecated Use {@link #erase}]]>
      </doc>
    </method>
    <method name="erase" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Associates the value {@code null} with the specified keys, assuming both keys are valid. If
 either key is null or isn't among the keys provided during construction, this method has no
 effect.

 <p>This method is equivalent to {@code put(rowKey, columnKey, null)} when both provided keys
 are valid.

 @param rowKey row key of mapping to be erased
 @param columnKey column key of mapping to be erased
 @return the value previously associated with the keys, or {@code null} if no mapping existed
     for the keys]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cellSet" return="java.util.Set&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable set of all row key / column key / value triplets. Changes to the table
 will update the returned set.

 <p>The returned set's iterator traverses the mappings with the first row key, the mappings with
 the second row key, and so on.

 <p>The value in the returned cells may change if the table subsequently changes.

 @return set of table cells consisting of row key / column key / value triplets]]>
      </doc>
    </method>
    <method name="column" return="java.util.Map&lt;R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given column key. If the column key isn't in
 {@link #columnKeySet()}, an empty immutable map is returned.

 <p>Otherwise, for each row key in {@link #rowKeySet()}, the returned map associates the row key
 with the corresponding value in the table. Changes to the returned map will update the
 underlying table, and vice versa.

 @param columnKey key of column to search for in the table
 @return the corresponding map from row keys to values]]>
      </doc>
    </method>
    <method name="columnKeySet" return="com.google.common.collect.ImmutableSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the valid column keys, including those that are associated with
 null values only.

 @return immutable set of column keys]]>
      </doc>
    </method>
    <method name="columnMap" return="java.util.Map&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="row" return="java.util.Map&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given row key. If the row key isn't in {@link
 #rowKeySet()}, an empty immutable map is returned.

 <p>Otherwise, for each column key in {@link #columnKeySet()}, the returned map associates the
 column key with the corresponding value in the table. Changes to the returned map will update
 the underlying table, and vice versa.

 @param rowKey key of row to search for in the table
 @return the corresponding map from column keys to values]]>
      </doc>
    </method>
    <method name="rowKeySet" return="com.google.common.collect.ImmutableSet&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the valid row keys, including those that are associated with null
 values only.

 @return immutable set of row keys]]>
      </doc>
    </method>
    <method name="rowMap" return="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable collection of all values, which may contain duplicates. Changes to the
 table will update the returned collection.

 <p>The returned collection's iterator traverses the values of the first row key, the values of
 the second row key, and so on.

 @return collection of values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fixed-size {@link Table} implementation backed by a two-dimensional array.

 <p><b>Warning:</b> {@code ArrayTable} is rarely the {@link Table} implementation you want. First,
 it requires that the complete universe of rows and columns be specified at construction time.
 Second, it is always backed by an array large enough to hold a value for every possible
 combination of row and column keys. (This is rarely optimal unless the table is extremely dense.)
 Finally, every possible combination of row and column keys is always considered to have a value
 associated with it: It is not possible to "remove" a value, only to replace it with {@code null},
 which will still appear when iterating over the table's contents in a foreach loop or a call to a
 null-hostile method like {@link ImmutableTable#copyOf}. For alternatives, please see <a
 href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#table">the wiki</a>.

 <p>The allowed row and column keys must be supplied when the table is created. The table always
 contains a mapping for every row key / column pair. The value corresponding to a given row and
 column is null unless another value is provided.

 <p>The table's size is constant: the product of the number of supplied row keys and the number of
 supplied column keys. The {@code remove} and {@code clear} methods are not supported by the table
 or its views. The {@link #erase} and {@link #eraseAll} methods may be used instead.

 <p>The ordering of the row and column keys provided when the table is constructed determines the
 iteration ordering across rows and columns in the table's views. None of the view iterators
 support {@link Iterator#remove}. If the table is modified after an iterator is created, the
 iterator remains valid.

 <p>This class requires less memory than the {@link HashBasedTable} and {@link TreeBasedTable}
 implementations, except when the table is sparse.

 <p>Null row keys or column keys are not permitted.

 <p>This class provides methods involving the underlying array structure, where the array indices
 correspond to the position of a row or column in the lists of allowed keys and values. See the
 {@link #at}, {@link #set}, {@link #toArray}, {@link #rowKeyList}, and {@link #columnKeyList}
 methods for more details.

 <p>Note that this implementation is not synchronized. If multiple threads access the same cell of
 an {@code ArrayTable} concurrently and one of the threads modifies its value, there is no
 guarantee that the new value will be fully visible to the other threads. To guarantee that
 modifications are visible, synchronize access to the table. Unlike other {@code Table}
 implementations, synchronization is unnecessary between a thread that writes to one cell and a
 thread that reads from another.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#table">{@code Table}</a>.

 @author Jared Levy
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ArrayTable -->
  <!-- start interface com.google.common.collect.BiMap -->
  <interface name="BiMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <method name="put" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws IllegalArgumentException if the given value is already bound to a different key in this
     bimap. The bimap will remain unmodified in this event. To avoid this exception, call {@link
     #forcePut} instead.]]>
      </doc>
    </method>
    <method name="forcePut" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[An alternate form of {@code put} that silently removes any existing entry with the value {@code
 value} before proceeding with the {@link #put} operation. If the bimap previously contained the
 provided key-value mapping, this method has no effect.

 <p>Note that a successful call to this method could cause the size of the bimap to increase by
 one, stay the same, or even decrease by one.

 <p><b>Warning:</b> If an existing entry with this value is removed, the key for that entry is
 discarded and not returned.

 @param key the key with which the specified value is to be associated
 @param value the value to be associated with the specified key
 @return the value that was previously associated with the key, or {@code null} if there was no
     previous entry. (If the bimap contains null values, then {@code forcePut}, like {@code
     put}, returns {@code null} both if the key is absent and if it is present with a null
     value.)]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Warning:</b> the results of calling this method may vary depending on the iteration order
 of {@code map}.

 @throws IllegalArgumentException if an attempt to {@code put} any entry fails. Note that some
     map entries may have been added to the bimap before the exception was thrown.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Set&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a bimap has unique values, this method returns a {@link Set}, instead of the {@link
 java.util.Collection} specified in the {@link Map} interface.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.BiMap&lt;V, K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the inverse view of this bimap, which maps each of this bimap's values to its
 associated key. The two bimaps are backed by the same data; any changes to one will appear in
 the other.

 <p><b>Note:</b> There is no guaranteed correspondence between the iteration order of a bimap
 and that of its inverse.

 @return the inverse view of this bimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A bimap (or "bidirectional map") is a map that preserves the uniqueness of its values as well as
 that of its keys. This constraint enables bimaps to support an "inverse view", which is another
 bimap containing the same entries as this bimap but with reversed keys and values.

 <h3>Implementations</h3>

 <ul>
   <li>{@link ImmutableBiMap}
   <li>{@link HashBiMap}
   <li>{@link EnumBiMap}
   <li>{@link EnumHashBiMap}
 </ul>

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap">{@code BiMap}</a>.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.BiMap -->
  <!-- start class com.google.common.collect.BoundType -->
  <class name="BoundType" extends="java.lang.Enum&lt;com.google.common.collect.BoundType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.collect.BoundType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.collect.BoundType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Indicates whether an endpoint of some range is contained in the range itself ("closed") or not
 ("open"). If a range is unbounded on a side, it is neither open nor closed on that side; the
 bound simply does not exist.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.BoundType -->
  <!-- start interface com.google.common.collect.ClassToInstanceMap -->
  <interface name="ClassToInstanceMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"/>
    <method name="getInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value the specified class is mapped to, or {@code null} if no entry for this class
 is present. This will only return a value that was bound to this specific class, not a value
 that may have been bound to a subtype.]]>
      </doc>
    </method>
    <method name="putInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Maps the specified class to the specified value. Does <i>not</i> associate this value with any
 of the class's supertypes.

 @return the value previously associated with this class (possibly {@code null}), or {@code
     null} if there was no previous entry.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map, each entry of which maps a Java <a href="http://tinyurl.com/2cmwkz">raw type</a> to an
 instance of that type. In addition to implementing {@code Map}, the additional type-safe
 operations {@link #putInstance} and {@link #getInstance} are available.

 <p>Like any other {@code Map<Class, Object>}, this map may contain entries for primitive types,
 and a primitive type and its corresponding wrapper type may map to different values.

 <h3>Implementations</h3>

 <ul>
   <li>{@link ImmutableClassToInstanceMap}
   <li>{@link MutableClassToInstanceMap}
 </ul>

 <p>To map a generic type to an instance of that type, use {@link
 com.google.common.reflect.TypeToInstanceMap} instead.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#classtoinstancemap">{@code
 ClassToInstanceMap}</a>.

 @param <B> the common supertype that all values will share. When in doubt, just use {@link
     Object}, or use {@code @Nullable Object} to allow null values.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.ClassToInstanceMap -->
  <!-- start class com.google.common.collect.Collections2 -->
  <class name="Collections2" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="filter" return="java.util.Collection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Collection&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The returned collection is
 a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting collection's iterator does not support {@code remove()}, but all other
 collection methods are supported. When given an element that doesn't satisfy the predicate, the
 collection's {@code add()} and {@code addAll()} methods throw an {@link
 IllegalArgumentException}. When methods such as {@code removeAll()} and {@code clear()} are
 called on the filtered collection, only elements that satisfy the filter will be removed from
 the underlying collection.

 <p>The returned collection isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered collection's methods, such as {@code size()}, iterate across every
 element in the underlying collection and determine which elements satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered,
 predicate)} and use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
 Iterables#filter(Iterable, Class)} for related functionality.)

 <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#filter Stream.filter}.]]>
      </doc>
    </method>
    <method name="transform" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromCollection" type="java.util.Collection&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, T&gt;"/>
      <doc>
      <![CDATA[Returns a collection that applies {@code function} to each element of {@code fromCollection}.
 The returned collection is a live view of {@code fromCollection}; changes to one affect the
 other.

 <p>The returned collection's {@code add()} and {@code addAll()} methods throw an {@link
 UnsupportedOperationException}. All other collection methods are supported, as long as {@code
 fromCollection} supports them.

 <p>The returned collection isn't threadsafe or serializable, even if {@code fromCollection} is.

 <p>When a live view is <i>not</i> needed, it may be faster to copy the transformed collection
 and use the copy.

 <p>If the input {@code Collection} is known to be a {@code List}, consider {@link
 Lists#transform}. If only an {@code Iterable} is available, use {@link Iterables#transform}.

 <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#map Stream.map}.]]>
      </doc>
    </method>
    <method name="orderedPermutations" return="java.util.Collection&lt;java.util.List&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collection} of all the permutations of the specified {@link Iterable}.

 <p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations
 Generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7,
 Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the
 first permutation will be in ascending order, and the last will be in descending order.

 <p>Duplicate elements are considered equal. For example, the list [1, 1] will have only one
 permutation, instead of two. This is why the elements have to implement {@link Comparable}.

 <p>An empty iterable has only one permutation, which is an empty list.

 <p>This method is equivalent to {@code Collections2.orderedPermutations(list,
 Ordering.natural())}.

 @param elements the original iterable whose elements have to be permuted.
 @return an immutable {@link Collection} containing all the different permutations of the
     original iterable.
 @throws NullPointerException if the specified iterable is null or has any null elements.
 @since 12.0]]>
      </doc>
    </method>
    <method name="orderedPermutations" return="java.util.Collection&lt;java.util.List&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collection} of all the permutations of the specified {@link Iterable} using
 the specified {@link Comparator} for establishing the lexicographical ordering.

 <p>Examples:

 {@snippet :
 for (List<String> perm : orderedPermutations(asList("b", "c", "a"))) {
   println(perm);
 }
 // -> ["a", "b", "c"]
 // -> ["a", "c", "b"]
 // -> ["b", "a", "c"]
 // -> ["b", "c", "a"]
 // -> ["c", "a", "b"]
 // -> ["c", "b", "a"]

 for (List<Integer> perm : orderedPermutations(asList(1, 2, 2, 1))) {
   println(perm);
 }
 // -> [1, 1, 2, 2]
 // -> [1, 2, 1, 2]
 // -> [1, 2, 2, 1]
 // -> [2, 1, 1, 2]
 // -> [2, 1, 2, 1]
 // -> [2, 2, 1, 1]
 }

 <p><i>Notes:</i> This is an implementation of the algorithm for Lexicographical Permutations
 Generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7,
 Section 7.2.1.2. The iteration order follows the lexicographical order. This means that the
 first permutation will be in ascending order, and the last will be in descending order.

 <p>Elements that compare equal are considered equal and no new permutations are created by
 swapping them.

 <p>An empty iterable has only one permutation, which is an empty list.

 @param elements the original iterable whose elements have to be permuted.
 @param comparator a comparator for the iterable's elements.
 @return an immutable {@link Collection} containing all the different permutations of the
     original iterable.
 @throws NullPointerException If the specified iterable is null, has any null elements, or if
     the specified comparator is null.
 @since 12.0]]>
      </doc>
    </method>
    <method name="permutations" return="java.util.Collection&lt;java.util.List&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collection} of all the permutations of the specified {@link Collection}.

 <p><i>Notes:</i> This is an implementation of the Plain Changes algorithm for permutations
 generation, described in Knuth's "The Art of Computer Programming", Volume 4, Chapter 7,
 Section 7.2.1.2.

 <p>If the input list contains equal elements, some of the generated permutations will be equal.

 <p>An empty collection has only one permutation, which is an empty list.

 @param elements the original collection whose elements have to be permuted.
 @return an immutable {@link Collection} containing all the different permutations of the
     original collection.
 @throws NullPointerException if the specified collection is null or has any null elements.
 @since 12.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods for working with {@code Collection} instances.

 <p><b>Java 8+ users:</b> several common uses for this class are now more comprehensively
 addressed by the new {@link java.util.stream.Stream} library. Read the method documentation below
 for comparisons. These methods are not being deprecated, but we gently encourage you to migrate
 to streams.

 @author Chris Povirk
 @author Mike Bostock
 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Collections2 -->
  <!-- start class com.google.common.collect.Comparators -->
  <class name="Comparators" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="lexicographical" return="java.util.Comparator&lt;java.lang.Iterable&lt;S&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new comparator which sorts iterables by comparing corresponding elements pairwise
 until a nonzero result is found; imposes "dictionary order." If the end of one iterable is
 reached, but not the other, the shorter iterable is considered to be less than the longer one.
 For example, a lexicographical natural ordering over integers considers {@code [] < [1] < [1,
 1] < [1, 2] < [2]}.

 <p>Note that {@code Collections.reverseOrder(lexicographical(comparator))} is not equivalent to
 {@code lexicographical(Collections.reverseOrder(comparator))} (consider how each would order
 {@code [1]} and {@code [1, 1]}).]]>
      </doc>
    </method>
    <method name="isInOrder" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is greater than or
 equal to the element that preceded it, according to the specified comparator. Note that this is
 always true when the iterable has fewer than two elements.]]>
      </doc>
    </method>
    <method name="isInStrictOrder" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is <i>strictly</i>
 greater than the element that preceded it, according to the specified comparator. Note that
 this is always true when the iterable has fewer than two elements.]]>
      </doc>
    </method>
    <method name="least" return="java.util.stream.Collector&lt;T, ?, java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="int"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that returns the {@code k} smallest (relative to the specified
 {@code Comparator}) input elements, in ascending order, as an unmodifiable {@code List}. Ties
 are broken arbitrarily.

 <p>For example:

 {@snippet :
 Stream.of("foo", "quux", "banana", "elephant")
     .collect(least(2, comparingInt(String::length)))
 // returns {"foo", "quux"}
 }

 <p>This {@code Collector} uses O(k) memory and takes expected time O(n) (worst-case O(n log
 k)), as opposed to e.g. {@code Stream.sorted(comparator).limit(k)}, which currently takes O(n
 log n) time and O(n) space.

 @throws IllegalArgumentException if {@code k < 0}
 @since 33.2.0 (available since 22.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="greatest" return="java.util.stream.Collector&lt;T, ?, java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="int"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that returns the {@code k} greatest (relative to the specified
 {@code Comparator}) input elements, in descending order, as an unmodifiable {@code List}. Ties
 are broken arbitrarily.

 <p>For example:

 {@snippet :
 Stream.of("foo", "quux", "banana", "elephant")
     .collect(greatest(2, comparingInt(String::length)))
 // returns {"elephant", "banana"}
 }

 <p>This {@code Collector} uses O(k) memory and takes expected time O(n) (worst-case O(n log
 k)), as opposed to e.g. {@code Stream.sorted(comparator.reversed()).limit(k)}, which currently
 takes O(n log n) time and O(n) space.

 @throws IllegalArgumentException if {@code k < 0}
 @since 33.2.0 (available since 22.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="emptiesFirst" return="java.util.Comparator&lt;java.util.Optional&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a comparator of {@link Optional} values which treats {@link Optional#empty} as less
 than all other values, and orders the rest using {@code valueComparator} on the contained
 value.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="emptiesLast" return="java.util.Comparator&lt;java.util.Optional&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a comparator of {@link Optional} values which treats {@link Optional#empty} as greater
 than all other values, and orders the rest using {@code valueComparator} on the contained
 value.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="min" return="T extends java.lang.Comparable&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="T extends java.lang.Comparable&lt;? super T&gt;"/>
      <param name="b" type="T extends java.lang.Comparable&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the minimum of the two values. If the values compare as 0, the first is returned.

 <p>The recommended solution for finding the {@code minimum} of some values depends on the type
 of your data and the number of elements you have. Read more in the Guava User Guide article on
 <a href="https://github.com/google/guava/wiki/CollectionUtilitiesExplained#comparators">{@code
 Comparators}</a>.

 @param a first value to compare, returned if less than or equal to b.
 @param b second value to compare.
 @throws ClassCastException if the parameters are not <i>mutually comparable</i>.
 @since 30.0]]>
      </doc>
    </method>
    <method name="min" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="T extends java.lang.Object"/>
      <param name="b" type="T extends java.lang.Object"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the minimum of the two values, according to the given comparator. If the values compare
 as equal, the first is returned.

 <p>The recommended solution for finding the {@code minimum} of some values depends on the type
 of your data and the number of elements you have. Read more in the Guava User Guide article on
 <a href="https://github.com/google/guava/wiki/CollectionUtilitiesExplained#comparators">{@code
 Comparators}</a>.

 @param a first value to compare, returned if less than or equal to b
 @param b second value to compare.
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> using the given
     comparator.
 @since 30.0]]>
      </doc>
    </method>
    <method name="max" return="T extends java.lang.Comparable&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="T extends java.lang.Comparable&lt;? super T&gt;"/>
      <param name="b" type="T extends java.lang.Comparable&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the maximum of the two values. If the values compare as 0, the first is returned.

 <p>The recommended solution for finding the {@code maximum} of some values depends on the type
 of your data and the number of elements you have. Read more in the Guava User Guide article on
 <a href="https://github.com/google/guava/wiki/CollectionUtilitiesExplained#comparators">{@code
 Comparators}</a>.

 @param a first value to compare, returned if greater than or equal to b.
 @param b second value to compare.
 @throws ClassCastException if the parameters are not <i>mutually comparable</i>.
 @since 30.0]]>
      </doc>
    </method>
    <method name="max" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="T extends java.lang.Object"/>
      <param name="b" type="T extends java.lang.Object"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the maximum of the two values, according to the given comparator. If the values compare
 as equal, the first is returned.

 <p>The recommended solution for finding the {@code maximum} of some values depends on the type
 of your data and the number of elements you have. Read more in the Guava User Guide article on
 <a href="https://github.com/google/guava/wiki/CollectionUtilitiesExplained#comparators">{@code
 Comparators}</a>.

 @param a first value to compare, returned if greater than or equal to b.
 @param b second value to compare.
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> using the given
     comparator.
 @since 30.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods for working with {@link Comparator} instances. For many other helpful
 comparator utilities, see either {@code Comparator} itself (for Java 8+), or {@code
 com.google.common.collect.Ordering} (otherwise).

 <h3>Relationship to {@code Ordering}</h3>

 <p>In light of the significant enhancements to {@code Comparator} in Java 8, the overwhelming
 majority of usages of {@code Ordering} can be written using only built-in JDK APIs. This class is
 intended to "fill the gap" and provide those features of {@code Ordering} not already provided by
 the JDK.

 @since 21.0
 @author Louis Wasserman]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Comparators -->
  <!-- start class com.google.common.collect.ComparisonChain -->
  <class name="ComparisonChain" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start" return="com.google.common.collect.ComparisonChain"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Begins a new chained comparison statement. See example in the class documentation.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.lang.Comparable&lt;?&gt;"/>
      <param name="right" type="java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Compares two comparable objects as specified by {@link Comparable#compareTo}, <i>if</i> the
 result of this comparison chain has not already been determined.

 <p>This method is declared to accept any 2 {@code Comparable} objects, even if they are not <a
 href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">mutually
 comparable</a>. If you pass objects that are not mutually comparable, this method may throw an
 exception. (The reason for this decision is lost to time, but the reason <i>might</i> be that
 we wanted to support legacy classes that implement the raw type {@code Comparable} (instead of
 implementing {@code Comparable<Foo>}) without producing warnings. If so, we would prefer today
 to produce warnings in that case, and we may change this method to do so in the future. Support
 for raw {@code Comparable} types in Guava in general is tracked as <a
 href="https://github.com/google/guava/issues/989">#989</a>.)

 @throws ClassCastException if the parameters are not mutually comparable]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="T extends java.lang.Object"/>
      <param name="right" type="T extends java.lang.Object"/>
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Compares two objects using a comparator, <i>if</i> the result of this comparison chain has not
 already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="int"/>
      <param name="right" type="int"/>
      <doc>
      <![CDATA[Compares two {@code int} values as specified by {@link Integer#compare}, <i>if</i> the result
 of this comparison chain has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="long"/>
      <param name="right" type="long"/>
      <doc>
      <![CDATA[Compares two {@code long} values as specified by {@link Long#compare}, <i>if</i> the result of
 this comparison chain has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="float"/>
      <param name="right" type="float"/>
      <doc>
      <![CDATA[Compares two {@code float} values as specified by {@link Float#compare}, <i>if</i> the result
 of this comparison chain has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="double"/>
      <param name="right" type="double"/>
      <doc>
      <![CDATA[Compares two {@code double} values as specified by {@link Double#compare}, <i>if</i> the result
 of this comparison chain has not already been determined.]]>
      </doc>
    </method>
    <method name="compare" return="com.google.common.collect.ComparisonChain"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Use {@link #compareFalseFirst}; or, if the parameters passed are being either
     negated or reversed, undo the negation or reversal and use {@link #compareTrueFirst}.">
      <param name="left" type="java.lang.Boolean"/>
      <param name="right" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[Discouraged synonym for {@link #compareFalseFirst}.

 @deprecated Use {@link #compareFalseFirst}; or, if the parameters passed are being either
     negated or reversed, undo the negation or reversal and use {@link #compareTrueFirst}.
 @since 19.0]]>
      </doc>
    </method>
    <method name="compareTrueFirst" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="boolean"/>
      <param name="right" type="boolean"/>
      <doc>
      <![CDATA[Compares two {@code boolean} values, considering {@code true} to be less than {@code false},
 <i>if</i> the result of this comparison chain has not already been determined.

 @since 12.0]]>
      </doc>
    </method>
    <method name="compareFalseFirst" return="com.google.common.collect.ComparisonChain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="boolean"/>
      <param name="right" type="boolean"/>
      <doc>
      <![CDATA[Compares two {@code boolean} values, considering {@code false} to be less than {@code true},
 <i>if</i> the result of this comparison chain has not already been determined.

 @since 12.0 (present as {@code compare} since 2.0)]]>
      </doc>
    </method>
    <method name="result" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ends this comparison chain and returns its result: a value having the same sign as the first
 nonzero comparison result in the chain, or zero if every result was zero.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A utility for performing a chained comparison statement. For example:

 {@snippet :
 public int compareTo(Foo that) {
   return ComparisonChain.start()
       .compare(this.aString, that.aString)
       .compare(this.anInt, that.anInt)
       .compare(this.anEnum, that.anEnum, Ordering.natural().nullsLast())
       .result();
 }
 }

 <p>The value of this expression will have the same sign as the <i>first nonzero</i> comparison
 result in the chain, or will be zero if every comparison result was zero.

 <p><b>Note:</b> {@code ComparisonChain} instances are <b>immutable</b>. For this utility to work
 correctly, calls must be chained as illustrated above.

 <p>Performance note: Even though the {@code ComparisonChain} caller always invokes its {@code
 compare} methods unconditionally, the {@code ComparisonChain} implementation stops calling its
 inputs' {@link Comparable#compareTo compareTo} and {@link Comparator#compare compare} methods as
 soon as one of them returns a nonzero result. This optimization is typically important only in
 the presence of expensive {@code compareTo} and {@code compare} implementations.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained#comparecompareto">{@code
 ComparisonChain}</a>.

 <h4 id="java8">Java 8+ equivalents</h4>

 If you are using Java version 8 or greater, you should generally use the static methods in {@link
 Comparator} instead of {@code ComparisonChain}. The example above can be implemented like this:

 {@snippet :
 import static java.util.Comparator.comparing;
 import static java.util.Comparator.nullsLast;
 import static java.util.Comparator.naturalOrder;

 ...
   private static final Comparator<Foo> COMPARATOR =
       comparing((Foo foo) -> foo.aString)
           .thenComparing(foo -> foo.anInt)
           .thenComparing(foo -> foo.anEnum, nullsLast(naturalOrder()));

   @Override
   public int compareTo(Foo that) {
     return COMPARATOR.compare(this, that);
   }
 }

 <p>With method references it is more succinct: {@code comparing(Foo::aString)} for example.

 <p>Using {@link Comparator} avoids certain types of bugs, for example when you meant to write
 {@code .compare(a.foo, b.foo)} but you actually wrote {@code .compare(a.foo, a.foo)} or {@code
 .compare(a.foo, b.bar)}. {@code ComparisonChain} also has a potential performance problem that
 {@code Comparator} doesn't: it evaluates all the parameters of all the {@code .compare} calls,
 even when the result of the comparison is already known from previous {@code .compare} calls.
 That can be expensive.

 @author Mark Davis
 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ComparisonChain -->
  <!-- start class com.google.common.collect.ComputationException -->
  <class name="ComputationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="This exception is no longer thrown by {@code com.google.common}. Previously, it was
     thrown by {@link MapMaker} computing maps. When support for computing maps was removed from
     {@code MapMaker}, it was added to {@code CacheBuilder}, which throws {@code
     ExecutionException}, {@code UncheckedExecutionException}, and {@code ExecutionError}. Any
     code that is still catching {@code ComputationException} may need to be updated to catch some
     of those types instead. (Note that this type, though deprecated, is not planned to be removed
     from Guava.)">
    <constructor name="ComputationException" type="Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given cause.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Wraps an exception that occurred during a computation.

 @author Bob Lee
 @since 2.0
 @deprecated This exception is no longer thrown by {@code com.google.common}. Previously, it was
     thrown by {@link MapMaker} computing maps. When support for computing maps was removed from
     {@code MapMaker}, it was added to {@code CacheBuilder}, which throws {@code
     ExecutionException}, {@code UncheckedExecutionException}, and {@code ExecutionError}. Any
     code that is still catching {@code ComputationException} may need to be updated to catch some
     of those types instead. (Note that this type, though deprecated, is not planned to be removed
     from Guava.)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ComputationException -->
  <!-- start class com.google.common.collect.ConcurrentHashMultiset -->
  <class name="ConcurrentHashMultiset" extends="com.google.common.collect.AbstractMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code ConcurrentHashMultiset} using the default initial capacity, load
 factor, and concurrency settings.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ConcurrentHashMultiset} containing the specified elements, using the
 default initial capacity, load factor, and concurrency settings.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.ConcurrentHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="countMap" type="java.util.concurrent.ConcurrentMap&lt;E, java.util.concurrent.atomic.AtomicInteger&gt;"/>
      <doc>
      <![CDATA[Creates a new, empty {@code ConcurrentHashMultiset} using {@code countMap} as the internal
 backing map.

 <p>This instance will assume ownership of {@code countMap}, and other code should not maintain
 references to the map or modify it in any way.

 <p>The returned multiset is serializable if the input map is.

 @param countMap backing map for storing the elements in the multiset and their counts. It must
     be empty.
 @throws IllegalArgumentException if {@code countMap} is not empty
 @since 20.0]]>
      </doc>
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Returns the number of occurrences of {@code element} in this multiset.

 @param element the element to look for
 @return the nonnegative number of occurrences of the element]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If the data in the multiset is modified by any other threads during this method, it is
 undefined which (if any) of these modifications will be reflected in the result.]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of the specified element to this multiset.

 @param element the element to add
 @param occurrences the number of occurrences to add
 @return the previous count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative, or if the resulting amount
     would exceed {@link Integer#MAX_VALUE}]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes a number of occurrences of the specified element from this multiset. If the multiset
 contains fewer than this number of occurrences to begin with, all occurrences will be removed.

 @param element the element whose occurrences should be removed
 @param occurrences the number of occurrences of the element to remove
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative]]>
      </doc>
    </method>
    <method name="removeExactly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes exactly the specified number of occurrences of {@code element}, or makes no change if
 this is not possible.

 <p>This method, in contrast to {@link #remove(Object, int)}, has no effect when the element
 count is smaller than {@code occurrences}.

 @param element the element to remove
 @param occurrences the number of occurrences of {@code element} to remove
 @return {@code true} if the removal was possible (including if {@code occurrences} is zero)
 @throws IllegalArgumentException if {@code occurrences} is negative]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes occurrences of {@code element} such that the {@link #count} of the element
 becomes {@code count}.

 @return the count of {@code element} in the multiset before this call
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="expectedOldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Sets the number of occurrences of {@code element} to {@code newCount}, but only if the count is
 currently {@code expectedOldCount}. If {@code element} does not appear in the multiset exactly
 {@code expectedOldCount} times, no changes will be made.

 @return {@code true} if the change was successful. This usually indicates that the multiset has
     been modified, but not always: in the case that {@code expectedOldCount == newCount}, the
     method will return {@code true} if the condition was met.
 @throws IllegalArgumentException if {@code expectedOldCount} or {@code newCount} is negative]]>
      </doc>
    </method>
    <method name="createEntrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Internal method, use {@link #entrySet()}.">
      <doc>
      <![CDATA[@deprecated Internal method, use {@link #entrySet()}.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A multiset that supports concurrent modifications and that provides atomic versions of most
 {@code Multiset} operations (exceptions where noted). Null elements are not supported.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset">{@code Multiset}</a>.

 @author Cliff L. Biffle
 @author mike nonemacher
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ConcurrentHashMultiset -->
  <!-- start class com.google.common.collect.ContiguousSet -->
  <class name="ContiguousSet" extends="com.google.common.collect.ImmutableSortedSet&lt;C&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <param name="domain" type="com.google.common.collect.DiscreteDomain&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a {@code ContiguousSet} containing the same values in the given domain {@linkplain
 Range#contains contained} by the range.

 @throws IllegalArgumentException if neither range nor the domain has a lower bound, or if
     neither has an upper bound
 @since 13.0]]>
      </doc>
    </method>
    <method name="closed" return="com.google.common.collect.ContiguousSet&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="int"/>
      <param name="upper" type="int"/>
      <doc>
      <![CDATA[Returns a nonempty contiguous set containing all {@code int} values from {@code lower}
 (inclusive) to {@code upper} (inclusive). (These are the same values contained in {@code
 Range.closed(lower, upper)}.)

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @since 23.0]]>
      </doc>
    </method>
    <method name="closed" return="com.google.common.collect.ContiguousSet&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="long"/>
      <param name="upper" type="long"/>
      <doc>
      <![CDATA[Returns a nonempty contiguous set containing all {@code long} values from {@code lower}
 (inclusive) to {@code upper} (inclusive). (These are the same values contained in {@code
 Range.closed(lower, upper)}.)

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @since 23.0]]>
      </doc>
    </method>
    <method name="closedOpen" return="com.google.common.collect.ContiguousSet&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="int"/>
      <param name="upper" type="int"/>
      <doc>
      <![CDATA[Returns a contiguous set containing all {@code int} values from {@code lower} (inclusive) to
 {@code upper} (exclusive). If the endpoints are equal, an empty set is returned. (These are the
 same values contained in {@code Range.closedOpen(lower, upper)}.)

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @since 23.0]]>
      </doc>
    </method>
    <method name="closedOpen" return="com.google.common.collect.ContiguousSet&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="long"/>
      <param name="upper" type="long"/>
      <doc>
      <![CDATA[Returns a contiguous set containing all {@code long} values from {@code lower} (inclusive) to
 {@code upper} (exclusive). If the endpoints are equal, an empty set is returned. (These are the
 same values contained in {@code Range.closedOpen(lower, upper)}.)

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @since 23.0]]>
      </doc>
    </method>
    <method name="headSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="C extends java.lang.Comparable"/>
    </method>
    <method name="headSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="C extends java.lang.Comparable"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="subSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
      <param name="toElement" type="C extends java.lang.Comparable"/>
    </method>
    <method name="subSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="C extends java.lang.Comparable"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="tailSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
    </method>
    <method name="tailSet" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="C extends java.lang.Comparable"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.ContiguousSet&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.ContiguousSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the set of values that are contained in both this set and the other.

 <p>This method should always be used instead of {@link Sets#intersection} for {@link
 ContiguousSet} instances.]]>
      </doc>
    </method>
    <method name="range" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a range, closed on both ends, whose endpoints are the minimum and maximum values
 contained in this set. This is equivalent to {@code range(CLOSED, CLOSED)}.

 @throws NoSuchElementException if this set is empty]]>
      </doc>
    </method>
    <method name="range" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns the minimal range with the given boundary types for which all values in this set are
 {@linkplain Range#contains(Comparable) contained} within the range.

 <p>Note that this method will return ranges with unbounded endpoints if {@link BoundType#OPEN}
 is requested for a domain minimum or maximum. For example, if {@code set} was created from the
 range {@code [1..Integer.MAX_VALUE]} then {@code set.range(CLOSED, OPEN)} must return {@code
 [1..#)}.

 @throws NoSuchElementException if this set is empty]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a shorthand representation of the contents such as {@code "[1..100]"}.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #create}.">
      <doc>
      <![CDATA[Not supported. {@code ContiguousSet} instances are constructed with {@link #create}. This
 method exists only to hide {@link ImmutableSet#builder} from consumers of {@code
 ContiguousSet}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link #create}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A sorted set of contiguous values in a given {@link DiscreteDomain}. Example:

 {@snippet :
 ContiguousSet.create(Range.closed(5, 42), DiscreteDomain.integers())
 }

 <p>Note that because bounded ranges over {@code int} and {@code long} values are so common, this
 particular example can be written as just:

 {@snippet :
 ContiguousSet.closed(5, 42)
 }

 <p><b>Warning:</b> Be extremely careful what you do with conceptually large instances (such as
 {@code ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers()}). Certain operations
 on such a set can be performed efficiently, but others (such as {@link Set#hashCode} or {@link
 Collections#frequency}) can cause major performance problems.

 @author Gregory Kick
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ContiguousSet -->
  <!-- start class com.google.common.collect.DiscreteDomain -->
  <class name="DiscreteDomain" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiscreteDomain"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="integers" return="com.google.common.collect.DiscreteDomain&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the discrete domain for values of type {@code Integer}.

 <p>This method always returns the same object. That object is serializable; deserializing it
 results in the same object too.

 @since 14.0 (since 10.0 as {@code DiscreteDomains.integers()})]]>
      </doc>
    </method>
    <method name="longs" return="com.google.common.collect.DiscreteDomain&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the discrete domain for values of type {@code Long}.

 <p>This method always returns the same object. That object is serializable; deserializing it
 results in the same object too.

 @since 14.0 (since 10.0 as {@code DiscreteDomains.longs()})]]>
      </doc>
    </method>
    <method name="bigIntegers" return="com.google.common.collect.DiscreteDomain&lt;java.math.BigInteger&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the discrete domain for values of type {@code BigInteger}.

 <p>This method always returns the same object. That object is serializable; deserializing it
 results in the same object too.

 @since 15.0]]>
      </doc>
    </method>
    <method name="next" return="C"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns the unique least value of type {@code C} that is greater than {@code value}, or {@code
 null} if none exists. Inverse operation to {@link #previous}.

 @param value any value of type {@code C}
 @return the least value greater than {@code value}, or {@code null} if {@code value} is {@code
     maxValue()}]]>
      </doc>
    </method>
    <method name="previous" return="C"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns the unique greatest value of type {@code C} that is less than {@code value}, or {@code
 null} if none exists. Inverse operation to {@link #next}.

 @param value any value of type {@code C}
 @return the greatest value less than {@code value}, or {@code null} if {@code value} is {@code
     minValue()}]]>
      </doc>
    </method>
    <method name="distance" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="C extends java.lang.Comparable"/>
      <param name="end" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns a signed value indicating how many nested invocations of {@link #next} (if positive) or
 {@link #previous} (if negative) are needed to reach {@code end} starting from {@code start}.
 For example, if {@code end = next(next(next(start)))}, then {@code distance(start, end) == 3}
 and {@code distance(end, start) == -3}. As well, {@code distance(a, a)} is always zero.

 <p>Note that this function is necessarily well-defined for any discrete type.

 @return the distance as described above, or {@link Long#MIN_VALUE} or {@link Long#MAX_VALUE} if
     the distance is too small or too large, respectively.]]>
      </doc>
    </method>
    <method name="minValue" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the minimum value of type {@code C}, if it has one. The minimum value is the unique
 value for which {@link Comparable#compareTo(Object)} never returns a positive value for any
 input of type {@code C}.

 <p>The default implementation throws {@code NoSuchElementException}.

 @return the minimum value of type {@code C}; never null
 @throws NoSuchElementException if the type has no (practical) minimum value; for example,
     {@link java.math.BigInteger}]]>
      </doc>
    </method>
    <method name="maxValue" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the maximum value of type {@code C}, if it has one. The maximum value is the unique
 value for which {@link Comparable#compareTo(Object)} never returns a negative value for any
 input of type {@code C}.

 <p>The default implementation throws {@code NoSuchElementException}.

 @return the maximum value of type {@code C}; never null
 @throws NoSuchElementException if the type has no (practical) maximum value; for example,
     {@link java.math.BigInteger}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A descriptor for a <i>discrete</i> {@code Comparable} domain such as all {@link Integer}
 instances. A discrete domain is one that supports the three basic operations: {@link #next},
 {@link #previous} and {@link #distance}, according to their specifications. The methods {@link
 #minValue} and {@link #maxValue} should also be overridden for bounded types.

 <p>A discrete domain always represents the <i>entire</i> set of values of its type; it cannot
 represent partial domains such as "prime integers" or "strings of length 5."

 <p>See the Guava User Guide section on <a href=
 "https://github.com/google/guava/wiki/RangesExplained#discrete-domains">{@code
 DiscreteDomain}</a>.

 @author Kevin Bourrillion
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.DiscreteDomain -->
  <!-- start class com.google.common.collect.EnumBiMap -->
  <class name="EnumBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new, empty {@code EnumBiMap} using the specified key and value types.

 @param keyType the key type
 @param valueType the value type]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a new bimap with the same mappings as the specified map. If the specified map is an
 {@code EnumBiMap}, the new bimap has the same types as the provided map. Otherwise, the
 specified map must contain at least one mapping, in order to determine the key and value types.

 @param map the map whose mappings are to be placed in this map
 @throws IllegalArgumentException if map is not an {@code EnumBiMap} instance and contains no
     mappings]]>
      </doc>
    </method>
    <method name="keyType" return="java.lang.Class&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated key type.]]>
      </doc>
    </method>
    <method name="valueType" return="java.lang.Class&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated value type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code BiMap} backed by two {@code EnumMap} instances. Null keys and values are not permitted.
 An {@code EnumBiMap} and its inverse are both serializable.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap">{@code BiMap}</a>.

 @author Mike Bostock
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumBiMap -->
  <!-- start class com.google.common.collect.EnumHashBiMap -->
  <class name="EnumHashBiMap" extends="com.google.common.collect.AbstractBiMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.EnumHashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a new, empty {@code EnumHashBiMap} using the specified key type.

 @param keyType the key type]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumHashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a new bimap with the same mappings as the specified map. If the specified map is an
 {@code EnumHashBiMap} or an {@link EnumBiMap}, the new bimap has the same key type as the input
 bimap. Otherwise, the specified map must contain at least one mapping, in order to determine
 the key type.

 @param map the map whose mappings are to be placed in this map
 @throws IllegalArgumentException if map is not an {@code EnumBiMap} or an {@code EnumHashBiMap}
     instance and contains no mappings]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Enum&lt;K&gt;"/>
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Enum&lt;K&gt;"/>
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="keyType" return="java.lang.Class&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the associated key type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code BiMap} backed by an {@code EnumMap} instance for keys-to-values, and a {@code HashMap}
 instance for values-to-keys. Null keys are not permitted, but null values are. An {@code
 EnumHashBiMap} and its inverse are both serializable.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap">{@code BiMap}</a>.

 @author Mike Bostock
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumHashBiMap -->
  <!-- start class com.google.common.collect.EnumMultiset -->
  <class name="EnumMultiset" extends="com.google.common.collect.AbstractMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.EnumMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code EnumMultiset}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code EnumMultiset} containing the specified elements.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.

 @param elements the elements that the multiset should contain
 @throws IllegalArgumentException if {@code elements} is empty]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.EnumMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code EnumMultiset} instance containing the given elements. Unlike {@link
 EnumMultiset#create(Iterable)}, this method does not produce an exception on an empty iterable.

 @since 14.0]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="count" type="int"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Multiset implementation specialized for enum elements, supporting all single-element operations
 in O(1).

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset">{@code Multiset}</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EnumMultiset -->
  <!-- start class com.google.common.collect.EvictingQueue -->
  <class name="EvictingQueue" extends="com.google.common.collect.ForwardingQueue&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.EvictingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxSize" type="int"/>
      <doc>
      <![CDATA[Creates and returns a new evicting queue that will hold up to {@code maxSize} elements.

 <p>When {@code maxSize} is zero, elements will be evicted immediately after being added to the
 queue.]]>
      </doc>
    </method>
    <method name="remainingCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of additional elements that this queue can accept without evicting; zero if
 the queue is currently full.

 @since 16.0]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Queue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[Adds the given element to this queue. If the queue is currently full, the element at the head
 of the queue is evicted to make room.

 @return {@code true} always]]>
      </doc>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[Adds the given element to this queue. If the queue is currently full, the element at the head
 of the queue is evicted to make room.

 @return {@code true} always]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A non-blocking queue which automatically evicts elements from the head of the queue when
 attempting to add new elements onto the queue and it is full. This queue orders elements FIFO
 (first-in-first-out). This data structure is logically equivalent to a circular buffer (i.e.,
 cyclic buffer or ring buffer).

 <p>An evicting queue must be configured with a maximum size. Each time an element is added to a
 full queue, the queue automatically removes its head element. This is different from conventional
 bounded queues, which either block or reject new elements when full.

 <p>This class is not thread-safe, and does not accept null elements.

 @author Kurt Alfred Kluever
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.EvictingQueue -->
  <!-- start class com.google.common.collect.FluentIterable -->
  <class name="FluentIterable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;E&gt;"/>
    <constructor name="FluentIterable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="from" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that wraps {@code iterable}, or {@code iterable} itself if it is
 already a {@code FluentIterable}.

 <p><b>{@code Stream} equivalent:</b> {@code iterable.stream()} if {@code iterable} is a {@link
 Collection}; {@code StreamSupport.stream(iterable.spliterator(), false)} otherwise.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns a fluent iterable containing {@code elements} in the specified order.

 <p>The returned iterable is an unmodifiable view of the input array.

 <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#of(Object[])
 Stream.of(T...)}.

 @since 20.0 (since 18.0 as an overload of {@code of})]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="instances of {@code FluentIterable} don't need to be converted to {@code
     FluentIterable}">
      <param name="iterable" type="com.google.common.collect.FluentIterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Construct a fluent iterable from another fluent iterable. This is obviously never necessary,
 but is intended to help call out cases where one migration from {@code Iterable} to {@code
 FluentIterable} has obviated the need to explicitly convert to a {@code FluentIterable}.

 @deprecated instances of {@code FluentIterable} don't need to be converted to {@code
     FluentIterable}]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that combines two iterables. The returned iterable has an iterator
 that traverses the elements in {@code a}, followed by the elements in {@code b}. The source
 iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#concat}.

 @since 20.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that combines three iterables. The returned iterable has an iterator
 that traverses the elements in {@code a}, followed by the elements in {@code b}, followed by
 the elements in {@code c}. The source iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>{@code Stream} equivalent:</b> use nested calls to {@link Stream#concat}, or see the
 advice in {@link #concat(Iterable...)}.

 @since 20.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="d" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that combines four iterables. The returned iterable has an iterator
 that traverses the elements in {@code a}, followed by the elements in {@code b}, followed by
 the elements in {@code c}, followed by the elements in {@code d}. The source iterators are not
 polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>{@code Stream} equivalent:</b> use nested calls to {@link Stream#concat}, or see the
 advice in {@link #concat(Iterable...)}.

 @since 20.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable[]"/>
      <doc>
      <![CDATA[Returns a fluent iterable that combines several iterables. The returned iterable has an
 iterator that traverses the elements of each iterable in {@code inputs}. The input iterators
 are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>{@code Stream} equivalent:</b> to concatenate an arbitrary number of streams, use {@code
 Stream.of(stream1, stream2, ...).flatMap(s -> s)}. If the sources are iterables, use {@code
 Stream.of(iter1, iter2, ...).flatMap(Streams::stream)}.

 @throws NullPointerException if any of the provided iterables is {@code null}
 @since 20.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable&lt;? extends java.lang.Iterable&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that combines several iterables. The returned iterable has an
 iterator that traverses the elements of each iterable in {@code inputs}. The input iterators
 are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it. The methods of the returned iterable may throw {@code
 NullPointerException} if any of the input iterators is {@code null}.

 <p><b>{@code Stream} equivalent:</b> {@code streamOfStreams.flatMap(s -> s)} or {@code
 streamOfIterables.flatMap(Streams::stream)}. (See {@link Streams#stream}.)

 @since 20.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a fluent iterable containing no elements.

 <p><b>{@code Stream} equivalent:</b> {@code Stream.empty()}.

 @since 20.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns a fluent iterable containing the specified elements in order.

 <p><b>{@code Stream} equivalent:</b> {@link java.util.stream.Stream#of(Object[])
 Stream.of(T...)}.

 @since 20.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this fluent iterable, with the format {@code [e1, e2, ...,
 en]}.

 <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.joining(", ", "[", "]"))}
 or (less efficiently) {@code stream.collect(Collectors.toList()).toString()}.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of elements in this fluent iterable.

 <p><b>{@code Stream} equivalent:</b> {@code stream.count()}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if this fluent iterable contains any object for which {@code
 equals(target)} is true.

 <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}.]]>
      </doc>
    </method>
    <method name="cycle" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a fluent iterable whose {@code Iterator} cycles indefinitely over the elements of this
 fluent iterable.

 <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code
 remove()} is called, subsequent cycles omit the removed element, which is no longer in this
 fluent iterable. The iterator's {@code hasNext()} method returns {@code true} until this fluent
 iterable is empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You
 should use an explicit {@code break} or be certain that you will eventually remove all the
 elements.

 <p><b>{@code Stream} equivalent:</b> if the source iterable has only a single element {@code
 e}, use {@code Stream.generate(() -> e)}. Otherwise, collect your stream into a collection and
 use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.]]>
      </doc>
    </method>
    <method name="append" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,
 followed by those of {@code other}. The iterators are not polled until necessary.

 <p>The returned iterable's {@code Iterator} supports {@code remove()} when the corresponding
 {@code Iterator} supports it.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#concat}.

 @since 18.0]]>
      </doc>
    </method>
    <method name="append" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns a fluent iterable whose iterators traverse first the elements of this fluent iterable,
 followed by {@code elements}.

 <p><b>{@code Stream} equivalent:</b> {@code Stream.concat(thisStream, Stream.of(elements))}.

 @since 18.0]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements from this fluent iterable that satisfy a predicate. The resulting fluent
 iterable's iterator does not support {@code remove()}.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#filter} (same).]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the elements from this fluent iterable that are instances of class {@code type}.

 <p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.
 This does perform a little more work than necessary, so another option is to insert an
 unchecked cast at some later point:

 {@snippet :
 @SuppressWarnings("unchecked") // safe because of ::isInstance check
 ImmutableList<NewType> result =
     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());
 }]]>
      </doc>
    </method>
    <method name="anyMatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if any element in this fluent iterable satisfies the predicate.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch} (same).]]>
      </doc>
    </method>
    <method name="allMatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element in this fluent iterable satisfies the predicate. If this
 fluent iterable is empty, {@code true} is returned.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch} (same).]]>
      </doc>
    </method>
    <method name="firstMatch" return="com.google.common.base.Optional&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in this fluent iterable that satisfies
 the given predicate, if such an element exists.

 <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}
 is matched in this fluent iterable, a {@link NullPointerException} will be thrown.

 <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}.]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super E, T&gt;"/>
      <doc>
      <![CDATA[Returns a fluent iterable that applies {@code function} to each element of this fluent
 iterable.

 <p>The returned fluent iterable's iterator supports {@code remove()} if this iterable's
 iterator does. After a successful {@code remove()} call, this fluent iterable no longer
 contains the corresponding element.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#map}.]]>
      </doc>
    </method>
    <method name="transformAndConcat" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super E, ? extends java.lang.Iterable&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Applies {@code function} to each element of this fluent iterable and returns a fluent iterable
 with the concatenated combination of results. {@code function} returns an Iterable of results.

 <p>The returned fluent iterable's iterator supports {@code remove()} if this function-returned
 iterables' iterator does. After a successful {@code remove()} call, the returned fluent
 iterable no longer contains the corresponding element.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#flatMap} (using a function that produces
 streams, not iterables).

 @since 13.0 (required {@code Function<E, Iterable<T>>} until 14.0)]]>
      </doc>
    </method>
    <method name="first" return="com.google.common.base.Optional&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in this fluent iterable. If the
 iterable is empty, {@code Optional.absent()} is returned.

 <p><b>{@code Stream} equivalent:</b> if the goal is to obtain any element, {@link
 Stream#findAny}; if it must specifically be the <i>first</i> element, {@code Stream#findFirst}.

 @throws NullPointerException if the first element is null; if this is a possibility, use {@code
     iterator().next()} or {@link Iterables#getFirst} instead.]]>
      </doc>
    </method>
    <method name="last" return="com.google.common.base.Optional&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Optional} containing the last element in this fluent iterable. If the
 iterable is empty, {@code Optional.absent()} is returned. If the underlying {@code iterable} is
 a {@link List} with {@link java.util.RandomAccess} support, then this operation is guaranteed
 to be {@code O(1)}.

 <p><b>{@code Stream} equivalent:</b> {@code stream.reduce((a, b) -> b)}.

 @throws NullPointerException if the last element is null; if this is a possibility, use {@link
     Iterables#getLast} instead.]]>
      </doc>
    </method>
    <method name="skip" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="numberToSkip" type="int"/>
      <doc>
      <![CDATA[Returns a view of this fluent iterable that skips its first {@code numberToSkip} elements. If
 this fluent iterable contains fewer than {@code numberToSkip} elements, the returned fluent
 iterable skips all of its elements.

 <p>Modifications to this fluent iterable before a call to {@code iterator()} are reflected in
 the returned fluent iterable. That is, the iterator skips the first {@code numberToSkip}
 elements that exist when the iterator is created, not when {@code skip()} is called.

 <p>The returned fluent iterable's iterator supports {@code remove()} if the {@code Iterator} of
 this fluent iterable supports it. Note that it is <i>not</i> possible to delete the last
 skipped element by immediately calling {@code remove()} on the returned fluent iterable's
 iterator, as the {@code Iterator} contract states that a call to {@code * remove()} before a
 call to {@code next()} will throw an {@link IllegalStateException}.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#skip} (same).]]>
      </doc>
    </method>
    <method name="limit" return="com.google.common.collect.FluentIterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="maxSize" type="int"/>
      <doc>
      <![CDATA[Creates a fluent iterable with the first {@code size} elements of this fluent iterable. If this
 fluent iterable does not contain that many elements, the returned fluent iterable will have the
 same behavior as this fluent iterable. The returned fluent iterable's iterator supports {@code
 remove()} if this fluent iterable's iterator does.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#limit} (same).

 @param maxSize the maximum number of elements in the returned fluent iterable
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines whether this fluent iterable is empty.

 <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}.]]>
      </doc>
    </method>
    <method name="toList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableList} containing all of the elements from this fluent iterable in
 proper sequence.

 <p><b>{@code Stream} equivalent:</b> {@code ImmutableList.copyOf(stream.iterator())}, or pass
 {@link ImmutableList#toImmutableList} to {@code stream.collect()}.

 @throws NullPointerException if any element is {@code null}
 @since 14.0 (since 12.0 as {@code toImmutableList()}).]]>
      </doc>
    </method>
    <method name="toSortedList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an {@code ImmutableList} containing all of the elements from this {@code
 FluentIterable} in the order specified by {@code comparator}. To produce an {@code
 ImmutableList} sorted by its natural ordering, use {@code toSortedList(Ordering.natural())}.

 <p><b>{@code Stream} equivalent:</b> {@code
 ImmutableList.copyOf(stream.sorted(comparator).iterator())}, or pass {@link
 ImmutableList#toImmutableList} to {@code stream.sorted(comparator).collect()}.

 @param comparator the function by which to sort list elements
 @throws NullPointerException if any element of this iterable is {@code null}
 @since 14.0 (since 13.0 as {@code toSortedImmutableList()}).]]>
      </doc>
    </method>
    <method name="toSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableSet} containing all of the elements from this fluent iterable with
 duplicates removed.

 <p><b>{@code Stream} equivalent:</b> {@code ImmutableSet.copyOf(stream.iterator())}, or pass
 {@link ImmutableSet#toImmutableSet} to {@code stream.collect()}.

 @throws NullPointerException if any element is {@code null}
 @since 14.0 (since 12.0 as {@code toImmutableSet()}).]]>
      </doc>
    </method>
    <method name="toSortedSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an {@code ImmutableSortedSet} containing all of the elements from this {@code
 FluentIterable} in the order specified by {@code comparator}, with duplicates (determined by
 {@code comparator.compare(x, y) == 0}) removed. To produce an {@code ImmutableSortedSet} sorted
 by its natural ordering, use {@code toSortedSet(Ordering.natural())}.

 <p><b>{@code Stream} equivalent:</b> {@code ImmutableSortedSet.copyOf(comparator,
 stream.iterator())}, or pass {@link ImmutableSortedSet#toImmutableSortedSet} to {@code
 stream.collect()}.

 @param comparator the function by which to sort set elements
 @throws NullPointerException if any element of this iterable is {@code null}
 @since 14.0 (since 12.0 as {@code toImmutableSortedSet()}).]]>
      </doc>
    </method>
    <method name="toMultiset" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableMultiset} containing all of the elements from this fluent iterable.

 <p><b>{@code Stream} equivalent:</b> {@code ImmutableMultiset.copyOf(stream.iterator())}, or
 pass {@link ImmutableMultiset#toImmutableMultiset} to {@code stream.collect()}.

 @throws NullPointerException if any element is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="toMap" return="com.google.common.collect.ImmutableMap&lt;E, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="valueFunction" type="com.google.common.base.Function&lt;? super E, V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map whose keys are the distinct elements of this {@code FluentIterable}
 and whose value for each key was computed by {@code valueFunction}. The map's iteration order
 is the order of the first appearance of each key in this iterable.

 <p>When there are multiple instances of a key in this iterable, it is unspecified whether
 {@code valueFunction} will be applied to more than one instance of that key and, if it is,
 which result will be mapped to that key in the returned map.

 <p><b>{@code Stream} equivalent:</b> use {@code stream.collect(ImmutableMap.toImmutableMap(k ->
 k, valueFunction))}. {@code ImmutableMap.copyOf(stream.collect(Collectors.toMap(k -> k,
 valueFunction)))} behaves similarly, but may not preserve the order of entries.

 @throws NullPointerException if any element of this iterable is {@code null}, or if {@code
     valueFunction} produces {@code null} for any key
 @since 14.0]]>
      </doc>
    </method>
    <method name="index" return="com.google.common.collect.ImmutableListMultimap&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super E, K&gt;"/>
      <doc>
      <![CDATA[Creates an index {@code ImmutableListMultimap} that contains the results of applying a
 specified function to each item in this {@code FluentIterable} of values. Each element of this
 iterable will be stored as a value in the resulting multimap, yielding a multimap with the same
 size as this iterable. The key used to store that value in the multimap will be the result of
 calling the function on that value. The resulting multimap is created as an immutable snapshot.
 In the returned multimap, keys appear in the order they are first encountered, and the values
 corresponding to each key appear in the same order as they are encountered.

 <p><b>{@code Stream} equivalent:</b> {@code stream.collect(Collectors.groupingBy(keyFunction))}
 behaves similarly, but returns a mutable {@code Map<K, List<E>>} instead, and may not preserve
 the order of entries.

 @param keyFunction the function used to produce the key for each value
 @throws NullPointerException if any element of this iterable is {@code null}, or if {@code
     keyFunction} produces {@code null} for any key
 @since 14.0]]>
      </doc>
    </method>
    <method name="uniqueIndex" return="com.google.common.collect.ImmutableMap&lt;K, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super E, K&gt;"/>
      <doc>
      <![CDATA[Returns a map with the contents of this {@code FluentIterable} as its {@code values}, indexed
 by keys derived from those values. In other words, each input value produces an entry in the
 map whose key is the result of applying {@code keyFunction} to that value. These entries appear
 in the same order as they appeared in this fluent iterable. Example usage:

 {@snippet :
 Color red = new Color("red", 255, 0, 0);
 ...
 FluentIterable<Color> allColors = FluentIterable.from(ImmutableSet.of(red, green, blue));

 Map<String, Color> colorForName = allColors.uniqueIndex(toStringFunction());
 assertThat(colorForName).containsEntry("red", red);
 }

 <p>If your index may associate multiple values with each key, use {@link #index(Function)
 index}.

 <p><b>{@code Stream} equivalent:</b> use {@code
 stream.collect(ImmutableMap.toImmutableMap(keyFunction, v -> v))}. {@code
 ImmutableMap.copyOf(stream.collect(Collectors.toMap(keyFunction, v -> v)))}, but be aware that
 this may not preserve the order of entries.

 @param keyFunction the function used to produce the key for each value
 @return a map mapping the result of evaluating the function {@code keyFunction} on each value
     in this fluent iterable to that value
 @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one
     value in this fluent iterable
 @throws NullPointerException if any element of this iterable is {@code null}, or if {@code
     keyFunction} produces {@code null} for any key
 @since 14.0]]>
      </doc>
    </method>
    <method name="toArray" return="E[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an array containing all of the elements from this fluent iterable in iteration order.

 <p><b>{@code Stream} equivalent:</b> if an object array is acceptable, use {@code
 stream.toArray()}; if {@code type} is a class literal such as {@code MyType.class}, use {@code
 stream.toArray(MyType[]::new)}. Otherwise use {@code stream.toArray( len -> (E[])
 Array.newInstance(type, len))}.

 @param type the type of the elements
 @return a newly-allocated array into which all the elements of this fluent iterable have been
     copied]]>
      </doc>
    </method>
    <method name="copyInto" return="C extends java.util.Collection&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="C extends java.util.Collection&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Copies all the elements from this fluent iterable to {@code collection}. This is equivalent to
 calling {@code Iterables.addAll(collection, this)}.

 <p><b>{@code Stream} equivalent:</b> {@code stream.forEachOrdered(collection::add)} or {@code
 stream.forEach(collection::add)}.

 @param collection the collection to copy elements to
 @return {@code collection}, for convenience
 @since 14.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="joiner" type="com.google.common.base.Joiner"/>
      <doc>
      <![CDATA[Returns a {@link String} containing all of the elements of this fluent iterable joined with
 {@code joiner}.

 <p><b>{@code Stream} equivalent:</b> {@code joiner.join(stream.iterator())}, or, if you are not
 using any optional {@code Joiner} features, {@code
 stream.collect(Collectors.joining(delimiter)}.

 @since 18.0]]>
      </doc>
    </method>
    <method name="get" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the element at the specified position in this fluent iterable.

 <p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (but note
 that this throws different exception types, and throws an exception if {@code null} would be
 returned).

 @param position position of the element to return
 @return the element at the specified position in this fluent iterable
 @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to
     the size of this fluent iterable]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An expanded {@code Iterable} API, providing functionality similar to Java 8's powerful <a href=
 "https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#package.description"
 >streams library</a> in a slightly different way.

 <p>The following types of methods are provided:

 <ul>
   <li>chaining methods which return a new {@code FluentIterable} based in some way on the
       contents of the current one (for example {@link #transform})
   <li>element extraction methods which facilitate the retrieval of certain elements (for example
       {@link #last})
   <li>query methods which answer questions about the {@code FluentIterable}'s contents (for
       example {@link #anyMatch})
   <li>conversion methods which copy the {@code FluentIterable}'s contents into a new collection
       or array (for example {@link #toList})
 </ul>

 <p>Several lesser-used features are currently available only as static methods on the {@link
 Iterables} class.

 <p><a id="streams"></a>

 <h3>Comparison to streams</h3>

 <p>Starting with Java 8, the core Java class libraries provide a new "Streams" library (in {@code
 java.util.stream}), which is similar to {@code FluentIterable} but generally more powerful. Key
 differences include:

 <ul>
   <li>A stream is <i>single-use</i>; it becomes invalid as soon as any "terminal operation" such
       as {@code findFirst()} or {@code iterator()} is invoked. (Even though {@code Stream}
       contains all the right method <i>signatures</i> to implement {@link Iterable}, it does not
       actually do so, to avoid implying repeat-iterability.) {@code FluentIterable}, on the other
       hand, is multiple-use, and does implement {@link Iterable}.
   <li>Streams offer many features not found here, including {@code min/max}, {@code distinct},
       {@code reduce}, {@code sorted}, the very powerful {@code collect}, and built-in support for
       parallelizing stream operations.
   <li>{@code FluentIterable} contains several features not available on {@code Stream}, which are
       noted in the method descriptions below.
   <li>Streams include primitive-specialized variants such as {@code IntStream}, the use of which
       is strongly recommended.
   <li>Streams are standard Java, not requiring a third-party dependency (but do render your code
       incompatible with Java 7 and earlier).
 </ul>

 <h3>Example</h3>

 <p>Here is an example that accepts a list from a database call, filters it based on a predicate,
 transforms it by invoking {@code toString()} on each element, and returns the first 10 elements
 as a {@code List}:

 {@snippet :
 ImmutableList<String> results =
     FluentIterable.from(database.getClientList())
         .filter(Client::isActiveInLastMonth)
         .transform(Object::toString)
         .limit(10)
         .toList();
 }

 The approximate stream equivalent is:

 {@snippet :
 List<String> results =
     database.getClientList()
         .stream()
         .filter(Client::isActiveInLastMonth)
         .map(Object::toString)
         .limit(10)
         .collect(Collectors.toList());
 }

 @author Marcin Mikosik
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.FluentIterable -->
  <!-- start class com.google.common.collect.ForwardingBlockingDeque -->
  <class name="ForwardingBlockingDeque" extends="com.google.common.collect.ForwardingDeque&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="This class has moved to {@code com.google.common.util.concurrent}. Please use {@link
     com.google.common.util.concurrent.ForwardingBlockingDeque} instead.">
    <implements name="java.util.concurrent.BlockingDeque&lt;E&gt;"/>
    <constructor name="ForwardingBlockingDeque"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.BlockingDeque&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="remainingCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="putFirst"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="putLast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offerFirst" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offerLast" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="takeFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="takeLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="take" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="maxElements" type="int"/>
    </method>
    <doc>
    <![CDATA[A {@link BlockingDeque} which forwards all its method calls to another {@code BlockingDeque}.
 Subclasses should override one or more methods to modify the behavior of the backing deque as
 desired per the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingBlockingDeque} forward <b>indiscriminately</b>
 to the methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change
 the behaviour of {@link #offer} which can lead to unexpected behaviour. In this case, you should
 override {@code offer} as well, either providing your own implementation, or delegating to the
 provided {@code standardOffer} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingBlockingDeque}.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even when all of the
 methods that they depend on are thread-safe.

 @author Emily Soldal
 @since 14.0
 @deprecated This class has moved to {@code com.google.common.util.concurrent}. Please use {@link
     com.google.common.util.concurrent.ForwardingBlockingDeque} instead.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingBlockingDeque -->
  <!-- start class com.google.common.collect.ForwardingCollection -->
  <class name="ForwardingCollection" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <constructor name="ForwardingCollection"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Collection&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
    </method>
    <method name="standardContains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #contains} in terms of {@link #iterator}. If you override
 {@link #iterator}, you may wish to override {@link #contains} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardContainsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #containsAll} in terms of {@link #contains} . If you override
 {@link #contains}, you may wish to override {@link #containsAll} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAddAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #addAll} in terms of {@link #add}. If you override {@link
 #add}, you may wish to override {@link #addAll} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #remove} in terms of {@link #iterator}, using the iterator's
 {@code remove} method. If you override {@link #iterator}, you may wish to override {@link
 #remove} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemoveAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #removeAll} in terms of {@link #iterator}, using the iterator's
 {@code remove} method. If you override {@link #iterator}, you may wish to override {@link
 #removeAll} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRetainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #retainAll} in terms of {@link #iterator}, using the iterator's
 {@code remove} method. If you override {@link #iterator}, you may wish to override {@link
 #retainAll} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #clear} in terms of {@link #iterator}, using the iterator's
 {@code remove} method. If you override {@link #iterator}, you may wish to override {@link
 #clear} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIsEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #isEmpty} as {@code !iterator().hasNext}. If you override
 {@link #isEmpty}, you may wish to override {@link #isEmpty} to forward to this implementation.
 Alternately, it may be more efficient to implement {@code isEmpty} as {@code size() == 0}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} in terms of {@link #iterator}. If you override
 {@link #iterator}, you may wish to override {@link #toString} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toArray()} in terms of {@link #toArray(Object[])}. If you
 override {@link #toArray(Object[])}, you may wish to override {@link #toArray} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[A sensible definition of {@link #toArray(Object[])} in terms of {@link #size} and {@link
 #iterator}. If you override either of these methods, you may wish to override {@link #toArray}
 to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection which forwards all its method calls to another collection. Subclasses should
 override one or more methods to modify the behavior of the backing collection as desired per the
 <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingCollection} forward <b>indiscriminately</b> to
 the methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change
 the behavior of {@link #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardAddAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingCollection}.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even when all of the
 methods that they depend on are thread-safe.

 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingCollection -->
  <!-- start class com.google.common.collect.ForwardingConcurrentMap -->
  <class name="ForwardingConcurrentMap" extends="com.google.common.collect.ForwardingMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"/>
    <constructor name="ForwardingConcurrentMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="putIfAbsent" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <param name="value" type="Object"/>
    </method>
    <method name="replace" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="replace" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="oldValue" type="V"/>
      <param name="newValue" type="V"/>
    </method>
    <doc>
    <![CDATA[A concurrent map which forwards all its method calls to another concurrent map. Subclasses should
 override one or more methods to modify the behavior of the backing map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class forwards calls to <i>only some</i> {@code
 default} methods. Specifically, it forwards calls only for methods that existed <a
 href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentMap.html">before
 {@code default} methods were introduced</a>. For newer methods, like {@code forEach}, it inherits
 their default implementations. When those implementations invoke methods, they invoke methods on
 the {@code ForwardingConcurrentMap}.

 @author Charles Fry
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingConcurrentMap -->
  <!-- start class com.google.common.collect.ForwardingDeque -->
  <class name="ForwardingDeque" extends="com.google.common.collect.ForwardingQueue&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Deque&lt;E&gt;"/>
    <constructor name="ForwardingDeque"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Deque&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="addFirst"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="addLast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="descendingIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFirst" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLast" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="offerFirst" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="offerLast" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="peekFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peekLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pop" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="push"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="removeFirst" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeLast" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeFirstOccurrence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
    </method>
    <method name="removeLastOccurrence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
    </method>
    <doc>
    <![CDATA[A deque which forwards all its method calls to another deque. Subclasses should override one or
 more methods to modify the behavior of the backing deque as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingDeque} forward <b>indiscriminately</b> to the
 methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change the
 behavior of {@link #offer} which can lead to unexpected behavior. In this case, you should
 override {@code offer} as well.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingDeque}.

 @author Kurt Alfred Kluever
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingDeque -->
  <!-- start class com.google.common.collect.ForwardingIterator -->
  <class name="ForwardingIterator" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;T&gt;"/>
    <constructor name="ForwardingIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Iterator&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An iterator which forwards all its method calls to another iterator. Subclasses should override
 one or more methods to modify the behavior of the backing iterator as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class forwards calls to <i>only some</i> {@code
 default} methods. Specifically, it forwards calls only for methods that existed <a
 href="https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html">before {@code default}
 methods were introduced</a>. For newer methods, like {@code forEachRemaining}, it inherits their
 default implementations. When those implementations invoke methods, they invoke methods on the
 {@code ForwardingIterator}.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingIterator -->
  <!-- start class com.google.common.collect.ForwardingList -->
  <class name="ForwardingList" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.List&lt;E&gt;"/>
    <constructor name="ForwardingList"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.List&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E extends java.lang.Object"/>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="get" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
    </method>
    <method name="listIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="remove" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="set" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="element" type="E extends java.lang.Object"/>
    </method>
    <method name="subList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardAdd" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #add(Object)}, in terms of {@link #add(int,
 Object)}. If you override {@link #add(int, Object)}, you may wish to override {@link
 #add(Object)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAddAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #addAll(int, Collection)}, in terms of the {@code
 add} method of {@link #listIterator(int)}. If you override {@link #listIterator(int)}, you may
 wish to override {@link #addAll(int, Collection)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #indexOf}, in terms of {@link #listIterator()}. If
 you override {@link #listIterator()}, you may wish to override {@link #indexOf} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardLastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #lastIndexOf}, in terms of {@link
 #listIterator(int)}. If you override {@link #listIterator(int)}, you may wish to override
 {@link #lastIndexOf} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible default implementation of {@link #iterator}, in terms of {@link #listIterator()}. If
 you override {@link #listIterator()}, you may wish to override {@link #iterator} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardListIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible default implementation of {@link #listIterator()}, in terms of {@link
 #listIterator(int)}. If you override {@link #listIterator(int)}, you may wish to override
 {@link #listIterator()} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardListIterator" return="java.util.ListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="start" type="int"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #listIterator(int)}, in terms of {@link #size},
 {@link #get(int)}, {@link #set(int, Object)}, {@link #add(int, Object)}, and {@link
 #remove(int)}. If you override any of these methods, you may wish to override {@link
 #listIterator(int)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSubList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #subList(int, int)}. If you override any other
 methods, you may wish to override {@link #subList(int, int)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals(Object)} in terms of {@link #size} and {@link
 #iterator}. If you override either of those methods, you may wish to override {@link
 #equals(Object)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} in terms of {@link #iterator}. If you override
 {@link #iterator}, you may wish to override {@link #hashCode} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A list which forwards all its method calls to another list. Subclasses should override one or
 more methods to modify the behavior of the backing list as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>This class does not implement {@link java.util.RandomAccess}. If the delegate supports random
 access, the {@code ForwardingList} subclass should implement the {@code RandomAccess} interface.

 <p><b>Warning:</b> The methods of {@code ForwardingList} forward <b>indiscriminately</b> to the
 methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change the
 behavior of {@link #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardAddAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingList}.

 <p>The {@code standard} methods and any collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingList -->
  <!-- start class com.google.common.collect.ForwardingListIterator -->
  <class name="ForwardingListIterator" extends="com.google.common.collect.ForwardingIterator&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.ListIterator&lt;E&gt;"/>
    <constructor name="ForwardingListIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.ListIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
    </method>
    <method name="hasPrevious" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="previous" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="previousIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A list iterator which forwards all its method calls to another list iterator. Subclasses should
 override one or more methods to modify the behavior of the backing iterator as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class forwards calls to <i>only some</i> {@code
 default} methods. Specifically, it forwards calls only for methods that existed <a
 href="https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html">before {@code
 default} methods were introduced</a>. For newer methods, like {@code forEachRemaining}, it
 inherits their default implementations. When those implementations invoke methods, they invoke
 methods on the {@code ForwardingListIterator}.

 @author Mike Bostock
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingListIterator -->
  <!-- start class com.google.common.collect.ForwardingListMultimap -->
  <class name="ForwardingListMultimap" extends="com.google.common.collect.ForwardingMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingListMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A list multimap which forwards all its method calls to another list multimap. Subclasses should
 override one or more methods to modify the behavior of the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingListMultimap}.

 @author Kurt Alfred Kluever
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingListMultimap -->
  <!-- start class com.google.common.collect.ForwardingMap -->
  <class name="ForwardingMap" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <constructor name="ForwardingMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Map&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPutAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #putAll(Map)} in terms of {@link #put(Object, Object)}. If you
 override {@link #put(Object, Object)}, you may wish to override {@link #putAll(Map)} to forward
 to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #remove} in terms of the {@code iterator}
 method of {@link #entrySet}. If you override {@link #entrySet}, you may wish to override {@link
 #remove} to forward to this implementation.

 <p>Alternately, you may wish to override {@link #remove} with {@code keySet().remove}, assuming
 that approach would not lead to an infinite loop.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #clear} in terms of the {@code iterator} method of {@link
 #entrySet}. In many cases, you may wish to override {@link #clear} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardContainsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #containsKey} in terms of the {@code
 iterator} method of {@link #entrySet}. If you override {@link #entrySet}, you may wish to
 override {@link #containsKey} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardContainsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #containsValue} in terms of the {@code iterator} method of
 {@link #entrySet}. If you override {@link #entrySet}, you may wish to override {@link
 #containsValue} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIsEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #isEmpty} in terms of the {@code iterator} method of {@link
 #entrySet}. If you override {@link #entrySet}, you may wish to override {@link #isEmpty} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals} in terms of the {@code equals} method of {@link
 #entrySet}. If you override {@link #entrySet}, you may wish to override {@link #equals} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} in terms of the {@code iterator} method of {@link
 #entrySet}. If you override {@link #entrySet}, you may wish to override {@link #hashCode} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} in terms of the {@code iterator} method of {@link
 #entrySet}. If you override {@link #entrySet}, you may wish to override {@link #toString} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map which forwards all its method calls to another map. Subclasses should override one or more
 methods to modify the behavior of the backing map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingMap} forward <i>indiscriminately</i> to the
 methods of the delegate. For example, overriding {@link #put} alone <i>will not</i> change the
 behavior of {@link #putAll}, which can lead to unexpected behavior. In this case, you should
 override {@code putAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardPutAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingMap}.

 <p>Each of the {@code standard} methods, where appropriate, use {@link Objects#equals} to test
 equality for both keys and values. This may not be the desired behavior for map implementations
 that use non-standard notions of key equality, such as a {@code SortedMap} whose comparator is
 not consistent with {@code equals}.

 <p>The {@code standard} methods and the collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Kevin Bourrillion
 @author Jared Levy
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap -->
  <!-- start class com.google.common.collect.ForwardingMap.StandardEntrySet -->
  <class name="ForwardingMap.StandardEntrySet" extends="com.google.common.collect.Maps.EntrySet&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardEntrySet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link Map#entrySet} in terms of the following methods: {@link
 ForwardingMap#clear}, {@link ForwardingMap#containsKey}, {@link ForwardingMap#get}, {@link
 ForwardingMap#isEmpty}, {@link ForwardingMap#remove}, and {@link ForwardingMap#size}. In many
 cases, you may wish to override {@link #entrySet} to forward to this implementation or a
 subclass thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap.StandardEntrySet -->
  <!-- start class com.google.common.collect.ForwardingMap.StandardKeySet -->
  <class name="ForwardingMap.StandardKeySet" extends="com.google.common.collect.Maps.KeySet&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardKeySet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link Map#keySet} in terms of the following methods: {@link
 ForwardingMap#clear}, {@link ForwardingMap#containsKey}, {@link ForwardingMap#isEmpty}, {@link
 ForwardingMap#remove}, {@link ForwardingMap#size}, and the {@link Set#iterator} method of
 {@link ForwardingMap#entrySet}. In many cases, you may wish to override {@link
 ForwardingMap#keySet} to forward to this implementation or a subclass thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap.StandardKeySet -->
  <!-- start class com.google.common.collect.ForwardingMap.StandardValues -->
  <class name="ForwardingMap.StandardValues" extends="com.google.common.collect.Maps.Values&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardValues"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link Map#values} in terms of the following methods: {@link
 ForwardingMap#clear}, {@link ForwardingMap#containsValue}, {@link ForwardingMap#isEmpty},
 {@link ForwardingMap#size}, and the {@link Set#iterator} method of {@link
 ForwardingMap#entrySet}. In many cases, you may wish to override {@link ForwardingMap#values}
 to forward to this implementation or a subclass thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMap.StandardValues -->
  <!-- start class com.google.common.collect.ForwardingMapEntry -->
  <class name="ForwardingMapEntry" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map.Entry&lt;K, V&gt;"/>
    <constructor name="ForwardingMapEntry"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="K extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals(Object)} in terms of {@link #getKey()} and {@link
 #getValue()}. If you override either of these methods, you may wish to override {@link
 #equals(Object)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode()} in terms of {@link #getKey()} and {@link
 #getValue()}. If you override either of these methods, you may wish to override {@link
 #hashCode()} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} in terms of {@link #getKey} and {@link #getValue}.
 If you override either of these methods, you may wish to override {@link #equals} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map entry which forwards all its method calls to another map entry. Subclasses should override
 one or more methods to modify the behavior of the backing map entry as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingMapEntry} forward <i>indiscriminately</i> to
 the methods of the delegate. For example, overriding {@link #getValue} alone <i>will not</i>
 change the behavior of {@link #equals}, which can lead to unexpected behavior. In this case, you
 should override {@code equals} as well, either providing your own implementation, or delegating
 to the provided {@code standardEquals} method.

 <p>Each of the {@code standard} methods, where appropriate, use {@link Objects#equals} to test
 equality for both keys and values. This may not be the desired behavior for map implementations
 that use non-standard notions of key equality, such as the entry of a {@code SortedMap} whose
 comparator is not consistent with {@code equals}.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even when all of the
 methods that they depend on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMapEntry -->
  <!-- start class com.google.common.collect.ForwardingMultimap -->
  <class name="ForwardingMultimap" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <constructor name="ForwardingMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsEntry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <param name="value" type="Object"/>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="entries" return="java.util.Collection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <param name="value" type="Object"/>
    </method>
    <method name="removeAll" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="replaceValues" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A multimap which forwards all its method calls to another multimap. Subclasses should override
 one or more methods to modify the behavior of the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingMultimap}.

 @author Robert Konigsberg
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultimap -->
  <!-- start class com.google.common.collect.ForwardingMultiset -->
  <class name="ForwardingMultiset" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multiset&lt;E&gt;"/>
    <constructor name="ForwardingMultiset"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="elementSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="count" type="int"/>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
    </method>
    <method name="standardContains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #contains} in terms of {@link #count}. If you override {@link
 #count}, you may wish to override {@link #contains} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardClear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #clear} in terms of the {@code iterator} method of {@link
 #entrySet}. If you override {@link #entrySet}, you may wish to override {@link #clear} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #count} in terms of {@link #entrySet}. If
 you override {@link #entrySet}, you may wish to override {@link #count} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAdd" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #add(Object)} in terms of {@link #add(Object, int)}. If you
 override {@link #add(Object, int)}, you may wish to override {@link #add(Object)} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardAddAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="elementsToAdd" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #addAll(Collection)} in terms of {@link #add(Object)} and
 {@link #add(Object, int)}. If you override either of these methods, you may wish to override
 {@link #addAll(Collection)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #remove(Object)} in terms of {@link #remove(Object, int)}. If
 you override {@link #remove(Object, int)}, you may wish to override {@link #remove(Object)} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemoveAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #removeAll} in terms of the {@code removeAll} method of {@link
 #elementSet}. If you override {@link #elementSet}, you may wish to override {@link #removeAll}
 to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRetainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #retainAll} in terms of the {@code retainAll} method of {@link
 #elementSet}. If you override {@link #elementSet}, you may wish to override {@link #retainAll}
 to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSetCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[A sensible definition of {@link #setCount(Object, int)} in terms of {@link #count(Object)},
 {@link #add(Object, int)}, and {@link #remove(Object, int)}. {@link #entrySet()}. If you
 override any of these methods, you may wish to override {@link #setCount(Object, int)} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSetCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[A sensible definition of {@link #setCount(Object, int, int)} in terms of {@link #count(Object)}
 and {@link #setCount(Object, int)}. If you override either of these methods, you may wish to
 override {@link #setCount(Object, int, int)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #iterator} in terms of {@link #entrySet} and {@link
 #remove(Object)}. If you override either of these methods, you may wish to override {@link
 #iterator} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #size} in terms of {@link #entrySet}. If
 you override {@link #entrySet}, you may wish to override {@link #size} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible, albeit inefficient, definition of {@link #equals} in terms of {@code
 entrySet().size()} and {@link #count}. If you override either of these methods, you may wish to
 override {@link #equals} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} as {@code entrySet().hashCode()} . If you override
 {@link #entrySet}, you may wish to override {@link #hashCode} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #toString} as {@code entrySet().toString()} . If you override
 {@link #entrySet}, you may wish to override {@link #toString} to forward to this
 implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A multiset which forwards all its method calls to another multiset. Subclasses should override
 one or more methods to modify the behavior of the backing multiset as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingMultiset} forward <b>indiscriminately</b> to
 the methods of the delegate. For example, overriding {@link #add(Object, int)} alone <b>will
 not</b> change the behavior of {@link #add(Object)}, which can lead to unexpected behavior. In
 this case, you should override {@code add(Object)} as well, either providing your own
 implementation, or delegating to the provided {@code standardAdd} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingMultiset}.

 <p>The {@code standard} methods and any collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultiset -->
  <!-- start class com.google.common.collect.ForwardingMultiset.StandardElementSet -->
  <class name="ForwardingMultiset.StandardElementSet" extends="com.google.common.collect.Multisets.ElementSet&lt;E&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardElementSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A sensible implementation of {@link Multiset#elementSet} in terms of the following methods:
 {@link ForwardingMultiset#clear}, {@link ForwardingMultiset#contains}, {@link
 ForwardingMultiset#containsAll}, {@link ForwardingMultiset#count}, {@link
 ForwardingMultiset#isEmpty}, the {@link Set#size} and {@link Set#iterator} methods of {@link
 ForwardingMultiset#entrySet}, and {@link ForwardingMultiset#remove(Object, int)}. In many
 situations, you may wish to override {@link ForwardingMultiset#elementSet} to forward to this
 implementation or a subclass thereof.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingMultiset.StandardElementSet -->
  <!-- start class com.google.common.collect.ForwardingNavigableMap -->
  <class name="ForwardingNavigableMap" extends="com.google.common.collect.ForwardingSortedMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableMap&lt;K, V&gt;"/>
    <constructor name="ForwardingNavigableMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="lowerEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardLowerEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #lowerEntry} in terms of the {@code lastEntry()} of {@link
 #headMap(Object, boolean)}. If you override {@code headMap}, you may wish to override {@code
 lowerEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="lowerKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardLowerKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #lowerKey} in terms of {@code lowerEntry}. If you override
 {@link #lowerEntry}, you may wish to override {@code lowerKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="floorEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardFloorEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #floorEntry} in terms of the {@code lastEntry()} of {@link
 #headMap(Object, boolean)}. If you override {@code headMap}, you may wish to override {@code
 floorEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="floorKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardFloorKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #floorKey} in terms of {@code floorEntry}. If you override
 {@code floorEntry}, you may wish to override {@code floorKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="ceilingEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardCeilingEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #ceilingEntry} in terms of the {@code firstEntry()} of {@link
 #tailMap(Object, boolean)}. If you override {@code tailMap}, you may wish to override {@code
 ceilingEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="ceilingKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardCeilingKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #ceilingKey} in terms of {@code ceilingEntry}. If you override
 {@code ceilingEntry}, you may wish to override {@code ceilingKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="higherEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardHigherEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #higherEntry} in terms of the {@code firstEntry()} of {@link
 #tailMap(Object, boolean)}. If you override {@code tailMap}, you may wish to override {@code
 higherEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="higherKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="standardHigherKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #higherKey} in terms of {@code higherEntry}. If you override
 {@code higherEntry}, you may wish to override {@code higherKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="firstEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardFirstEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #firstEntry} in terms of the {@code iterator()} of {@link
 #entrySet}. If you override {@code entrySet}, you may wish to override {@code firstEntry} to
 forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardFirstKey" return="K extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #firstKey} in terms of {@code firstEntry}. If you override
 {@code firstEntry}, you may wish to override {@code firstKey} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="lastEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardLastEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #lastEntry} in terms of the {@code iterator()} of the {@link
 #entrySet} of {@link #descendingMap}. If you override {@code descendingMap}, you may wish to
 override {@code lastEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardLastKey" return="K extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #lastKey} in terms of {@code lastEntry}. If you override {@code
 lastEntry}, you may wish to override {@code lastKey} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollFirstEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollFirstEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollFirstEntry} in terms of the {@code iterator} of {@code
 entrySet}. If you override {@code entrySet}, you may wish to override {@code pollFirstEntry} to
 forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollLastEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollFirstEntry} in terms of the {@code iterator} of the {@code
 entrySet} of {@code descendingMap}. If you override {@code descendingMap}, you may wish to
 override {@code pollFirstEntry} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="descendingMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="navigableKeySet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingKeySet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardDescendingKeySet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #descendingKeySet} as the {@code navigableKeySet} of {@link
 #descendingMap}. (The {@link StandardDescendingMap} implementation implements {@code
 navigableKeySet} on its own, so as not to cause an infinite loop.) If you override {@code
 descendingMap}, you may wish to override {@code descendingKeySet} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="standardSubMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromKey" type="K extends java.lang.Object"/>
      <param name="toKey" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #subMap(Object, Object)} in terms of {@link #subMap(Object,
 boolean, Object, boolean)}. If you override {@code subMap(K, boolean, K, boolean)}, you may
 wish to override {@code subMap} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="subMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K extends java.lang.Object"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toKey" type="K extends java.lang.Object"/>
      <param name="toInclusive" type="boolean"/>
    </method>
    <method name="headMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K extends java.lang.Object"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="tailMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K extends java.lang.Object"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="standardHeadMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="toKey" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #headMap(Object)} in terms of {@link #headMap(Object,
 boolean)}. If you override {@code headMap(K, boolean)}, you may wish to override {@code
 headMap} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardTailMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromKey" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #tailMap(Object)} in terms of {@link #tailMap(Object,
 boolean)}. If you override {@code tailMap(K, boolean)}, you may wish to override {@code
 tailMap} to forward to this implementation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A navigable map which forwards all its method calls to another navigable map. Subclasses should
 override one or more methods to modify the behavior of the backing map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingNavigableMap} forward <i>indiscriminately</i>
 to the methods of the delegate. For example, overriding {@link #put} alone <i>will not</i> change
 the behavior of {@link #putAll}, which can lead to unexpected behavior. In this case, you should
 override {@code putAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardPutAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingNavigableMap}.

 <p>Each of the {@code standard} methods uses the map's comparator (or the natural ordering of the
 elements, if there is no comparator) to test element equality. As a result, if the comparator is
 not consistent with equals, some of the standard implementations may violate the {@code Map}
 contract.

 <p>The {@code standard} methods and the collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Louis Wasserman
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableMap -->
  <!-- start class com.google.common.collect.ForwardingNavigableMap.StandardDescendingMap -->
  <class name="ForwardingNavigableMap.StandardDescendingMap" extends="com.google.common.collect.Maps.DescendingMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardDescendingMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="entryIterator" return="java.util.Iterator&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A sensible implementation of {@link NavigableMap#descendingMap} in terms of the methods of this
 {@code NavigableMap}. In many cases, you may wish to override {@link
 ForwardingNavigableMap#descendingMap} to forward to this implementation or a subclass thereof.

 <p>In particular, this map iterates over entries with repeated calls to {@link
 NavigableMap#lowerEntry}. If a more efficient means of iteration is available, you may wish to
 override the {@code entryIterator()} method of this class.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableMap.StandardDescendingMap -->
  <!-- start class com.google.common.collect.ForwardingNavigableMap.StandardNavigableKeySet -->
  <class name="ForwardingNavigableMap.StandardNavigableKeySet" extends="com.google.common.collect.Maps.NavigableKeySet&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardNavigableKeySet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link NavigableMap#navigableKeySet} in terms of the methods of
 this {@code NavigableMap}. In many cases, you may wish to override {@link
 ForwardingNavigableMap#navigableKeySet} to forward to this implementation or a subclass
 thereof.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableMap.StandardNavigableKeySet -->
  <!-- start class com.google.common.collect.ForwardingNavigableSet -->
  <class name="ForwardingNavigableSet" extends="com.google.common.collect.ForwardingSortedSet&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableSet&lt;E&gt;"/>
    <constructor name="ForwardingNavigableSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.NavigableSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="lower" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="standardLower" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #lower} in terms of the {@code descendingIterator} method of
 {@link #headSet(Object, boolean)}. If you override {@link #headSet(Object, boolean)}, you may
 wish to override {@link #lower} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="floor" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="standardFloor" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #floor} in terms of the {@code descendingIterator} method of
 {@link #headSet(Object, boolean)}. If you override {@link #headSet(Object, boolean)}, you may
 wish to override {@link #floor} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="ceiling" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="standardCeiling" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #ceiling} in terms of the {@code iterator} method of {@link
 #tailSet(Object, boolean)}. If you override {@link #tailSet(Object, boolean)}, you may wish to
 override {@link #ceiling} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="higher" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
    </method>
    <method name="standardHigher" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #higher} in terms of the {@code iterator} method of {@link
 #tailSet(Object, boolean)}. If you override {@link #tailSet(Object, boolean)}, you may wish to
 override {@link #higher} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollFirst} in terms of the {@code iterator} method. If you
 override {@link #iterator} you may wish to override {@link #pollFirst} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollLast} in terms of the {@code descendingIterator} method.
 If you override {@link #descendingIterator} you may wish to override {@link #pollLast} to
 forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardFirst" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="standardLast" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="descendingSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingIterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="E extends java.lang.Object"/>
      <param name="toInclusive" type="boolean"/>
    </method>
    <method name="standardSubSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="E extends java.lang.Object"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[A sensible definition of {@link #subSet(Object, boolean, Object, boolean)} in terms of the
 {@code headSet} and {@code tailSet} methods. In many cases, you may wish to override {@link
 #subSet(Object, boolean, Object, boolean)} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="standardSubSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
      <param name="toElement" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #subSet(Object, Object)} in terms of the {@link #subSet(Object,
 boolean, Object, boolean)} method. If you override {@link #subSet(Object, boolean, Object,
 boolean)}, you may wish to override {@link #subSet(Object, Object)} to forward to this
 implementation.]]>
      </doc>
    </method>
    <method name="headSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E extends java.lang.Object"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="standardHeadSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="toElement" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #headSet(Object)} in terms of the {@link #headSet(Object,
 boolean)} method. If you override {@link #headSet(Object, boolean)}, you may wish to override
 {@link #headSet(Object)} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="tailSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
      <param name="inclusive" type="boolean"/>
    </method>
    <method name="standardTailSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #tailSet(Object)} in terms of the {@link #tailSet(Object,
 boolean)} method. If you override {@link #tailSet(Object, boolean)}, you may wish to override
 {@link #tailSet(Object)} to forward to this implementation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A navigable set which forwards all its method calls to another navigable set. Subclasses should
 override one or more methods to modify the behavior of the backing set as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingNavigableSet} forward <i>indiscriminately</i>
 to the methods of the delegate. For example, overriding {@link #add} alone <i>will not</i> change
 the behavior of {@link #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardAddAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingNavigableSet}.

 <p>Each of the {@code standard} methods uses the set's comparator (or the natural ordering of the
 elements, if there is no comparator) to test element equality. As a result, if the comparator is
 not consistent with equals, some of the standard implementations may violate the {@code Set}
 contract.

 <p>The {@code standard} methods and the collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Louis Wasserman
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableSet -->
  <!-- start class com.google.common.collect.ForwardingNavigableSet.StandardDescendingSet -->
  <class name="ForwardingNavigableSet.StandardDescendingSet" extends="com.google.common.collect.Sets.DescendingSet&lt;E&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardDescendingSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link NavigableSet#descendingSet} in terms of the other methods
 of {@link NavigableSet}, notably including {@link NavigableSet#descendingIterator}.

 <p>In many cases, you may wish to override {@link ForwardingNavigableSet#descendingSet} to
 forward to this implementation or a subclass thereof.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingNavigableSet.StandardDescendingSet -->
  <!-- start class com.google.common.collect.ForwardingObject -->
  <class name="ForwardingObject" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ForwardingObject"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the backing delegate instance that methods are forwarded to. Abstract subclasses
 generally override this method with an abstract method that has a more specific return type,
 such as {@link ForwardingSet#delegate}. Concrete subclasses override this method to supply the
 instance being decorated.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the string representation generated by the delegate's {@code toString} method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract base class for implementing the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>. The {@link
 #delegate()} method must be overridden to return the instance being decorated.

 <p>This class does <i>not</i> forward the {@code hashCode} and {@code equals} methods through to
 the backing object, but relies on {@code Object}'s implementation. This is necessary to preserve
 the symmetry of {@code equals}. Custom definitions of equality are usually based on an interface,
 such as {@code Set} or {@code List}, so that the implementation of {@code equals} can cast the
 object being tested for equality to the custom interface. {@code ForwardingObject} implements no
 such custom interfaces directly; they are implemented only in subclasses. Therefore, forwarding
 {@code equals} would break symmetry, as the forwarding object might consider itself equal to the
 object being tested, but the reverse could not be true. This behavior is consistent with the
 JDK's collection wrappers, such as {@link java.util.Collections#unmodifiableCollection}. Use an
 interface-specific subclass of {@code ForwardingObject}, such as {@link ForwardingList}, to
 preserve equality behavior, or override {@code equals} directly.

 <p>The {@code toString} method is forwarded to the delegate. Although this class does not
 implement {@link Serializable}, a serializable subclass may be created since this class has a
 parameter-less constructor.

 @author Mike Bostock
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingObject -->
  <!-- start class com.google.common.collect.ForwardingQueue -->
  <class name="ForwardingQueue" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Queue&lt;E&gt;"/>
    <constructor name="ForwardingQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Queue&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="E extends java.lang.Object"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="element" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardOffer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #offer} in terms of {@link #add}. If you override {@link #add},
 you may wish to override {@link #offer} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardPeek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #peek} in terms of {@link #element}. If you override {@link
 #element}, you may wish to override {@link #peek} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardPoll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #poll} in terms of {@link #remove}. If you override {@link
 #remove}, you may wish to override {@link #poll} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A queue which forwards all its method calls to another queue. Subclasses should override one or
 more methods to modify the behavior of the backing queue as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingQueue} forward <b>indiscriminately</b> to the
 methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change the
 behavior of {@link #offer} which can lead to unexpected behavior. In this case, you should
 override {@code offer} as well, either providing your own implementation, or delegating to the
 provided {@code standardOffer} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingQueue}.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even when all of the
 methods that they depend on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingQueue -->
  <!-- start class com.google.common.collect.ForwardingSet -->
  <class name="ForwardingSet" extends="com.google.common.collect.ForwardingCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set&lt;E&gt;"/>
    <constructor name="ForwardingSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardRemoveAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[A sensible definition of {@link #removeAll} in terms of {@link #iterator} and {@link #remove}.
 If you override {@code iterator} or {@code remove}, you may wish to override {@link #removeAll}
 to forward to this implementation.

 @since 7.0 (this version overrides the {@code ForwardingCollection} version as of 12.0)]]>
      </doc>
    </method>
    <method name="standardEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #equals} in terms of {@link #size} and {@link #containsAll}. If
 you override either of those methods, you may wish to override {@link #equals} to forward to
 this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardHashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #hashCode} in terms of {@link #iterator}. If you override
 {@link #iterator}, you may wish to override {@link #equals} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A set which forwards all its method calls to another set. Subclasses should override one or more
 methods to modify the behavior of the backing set as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingSet} forward <b>indiscriminately</b> to the
 methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change the
 behavior of {@link #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardAddAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingSet}.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even when all of the
 methods that they depend on are thread-safe.

 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSet -->
  <!-- start class com.google.common.collect.ForwardingSetMultimap -->
  <class name="ForwardingSetMultimap" extends="com.google.common.collect.ForwardingMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingSetMultimap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="removeAll" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A set multimap which forwards all its method calls to another set multimap. Subclasses should
 override one or more methods to modify the behavior of the backing multimap as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingSetMultimap}.

 @author Kurt Alfred Kluever
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSetMultimap -->
  <!-- start class com.google.common.collect.ForwardingSortedMap -->
  <class name="ForwardingSortedMap" extends="com.google.common.collect.ForwardingMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedMap&lt;K, V&gt;"/>
    <constructor name="ForwardingSortedMap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="firstKey" return="K extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K extends java.lang.Object"/>
    </method>
    <method name="lastKey" return="K extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K extends java.lang.Object"/>
      <param name="toKey" type="K extends java.lang.Object"/>
    </method>
    <method name="tailMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K extends java.lang.Object"/>
    </method>
    <method name="standardContainsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #containsKey} in terms of the {@code firstKey()} method of
 {@link #tailMap}. If you override {@link #tailMap}, you may wish to override {@link
 #containsKey} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSubMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromKey" type="K extends java.lang.Object"/>
      <param name="toKey" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #subMap(Object, Object)} in terms of {@link
 #headMap(Object)} and {@link #tailMap(Object)}. In some situations, you may wish to override
 {@link #subMap(Object, Object)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A sorted map which forwards all its method calls to another sorted map. Subclasses should
 override one or more methods to modify the behavior of the backing sorted map as desired per the
 <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingSortedMap} forward <i>indiscriminately</i> to
 the methods of the delegate. For example, overriding {@link #put} alone <i>will not</i> change
 the behavior of {@link #putAll}, which can lead to unexpected behavior. In this case, you should
 override {@code putAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardPutAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingSortedMap}.

 <p>Each of the {@code standard} methods, where appropriate, use the comparator of the map to test
 equality for both keys and values, unlike {@code ForwardingMap}.

 <p>The {@code standard} methods and the collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedMap -->
  <!-- start class com.google.common.collect.ForwardingSortedMap.StandardKeySet -->
  <class name="ForwardingSortedMap.StandardKeySet" extends="com.google.common.collect.Maps.SortedKeySet&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardKeySet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link SortedMap#keySet} in terms of the methods of {@code
 ForwardingSortedMap}. In many cases, you may wish to override {@link
 ForwardingSortedMap#keySet} to forward to this implementation or a subclass thereof.

 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedMap.StandardKeySet -->
  <!-- start class com.google.common.collect.ForwardingSortedMultiset -->
  <class name="ForwardingSortedMultiset" extends="com.google.common.collect.ForwardingMultiset&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SortedMultiset&lt;E&gt;"/>
    <constructor name="ForwardingSortedMultiset"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="elementSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="firstEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardFirstEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #firstEntry()} in terms of {@code entrySet().iterator()}.

 <p>If you override {@link #entrySet()}, you may wish to override {@link #firstEntry()} to
 forward to this implementation.]]>
      </doc>
    </method>
    <method name="lastEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardLastEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #lastEntry()} in terms of {@code
 descendingMultiset().entrySet().iterator()}.

 <p>If you override {@link #descendingMultiset} or {@link #entrySet()}, you may wish to override
 {@link #firstEntry()} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollFirstEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollFirstEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollFirstEntry()} in terms of {@code entrySet().iterator()}.

 <p>If you override {@link #entrySet()}, you may wish to override {@link #pollFirstEntry()} to
 forward to this implementation.]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="standardPollLastEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A sensible definition of {@link #pollLastEntry()} in terms of {@code
 descendingMultiset().entrySet().iterator()}.

 <p>If you override {@link #descendingMultiset()} or {@link #entrySet()}, you may wish to
 override {@link #pollLastEntry()} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="headMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperBound" type="E extends java.lang.Object"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="subMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E extends java.lang.Object"/>
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBound" type="E extends java.lang.Object"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="standardSubMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="lowerBound" type="E extends java.lang.Object"/>
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBound" type="E extends java.lang.Object"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[A sensible definition of {@link #subMultiset(Object, BoundType, Object, BoundType)} in terms of
 {@link #headMultiset(Object, BoundType) headMultiset} and {@link #tailMultiset(Object,
 BoundType) tailMultiset}.

 <p>If you override either of these methods, you may wish to override {@link
 #subMultiset(Object, BoundType, Object, BoundType)} to forward to this implementation.]]>
      </doc>
    </method>
    <method name="tailMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E extends java.lang.Object"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <doc>
    <![CDATA[A sorted multiset which forwards all its method calls to another sorted multiset. Subclasses
 should override one or more methods to modify the behavior of the backing multiset as desired per
 the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingSortedMultiset} forward
 <b>indiscriminately</b> to the methods of the delegate. For example, overriding {@link
 #add(Object, int)} alone <b>will not</b> change the behavior of {@link #add(Object)}, which can
 lead to unexpected behavior. In this case, you should override {@code add(Object)} as well,
 either providing your own implementation, or delegating to the provided {@code standardAdd}
 method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingSortedMultiset}.

 <p>The {@code standard} methods and any collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Louis Wasserman
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedMultiset -->
  <!-- start class com.google.common.collect.ForwardingSortedMultiset.StandardDescendingMultiset -->
  <class name="ForwardingSortedMultiset.StandardDescendingMultiset" extends="com.google.common.collect.DescendingMultiset&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardDescendingMultiset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A skeleton implementation of a descending multiset view. Normally, {@link
 #descendingMultiset()} will not reflect any changes you make to the behavior of methods such as
 {@link #add(Object)} or {@link #pollFirstEntry}. This skeleton implementation correctly
 delegates each of its operations to the appropriate methods of this {@code
 ForwardingSortedMultiset}.

 <p>In many cases, you may wish to override {@link #descendingMultiset()} to return an instance
 of a subclass of {@code StandardDescendingMultiset}.

 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedMultiset.StandardDescendingMultiset -->
  <!-- start class com.google.common.collect.ForwardingSortedMultiset.StandardElementSet -->
  <class name="ForwardingSortedMultiset.StandardElementSet" extends="com.google.common.collect.SortedMultisets.NavigableElementSet&lt;E&gt;"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="StandardElementSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A sensible implementation of {@link SortedMultiset#elementSet} in terms of the following
 methods: {@link SortedMultiset#clear}, {@link SortedMultiset#comparator}, {@link
 SortedMultiset#contains}, {@link SortedMultiset#containsAll}, {@link SortedMultiset#count},
 {@link SortedMultiset#firstEntry} {@link SortedMultiset#headMultiset}, {@link
 SortedMultiset#isEmpty}, {@link SortedMultiset#lastEntry}, {@link SortedMultiset#subMultiset},
 {@link SortedMultiset#tailMultiset}, the {@code size()} and {@code iterator()} methods of
 {@link SortedMultiset#entrySet}, and {@link SortedMultiset#remove(Object, int)}. In many
 situations, you may wish to override {@link SortedMultiset#elementSet} to forward to this
 implementation or a subclass thereof.

 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedMultiset.StandardElementSet -->
  <!-- start class com.google.common.collect.ForwardingSortedSet -->
  <class name="ForwardingSortedSet" extends="com.google.common.collect.ForwardingSet&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedSet&lt;E&gt;"/>
    <constructor name="ForwardingSortedSet"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.SortedSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="first" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E extends java.lang.Object"/>
    </method>
    <method name="last" return="E extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
      <param name="toElement" type="E extends java.lang.Object"/>
    </method>
    <method name="tailSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
    </method>
    <method name="standardContains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #contains} in terms of the {@code first()} method of {@link
 #tailSet}. If you override {@link #tailSet}, you may wish to override {@link #contains} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardRemove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[A sensible definition of {@link #remove} in terms of the {@code iterator()} method of {@link
 #tailSet}. If you override {@link #tailSet}, you may wish to override {@link #remove} to
 forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <method name="standardSubSet" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fromElement" type="E extends java.lang.Object"/>
      <param name="toElement" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[A sensible default implementation of {@link #subSet(Object, Object)} in terms of {@link
 #headSet(Object)} and {@link #tailSet(Object)}. In some situations, you may wish to override
 {@link #subSet(Object, Object)} to forward to this implementation.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A sorted set which forwards all its method calls to another sorted set. Subclasses should
 override one or more methods to modify the behavior of the backing sorted set as desired per the
 <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingSortedSet} forward <i>indiscriminately</i> to
 the methods of the delegate. For example, overriding {@link #add} alone <i>will not</i> change
 the behavior of {@link #addAll}, which can lead to unexpected behavior. In this case, you should
 override {@code addAll} as well, either providing your own implementation, or delegating to the
 provided {@code standardAddAll} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingSortedSet}.

 <p>Each of the {@code standard} methods, where appropriate, uses the set's comparator (or the
 natural ordering of the elements, if there is no comparator) to test element equality. As a
 result, if the comparator is not consistent with equals, some of the standard implementations may
 violate the {@code Set} contract.

 <p>The {@code standard} methods and the collection views they return are not guaranteed to be
 thread-safe, even when all of the methods that they depend on are thread-safe.

 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedSet -->
  <!-- start class com.google.common.collect.ForwardingSortedSetMultimap -->
  <class name="ForwardingSortedSetMultimap" extends="com.google.common.collect.ForwardingSetMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
    <constructor name="ForwardingSortedSetMultimap"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
    </method>
    <method name="removeAll" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="replaceValues" return="java.util.SortedSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="valueComparator" return="Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A sorted set multimap which forwards all its method calls to another sorted set multimap.
 Subclasses should override one or more methods to modify the behavior of the backing multimap as
 desired per the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingSortedSetMultimap}.

 @author Kurt Alfred Kluever
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingSortedSetMultimap -->
  <!-- start class com.google.common.collect.ForwardingTable -->
  <class name="ForwardingTable" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Table&lt;R, C, V&gt;"/>
    <constructor name="ForwardingTable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.collect.Table&lt;R, C, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="cellSet" return="java.util.Set&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="column" return="java.util.Map&lt;R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C extends java.lang.Object"/>
    </method>
    <method name="columnKeySet" return="java.util.Set&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="columnMap" return="java.util.Map&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="Object"/>
    </method>
    <method name="containsRow" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R extends java.lang.Object"/>
      <param name="columnKey" type="C extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
    </method>
    <method name="row" return="java.util.Map&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R extends java.lang.Object"/>
    </method>
    <method name="rowKeySet" return="java.util.Set&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="rowMap" return="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A table which forwards all its method calls to another table. Subclasses should override one or
 more methods to modify the behavior of the backing map as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 @author Gregory Kick
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ForwardingTable -->
  <!-- start class com.google.common.collect.HashBasedTable -->
  <class name="HashBasedTable" extends="com.google.common.collect.StandardTable&lt;R, C, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code HashBasedTable}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedRows" type="int"/>
      <param name="expectedCellsPerRow" type="int"/>
      <doc>
      <![CDATA[Creates an empty {@code HashBasedTable} with the specified map sizes.

 @param expectedRows the expected number of distinct row keys
 @param expectedCellsPerRow the expected number of column key / value mappings in each row
 @throws IllegalArgumentException if {@code expectedRows} or {@code expectedCellsPerRow} is
     negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a {@code HashBasedTable} with the same mappings as the specified table.

 @param table the table to copy
 @throws NullPointerException if any of the row keys, column keys, or values in {@code table} is
     null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@link Table} using linked hash tables. This guarantees predictable iteration
 order of the various views.

 <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link #columnMap()} have
 iterators that don't support {@code remove()}. Otherwise, all optional operations are supported.
 Null row keys, columns keys, and values are not supported.

 <p>Lookups by row key are often faster than lookups by column key, because the data is stored in
 a {@code Map<R, Map<C, V>>}. A method call like {@code column(columnKey).get(rowKey)} still runs
 quickly, since the row key is provided. However, {@code column(columnKey).size()} takes longer,
 since an iteration across all row keys occurs.

 <p>Note that this implementation is not synchronized. If multiple threads access this table
 concurrently and one of the threads modifies the table, it must be synchronized externally.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#table">{@code Table}</a>.

 @author Jared Levy
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashBasedTable -->
  <!-- start class com.google.common.collect.HashBiMap -->
  <class name="HashBiMap" extends="java.util.AbstractMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.BiMap&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty {@code HashBiMap} with the default initial capacity (16).]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Constructs a new, empty bimap with the specified expected size.

 @param expectedSize the expected number of entries
 @throws IllegalArgumentException if the specified expected size is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a new bimap containing initial values from {@code map}. The bimap is created with an
 initial capacity sufficient to hold the mappings in the specified map.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if this BiMap contains an entry whose value is equal to {@code value} (or,
 equivalently, if this inverse view contains a key that is equal to {@code value}).

 <p>Due to the property that values in a BiMap are unique, this will tend to execute in
 faster-than-linear time.

 @param value the object to search for in the values of this BiMap
 @return true if a mapping exists from a key to the specified value]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="inverse" return="com.google.common.collect.BiMap&lt;V, K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link BiMap} backed by two hash tables. This implementation allows null keys and values. A
 {@code HashBiMap} and its inverse are both serializable.

 <p>This implementation guarantees insertion-based iteration order of its keys.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#bimap">{@code BiMap} </a>.

 @author Louis Wasserman
 @author Mike Bostock
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashBiMap -->
  <!-- start class com.google.common.collect.HashMultimap -->
  <class name="HashMultimap" extends="com.google.common.collect.AbstractSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultimap} with the default initial capacities.

 <p>You may also consider the equivalent {@code
 MultimapBuilder.hashKeys().hashSetValues().build()}, which provides more control over the
 underlying data structure.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code HashMultimap} with enough capacity to hold the specified numbers of
 keys and values without rehashing.

 <p>You may also consider the equivalent {@code
 MultimapBuilder.hashKeys(expectedKeys).hashSetValues(expectedValuesPerKey).build()}, which
 provides more control over the underlying data structure.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is
     negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code HashMultimap} with the same mappings as the specified multimap. If a
 key-value mapping appears multiple times in the input multimap, it only appears once in the
 constructed multimap.

 <p>You may also consider the equivalent {@code
 MultimapBuilder.hashKeys().hashSetValues().build(multimap)}, which provides more control over
 the underlying data structure.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@link Multimap} using hash tables.

 <p>The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an
 existing key-value pair has no effect.

 <p>Keys and values may be null. All optional multimap methods are supported, and all returned
 views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent
 read operations will work correctly if the last write <i>happens-before</i> any reads. To allow
 concurrent update operations, wrap your multimap with a call to {@link
 Multimaps#synchronizedSetMultimap}.

 <p><b>Warning:</b> Do not modify either a key <i>or a value</i> of a {@code HashMultimap} in a
 way that affects its {@link Object#equals} behavior. Undefined behavior and bugs will result.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashMultimap -->
  <!-- start class com.google.common.collect.HashMultiset -->
  <class name="HashMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultiset} using the default initial capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distinctElements" type="int"/>
      <doc>
      <![CDATA[Creates a new, empty {@code HashMultiset} with the specified expected number of distinct
 elements.

 @param distinctElements the expected number of distinct elements
 @throws IllegalArgumentException if {@code distinctElements} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.HashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code HashMultiset} containing the specified elements.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Multiset implementation that uses hashing for key and entry access.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.HashMultiset -->
  <!-- start class com.google.common.collect.ImmutableBiMap -->
  <class name="ImmutableBiMap" extends="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.BiMap&lt;K, V&gt;"/>
    <method name="toImmutableBiMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableBiMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableBiMap} whose keys
 and values are the result of applying the provided mapping functions to the input elements.
 Entries appear in the result {@code ImmutableBiMap} in encounter order.

 <p>If the mapped keys or values contain duplicates (according to {@link
 Object#equals(Object)}), an {@code IllegalArgumentException} is thrown when the collection
 operation is performed. (This differs from the {@code Collector} returned by {@link
 Collectors#toMap(Function, Function)}, which throws an {@code IllegalStateException}.)

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty bimap.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable bimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K"/>
      <param name="v9" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K"/>
      <param name="v9" type="V"/>
      <param name="k10" type="K"/>
      <param name="v10" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are added
 @since 31.0]]>
      </doc>
    </method>
    <method name="ofEntries" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.util.Map.Entry[]"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys or values are provided
 @since 31.0]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <method name="builderWithExpectedSize" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Returns a new builder, expecting the specified number of entries to be added.

 <p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link
 Builder#build} is called, the builder is likely to perform better than an unsized {@link
 #builder()} would have.

 <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
 but not exactly, the number of entries added to the builder.

 @since 23.1]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable bimap containing the same entries as {@code map}. If {@code map} somehow
 contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose
 comparator is not <i>consistent with equals</i>), the results of this method are undefined.

 <p>The returned {@code BiMap} iterates over entries in the same order as the {@code entrySet}
 of the original map.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws IllegalArgumentException if two keys have the same value or two values have the same
     key
 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an immutable bimap containing the given entries. The returned bimap iterates over
 entries in the same order as the original iterable.

 @throws IllegalArgumentException if two keys have the same value or two values have the same
     key
 @throws NullPointerException if any key, value, or entry is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableBiMap&lt;V, K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The inverse of an {@code ImmutableBiMap} is another {@code ImmutableBiMap}.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the values in this map, in the same order they appear in {@link
 #entrySet}.]]>
      </doc>
    </method>
    <method name="forcePut" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the bimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="toImmutableMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableBiMap#toImmutableBiMap(Function, Function)}.">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Not supported. Use {@link #toImmutableBiMap} instead. This method exists only to hide {@link
 ImmutableMap#toImmutableMap(Function, Function)} from consumers of {@code ImmutableBiMap}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableBiMap#toImmutableBiMap(Function, Function)}.
 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Merging values does not make sense for a {@code BiMap}.">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="mergeFunction" type="java.util.function.BinaryOperator&lt;V&gt;"/>
      <doc>
      <![CDATA[Not supported. This method does not make sense for {@code BiMap}. This method exists only to
 hide {@link ImmutableMap#toImmutableMap(Function, Function, BinaryOperator)} from consumers of
 {@code ImmutableBiMap}.

 @throws UnsupportedOperationException always
 @deprecated Merging values does not make sense for a {@code BiMap}.
 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link BiMap} whose contents will never change, with many other important properties detailed
 at {@link ImmutableCollection}.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableBiMap -->
  <!-- start class com.google.common.collect.ImmutableBiMap.Builder -->
  <class name="ImmutableBiMap.Builder" extends="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableBiMap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built bimap. Duplicate keys or values are
 not allowed, and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds the given {@code entry} to the bimap. Duplicate keys or values are not allowed, and will
 cause {@link #build} to fail.

 @since 19.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built bimap. Duplicate keys or
 values are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Adds all of the given entries to the built bimap. Duplicate keys or values are not allowed,
 and will cause {@link #build} to fail.

 @throws NullPointerException if any key, value, or entry is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="orderEntriesByValue" return="com.google.common.collect.ImmutableBiMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Configures this {@code Builder} to order entries by value according to the specified
 comparator.

 <p>The sort order is stable, that is, if two entries have values that compare as equivalent,
 the entry that was inserted first will be first in the built map's iteration order.

 @throws IllegalStateException if this method was already called
 @since 19.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable bimap. The iteration order of the returned bimap is the
 order in which entries were inserted into the builder, unless {@link #orderEntriesByValue}
 was called, in which case entries are sorted by value.

 <p>Prefer the equivalent method {@link #buildOrThrow()} to make it explicit that the method
 will throw an exception if there are duplicate keys or values. The {@code build()} method
 will soon be deprecated.

 @throws IllegalArgumentException if duplicate keys or values were added]]>
      </doc>
    </method>
    <method name="buildOrThrow" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable bimap, or throws an exception if any key or value was added
 more than once. The iteration order of the returned bimap is the order in which entries were
 inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case
 entries are sorted by value.

 @throws IllegalArgumentException if duplicate keys or values were added
 @since 31.0]]>
      </doc>
    </method>
    <method name="buildKeepingLast" return="com.google.common.collect.ImmutableBiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method does not make sense for bimaps and should not be called.">
      <doc>
      <![CDATA[Throws {@link UnsupportedOperationException}. This method is inherited from {@link
 ImmutableMap.Builder}, but it does not make sense for bimaps.

 @throws UnsupportedOperationException always
 @deprecated This method does not make sense for bimaps and should not be called.
 @since 31.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable bimap instances, especially {@code public static final} bimaps
 ("constant bimaps"). Example:

 {@snippet :
 static final ImmutableBiMap<String, Integer> WORD_TO_INT =
     new ImmutableBiMap.Builder<String, Integer>()
         .put("one", 1)
         .put("two", 2)
         .put("three", 3)
         .buildOrThrow();
 }

 <p>For <i>small</i> immutable bimaps, the {@code ImmutableBiMap.of()} methods are even more
 convenient.

 <p>By default, a {@code Builder} will generate bimaps that iterate over entries in the order
 they were inserted into the builder. For example, in the above example, {@code
 WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in the order {@code "one"=1,
 "two"=2, "three"=3}, and {@code keySet()} and {@code values()} respect the same order. If you
 want a different order, consider using {@link #orderEntriesByValue(Comparator)}, which changes
 this builder to sort entries by value.

 <p>Builder instances can be reused - it is safe to call {@link #buildOrThrow} multiple times to
 build multiple bimaps in series. Each bimap is a superset of the bimaps created before it.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableBiMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableClassToInstanceMap -->
  <class name="ImmutableClassToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ClassToInstanceMap&lt;B&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty {@code ImmutableClassToInstanceMap}.

 <p><b>Performance note:</b> the instance returned is a singleton.

 @since 19.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Returns an {@code ImmutableClassToInstanceMap} containing a single entry.

 @since 19.0]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.Class&lt;? extends S&gt;, ? extends S&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}. If {@code map} somehow
 contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose
 comparator is not <i>consistent with equals</i>), the results of this method are undefined.

 <p><b>Note:</b> Despite what the method name suggests, if {@code map} is an {@code
 ImmutableClassToInstanceMap}, no copy will actually be performed.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws ClassCastException if any value is not an instance of the type specified by its key]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link ClassToInstanceMap} whose contents will never change, with many other important
 properties detailed at {@link ImmutableCollection}.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableClassToInstanceMap -->
  <!-- start class com.google.common.collect.ImmutableClassToInstanceMap.Builder -->
  <class name="ImmutableClassToInstanceMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,
 and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableClassToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.Class&lt;? extends T&gt;, ? extends T&gt;"/>
      <doc>
      <![CDATA[Associates all of {@code map's} keys and values in the built map. Duplicate keys are not
 allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws ClassCastException if any value is not an instance of the type specified by its key]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable class-to-instance map containing the entries provided to this
 builder.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable class-to-instance maps. Example:

 {@snippet :
 static final ImmutableClassToInstanceMap<Handler> HANDLERS =
     new ImmutableClassToInstanceMap.Builder<Handler>()
         .put(FooHandler.class, new FooHandler())
         .put(BarHandler.class, new SubBarHandler())
         .put(Handler.class, new QuuxHandler())
         .build();
 }

 <p>After invoking {@link #build()} it is still possible to add more entries and build again.
 Thus each map generated by this builder will be a superset of any map generated before it.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableClassToInstanceMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableCollection -->
  <class name="ImmutableCollection" extends="java.util.AbstractCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable iterator across the elements in this collection.]]>
      </doc>
    </method>
    <method name="spliterator" return="java.util.Spliterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="T[]"/>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="oldElements" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="elementsToKeep" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableList} containing the same elements, in the same order, as this
 collection.

 <p><b>Performance note:</b> in most cases this method can return quickly without actually
 copying anything. The exact circumstances under which the copy is performed are undefined and
 subject to change.

 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Collection} whose contents will never change, and which offers a few additional
 guarantees detailed below.

 <p><b>Warning:</b> avoid <i>direct</i> usage of {@link ImmutableCollection} as a type (just as
 with {@link Collection} itself). Prefer subtypes such as {@link ImmutableSet} or {@link
 ImmutableList}, which have well-defined {@link #equals} semantics, thus avoiding a common source
 of bugs and confusion.

 <h3>About <i>all</i> {@code Immutable-} collections</h3>

 <p>The remainder of this documentation applies to every public {@code Immutable-} type in this
 package, whether it is a subtype of {@code ImmutableCollection} or not.

 <h4>Guarantees</h4>

 <p>Each makes the following guarantees:

 <ul>
   <li><b>Shallow immutability.</b> Elements can never be added, removed or replaced in this
       collection. This is a stronger guarantee than that of {@link
       Collections#unmodifiableCollection}, whose contents change whenever the wrapped collection
       is modified.
   <li><b>Null-hostility.</b> This collection will never contain a null element.
   <li><b>Deterministic iteration.</b> The iteration order is always well-defined, depending on
       how the collection was created. Typically this is insertion order unless an explicit
       ordering is otherwise specified (e.g. {@link ImmutableSortedSet#naturalOrder}). See the
       appropriate factory method for details. View collections such as {@link
       ImmutableMultiset#elementSet} iterate in the same order as the parent, except as noted.
   <li><b>Thread safety.</b> It is safe to access this collection concurrently from multiple
       threads.
   <li><b>Integrity.</b> This type cannot be subclassed outside this package (which would allow
       these guarantees to be violated).
 </ul>

 <h4>"Interfaces", not implementations</h4>

 <p>These are classes instead of interfaces to prevent external subtyping, but should be thought
 of as interfaces in every important sense. Each public class such as {@link ImmutableSet} is a
 <i>type</i> offering meaningful behavioral guarantees. This is substantially different from the
 case of (say) {@link HashSet}, which is an <i>implementation</i>, with semantics that were
 largely defined by its supertype.

 <p>For field types and method return types, you should generally use the immutable type (such as
 {@link ImmutableList}) instead of the general collection interface type (such as {@link List}).
 This communicates to your callers all of the semantic guarantees listed above, which is almost
 always very useful information.

 <p>On the other hand, a <i>parameter</i> type of {@link ImmutableList} is generally a nuisance to
 callers. Instead, accept {@link Iterable} and have your method or constructor body pass it to the
 appropriate {@code copyOf} method itself.

 <p>Expressing the immutability guarantee directly in the type that user code references is a
 powerful advantage. Although Java offers certain immutable collection factory methods, such as
 {@link Collections#singleton(Object)} and <a
 href="https://docs.oracle.com/javase/9/docs/api/java/util/Set.html#immutable">{@code Set.of}</a>,
 we recommend using <i>these</i> classes instead for this reason (as well as for consistency).

 <h4>Creation</h4>

 <p>Except for logically "abstract" types like {@code ImmutableCollection} itself, each {@code
 Immutable} type provides the static operations you need to obtain instances of that type. These
 usually include:

 <ul>
   <li>Static methods named {@code of}, accepting an explicit list of elements or entries.
   <li>Static methods named {@code copyOf} (or {@code copyOfSorted}), accepting an existing
       collection whose contents should be copied.
   <li>A static nested {@code Builder} class which can be used to populate a new immutable
       instance.
 </ul>

 <h4>Warnings</h4>

 <ul>
   <li><b>Warning:</b> as with any collection, it is almost always a bad idea to modify an element
       (in a way that affects its {@link Object#equals} behavior) while it is contained in a
       collection. Undefined behavior and bugs will result. It's generally best to avoid using
       mutable objects as elements at all, as many users may expect your "immutable" object to be
       <i>deeply</i> immutable.
 </ul>

 <h4>Performance notes</h4>

 <ul>
   <li>Implementations can be generally assumed to prioritize memory efficiency, then speed of
       access, and lastly speed of creation.
   <li>The {@code copyOf} methods will sometimes recognize that the actual copy operation is
       unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only
       once. This reduces the expense of habitually making defensive copies at API boundaries.
       However, the precise conditions for skipping the copy operation are undefined.
   <li><b>Warning:</b> a view collection such as {@link ImmutableMap#keySet} or {@link
       ImmutableList#subList} may retain a reference to the entire data set, preventing it from
       being garbage collected. If some of the data is no longer reachable through other means,
       this constitutes a memory leak. Pass the view collection to the appropriate {@code copyOf}
       method to obtain a correctly-sized copy.
   <li>The performance of using the associated {@code Builder} class can be assumed to be no
       worse, and possibly better, than creating a mutable collection and copying it.
   <li>Implementations generally do not cache hash codes. If your element or key type has a slow
       {@code hashCode} implementation, it should cache it itself.
 </ul>

 <h4>Example usage</h4>

 {@snippet :
 class Foo {
   private static final ImmutableSet<String> RESERVED_CODES =
       ImmutableSet.of("AZ", "CQ", "ZX");

   private final ImmutableSet<String> codes;

   public Foo(Iterable<String> codes) {
     this.codes = ImmutableSet.copyOf(codes);
     checkArgument(Collections.disjoint(this.codes, RESERVED_CODES));
   }
 }
 }

 <h3>See also</h3>

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableCollection -->
  <!-- start class com.google.common.collect.ImmutableCollection.Builder -->
  <class name="ImmutableCollection.Builder" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="add" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableCollection} being built.

 <p>Note that each builder class covariantly returns its own type from this method.

 @param element the element to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableCollection} being built.

 <p>Note that each builder class overrides this method in order to covariantly return its own
 type.

 @param elements the elements to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableCollection} being built.

 <p>Note that each builder class overrides this method in order to covariantly return its own
 type.

 @param elements the elements to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableCollection} being built.

 <p>Note that each builder class overrides this method in order to covariantly return its own
 type.

 @param elements the elements to add
 @return this {@code Builder} instance
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableCollection&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableCollection} of the appropriate type, containing the
 elements provided to this builder.

 <p>Note that each builder class covariantly returns the appropriate type of {@code
 ImmutableCollection} from this method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract base class for builders of {@link ImmutableCollection} types.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableCollection.Builder -->
  <!-- start class com.google.common.collect.ImmutableList -->
  <class name="ImmutableList" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.List&lt;E&gt;"/>
    <implements name="java.util.RandomAccess"/>
    <method name="toImmutableList" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableList&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code
 ImmutableList}, in encounter order.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable list. This list behaves and performs comparably to {@link
 Collections#emptyList}, and is preferable mainly for consistency and maintainability of your
 code.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing a single element. This list behaves and performs
 comparably to {@link Collections#singletonList}, but will not accept a null element. It is
 preferable mainly for consistency and maintainability of your code.

 @throws NullPointerException if the element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <param name="e11" type="E"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="e7" type="E"/>
      <param name="e8" type="E"/>
      <param name="e9" type="E"/>
      <param name="e10" type="E"/>
      <param name="e11" type="E"/>
      <param name="e12" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 <p>The array {@code others} must not be longer than {@code Integer.MAX_VALUE - 12}.

 @throws NullPointerException if any element is null
 @since 3.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order. If {@code elements} is a
 {@link Collection}, this method behaves exactly as {@link #copyOf(Collection)}; otherwise, it
 behaves exactly as {@code copyOf(elements.iterator()}.

 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>Note that if {@code list} is a {@code List<String>}, then {@code ImmutableList.copyOf(list)}
 returns an {@code ImmutableList<String>} containing each of the strings in {@code list}, while
 {@code ImmutableList.of(list)} returns an {@code ImmutableList<List<String>>} containing one
 element (the given list itself).

 <p>This method is safe to use even when {@code elements} is a synchronized or concurrent
 collection that is currently being modified by another thread.

 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in order.

 @throws NullPointerException if {@code elements} contains a null element
 @since 3.0]]>
      </doc>
    </method>
    <method name="sortedCopyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, sorted according to their natural
 order. The sorting algorithm used is stable, so elements that compare as equal will stay in the
 order in which they appear in the input.

 <p>If your data has no duplicates, or you wish to deduplicate elements, use {@code
 ImmutableSortedSet.copyOf(elements)}; if you want a {@code List} you can use its {@code
 asList()} view.

 <p><b>Java 8+ users:</b> If you want to convert a {@link java.util.stream.Stream} to a sorted
 {@code ImmutableList}, use {@code stream.sorted().collect(toImmutableList())}.

 @throws NullPointerException if any element in the input is null
 @since 21.0]]>
      </doc>
    </method>
    <method name="sortedCopyOf" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable list containing the given elements, in sorted order relative to the
 specified comparator. The sorting algorithm used is stable, so elements that compare as equal
 will stay in the order in which they appear in the input.

 <p>If your data has no duplicates, or you wish to deduplicate elements, use {@code
 ImmutableSortedSet.copyOf(comparator, elements)}; if you want a {@code List} you can use its
 {@code asList()} view.

 <p><b>Java 8+ users:</b> If you want to convert a {@link java.util.stream.Stream} to a sorted
 {@code ImmutableList}, use {@code stream.sorted(comparator).collect(toImmutableList())}.

 @throws NullPointerException if any element in the input is null
 @since 21.0]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listIterator" return="com.google.common.collect.UnmodifiableListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listIterator" return="com.google.common.collect.UnmodifiableListIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="subList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Returns an immutable list of the elements between the specified {@code fromIndex}, inclusive,
 and {@code toIndex}, exclusive. (If {@code fromIndex} and {@code toIndex} are equal, the empty
 immutable list is returned.)

 <p><b>Note:</b> in almost all circumstances, the returned {@link ImmutableList} retains a
 strong reference to {@code this}, which may prevent the original list from being garbage
 collected. If you want the original list to be eligible for garbage collection, you should
 create and use a copy of the sub list (e.g., {@code
 ImmutableList.copyOf(originalList.subList(...))}).]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="index" type="int"/>
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="set" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="index" type="int"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the list unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="There is no reason to use this; it always returns {@code this}.">
      <doc>
      <![CDATA[Returns this list instance.

 @since 2.0
 @deprecated There is no reason to use this; it always returns {@code this}.]]>
      </doc>
    </method>
    <method name="reverse" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of this immutable list in reverse order. For example, {@code ImmutableList.of(1,
 2, 3).reverse()} is equivalent to {@code ImmutableList.of(3, 2, 1)}.

 @return a view of this immutable list in reverse order
 @since 7.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <method name="builderWithExpectedSize" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Returns a new builder, expecting the specified number of elements to be added.

 <p>If {@code expectedSize} is exactly the number of elements added to the builder before {@link
 Builder#build} is called, the builder is likely to perform better than an unsized {@link
 #builder()} would have.

 <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
 but not exactly, the number of elements added to the builder.

 @since 23.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link List} whose contents will never change, with many other important properties detailed at
 {@link ImmutableCollection}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @see ImmutableMap
 @see ImmutableSet
 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableList -->
  <!-- start class com.google.common.collect.ImmutableList.Builder -->
  <class name="ImmutableList.Builder" extends="com.google.common.collect.ImmutableCollection.ArrayBasedBuilder&lt;E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableList#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableList}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterable} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableList.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableList}.

 @param elements the {@code Iterator} to add to the {@code ImmutableList}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableList} based on the contents of the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable list instances, especially {@code public static final} lists
 ("constant lists"). Example:

 {@snippet :
 public static final ImmutableList<Color> GOOGLE_COLORS =
     new ImmutableList.Builder<Color>()
         .addAll(WEBSAFE_COLORS)
         .add(new Color(0, 191, 255))
         .build();
 }

 <p>Elements appear in the resulting list in the same order they were added to the builder.

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple lists in series. Each new list contains all the elements of the ones created before
 it.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableList.Builder -->
  <!-- start class com.google.common.collect.ImmutableListMultimap -->
  <class name="ImmutableListMultimap" extends="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <method name="toImmutableListMultimap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableListMultimap}
 whose keys and values are the result of applying the provided mapping functions to the input
 elements.

 <p>For streams with defined encounter order (as defined in the Ordering section of the {@link
 java.util.stream} Javadoc), that order is preserved, but entries are <a
 href="ImmutableMultimap.html#iteration">grouped by key</a>.

 <p>Example:

 {@snippet :
 static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =
     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
         .collect(toImmutableListMultimap(str -> str.charAt(0), str -> str.substring(1)));

 // is equivalent to

 static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =
     new ImmutableListMultimap.Builder<Character, String>()
         .put('b', "anana")
         .putAll('a', "pple", "sparagus")
         .putAll('c', "arrot", "herry")
         .build();
 }

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="flatteningToImmutableListMultimap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valuesFunction" type="java.util.function.Function&lt;? super T, ? extends java.util.stream.Stream&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} accumulating entries into an {@code ImmutableListMultimap}. Each
 input element is mapped to a key and a stream of values, each of which are put into the
 resulting {@code Multimap}, in the encounter order of the stream and the encounter order of the
 streams of values.

 <p>Example:

 {@snippet :
 static final ImmutableListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =
     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
         .collect(
             flatteningToImmutableListMultimap(
                  str -> str.charAt(0),
                  str -> str.substring(1).chars().mapToObj(c -> (char) c));

 // is equivalent to

 static final ImmutableListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =
     ImmutableListMultimap.<Character, Character>builder()
         .putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'))
         .putAll('a', Arrays.asList('p', 'p', 'l', 'e'))
         .putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'))
         .putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'))
         .putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'))
         .build();
 }

 }

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty multimap.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <method name="builderWithExpectedKeys" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Returns a new builder with a hint for how many distinct keys are expected to be added. The
 generated builder is equivalent to that returned by {@link #builder}, but may perform better if
 {@code expectedKeys} is a good estimate.

 @throws IllegalArgumentException if {@code expectedKeys} is negative
 @since 33.3.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the same mappings as {@code multimap}. The generated
 multimap's key and value orderings correspond to the iteration ordering of the {@code
 multimap.asMap()} view.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code multimap} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the specified entries. The returned multimap iterates
 over keys in the order they were first encountered in the input, and the values for each key
 are iterated in the order they were encountered.

 @throws NullPointerException if any key, value, or entry is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable list of the values for the given key. If no mappings in the multimap have
 the provided key, an empty immutable list is returned. The values are in the same order as the
 parameters used to build this multimap.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableListMultimap&lt;V, K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because an inverse of a list multimap can contain multiple pairs with the same key and
 value, this method returns an {@code ImmutableListMultimap} rather than the {@code
 ImmutableMultimap} specified in the {@code ImmutableMultimap} class.

 @since 11.0]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableList&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link ListMultimap} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableListMultimap -->
  <!-- start class com.google.common.collect.ImmutableListMultimap.Builder -->
  <class name="ImmutableListMultimap.Builder" extends="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableListMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="expectedValuesPerKey" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 33.3.0]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 19.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="orderKeysBy" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 8.0]]>
      </doc>
    </method>
    <method name="orderValuesBy" return="com.google.common.collect.ImmutableListMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 8.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable list multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable {@code ListMultimap} instances, especially {@code public
 static final} multimaps ("constant multimaps"). Example:

 {@snippet :
 static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
     new ImmutableListMultimap.Builder<String, Integer>()
         .put("one", 1)
         .putAll("several", 1, 2, 3)
         .putAll("many", 1, 2, 3, 4, 5)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple multimaps in series. Each multimap contains the key-value mappings in the previously
 created multimaps.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableListMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMap -->
  <class name="ImmutableMap" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="toImmutableMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys
 and values are the result of applying the provided mapping functions to the input elements.
 Entries appear in the result {@code ImmutableMap} in encounter order.

 <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}, an {@code
 IllegalArgumentException} is thrown when the collection operation is performed. (This differs
 from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)}, which
 throws an {@code IllegalStateException}.)

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="mergeFunction" type="java.util.function.BinaryOperator&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys
 and values are the result of applying the provided mapping functions to the input elements.

 <p>If the mapped keys contain duplicates (according to {@link Object#equals(Object)}), the
 values are merged using the specified merging function. If the merging function returns {@code
 null}, then the collector removes the value that has been computed for the key thus far (though
 future occurrences of the key would reinsert it).

 <p>Entries will appear in the encounter order of the first occurrence of the key.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty map. This map behaves and performs comparably to {@link
 Collections#emptyMap}, and is preferable mainly for consistency and maintainability of your
 code.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing a single entry. This map behaves and performs comparably to
 {@link Collections#singletonMap} but will not accept a null key or value. It is preferable
 mainly for consistency and maintainability of your code.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K"/>
      <param name="v9" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K"/>
      <param name="v9" type="V"/>
      <param name="k10" type="K"/>
      <param name="v10" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided
 @since 31.0]]>
      </doc>
    </method>
    <method name="ofEntries" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.util.Map.Entry[]"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, in order.

 @throws IllegalArgumentException if duplicate keys are provided
 @since 31.0]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <method name="builderWithExpectedSize" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Returns a new builder, expecting the specified number of entries to be added.

 <p>If {@code expectedSize} is exactly the number of entries added to the builder before {@link
 Builder#build} is called, the builder is likely to perform better than an unsized {@link
 #builder()} would have.

 <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
 but not exactly, the number of entries added to the builder.

 @since 23.1]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}. The returned map iterates
 over entries in the same order as the {@code entrySet} of the original map. If {@code map}
 somehow contains entries with duplicate keys (for example, if it is a {@code SortedMap} whose
 comparator is not <i>consistent with equals</i>), the results of this method are undefined.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the specified entries. The returned map iterates over
 entries in the same order as the original iterable.

 @throws NullPointerException if any key, value, or entry is null
 @throws IllegalArgumentException if two entries have the same key
 @since 19.0]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="k" type="K"/>
      <param name="v" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="o" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="get" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="getOrDefault" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <param name="defaultValue" type="V"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>See <a
 href="https://developer.android.com/reference/java/util/Map.html#getOrDefault%28java.lang.Object,%20V%29">{@code
 Map.getOrDefault}</a>.

 @since 23.5 (but since 21.0 in the JRE <a
     href="https://github.com/google/guava#guava-google-core-libraries-for-java">flavor</a>).
     Note, however, that Java 8+ users can call this method with any version and flavor of
     Guava.]]>
      </doc>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the mappings in this map. The iteration order is specified by the
 method used to create this map. Typically, this is insertion order.]]>
      </doc>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the keys in this map, in the same order that they appear in {@link
 #entrySet}.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this map, in the same order that they appear
 in {@link #entrySet}.]]>
      </doc>
    </method>
    <method name="asMultimap" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a multimap view of the map.

 @since 14.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link Map} whose contents will never change, with many other important properties detailed at
 {@link ImmutableCollection}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMap -->
  <!-- start class com.google.common.collect.ImmutableMap.Builder -->
  <class name="ImmutableMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableMap#builder}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. If the same key is put more than
 once, {@link #buildOrThrow} will fail, while {@link #buildKeepingLast} will keep the last
 value put for that key.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds the given {@code entry} to the map, making it immutable if necessary. If the same key is
 put more than once, {@link #buildOrThrow} will fail, while {@link #buildKeepingLast} will
 keep the last value put for that key.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built map. If the same key is put
 more than once, {@link #buildOrThrow} will fail, while {@link #buildKeepingLast} will keep
 the last value put for that key.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Adds all of the given entries to the built map. If the same key is put more than once, {@link
 #buildOrThrow} will fail, while {@link #buildKeepingLast} will keep the last value put for
 that key.

 @throws NullPointerException if any key, value, or entry is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="orderEntriesByValue" return="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Configures this {@code Builder} to order entries by value according to the specified
 comparator.

 <p>The sort order is stable, that is, if two entries have values that compare as equivalent,
 the entry that was inserted first will be first in the built map's iteration order.

 @throws IllegalStateException if this method was already called
 @since 19.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable map. The iteration order of the returned map is the order
 in which entries were inserted into the builder, unless {@link #orderEntriesByValue} was
 called, in which case entries are sorted by value.

 <p>Prefer the equivalent method {@link #buildOrThrow()} to make it explicit that the method
 will throw an exception if there are duplicate keys. The {@code build()} method will soon be
 deprecated.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <method name="buildOrThrow" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable map, or throws an exception if any key was added more than
 once. The iteration order of the returned map is the order in which entries were inserted
 into the builder, unless {@link #orderEntriesByValue} was called, in which case entries are
 sorted by value.

 @throws IllegalArgumentException if duplicate keys were added
 @since 31.0]]>
      </doc>
    </method>
    <method name="buildKeepingLast" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable map, using the last value for any key that was added more
 than once. The iteration order of the returned map is the order in which entries were
 inserted into the builder, unless {@link #orderEntriesByValue} was called, in which case
 entries are sorted by value. If a key was added more than once, it appears in iteration order
 based on the first time it was added, again unless {@link #orderEntriesByValue} was called.

 <p>In the current implementation, all values associated with a given key are stored in the
 {@code Builder} object, even though only one of them will be used in the built map. If there
 can be many repeated keys, it may be more space-efficient to use a {@link
 java.util.LinkedHashMap LinkedHashMap} and {@link ImmutableMap#copyOf(Map)} rather than
 {@code ImmutableMap.Builder}.

 @since 31.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable map instances, especially {@code public static final} maps
 ("constant maps"). Example:

 {@snippet :
 static final ImmutableMap<String, Integer> WORD_TO_INT =
     new ImmutableMap.Builder<String, Integer>()
         .put("one", 1)
         .put("two", 2)
         .put("three", 3)
         .buildOrThrow();
 }

 <p>For <i>small</i> immutable maps, the {@code ImmutableMap.of()} methods are even more
 convenient.

 <p>By default, a {@code Builder} will generate maps that iterate over entries in the order they
 were inserted into the builder, equivalently to {@code LinkedHashMap}. For example, in the
 above example, {@code WORD_TO_INT.entrySet()} is guaranteed to iterate over the entries in the
 order {@code "one"=1, "two"=2, "three"=3}, and {@code keySet()} and {@code values()} respect
 the same order. If you want a different order, consider using {@link ImmutableSortedMap} to
 sort by keys, or call {@link #orderEntriesByValue(Comparator)}, which changes this builder to
 sort entries by value.

 <p>Builder instances can be reused - it is safe to call {@link #buildOrThrow} multiple times to
 build multiple maps in series. Each map is a superset of the maps created before it.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMultimap -->
  <class name="ImmutableMultimap" extends="com.google.common.collect.BaseImmutableMultimap&lt;K, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty multimap.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in the "key-grouped" insertion
 order described in the <a href="#iteration">class documentation</a>.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in the "key-grouped" insertion
 order described in the <a href="#iteration">class documentation</a>.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in the "key-grouped" insertion
 order described in the <a href="#iteration">class documentation</a>.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <method name="builderWithExpectedKeys" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Returns a new builder with a hint for how many distinct keys are expected to be added. The
 generated builder is equivalent to that returned by {@link #builder}, but may perform better if
 {@code expectedKeys} is a good estimate.

 @throws IllegalArgumentException if {@code expectedKeys} is negative
 @since 33.3.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the same mappings as {@code multimap}, in the
 "key-grouped" iteration order described in the class documentation.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code multimap} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the specified entries. The returned multimap iterates
 over keys in the order they were first encountered in the input, and the values for each key
 are iterated in the order they were encountered.

 @throws NullPointerException if any key, value, or entry is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable collection of the values for the given key. If no mappings in the multimap
 have the provided key, an empty immutable collection is returned. The values are in the same
 order as the parameters used to build this multimap.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableMultimap&lt;V, K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable multimap which is the inverse of this one. For every key-value mapping in
 the original, the result will have a mapping with key and value reversed.

 @since 11.0]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="Object"/>
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the distinct keys in this multimap, in the same order as they
 appear in this multimap.]]>
      </doc>
    </method>
    <method name="asMap" return="com.google.common.collect.ImmutableMap&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable map that associates each key with its corresponding values in the
 multimap. Keys and values appear in the same order as in this multimap.]]>
      </doc>
    </method>
    <method name="entries" return="com.google.common.collect.ImmutableCollection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of all key-value pairs in the multimap.]]>
      </doc>
    </method>
    <method name="keys" return="com.google.common.collect.ImmutableMultiset&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable multiset containing all the keys in this multimap, in the same order and
 with the same frequencies as they appear in this multimap; to get only a single occurrence of
 each key, use {@link #keySet}.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this multimap. Its iterator traverses the
 values for the first key, the values for the second key, and so on.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Multimap} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 <p><b>Warning:</b> avoid <i>direct</i> usage of {@link ImmutableMultimap} as a type (as with
 {@link Multimap} itself). Prefer subtypes such as {@link ImmutableSetMultimap} or {@link
 ImmutableListMultimap}, which have well-defined {@link #equals} semantics, thus avoiding a common
 source of bugs and confusion.

 <p><b>Note:</b> every {@link ImmutableMultimap} offers an {@link #inverse} view, so there is no
 need for a distinct {@code ImmutableBiMultimap} type.

 <p><a id="iteration"></a>

 <p><b>Key-grouped iteration.</b> All view collections follow the same iteration order. In all
 current implementations, the iteration order always keeps multiple entries with the same key
 together. Any creation method that would customarily respect insertion order (such as {@link
 #copyOf(Multimap)}) instead preserves key-grouped order by inserting entries for an existing key
 immediately after the last entry having that key.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultimap -->
  <!-- start class com.google.common.collect.ImmutableMultimap.Builder -->
  <class name="ImmutableMultimap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="expectedValuesPerKey" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Provides a hint for how many values will be associated with each key newly added to the
 builder after this call. This does not change semantics, but may improve performance if
 {@code expectedValuesPerKey} is a good estimate.

 <p>This may be called more than once; each newly added key will use the most recent call to
 {@link #expectedValuesPerKey} as its hint.

 @throws IllegalArgumentException if {@code expectedValuesPerKey} is negative
 @since 33.3.0]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds a key-value mapping to the built multimap.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds an entry to the built multimap.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Adds entries to the built multimap.

 @since 19.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key in the built multimap.

 @throws NullPointerException if {@code key}, {@code values}, or any element in {@code values}
     is null. The builder is left in an invalid state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
      <doc>
      <![CDATA[Stores an array of values with the same key in the built multimap.

 @throws NullPointerException if the key or any value is null. The builder is left in an
     invalid state.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Stores another multimap's entries in the built multimap. The generated multimap's key and
 value orderings correspond to the iteration ordering of the {@code multimap.asMap()} view,
 with new keys and values following any existing keys and values.

 @throws NullPointerException if any key or value in {@code multimap} is null. The builder is
     left in an invalid state.]]>
      </doc>
    </method>
    <method name="orderKeysBy" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated multimap's keys.

 @since 8.0]]>
      </doc>
    </method>
    <method name="orderValuesBy" return="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated multimap's values for each key.

 @since 8.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multimap instances, especially {@code public static final}
 multimaps ("constant multimaps"). Example:

 {@snippet :
 static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
     new ImmutableMultimap.Builder<String, Integer>()
         .put("one", 1)
         .putAll("several", 1, 2, 3)
         .putAll("many", 1, 2, 3, 4, 5)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple multimaps in series. Each multimap contains the key-value mappings in the previously
 created multimaps.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableMultiset -->
  <class name="ImmutableMultiset" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multiset&lt;E&gt;"/>
    <method name="toImmutableMultiset" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableMultiset&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code
 ImmutableMultiset}. Elements iterate in order by the <i>first</i> appearance of that element in
 encounter order.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableMultiset" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMultiset&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementFunction" type="java.util.function.Function&lt;? super T, ? extends E&gt;"/>
      <param name="countFunction" type="java.util.function.ToIntFunction&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates elements into an {@code ImmutableMultiset} whose
 elements are the result of applying {@code elementFunction} to the inputs, with counts equal to
 the result of applying {@code countFunction} to the inputs.

 <p>If the mapped elements contain duplicates (according to {@link Object#equals}), the first
 occurrence in encounter order appears in the resulting multiset, with count equal to the sum of
 the outputs of {@code countFunction.applyAsInt(t)} for each {@code t} mapped to that element.

 @since 33.2.0 (available since 22.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable multiset.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing a single element.

 @throws NullPointerException if the element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in order.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in the "grouped iteration order"
 described in the class documentation.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in the "grouped iteration order"
 described in the class documentation.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in the "grouped iteration order"
 described in the class documentation.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in the "grouped iteration order"
 described in the class documentation.

 @throws NullPointerException if any element is null
 @since 6.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in the "grouped iteration order"
 described in the class documentation.

 @throws NullPointerException if any of {@code elements} is null
 @since 6.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in the "grouped iteration order"
 described in the class documentation.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multiset containing the given elements, in the "grouped iteration order"
 described in the class documentation.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="element" type="Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="element" type="E"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="elementSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 21.0 (present with return type {@code Set} since 2.0)]]>
      </doc>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Multiset} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 <p><b>Grouped iteration.</b> In all current implementations, duplicate elements always appear
 consecutively when iterating. Elements iterate in order by the <i>first</i> appearance of that
 element when the multiset was created.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultiset -->
  <!-- start class com.google.common.collect.ImmutableMultiset.Builder -->
  <class name="ImmutableMultiset.Builder" extends="com.google.common.collect.ImmutableCollection.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableMultiset#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableMultiset}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addCopies" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this {@code ImmutableMultiset}.

 @param element the element to add
 @param occurrences the number of occurrences of the element to add. May be zero, in which
     case no change will be made.
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation
     would result in more than {@link Integer#MAX_VALUE} occurrences of the element]]>
      </doc>
    </method>
    <method name="setCount" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the element attains the
 desired count.

 @param element the element to add or remove occurrences of
 @param count the desired count of the element in this multiset
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the {@code Iterable} to add to the {@code ImmutableMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableMultiset}.

 @param elements the elements to add to the {@code ImmutableMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableMultiset} based on the contents of the {@code
 Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multiset instances, especially {@code public static final}
 multisets ("constant multisets"). Example:

 {@snippet :
 public static final ImmutableMultiset<Bean> BEANS =
     new ImmutableMultiset.Builder<Bean>()
         .addCopies(Bean.COCOA, 4)
         .addCopies(Bean.GARDEN, 6)
         .addCopies(Bean.RED, 8)
         .addCopies(Bean.BLACK_EYED, 10)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple multisets in series.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableMultiset.Builder -->
  <!-- start class com.google.common.collect.ImmutableRangeMap -->
  <class name="ImmutableRangeMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.RangeMap&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="toImmutableRangeMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableRangeMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, com.google.common.collect.Range&lt;K&gt;&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code
 ImmutableRangeMap}. As in {@link Builder}, overlapping ranges are not permitted.

 @since 33.2.0 (available since 23.1 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableRangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty immutable range map.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableRangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns an immutable range map mapping a single range to a single value.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableRangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeMap" type="com.google.common.collect.RangeMap&lt;K, ? extends V&gt;"/>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableRangeMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder for an immutable range map.]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Comparable&lt;?&gt;"/>
    </method>
    <method name="getEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Comparable&lt;?&gt;"/>
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="putCoalescing"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="rangeMap" type="com.google.common.collect.RangeMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="asMapOfRanges" return="com.google.common.collect.ImmutableMap&lt;com.google.common.collect.Range&lt;K&gt;, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asDescendingMapOfRanges" return="com.google.common.collect.ImmutableMap&lt;com.google.common.collect.Range&lt;K&gt;, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subRangeMap" return="com.google.common.collect.ImmutableRangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link RangeMap} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 @author Louis Wasserman
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableRangeMap -->
  <!-- start class com.google.common.collect.ImmutableRangeMap.Builder -->
  <class name="ImmutableRangeMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableRangeMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates the specified range with the specified value.

 @throws IllegalArgumentException if {@code range} is empty]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableRangeMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeMap" type="com.google.common.collect.RangeMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Copies all associations from the specified range map into this builder.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableRangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableRangeMap} containing the associations previously added to this
 builder.

 @throws IllegalArgumentException if any two ranges inserted into this builder overlap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for immutable range maps. Overlapping ranges are prohibited.

 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableRangeMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableRangeSet -->
  <class name="ImmutableRangeSet" extends="com.google.common.collect.AbstractRangeSet&lt;C&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="toImmutableRangeSet" return="java.util.stream.Collector&lt;com.google.common.collect.Range&lt;E&gt;, ?, com.google.common.collect.ImmutableRangeSet&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code
 ImmutableRangeSet}. As in {@link Builder}, overlapping ranges are not permitted and adjacent
 ranges will be merged.

 @since 33.2.0 (available since 23.1 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty immutable range set.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns an immutable range set containing the specified single range. If {@link Range#isEmpty()
 range.isEmpty()}, this is equivalent to {@link ImmutableRangeSet#of()}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeSet" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns an immutable copy of the specified {@code RangeSet}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an {@code ImmutableRangeSet} containing each of the specified disjoint ranges.
 Overlapping ranges and empty ranges are forbidden, though adjacent ranges are permitted and
 will be merged.

 @throws IllegalArgumentException if any ranges overlap or are empty
 @since 21.0]]>
      </doc>
    </method>
    <method name="unionOf" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an {@code ImmutableRangeSet} representing the union of the specified ranges.

 <p>This is the smallest {@code RangeSet} which encloses each of the specified ranges. Duplicate
 or connected ranges are permitted, and will be coalesced in the result.

 @since 21.0]]>
      </doc>
    </method>
    <method name="intersects" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherRange" type="com.google.common.collect.Range&lt;C&gt;"/>
    </method>
    <method name="encloses" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherRange" type="com.google.common.collect.Range&lt;C&gt;"/>
    </method>
    <method name="rangeContaining" return="Range"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="other" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="removeAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="removeAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Unsupported operation.">
      <param name="other" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the {@code RangeSet} unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="asRanges" return="com.google.common.collect.ImmutableSet&lt;com.google.common.collect.Range&lt;C&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asDescendingSetOfRanges" return="com.google.common.collect.ImmutableSet&lt;com.google.common.collect.Range&lt;C&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="complement" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="union" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a new range set consisting of the union of this range set and {@code other}.

 <p>This is essentially the same as {@code TreeRangeSet.create(this).addAll(other)} except it
 returns an {@code ImmutableRangeSet}.

 @since 21.0]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a new range set consisting of the intersection of this range set and {@code other}.

 <p>This is essentially the same as {@code
 TreeRangeSet.create(this).removeAll(other.complement())} except it returns an {@code
 ImmutableRangeSet}.

 @since 21.0]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a new range set consisting of the difference of this range set and {@code other}.

 <p>This is essentially the same as {@code TreeRangeSet.create(this).removeAll(other)} except it
 returns an {@code ImmutableRangeSet}.

 @since 21.0]]>
      </doc>
    </method>
    <method name="subRangeSet" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a view of the intersection of this range set with the given range.]]>
      </doc>
    </method>
    <method name="asSet" return="com.google.common.collect.ImmutableSortedSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="com.google.common.collect.DiscreteDomain&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns an {@link ImmutableSortedSet} containing the same values in the given domain
 {@linkplain RangeSet#contains contained} by this range set.

 <p><b>Note:</b> {@code a.asSet(d).equals(b.asSet(d))} does not imply {@code a.equals(b)}! For
 example, {@code a} and {@code b} could be {@code [2..4]} and {@code (1..5)}, or the empty
 ranges {@code [3..3)} and {@code [4..4)}.

 <p><b>Warning:</b> Be extremely careful what you do with the {@code asSet} view of a large
 range set (such as {@code ImmutableRangeSet.of(Range.greaterThan(0))}). Certain operations on
 such a set can be performed efficiently, but others (such as {@link Set#hashCode} or {@link
 Collections#frequency}) can cause major performance problems.

 <p>The returned set's {@link Object#toString} method returns a shorthand form of the set's
 contents, such as {@code "[1..100]}"}.

 @throws IllegalArgumentException if neither this range nor the domain has a lower bound, or if
     neither has an upper bound]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableRangeSet.Builder&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder for an immutable range set.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link RangeSet} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 @author Louis Wasserman
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableRangeSet -->
  <!-- start class com.google.common.collect.ImmutableRangeSet.Builder -->
  <class name="ImmutableRangeSet.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableRangeSet.Builder&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Add the specified range to this builder. Adjacent ranges are permitted and will be merged,
 but overlapping ranges will cause an exception when {@link #build()} is called.

 @throws IllegalArgumentException if {@code range} is empty]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableRangeSet.Builder&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Add all ranges from the specified range set to this builder. Adjacent ranges are permitted
 and will be merged, but overlapping ranges will cause an exception when {@link #build()} is
 called.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableRangeSet.Builder&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Add all of the specified ranges to this builder. Adjacent ranges are permitted and will be
 merged, but overlapping ranges will cause an exception when {@link #build()} is called.

 @throws IllegalArgumentException if any inserted ranges are empty
 @since 21.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code ImmutableRangeSet} containing the ranges added to this builder.

 @throws IllegalArgumentException if any input ranges have nonempty overlap]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for immutable range sets.

 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableRangeSet.Builder -->
  <!-- start class com.google.common.collect.ImmutableSet -->
  <class name="ImmutableSet" extends="com.google.common.collect.ImmutableCollection&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set&lt;E&gt;"/>
    <method name="toImmutableSet" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableSet&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code
 ImmutableSet}. Elements appear in the resulting set in the encounter order of the stream; if
 the stream contains duplicates (according to {@link Object#equals(Object)}), only the first
 duplicate in encounter order will appear in the result.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable set. Preferred over {@link Collections#emptySet} for code
 consistency, and because the return type conveys the immutability guarantee.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given element. Preferred over {@link
 Collections#singleton} for code consistency, {@code null} rejection, and because the return
 type conveys the immutability guarantee.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, minus duplicates, in the order each was
 first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, minus duplicates, in the order each was
 first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, minus duplicates, in the order each was
 first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, minus duplicates, in the order each was
 first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except
 the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="others" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set containing the given elements, minus duplicates, in the order each was
 first specified. That is, if multiple elements are {@linkplain Object#equals equal}, all except
 the first are ignored.

 <p>The array {@code others} must not be longer than {@code Integer.MAX_VALUE - 6}.

 @since 3.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing each of {@code elements}, minus duplicates, in the order
 each appears first in the source collection.

 <p><b>Performance note:</b> This method will sometimes recognize that the actual copy operation
 is unnecessary; for example, {@code copyOf(copyOf(anArrayList))} will copy the data only once.
 This reduces the expense of habitually making defensive copies at API boundaries. However, the
 precise conditions for skipping the copy operation are undefined.

 @throws NullPointerException if any of {@code elements} is null
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing each of {@code elements}, minus duplicates, in the order
 each appears first in the source iterable. This method iterates over {@code elements} only
 once.

 <p><b>Performance note:</b> This method will sometimes recognize that the actual copy operation
 is unnecessary; for example, {@code copyOf(copyOf(anArrayList))} should copy the data only
 once. This reduces the expense of habitually making defensive copies at API boundaries.
 However, the precise conditions for skipping the copy operation are undefined.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set containing each of {@code elements}, minus duplicates, in the order
 each appears first in the source iterator.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set containing each of {@code elements}, minus duplicates, in the order
 each appears first in the source array.

 @throws NullPointerException if any of {@code elements} is null
 @since 3.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asList" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder} constructor.]]>
      </doc>
    </method>
    <method name="builderWithExpectedSize" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Returns a new builder, expecting the specified number of distinct elements to be added.

 <p>If {@code expectedSize} is exactly the number of distinct elements added to the builder
 before {@link Builder#build} is called, the builder is likely to perform better than an unsized
 {@link #builder()} would have.

 <p>It is not specified if any performance benefits apply if {@code expectedSize} is close to,
 but not exactly, the number of distinct elements added to the builder.

 @since 23.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Set} whose contents will never change, with many other important properties detailed at
 {@link ImmutableCollection}.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSet -->
  <!-- start class com.google.common.collect.ImmutableSet.Builder -->
  <class name="ImmutableSet.Builder" extends="com.google.common.collect.ImmutableCollection.ArrayBasedBuilder&lt;E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableSet#builder}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSet}. If the {@code ImmutableSet} already
 contains {@code element}, then {@code add} has no effect (only the previously added element
 is retained).

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet}, ignoring duplicate
 elements (only the first duplicate element is added).

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet}, ignoring duplicate
 elements (only the first duplicate element is added).

 @param elements the {@code Iterable} to add to the {@code ImmutableSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSet}, ignoring duplicate
 elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSet} based on the contents of the {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating {@code ImmutableSet} instances. Example:

 {@snippet :
 static final ImmutableSet<Color> GOOGLE_COLORS =
     ImmutableSet.<Color>builder()
         .addAll(WEBSAFE_COLORS)
         .add(new Color(0, 191, 255))
         .build();
 }

 <p>Elements appear in the resulting set in the same order they were first added to the builder.

 <p>Building does not change the state of the builder, so it is still possible to add more
 elements and to build again.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSet.Builder -->
  <!-- start class com.google.common.collect.ImmutableSetMultimap -->
  <class name="ImmutableSetMultimap" extends="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <method name="toImmutableSetMultimap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableSetMultimap}
 whose keys and values are the result of applying the provided mapping functions to the input
 elements.

 <p>For streams with defined encounter order (as defined in the Ordering section of the {@link
 java.util.stream} Javadoc), that order is preserved, but entries are <a
 href="ImmutableMultimap.html#iteration">grouped by key</a>.

 <p>Example:

 {@snippet :
 static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =
     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
         .collect(toImmutableSetMultimap(str -> str.charAt(0), str -> str.substring(1)));

 // is equivalent to

 static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =
     new ImmutableSetMultimap.Builder<Character, String>()
         .put('b', "anana")
         .putAll('a', "pple", "sparagus")
         .putAll('c', "arrot", "herry")
         .build();
 }

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="flatteningToImmutableSetMultimap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valuesFunction" type="java.util.function.Function&lt;? super T, ? extends java.util.stream.Stream&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} accumulating entries into an {@code ImmutableSetMultimap}. Each
 input element is mapped to a key and a stream of values, each of which are put into the
 resulting {@code Multimap}, in the encounter order of the stream and the encounter order of the
 streams of values.

 <p>Example:

 {@snippet :
 static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =
     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
         .collect(
             flatteningToImmutableSetMultimap(
                  str -> str.charAt(0),
                  str -> str.substring(1).chars().mapToObj(c -> (char) c));

 // is equivalent to

 static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =
     ImmutableSetMultimap.<Character, Character>builder()
         .putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'))
         .putAll('a', Arrays.asList('p', 'p', 'l', 'e'))
         .putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'))
         .putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'))
         .putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'))
         .build();

 // after deduplication, the resulting multimap is equivalent to

 static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =
     ImmutableSetMultimap.<Character, Character>builder()
         .putAll('b', Arrays.asList('a', 'n'))
         .putAll('a', Arrays.asList('p', 'l', 'e', 's', 'a', 'r', 'g', 'u'))
         .putAll('c', Arrays.asList('a', 'r', 'o', 't', 'h', 'e', 'y'))
         .build();
 }

 }

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty multimap.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order. Repeated occurrences of
 an entry (according to {@link Object#equals}) after the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order. Repeated occurrences of
 an entry (according to {@link Object#equals}) after the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order. Repeated occurrences of
 an entry (according to {@link Object#equals}) after the first are ignored.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the given entries, in order. Repeated occurrences of
 an entry (according to {@link Object#equals}) after the first are ignored.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@link Builder}.]]>
      </doc>
    </method>
    <method name="builderWithExpectedKeys" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Returns a new builder with a hint for how many distinct keys are expected to be added. The
 generated builder is equivalent to that returned by {@link #builder}, but may perform better if
 {@code expectedKeys} is a good estimate.

 @throws IllegalArgumentException if {@code expectedKeys} is negative
 @since 33.3.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set multimap containing the same mappings as {@code multimap}. The
 generated multimap's key and value orderings correspond to the iteration ordering of the {@code
 multimap.asMap()} view. Repeated occurrences of an entry in the multimap after the first are
 ignored.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code multimap} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an immutable multimap containing the specified entries. The returned multimap iterates
 over keys in the order they were first encountered in the input, and the values for each key
 are iterated in the order they were encountered. If two values for the same key are {@linkplain
 Object#equals equal}, the first value encountered is used.

 @throws NullPointerException if any key, value, or entry is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="get" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns an immutable set of the values for the given key. If no mappings in the multimap have
 the provided key, an empty immutable set is returned. The values are in the same order as the
 parameters used to build this multimap.]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.collect.ImmutableSetMultimap&lt;V, K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because an inverse of a set multimap cannot contain multiple pairs with the same key and
 value, this method returns an {@code ImmutableSetMultimap} rather than the {@code
 ImmutableMultimap} specified in the {@code ImmutableMultimap} class.]]>
      </doc>
    </method>
    <method name="removeAll" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="replaceValues" return="com.google.common.collect.ImmutableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the multimap unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="entries" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of all key-value pairs in the multimap. Its iterator traverses
 the values for the first key, the values for the second key, and so on.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link SetMultimap} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 <p><b>Warning:</b> As in all {@link SetMultimap}s, do not modify either a key <i>or a value</i>
 of a {@code ImmutableSetMultimap} in a way that affects its {@link Object#equals} behavior.
 Undefined behavior and bugs will result.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Mike Ward
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSetMultimap -->
  <!-- start class com.google.common.collect.ImmutableSetMultimap.Builder -->
  <class name="ImmutableSetMultimap.Builder" extends="com.google.common.collect.ImmutableMultimap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableSetMultimap#builder}.]]>
      </doc>
    </constructor>
    <method name="expectedValuesPerKey" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Note that {@code expectedValuesPerKey} is taken to mean the expected number of
 <i>distinct</i> values per key.

 @since 33.3.0]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds a key-value mapping to the built multimap if it is not already present.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds an entry to the built multimap if it is not already present.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 19.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="values" type="V[]"/>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <method name="orderKeysBy" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 8.0]]>
      </doc>
    </method>
    <method name="orderValuesBy" return="com.google.common.collect.ImmutableSetMultimap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated multimap's values for each key.

 <p>If this method is called, the sets returned by the {@code get()} method of the generated
 multimap and its {@link Multimap#asMap()} view are {@link ImmutableSortedSet} instances.
 However, serialization does not preserve that property, though it does maintain the key and
 value ordering.

 @since 8.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable set multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable {@code SetMultimap} instances, especially {@code public static
 final} multimaps ("constant multimaps"). Example:

 {@snippet :
 static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP =
     new ImmutableSetMultimap.Builder<String, Integer>()
         .put("one", 1)
         .putAll("several", 1, 2, 3)
         .putAll("many", 1, 2, 3, 4, 5)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple multimaps in series. Each multimap contains the key-value mappings in the previously
 created multimaps.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSetMultimap.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedMap -->
  <class name="ImmutableSortedMap" extends="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableMap&lt;K, V&gt;"/>
    <method name="toImmutableSortedMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableSortedMap} whose
 keys and values are the result of applying the provided mapping functions to the input
 elements. The generated map is sorted by the specified comparator.

 <p>If the mapped keys contain duplicates (according to the specified comparator), an {@code
 IllegalArgumentException} is thrown when the collection operation is performed. (This differs
 from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)}, which
 throws an {@code IllegalStateException}.)

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableSortedMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="mergeFunction" type="java.util.function.BinaryOperator&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableSortedMap} whose
 keys and values are the result of applying the provided mapping functions to the input
 elements.

 <p>If the mapped keys contain duplicates (according to the comparator), the values are merged
 using the specified merging function. Entries will appear in the encounter order of the first
 occurrence of the key.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty sorted map.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Returns an immutable map containing a single entry.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if the two keys are equal according to their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v6" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v7" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v8" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v9" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering
 @since 31.0]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k1" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v9" type="V"/>
      <param name="k10" type="K extends java.lang.Comparable&lt;? super K&gt;"/>
      <param name="v10" type="V"/>
      <doc>
      <![CDATA[Returns an immutable sorted map containing the given entries, sorted by the natural ordering of
 their keys.

 @throws IllegalArgumentException if any two keys are equal according to their natural ordering
 @since 31.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}, sorted by the natural
 ordering of the keys.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is not type-safe, as it may be called on a map with keys that are not mutually
 comparable.

 @throws ClassCastException if the keys in {@code map} are not mutually comparable
 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to their natural ordering]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as {@code map}, with keys sorted by the
 provided comparator.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to the comparator]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, with keys sorted by their natural
 ordering.

 <p>This method is not type-safe, as it may be called on a map with keys that are not mutually
 comparable.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to the comparator
 @since 19.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the given entries, with keys sorted by the provided
 comparator.

 @throws NullPointerException if any key or value in {@code map} is null
 @throws IllegalArgumentException if any two keys are equal according to the comparator
 @since 19.0]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map containing the same entries as the provided sorted map, with the same
 ordering.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps whose keys are ordered by their natural
 ordering. The sorted maps use {@link Ordering#natural()} as the comparator.]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps with an explicit comparator. If the
 comparator has a more general type than the map's keys, such as creating a {@code
 SortedMap<Integer, String>} with a {@code Comparator<Number>}, use the {@link Builder}
 constructor instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted maps whose keys are ordered by the reverse of
 their natural ordering.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="entrySet" return="com.google.common.collect.ImmutableSet&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of the mappings in this map, sorted by the key ordering.]]>
      </doc>
    </method>
    <method name="keySet" return="com.google.common.collect.ImmutableSortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable sorted set of the keys in this map.]]>
      </doc>
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable collection of the values in this map, sorted by the ordering of the
 corresponding keys.]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the keys, which is {@link Ordering#natural()} when the
 natural ordering of the keys is used. Note that its behavior is not consistent with {@link
 TreeMap#comparator()}, which returns {@code null} to indicate natural ordering.]]>
      </doc>
    </method>
    <method name="firstKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lastKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys are less
 than {@code toKey}.

 <p>The {@link SortedMap#headMap} documentation states that a submap of a submap throws an
 {@link IllegalArgumentException} if passed a {@code toKey} greater than an earlier {@code
 toKey}. However, this method doesn't throw an exception in that situation, but instead keeps
 the original {@code toKey}.]]>
      </doc>
    </method>
    <method name="headMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys are less
 than (or equal to, if {@code inclusive}) {@code toKey}.

 <p>The {@link SortedMap#headMap} documentation states that a submap of a submap throws an
 {@link IllegalArgumentException} if passed a {@code toKey} greater than an earlier {@code
 toKey}. However, this method doesn't throw an exception in that situation, but instead keeps
 the original {@code toKey}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="subMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys ranges
 from {@code fromKey}, inclusive, to {@code toKey}, exclusive.

 <p>The {@link SortedMap#subMap} documentation states that a submap of a submap throws an {@link
 IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code fromKey}.
 However, this method doesn't throw an exception in that situation, but instead keeps the
 original {@code fromKey}. Similarly, this method keeps the original {@code toKey}, instead of
 throwing an exception, if passed a {@code toKey} greater than an earlier {@code toKey}.]]>
      </doc>
    </method>
    <method name="subMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toKey" type="K"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys ranges
 from {@code fromKey} to {@code toKey}, inclusive or exclusive as indicated by the boolean
 flags.

 <p>The {@link SortedMap#subMap} documentation states that a submap of a submap throws an {@link
 IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code fromKey}.
 However, this method doesn't throw an exception in that situation, but instead keeps the
 original {@code fromKey}. Similarly, this method keeps the original {@code toKey}, instead of
 throwing an exception, if passed a {@code toKey} greater than an earlier {@code toKey}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="tailMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys are
 greater than or equals to {@code fromKey}.

 <p>The {@link SortedMap#tailMap} documentation states that a submap of a submap throws an
 {@link IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code
 fromKey}. However, this method doesn't throw an exception in that situation, but instead keeps
 the original {@code fromKey}.]]>
      </doc>
    </method>
    <method name="tailMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[This method returns a {@code ImmutableSortedMap}, consisting of the entries whose keys are
 greater than (or equal to, if {@code inclusive}) {@code fromKey}.

 <p>The {@link SortedMap#tailMap} documentation states that a submap of a submap throws an
 {@link IllegalArgumentException} if passed a {@code fromKey} less than an earlier {@code
 fromKey}. However, this method doesn't throw an exception in that situation, but instead keeps
 the original {@code fromKey}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="lowerEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="lowerKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="floorEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="floorKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="ceilingEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="ceilingKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="higherEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="higherKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
    </method>
    <method name="firstEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lastEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirstEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="descendingMap" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="navigableKeySet" return="com.google.common.collect.ImmutableSortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingKeySet" return="com.google.common.collect.ImmutableSortedSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toImmutableMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedMap#toImmutableSortedMap}.">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Not supported. Use {@link #toImmutableSortedMap}, which offers better type-safety, instead.
 This method exists only to hide {@link ImmutableMap#toImmutableMap} from consumers of {@code
 ImmutableSortedMap}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.
 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedMap#toImmutableSortedMap}.">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="mergeFunction" type="java.util.function.BinaryOperator&lt;V&gt;"/>
      <doc>
      <![CDATA[Not supported. Use {@link #toImmutableSortedMap}, which offers better type-safety, instead.
 This method exists only to hide {@link ImmutableMap#toImmutableMap} from consumers of {@code
 ImmutableSortedMap}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.
 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedMap#naturalOrder}, which offers better type-safety.">
      <doc>
      <![CDATA[Not supported. Use {@link #naturalOrder}, which offers better type-safety, instead. This method
 exists only to hide {@link ImmutableMap#builder} from consumers of {@code ImmutableSortedMap}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedMap#naturalOrder}, which offers better type-safety.]]>
      </doc>
    </method>
    <method name="builderWithExpectedSize" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Not supported for ImmutableSortedMap.">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Not supported for ImmutableSortedMap.

 @throws UnsupportedOperationException always
 @deprecated Not supported for ImmutableSortedMap.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass a key of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain a non-{@code Comparable}
 key.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this dummy
 version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass a key of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls to will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K"/>
      <param name="v9" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.lEsS_tHaN/b>">
      <param name="k1" type="K"/>
      <param name="v1" type="V"/>
      <param name="k2" type="K"/>
      <param name="v2" type="V"/>
      <param name="k3" type="K"/>
      <param name="v3" type="V"/>
      <param name="k4" type="K"/>
      <param name="v4" type="V"/>
      <param name="k5" type="K"/>
      <param name="v5" type="V"/>
      <param name="k6" type="K"/>
      <param name="v6" type="V"/>
      <param name="k7" type="K"/>
      <param name="v7" type="V"/>
      <param name="k8" type="K"/>
      <param name="v8" type="V"/>
      <param name="k9" type="K"/>
      <param name="v9" type="V"/>
      <param name="k10" type="K"/>
      <param name="v10" type="V"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a map that may contain non-{@code Comparable}
 keys.</b> Proper calls will resolve to the version in {@code ImmutableSortedMap}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass keys of type {@code Comparable} to use {@link
     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
     Comparable, Object, Comparable, Object)}.</b>]]>
      </doc>
    </method>
    <method name="ofEntries" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@code ImmutableSortedMap.copyOf(ImmutableMap.ofEntries(...))}.">
      <param name="entries" type="java.util.Map.Entry[]"/>
      <doc>
      <![CDATA[Not supported. Use {@code ImmutableSortedMap.copyOf(ImmutableMap.ofEntries(...))}.

 @deprecated Use {@code ImmutableSortedMap.copyOf(ImmutableMap.ofEntries(...))}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link NavigableMap} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 <p><b>Warning:</b> as with any sorted collection, you are strongly advised not to use a {@link
 Comparator} or {@link Comparable} type whose comparison behavior is <i>inconsistent with
 equals</i>. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero
 <i>if and only if</i> {@code a.equals(b)}. If this advice is not followed, the resulting map will
 not correctly obey its specification.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0 (implements {@code NavigableMap} since 12.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMap -->
  <!-- start class com.google.common.collect.ImmutableSortedMap.Builder -->
  <class name="ImmutableSortedMap.Builder" extends="com.google.common.collect.ImmutableMap.Builder&lt;K, V&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder" type="java.util.Comparator&lt;? super K&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableSortedMap#orderedBy}.]]>
      </doc>
    </constructor>
    <method name="put" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate keys, according to the
 comparator (which might be the keys' natural order), are not allowed, and will cause {@link
 #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="java.util.Map.Entry&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds the given {@code entry} to the map, making it immutable if necessary. Duplicate keys,
 according to the comparator (which might be the keys' natural order), are not allowed, and
 will cause {@link #build} to fail.

 @since 11.0]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given map's keys and values in the built map. Duplicate keys, according
 to the comparator (which might be the keys' natural order), are not allowed, and will cause
 {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code map} is null]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable&lt;? extends java.util.Map.Entry&lt;? extends K, ? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Adds all the given entries to the built map. Duplicate keys, according to the comparator
 (which might be the keys' natural order), are not allowed, and will cause {@link #build} to
 fail.

 @throws NullPointerException if any key, value, or entry is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="orderEntriesByValue" return="com.google.common.collect.ImmutableSortedMap.Builder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported by ImmutableSortedMap.Builder.">
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Throws an {@code UnsupportedOperationException}.

 @since 19.0
 @deprecated Unsupported by ImmutableSortedMap.Builder.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable sorted map.

 <p>Prefer the equivalent method {@link #buildOrThrow()} to make it explicit that the method
 will throw an exception if there are duplicate keys. The {@code build()} method will soon be
 deprecated.

 @throws IllegalArgumentException if any two keys are equal according to the comparator (which
     might be the keys' natural order)]]>
      </doc>
    </method>
    <method name="buildOrThrow" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable sorted map, or throws an exception if any two keys are
 equal.

 @throws IllegalArgumentException if any two keys are equal according to the comparator (which
     might be the keys' natural order)
 @since 31.0]]>
      </doc>
    </method>
    <method name="buildKeepingLast" return="com.google.common.collect.ImmutableSortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="This method is not currently implemented, and may never be.">
      <doc>
      <![CDATA[Throws UnsupportedOperationException. A future version may support this operation. Then the
 value for any given key will be the one that was last supplied in a {@code put} operation for
 that key.

 @throws UnsupportedOperationException always
 @since 31.1
 @deprecated This method is not currently implemented, and may never be.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable sorted map instances, especially {@code public static final}
 maps ("constant maps"). Example:

 {@snippet :
 static final ImmutableSortedMap<Integer, String> INT_TO_WORD =
     new ImmutableSortedMap.Builder<Integer, String>(Ordering.natural())
         .put(1, "one")
         .put(2, "two")
         .put(3, "three")
         .buildOrThrow();
 }

 <p>For <i>small</i> immutable sorted maps, the {@code ImmutableSortedMap.of()} methods are even
 more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #buildOrThrow} multiple times to
 build multiple maps in series. Each map is a superset of the maps created before it.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMap.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedMultiset -->
  <class name="ImmutableSortedMultiset" extends="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SortedMultiset&lt;E&gt;"/>
    <method name="toImmutableSortedMultiset" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code
 ImmutableMultiset}. Elements are sorted by the specified comparator.

 <p><b>Warning:</b> {@code comparator} should be <i>consistent with {@code equals}</i> as
 explained in the {@link Comparator} documentation.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableSortedMultiset" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elementFunction" type="java.util.function.Function&lt;? super T, ? extends E&gt;"/>
      <param name="countFunction" type="java.util.function.ToIntFunction&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates elements into an {@code ImmutableSortedMultiset}
 whose elements are the result of applying {@code elementFunction} to the inputs, with counts
 equal to the result of applying {@code countFunction} to the inputs.

 <p>If the mapped elements contain duplicates (according to {@code comparator}), the first
 occurrence in encounter order appears in the resulting multiset, with count equal to the sum of
 the outputs of {@code countFunction.applyAsInt(t)} for each {@code t} mapped to that element.

 @since 33.2.0 (available since 22.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable sorted multiset.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing a single element.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e6" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="remaining" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering. To create a copy of a {@code SortedMultiset} that preserves the comparator, call
 {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.

 <p>Note that if {@code s} is a {@code Multiset<String>}, then {@code
 ImmutableSortedMultiset.copyOf(s)} returns an {@code ImmutableSortedMultiset<String>}
 containing each of the strings in {@code s}, while {@code ImmutableSortedMultiset.of(s)}
 returns an {@code ImmutableSortedMultiset<Multiset<String>>} containing one element (the given
 multiset itself).

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is not type-safe, as it may be called on elements that are not mutually
 comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by their natural
 ordering.

 <p>This method is not type-safe, as it may be called on elements that are not mutually
 comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by the given {@code
 Comparator}.

 @throws NullPointerException if {@code comparator} or any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the given elements sorted by the given {@code
 Comparator}. This method iterates over {@code elements} at most once.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if {@code comparator} or any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedMultiset" type="com.google.common.collect.SortedMultiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted multiset containing the elements of a sorted multiset, sorted by
 the same {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always
 uses the natural ordering of the elements.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is safe to use even when {@code sortedMultiset} is a synchronized or concurrent
 collection that is currently being modified by another thread.

 @throws NullPointerException if {@code sortedMultiset} or any of its elements is null]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="elementSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="descendingMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirstEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="Multiset.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This implementation is guaranteed to throw an {@link UnsupportedOperationException}.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="headMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="subMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E"/>
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBound" type="E"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="tailMultiset" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted multisets with an explicit comparator. If the
 comparator has a more general type than the set being generated, such as creating a {@code
 SortedMultiset<Integer>} with a {@code Comparator<Number>}, use the {@link Builder} constructor
 instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted multisets whose elements are ordered by the
 reverse of their natural ordering.

 <p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code
 Comparable<? super E>} in order to accommodate users of obsolete javac versions affected by <a
 href="https://bugs.openjdk.org/browse/JDK-6468354">JDK-6468354</a>.]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted multisets whose elements are ordered by their
 natural ordering. The sorted multisets use {@link Ordering#natural()} as the comparator. This
 method provides more type-safety than {@link #builder}, as it can be called only for classes
 that implement {@link Comparable}.

 <p>Note: the type parameter {@code E} extends {@code Comparable<?>} rather than {@code
 Comparable<? super E>} in order to accommodate users of obsolete javac versions affected by <a
 href="https://bugs.openjdk.org/browse/JDK-6468354">JDK-6468354</a>.]]>
      </doc>
    </method>
    <method name="toImmutableMultiset" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableMultiset&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.">
      <doc>
      <![CDATA[Not supported. Use {@link #toImmutableSortedMultiset} instead. This method exists only to hide
 {@link ImmutableMultiset#toImmutableMultiset} from consumers of {@code
 ImmutableSortedMultiset}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.
 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableMultiset" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMultiset&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.">
      <param name="elementFunction" type="java.util.function.Function&lt;? super T, ? extends E&gt;"/>
      <param name="countFunction" type="java.util.function.ToIntFunction&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Not supported. Use {@link #toImmutableSortedMultiset} instead. This method exists only to hide
 {@link ImmutableMultiset#toImmutableMultiset} from consumers of {@code
 ImmutableSortedMultiset}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.
 @since 33.2.0 (available since 22.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedMultiset#naturalOrder}, which offers better type-safety.">
      <doc>
      <![CDATA[Not supported. Use {@link #naturalOrder}, which offers better type-safety, instead. This method
 exists only to hide {@link ImmutableMultiset#builder} from consumers of {@code
 ImmutableSortedMultiset}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedMultiset#naturalOrder}, which offers better type-safety.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass a parameter of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable)}.lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a multiset that may contain a non-{@code
 Comparable} element.</b> Proper calls will resolve to the version in {@code
 ImmutableSortedMultiset}, not this dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass a parameter of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable)}.lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a multiset that may contain a non-{@code
 Comparable} element.</b> Proper calls will resolve to the version in {@code
 ImmutableSortedMultiset}, not this dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable)}.lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a multiset that may contain a non-{@code
 Comparable} element.</b> Proper calls will resolve to the version in {@code
 ImmutableSortedMultiset}, not this dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable)}. lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a multiset that may contain a non-{@code
 Comparable} element.</b> Proper calls will resolve to the version in {@code
 ImmutableSortedMultiset}, not this dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable)}. </b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable)} .
     lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a multiset that may contain a non-{@code
 Comparable} element.</b> Proper calls will resolve to the version in {@code
 ImmutableSortedMultiset}, not this dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable)} .
     </b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable,
     Comparable, Comparable...)} . lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="remaining" type="E[]"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a multiset that may contain a non-{@code
 Comparable} element.</b> Proper calls will resolve to the version in {@code
 ImmutableSortedMultiset}, not this dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable,
     Comparable, Comparable...)} . </b>]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedMultiset&lt;Z&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#copyOf(Comparable[])}.lEsS_tHaN/b>">
      <param name="elements" type="Z[]"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a multiset that may contain non-{@code
 Comparable} elements.</b> Proper calls will resolve to the version in {@code
 ImmutableSortedMultiset}, not this dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass parameters of type {@code Comparable} to use {@link
     ImmutableSortedMultiset#copyOf(Comparable[])}.</b>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link SortedMultiset} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 <p><b>Warning:</b> as with any sorted collection, you are strongly advised not to use a {@link
 Comparator} or {@link Comparable} type whose comparison behavior is <i>inconsistent with
 equals</i>. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero
 <i>if and only if</i> {@code a.equals(b)}. If this advice is not followed, the resulting
 collection will not correctly obey its specification.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Louis Wasserman
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMultiset -->
  <!-- start class com.google.common.collect.ImmutableSortedMultiset.Builder -->
  <class name="ImmutableSortedMultiset.Builder" extends="com.google.common.collect.ImmutableMultiset.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder" type="java.util.Comparator&lt;? super E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableSortedMultiset#orderedBy(Comparator)}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSortedMultiset}.

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addCopies" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this {@code ImmutableSortedMultiset}.

 @param element the element to add
 @param occurrences the number of occurrences of the element to add. May be zero, in which
     case no change will be made.
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation
     would result in more than {@link Integer#MAX_VALUE} occurrences of the element]]>
      </doc>
    </method>
    <method name="setCount" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the element attains the
 desired count.

 @param element the element to add or remove occurrences of
 @param count the desired count of the element in this multiset
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null
 @throws IllegalArgumentException if {@code count} is negative]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.

 @param elements the {@code Iterable} to add to the {@code ImmutableSortedMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedMultiset.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedMultiset}.

 @param elements the elements to add to the {@code ImmutableSortedMultiset}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} is null or contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSortedMultiset} based on the contents of the {@code
 Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable multiset instances, especially {@code public static final}
 multisets ("constant multisets"). Example:

 {@snippet :
 public static final ImmutableSortedMultiset<Bean> BEANS =
     new ImmutableSortedMultiset.Builder<Bean>(colorComparator())
         .addCopies(Bean.COCOA, 4)
         .addCopies(Bean.GARDEN, 6)
         .addCopies(Bean.RED, 8)
         .addCopies(Bean.BLACK_EYED, 10)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple multisets in series.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedMultiset.Builder -->
  <!-- start class com.google.common.collect.ImmutableSortedSet -->
  <class name="ImmutableSortedSet" extends="com.google.common.collect.ImmutableSet&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.NavigableSet&lt;E&gt;"/>
    <implements name="com.google.common.collect.SortedIterable&lt;E&gt;"/>
    <method name="toImmutableSortedSet" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableSortedSet&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code
 ImmutableSortedSet}, ordered by the specified comparator.

 <p>If the elements contain duplicates (according to the comparator), only the first duplicate
 in encounter order will appear in the result.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty immutable sorted set.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing a single element.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
 one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
 one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
 one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
 one specified is included.

 @throws NullPointerException if any element is null]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e1" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e2" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e3" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e4" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e5" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="e6" type="E extends java.lang.Comparable&lt;? super E&gt;"/>
      <param name="remaining" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
 one specified is included.

 @throws NullPointerException if any element is null
 @since 3.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@link Comparable#compareTo}, only the first
 one specified is included.

 @throws NullPointerException if any of {@code elements} is null
 @since 3.0]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@code compareTo()}, only the first one
 specified is included. To create a copy of a {@code SortedSet} that preserves the comparator,
 call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.

 <p>Note that if {@code s} is a {@code Set<String>}, then {@code ImmutableSortedSet.copyOf(s)}
 returns an {@code ImmutableSortedSet<String>} containing each of the strings in {@code s},
 while {@code ImmutableSortedSet.of(s)} returns an {@code ImmutableSortedSet<Set<String>>}
 containing one element (the given set itself).

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is not type-safe, as it may be called on elements that are not mutually
 comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@code compareTo()}, only the first one
 specified is included. To create a copy of a {@code SortedSet} that preserves the comparator,
 call {@link #copyOfSorted} instead. This method iterates over {@code elements} at most once.

 <p>Note that if {@code s} is a {@code Set<String>}, then {@code ImmutableSortedSet.copyOf(s)}
 returns an {@code ImmutableSortedSet<String>} containing each of the strings in {@code s},
 while {@code ImmutableSortedSet.of(s)} returns an {@code ImmutableSortedSet<Set<String>>}
 containing one element (the given set itself).

 <p><b>Note:</b> Despite what the method name suggests, if {@code elements} is an {@code
 ImmutableSortedSet}, it may be returned instead of a copy.

 <p>This method is not type-safe, as it may be called on elements that are not mutually
 comparable.

 <p>This method is safe to use even when {@code elements} is a synchronized or concurrent
 collection that is currently being modified by another thread.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by their natural ordering.
 When multiple elements are equivalent according to {@code compareTo()}, only the first one
 specified is included.

 <p>This method is not type-safe, as it may be called on elements that are not mutually
 comparable.

 @throws ClassCastException if the elements are not mutually comparable
 @throws NullPointerException if any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by the given {@code
 Comparator}. When multiple elements are equivalent according to {@code compareTo()}, only the
 first one specified is included.

 @throws NullPointerException if {@code comparator} or any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by the given {@code
 Comparator}. When multiple elements are equivalent according to {@code compare()}, only the
 first one specified is included. This method iterates over {@code elements} at most once.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 @throws NullPointerException if {@code comparator} or any of {@code elements} is null]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <param name="elements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the given elements sorted by the given {@code
 Comparator}. When multiple elements are equivalent according to {@code compareTo()}, only the
 first one specified is included.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is safe to use even when {@code elements} is a synchronized or concurrent
 collection that is currently being modified by another thread.

 @throws NullPointerException if {@code comparator} or any of {@code elements} is null
 @since 7.0 (source-compatible since 2.0)]]>
      </doc>
    </method>
    <method name="copyOfSorted" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedSet" type="java.util.SortedSet&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable sorted set containing the elements of a sorted set, sorted by the same
 {@code Comparator}. That behavior differs from {@link #copyOf(Iterable)}, which always uses the
 natural ordering of the elements.

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.

 <p>This method is safe to use even when {@code sortedSet} is a synchronized or concurrent
 collection that is currently being modified by another thread.

 @throws NullPointerException if {@code sortedSet} or any of its elements is null]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets with an explicit comparator. If the
 comparator has a more general type than the set being generated, such as creating a {@code
 SortedSet<Integer>} with a {@code Comparator<Number>}, use the {@link Builder} constructor
 instead.

 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="reverseOrder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets whose elements are ordered by the reverse
 of their natural ordering.]]>
      </doc>
    </method>
    <method name="naturalOrder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder that creates immutable sorted sets whose elements are ordered by their
 natural ordering. The sorted sets use {@link Ordering#natural()} as the comparator. This method
 provides more type-safety than {@link #builder}, as it can be called only for classes that
 implement {@link Comparable}.]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the elements, which is {@link Ordering#natural()} when the
 natural ordering of the elements is used. Note that its behavior is not consistent with {@link
 SortedSet#comparator()}, which returns {@code null} to indicate natural ordering.]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#headSet} documentation states that a subset of a subset throws an
 {@link IllegalArgumentException} if passed a {@code toElement} greater than an earlier {@code
 toElement}. However, this method doesn't throw an exception in that situation, but instead
 keeps the original {@code toElement}.]]>
      </doc>
    </method>
    <method name="headSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toElement" type="E"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="subSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="toElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#subSet} documentation states that a subset of a subset throws an {@link
 IllegalArgumentException} if passed a {@code fromElement} smaller than an earlier {@code
 fromElement}. However, this method doesn't throw an exception in that situation, but instead
 keeps the original {@code fromElement}. Similarly, this method keeps the original {@code
 toElement}, instead of throwing an exception, if passed a {@code toElement} greater than an
 earlier {@code toElement}.]]>
      </doc>
    </method>
    <method name="subSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="fromInclusive" type="boolean"/>
      <param name="toElement" type="E"/>
      <param name="toInclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="tailSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a serializable {@code ImmutableSortedSet}.

 <p>The {@link SortedSet#tailSet} documentation states that a subset of a subset throws an
 {@link IllegalArgumentException} if passed a {@code fromElement} smaller than an earlier {@code
 fromElement}. However, this method doesn't throw an exception in that situation, but instead
 keeps the original {@code fromElement}.]]>
      </doc>
    </method>
    <method name="tailSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromElement" type="E"/>
      <param name="inclusive" type="boolean"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="lower" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="floor" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="ceiling" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="higher" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="first" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="last" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the set unmodified.

 @since 12.0
 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the set unmodified.

 @since 12.0
 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="descendingSet" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="descendingIterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 12.0]]>
      </doc>
    </method>
    <method name="toImmutableSet" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableSet&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedSet#toImmutableSortedSet}.">
      <doc>
      <![CDATA[Not supported. Use {@link #toImmutableSortedSet} instead. This method exists only to hide
 {@link ImmutableSet#toImmutableSet} from consumers of {@code ImmutableSortedSet}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedSet#toImmutableSortedSet}.
 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link ImmutableSortedSet#naturalOrder}, which offers better type-safety.">
      <doc>
      <![CDATA[Not supported. Use {@link #naturalOrder}, which offers better type-safety, instead. This method
 exists only to hide {@link ImmutableSet#builder} from consumers of {@code ImmutableSortedSet}.

 @throws UnsupportedOperationException always
 @deprecated Use {@link ImmutableSortedSet#naturalOrder}, which offers better type-safety.]]>
      </doc>
    </method>
    <method name="builderWithExpectedSize" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Not supported by ImmutableSortedSet.">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Not supported. This method exists only to hide {@link ImmutableSet#builderWithExpectedSize}
 from consumers of {@code ImmutableSortedSet}.

 @throws UnsupportedOperationException always
 @deprecated Not supported by ImmutableSortedSet.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass a parameter of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable)}.lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable}
 element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass a parameter of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable)}.lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable}
 element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable, Comparable)}.lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable}
 element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable, Comparable)}.</b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable)}. lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable}
 element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable)}. </b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of( Comparable, Comparable, Comparable, Comparable, Comparable)}. lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable}
 element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of( Comparable, Comparable, Comparable, Comparable, Comparable)}. </b>]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable, Comparable,
     Comparable, Comparable...)}. lEsS_tHaN/b>">
      <param name="e1" type="E"/>
      <param name="e2" type="E"/>
      <param name="e3" type="E"/>
      <param name="e4" type="E"/>
      <param name="e5" type="E"/>
      <param name="e6" type="E"/>
      <param name="remaining" type="E[]"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a set that may contain a non-{@code Comparable}
 element.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable, Comparable,
     Comparable, Comparable...)}. </b>]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableSortedSet&lt;Z&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="lEsS_tHaNb>Pass parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#copyOf(Comparable[])}.lEsS_tHaN/b>">
      <param name="elements" type="Z[]"/>
      <doc>
      <![CDATA[Not supported. <b>You are attempting to create a set that may contain non-{@code Comparable}
 elements.</b> Proper calls will resolve to the version in {@code ImmutableSortedSet}, not this
 dummy version.

 @throws UnsupportedOperationException always
 @deprecated <b>Pass parameters of type {@code Comparable} to use {@link
     ImmutableSortedSet#copyOf(Comparable[])}.</b>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link NavigableSet} whose contents will never change, with many other important properties
 detailed at {@link ImmutableCollection}.

 <p><b>Warning:</b> as with any sorted collection, you are strongly advised not to use a {@link
 Comparator} or {@link Comparable} type whose comparison behavior is <i>inconsistent with
 equals</i>. That is, {@code a.compareTo(b)} or {@code comparator.compare(a, b)} should equal zero
 <i>if and only if</i> {@code a.equals(b)}. If this advice is not followed, the resulting
 collection will not correctly obey its specification.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0 (implements {@code NavigableSet} since 12.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedSet -->
  <!-- start class com.google.common.collect.ImmutableSortedSet.Builder -->
  <class name="ImmutableSortedSet.Builder" extends="com.google.common.collect.ImmutableSet.Builder&lt;E&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder" type="java.util.Comparator&lt;? super E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableSortedSet#orderedBy}.]]>
      </doc>
    </constructor>
    <method name="add" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds {@code element} to the {@code ImmutableSortedSet}. If the {@code ImmutableSortedSet}
 already contains {@code element}, then {@code add} has no effect. (only the previously added
 element is retained).

 @param element the element to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code element} is null]]>
      </doc>
    </method>
    <method name="add" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate
 elements (only the first duplicate element is added).

 @param elements the elements to add
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate
 elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSortedSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.collect.ImmutableSortedSet.Builder&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Adds each element of {@code elements} to the {@code ImmutableSortedSet}, ignoring duplicate
 elements (only the first duplicate element is added).

 @param elements the elements to add to the {@code ImmutableSortedSet}
 @return this {@code Builder} object
 @throws NullPointerException if {@code elements} contains a null element]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableSortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableSortedSet} based on the contents of the {@code
 Builder} and its comparator.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable sorted set instances, especially {@code public static final}
 sets ("constant sets"), with a given comparator. Example:

 {@snippet :
 public static final ImmutableSortedSet<Number> LUCKY_NUMBERS =
     new ImmutableSortedSet.Builder<Number>(ODDS_FIRST_COMPARATOR)
         .addAll(SINGLE_DIGIT_PRIMES)
         .add(42)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple sets in series. Each set is a superset of the set created before it.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableSortedSet.Builder -->
  <!-- start class com.google.common.collect.ImmutableTable -->
  <class name="ImmutableTable" extends="com.google.common.collect.AbstractTable&lt;R, C, V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="toImmutableTable" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableTable&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowFunction" type="java.util.function.Function&lt;? super T, ? extends R&gt;"/>
      <param name="columnFunction" type="java.util.function.Function&lt;? super T, ? extends C&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates elements into an {@code ImmutableTable}. Each
 input element is mapped to one cell in the returned table, with the rows, columns, and values
 generated by applying the specified functions.

 <p>The returned {@code Collector} will throw a {@code NullPointerException} at collection time
 if the row, column, or value functions return null on any input.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableTable" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableTable&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowFunction" type="java.util.function.Function&lt;? super T, ? extends R&gt;"/>
      <param name="columnFunction" type="java.util.function.Function&lt;? super T, ? extends C&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="mergeFunction" type="java.util.function.BinaryOperator&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates elements into an {@code ImmutableTable}. Each
 input element is mapped to one cell in the returned table, with the rows, columns, and values
 generated by applying the specified functions. If multiple inputs are mapped to the same row
 and column pair, they will be combined with the specified merging function in encounter order.

 <p>The returned {@code Collector} will throw a {@code NullPointerException} at collection time
 if the row, column, value, or merging functions return null on any input.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty immutable table.

 <p><b>Performance note:</b> the instance returned is a singleton.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Returns an immutable table containing a single cell.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable copy of the provided table.

 <p>The {@link Table#cellSet()} iteration order of the provided table determines the iteration
 ordering of all views in the returned table. Note that some views of the original table and the
 copied table may have different iteration orders. For more control over the ordering, create a
 {@link Builder} and call {@link Builder#orderRowsBy}, {@link Builder#orderColumnsBy}, and
 {@link Builder#putAll}

 <p>Despite the method name, this method attempts to avoid actually copying the data when it is
 safe to do so. The exact circumstances under which a copy will or will not be performed are
 undocumented and subject to change.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder. The generated builder is equivalent to the builder created by the {@link
 Builder#Builder() ImmutableTable.Builder()} constructor.]]>
      </doc>
    </method>
    <method name="cellSet" return="com.google.common.collect.ImmutableSet&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="com.google.common.collect.ImmutableCollection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="column" return="com.google.common.collect.ImmutableMap&lt;R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws NullPointerException if {@code columnKey} is {@code null}]]>
      </doc>
    </method>
    <method name="columnKeySet" return="com.google.common.collect.ImmutableSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="columnMap" return="com.google.common.collect.ImmutableMap&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The value {@code Map<R, V>} instances in the returned map are {@link ImmutableMap} instances
 as well.]]>
      </doc>
    </method>
    <method name="row" return="com.google.common.collect.ImmutableMap&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws NullPointerException if {@code rowKey} is {@code null}]]>
      </doc>
    </method>
    <method name="rowKeySet" return="com.google.common.collect.ImmutableSet&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="rowMap" return="com.google.common.collect.ImmutableMap&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The value {@code Map<C, V>} instances in the returned map are {@link ImmutableMap} instances
 as well.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the table unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Table} whose contents will never change, with many other important properties detailed
 at {@link ImmutableCollection}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/ImmutableCollectionsExplained">immutable collections</a>.

 @author Gregory Kick
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableTable -->
  <!-- start class com.google.common.collect.ImmutableTable.Builder -->
  <class name="ImmutableTable.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new builder. The returned builder is equivalent to the builder generated by {@link
 ImmutableTable#builder}.]]>
      </doc>
    </constructor>
    <method name="orderRowsBy" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowComparator" type="java.util.Comparator&lt;? super R&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated table's rows.]]>
      </doc>
    </method>
    <method name="orderColumnsBy" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnComparator" type="java.util.Comparator&lt;? super C&gt;"/>
      <doc>
      <![CDATA[Specifies the ordering of the generated table's columns.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <param name="columnKey" type="C"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Associates the ({@code rowKey}, {@code columnKey}) pair with {@code value} in the built
 table. Duplicate key pairs are not allowed and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cell" type="com.google.common.collect.Table.Cell&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Adds the given {@code cell} to the table, making it immutable if necessary. Duplicate key
 pairs are not allowed and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="putAll" return="com.google.common.collect.ImmutableTable.Builder&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Associates all of the given table's keys and values in the built table. Duplicate row key
 column key pairs are not allowed, and will cause {@link #build} to fail.

 @throws NullPointerException if any key or value in {@code table} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable table.

 <p>Prefer the equivalent method {@link #buildOrThrow()} to make it explicit that the method
 will throw an exception if there are duplicate key pairs. The {@code build()} method will
 soon be deprecated.

 @throws IllegalArgumentException if duplicate key pairs were added]]>
      </doc>
    </method>
    <method name="buildOrThrow" return="com.google.common.collect.ImmutableTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created immutable table, or throws an exception if duplicate key pairs were
 added.

 @throws IllegalArgumentException if duplicate key pairs were added
 @since 31.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable table instances, especially {@code public static final} tables
 ("constant tables"). Example:

 {@snippet :
 static final ImmutableTable<Integer, Character, String> SPREADSHEET =
     new ImmutableTable.Builder<Integer, Character, String>()
         .put(1, 'A', "foo")
         .put(1, 'B', "bar")
         .put(2, 'A', "baz")
         .buildOrThrow();
 }

 <p>By default, the order in which cells are added to the builder determines the iteration
 ordering of all views in the returned table, with {@link #putAll} following the {@link
 Table#cellSet()} iteration order. However, if {@link #orderRowsBy} or {@link #orderColumnsBy}
 is called, the views are sorted by the supplied comparators.

 <p>For empty or single-cell immutable tables, {@link #of()} and {@link #of(Object, Object,
 Object)} are even more convenient.

 <p>Builder instances can be reused - it is safe to call {@link #buildOrThrow} multiple times to
 build multiple tables in series. Each table is a superset of the tables created before it.

 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ImmutableTable.Builder -->
  <!-- start interface com.google.common.collect.Interner -->
  <interface name="Interner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="intern" return="E"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="E"/>
      <doc>
      <![CDATA[Chooses and returns the representative instance for any of a collection of instances that are
 equal to each other. If two {@linkplain Object#equals equal} inputs are given to this method,
 both calls will return the same instance. That is, {@code intern(a).equals(a)} always holds,
 and {@code intern(a) == intern(b)} if and only if {@code a.equals(b)}. Note that {@code
 intern(a)} is permitted to return one instance now and a different instance later if the
 original interned instance was garbage-collected.

 <p><b>Warning:</b> do not use with mutable objects.

 @throws NullPointerException if {@code sample} is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides similar behavior to {@link String#intern} for any immutable type. Common implementations
 are available from the {@link Interners} class.

 <p>Note that {@code String.intern()} has some well-known performance limitations, and should
 generally be avoided. Prefer {@link Interners#newWeakInterner} or another {@code Interner}
 implementation even for {@code String} interning.

 @author Kevin Bourrillion
 @since 3.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Interner -->
  <!-- start class com.google.common.collect.Interners -->
  <class name="Interners" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="com.google.common.collect.Interners.InternerBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a fresh {@link InternerBuilder} instance.]]>
      </doc>
    </method>
    <method name="newStrongInterner" return="com.google.common.collect.Interner&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread-safe interner which retains a strong reference to each instance it has
 interned, thus preventing these instances from being garbage-collected. If this retention is
 acceptable, this implementation may perform better than {@link #newWeakInterner}.]]>
      </doc>
    </method>
    <method name="newWeakInterner" return="com.google.common.collect.Interner&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread-safe interner which retains a weak reference to each instance it has
 interned, and so does not prevent these instances from being garbage-collected. This most
 likely does not perform as well as {@link #newStrongInterner}, but is the best alternative when
 the memory usage of that implementation is unacceptable.]]>
      </doc>
    </method>
    <method name="asFunction" return="com.google.common.base.Function&lt;E, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interner" type="com.google.common.collect.Interner&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a function that delegates to the {@link Interner#intern} method of the given interner.

 @since 8.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static methods pertaining to instances of {@link Interner}.

 @author Kevin Bourrillion
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Interners -->
  <!-- start class com.google.common.collect.Interners.InternerBuilder -->
  <class name="Interners.InternerBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="strong" return="com.google.common.collect.Interners.InternerBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the {@link InternerBuilder} to build a strong interner.

 @see Interners#newStrongInterner()]]>
      </doc>
    </method>
    <method name="weak" return="com.google.common.collect.Interners.InternerBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the {@link InternerBuilder} to build a weak interner.

 @see Interners#newWeakInterner()]]>
      </doc>
    </method>
    <method name="concurrencyLevel" return="com.google.common.collect.Interners.InternerBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="concurrencyLevel" type="int"/>
      <doc>
      <![CDATA[Sets the concurrency level that will be used by the to-be-built {@link Interner}.

 @see MapMaker#concurrencyLevel(int)]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.Interner&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Builder for {@link Interner} instances.

 @since 21.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Interners.InternerBuilder -->
  <!-- start class com.google.common.collect.Iterables -->
  <class name="Iterables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="unmodifiableIterable" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of {@code iterable}.]]>
      </doc>
    </method>
    <method name="unmodifiableIterable" return="java.lang.Iterable&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="iterable" type="com.google.common.collect.ImmutableCollection&lt;E&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the number of elements in {@code iterable}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code iterable} contains any element {@code o} for which {@code
 Objects.equals(o, element)} would return {@code true}. Otherwise returns {@code false}, even in
 cases where {@link Collection#contains} might throw {@link NullPointerException} or {@link
 ClassCastException}.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that belongs to the provided collection.

 <p>This method calls {@link Collection#removeAll} if {@code iterable} is a collection, and
 {@link Iterators#removeAll} otherwise.

 @param removeFrom the iterable to (potentially) remove elements from
 @param elementsToRemove the elements to remove
 @return {@code true} if any element was removed from {@code iterable}]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that does not belong to the provided collection.

 <p>This method calls {@link Collection#retainAll} if {@code iterable} is a collection, and
 {@link Iterators#retainAll} otherwise.

 @param removeFrom the iterable to (potentially) remove elements from
 @param elementsToRetain the elements to retain
 @return {@code true} if any element was removed from {@code iterable}]]>
      </doc>
    </method>
    <method name="removeIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Removes, from an iterable, every element that satisfies the provided predicate.

 <p>Removals may or may not happen immediately as each element is tested against the predicate.
 The behavior of this method is not specified if {@code predicate} is dependent on {@code
 removeFrom}.

 <p><b>Java 8+ users:</b> if {@code removeFrom} is a {@link Collection}, use {@code
 removeFrom.removeIf(predicate)} instead.

 @param removeFrom the iterable to (potentially) remove elements from
 @param predicate a predicate that determines whether an element should be removed
 @return {@code true} if any elements were removed from the iterable
 @throws UnsupportedOperationException if the iterable does not support {@code remove()}.
 @since 2.0]]>
      </doc>
    </method>
    <method name="elementsEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable1" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="iterable2" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines whether two iterables contain equal elements in the same order. More specifically,
 this method returns {@code true} if {@code iterable1} and {@code iterable2} contain the same
 number of elements and every element of {@code iterable1} is equal to the corresponding element
 of {@code iterable2}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string representation of {@code iterable}, with the format {@code [e1, e2, ..., en]}
 (that is, identical to {@link java.util.Arrays Arrays}{@code
 .toString(Iterables.toArray(iterable))}). Note that for <i>most</i> implementations of {@link
 Collection}, {@code collection.toString()} also gives the same result, but that behavior is not
 generally guaranteed.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterable}.

 <p><b>Java 8+ users:</b> the {@code Stream} equivalent to this method is {@code
 stream.collect(MoreCollectors.onlyElement())}.

 @throws NoSuchElementException if the iterable is empty
 @throws IllegalArgumentException if the iterable contains multiple elements]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterable}, or {@code defaultValue} if the
 iterable is empty.

 <p><b>Java 8+ users:</b> the {@code Stream} equivalent to this method is {@code
 stream.collect(MoreCollectors.toOptional()).orElse(defaultValue)}.

 @throws IllegalArgumentException if the iterator contains multiple elements]]>
      </doc>
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Copies an iterable's elements into an array.

 @param iterable the iterable to copy
 @param type the type of the elements
 @return a newly-allocated array into which all the elements of the iterable have been copied]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addTo" type="java.util.Collection&lt;T&gt;"/>
      <param name="elementsToAdd" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Adds all elements in {@code iterable} to {@code collection}.

 @return {@code true} if {@code collection} was modified as a result of this operation.]]>
      </doc>
    </method>
    <method name="frequency" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Returns the number of elements in the specified iterable that equal the specified object. This
 implementation avoids a full iteration when the iterable is a {@link Multiset} or {@link Set}.

 <p><b>Java 8+ users:</b> In most cases, the {@code Stream} equivalent of this method is {@code
 stream.filter(element::equals).count()}. If {@code element} might be null, use {@code
 stream.filter(Predicate.isEqual(element)).count()} instead.

 @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,
     Object)]]>
      </doc>
    </method>
    <method name="cycle" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an iterable whose iterators cycle indefinitely over the elements of {@code iterable}.

 <p>That iterator supports {@code remove()} if {@code iterable.iterator()} does. After {@code
 remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code
 iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}
 is empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You
 should use an explicit {@code break} or be certain that you will eventually remove all the
 elements.

 <p>To cycle over the iterable {@code n} times, use the following: {@code
 Iterables.concat(Collections.nCopies(n, iterable))}

 <p><b>Java 8+ users:</b> The {@code Stream} equivalent of this method is {@code
 Stream.generate(() -> iterable).flatMap(Streams::stream)}.]]>
      </doc>
    </method>
    <method name="cycle" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterable whose iterators cycle indefinitely over the provided elements.

 <p>After {@code remove} is invoked on a generated iterator, the removed element will no longer
 appear in either that iterator or any other iterator created from the same source iterable.
 That is, this method behaves exactly as {@code Iterables.cycle(Lists.newArrayList(elements))}.
 The iterator's {@code hasNext} method returns {@code true} until all of the original elements
 have been removed.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You
 should use an explicit {@code break} or be certain that you will eventually remove all the
 elements.

 <p>To cycle over the elements {@code n} times, use the following: {@code
 Iterables.concat(Collections.nCopies(n, Arrays.asList(elements)))}

 <p><b>Java 8+ users:</b> If passing a single element {@code e}, the {@code Stream} equivalent
 of this method is {@code Stream.generate(() -> e)}. Otherwise, put the elements in a collection
 and use {@code Stream.generate(() -> collection).flatMap(Collection::stream)}.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines two iterables into a single iterable. The returned iterable has an iterator that
 traverses the elements in {@code a}, followed by the elements in {@code b}. The source
 iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>Java 8+ users:</b> The {@code Stream} equivalent of this method is {@code
 Stream.concat(a, b)}.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines three iterables into a single iterable. The returned iterable has an iterator that
 traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the
 elements in {@code c}. The source iterators are not polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>Java 8+ users:</b> The {@code Stream} equivalent of this method is {@code
 Streams.concat(a, b, c)}.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="b" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="c" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="d" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines four iterables into a single iterable. The returned iterable has an iterator that
 traverses the elements in {@code a}, followed by the elements in {@code b}, followed by the
 elements in {@code c}, followed by the elements in {@code d}. The source iterators are not
 polled until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>Java 8+ users:</b> The {@code Stream} equivalent of this method is {@code
 Streams.concat(a, b, c, d)}.]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable[]"/>
      <doc>
      <![CDATA[Combines multiple iterables into a single iterable. The returned iterable has an iterator that
 traverses the elements of each iterable in {@code inputs}. The input iterators are not polled
 until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it.

 <p><b>Java 8+ users:</b> The {@code Stream} equivalent of this method is {@code
 Streams.concat(...)}.

 @throws NullPointerException if any of the provided iterables is null]]>
      </doc>
    </method>
    <method name="concat" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.lang.Iterable&lt;? extends java.lang.Iterable&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Combines multiple iterables into a single iterable. The returned iterable has an iterator that
 traverses the elements of each iterable in {@code inputs}. The input iterators are not polled
 until necessary.

 <p>The returned iterable's iterator supports {@code remove()} when the corresponding input
 iterator supports it. The methods of the returned iterable may throw {@code
 NullPointerException} if any of the input iterators is null.

 <p><b>Java 8+ users:</b> The {@code Stream} equivalent of this method is {@code
 streamOfStreams.flatMap(s -> s)}.]]>
      </doc>
    </method>
    <method name="partition" return="java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterable into unmodifiable sublists of the given size (the final iterable may be
 smaller). For example, partitioning an iterable containing {@code [a, b, c, d, e]} with a
 partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterable containing two
 inner lists of three and two elements, all in the original order.

 <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}
 method. The returned lists implement {@link RandomAccess}, whether or not the input list does.

 <p><b>Note:</b> The current implementation eagerly allocates storage for {@code size} elements.
 As a consequence, passing values like {@code Integer.MAX_VALUE} can lead to {@link
 OutOfMemoryError}.

 <p><b>Note:</b> if {@code iterable} is a {@link List}, use {@link Lists#partition(List, int)}
 instead.

 @param iterable the iterable to return a partitioned view of
 @param size the desired size of each partition (the last may be smaller)
 @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided
     into partitions
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="paddedPartition" return="java.lang.Iterable&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterable into unmodifiable sublists of the given size, padding the final iterable
 with null values if necessary. For example, partitioning an iterable containing {@code [a, b,
 c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer
 iterable containing two inner lists of three elements each, all in the original order.

 <p>Iterators returned by the returned iterable do not support the {@link Iterator#remove()}
 method.

 @param iterable the iterable to return a partitioned view of
 @param size the desired size of each partition
 @return an iterable of unmodifiable lists containing the elements of {@code iterable} divided
     into partitions (the final iterable may have trailing null elements)
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="filter" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="retainIfTrue" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate
 {@code retainIfTrue}. The returned iterable's iterator does not support {@code remove()}.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#filter}.]]>
      </doc>
    </method>
    <method name="filter" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.lang.Iterable&lt;?&gt;"/>
      <param name="desiredType" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of {@code unfiltered} containing all elements that are of the type {@code
 desiredType}. The returned iterable's iterator does not support {@code remove()}.

 <p><b>{@code Stream} equivalent:</b> {@code stream.filter(type::isInstance).map(type::cast)}.
 This does perform a little more work than necessary, so another option is to insert an
 unchecked cast at some later point:

 {@snippet :
 @SuppressWarnings("unchecked") // safe because of ::isInstance check
 ImmutableList<NewType> result =
     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());
 }]]>
      </doc>
    </method>
    <method name="any" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if any element in {@code iterable} satisfies the predicate.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#anyMatch}.]]>
      </doc>
    </method>
    <method name="all" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element in {@code iterable} satisfies the predicate. If {@code
 iterable} is empty, {@code true} is returned.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#allMatch}.]]>
      </doc>
    </method>
    <method name="find" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterable} that satisfies the given predicate; use this
 method only when such an element is known to exist. If it is possible that <i>no</i> element
 will match, use {@link #tryFind} or {@link #find(Iterable, Predicate, Object)} instead.

 <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst().get()}

 @throws NoSuchElementException if no element in {@code iterable} matches the given predicate]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterable} that satisfies the given predicate, or {@code
 defaultValue} if none found. Note that this can usually be handled more naturally using {@code
 tryFind(iterable, predicate).or(defaultValue)}.

 <p><b>{@code Stream} equivalent:</b> {@code
 stream.filter(predicate).findFirst().orElse(defaultValue)}

 @since 7.0]]>
      </doc>
    </method>
    <method name="tryFind" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in {@code iterable} that satisfies the
 given predicate, if such an element exists.

 <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}
 is matched in {@code iterable}, a NullPointerException will be thrown.

 <p><b>{@code Stream} equivalent:</b> {@code stream.filter(predicate).findFirst()}

 @since 11.0]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the index in {@code iterable} of the first element that satisfies the provided {@code
 predicate}, or {@code -1} if the Iterable has no such elements.

 <p>More formally, returns the lowest index {@code i} such that {@code
 predicate.apply(Iterables.get(iterable, i))} returns {@code true}, or {@code -1} if there is no
 such index.

 @since 2.0]]>
      </doc>
    </method>
    <method name="transform" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIterable" type="java.lang.Iterable&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a view containing the result of applying {@code function} to each element of {@code
 fromIterable}.

 <p>The returned iterable's iterator supports {@code remove()} if {@code fromIterable}'s
 iterator does. After a successful {@code remove()} call, {@code fromIterable} no longer
 contains the corresponding element.

 <p>If the input {@code Iterable} is known to be a {@code List} or other {@code Collection},
 consider {@link Lists#transform} and {@link Collections2#transform}.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#map}]]>
      </doc>
    </method>
    <method name="get" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the element at the specified position in an iterable.

 <p><b>{@code Stream} equivalent:</b> {@code stream.skip(position).findFirst().get()} (throws
 {@code NoSuchElementException} if out of bounds)

 @param position position of the element to return
 @return the element at the specified position in {@code iterable}
 @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to
     the size of {@code iterable}]]>
      </doc>
    </method>
    <method name="get" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="position" type="int"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the element at the specified position in an iterable or a default value otherwise.

 <p><b>{@code Stream} equivalent:</b> {@code
 stream.skip(position).findFirst().orElse(defaultValue)} (returns the default value if the index
 is out of bounds)

 @param position position of the element to return
 @param defaultValue the default value to return if {@code position} is greater than or equal to
     the size of the iterable
 @return the element at the specified position in {@code iterable} or {@code defaultValue} if
     {@code iterable} contains fewer than {@code position + 1} elements.
 @throws IndexOutOfBoundsException if {@code position} is negative
 @since 4.0]]>
      </doc>
    </method>
    <method name="getFirst" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterable} or {@code defaultValue} if the iterable is empty.
 The {@link Iterators} analog to this method is {@link Iterators#getNext}.

 <p>If no default value is desired (and the caller instead wants a {@link
 NoSuchElementException} to be thrown), it is recommended that {@code
 iterable.iterator().next()} is used instead.

 <p>To get the only element in a single-element {@code Iterable}, consider using {@link
 #getOnlyElement(Iterable)} or {@link #getOnlyElement(Iterable, Object)} instead.

 <p><b>{@code Stream} equivalent:</b> {@code stream.findFirst().orElse(defaultValue)}

 <p><b>Java 21+ users:</b> if {code iterable} is a {@code SequencedCollection} (e.g., any list),
 consider using {@code collection.getFirst()} instead. Note that if the collection is empty,
 {@code getFirst()} throws a {@code NoSuchElementException}, while this method returns the
 default value.

 @param defaultValue the default value to return if the iterable is empty
 @return the first element of {@code iterable} or the default value
 @since 7.0]]>
      </doc>
    </method>
    <method name="getLast" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the last element of {@code iterable}. If {@code iterable} is a {@link List} with {@link
 RandomAccess} support, then this operation is guaranteed to be {@code O(1)}.

 <p><b>{@code Stream} equivalent:</b> {@link Streams#findLast Streams.findLast(stream).get()}

 <p><b>Java 21+ users:</b> if {code iterable} is a {@code SequencedCollection} (e.g., any list),
 consider using {@code collection.getLast()} instead.

 @return the last element of {@code iterable}
 @throws NoSuchElementException if the iterable is empty]]>
      </doc>
    </method>
    <method name="getLast" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the last element of {@code iterable} or {@code defaultValue} if the iterable is empty.
 If {@code iterable} is a {@link List} with {@link RandomAccess} support, then this operation is
 guaranteed to be {@code O(1)}.

 <p><b>{@code Stream} equivalent:</b> {@code Streams.findLast(stream).orElse(defaultValue)}

 <p><b>Java 21+ users:</b> if {code iterable} is a {@code SequencedCollection} (e.g., any list),
 consider using {@code collection.getLast()} instead. Note that if the collection is empty,
 {@code getLast()} throws a {@code NoSuchElementException}, while this method returns the
 default value.

 @param defaultValue the value to return if {@code iterable} is empty
 @return the last element of {@code iterable} or the default value
 @since 3.0]]>
      </doc>
    </method>
    <method name="skip" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="numberToSkip" type="int"/>
      <doc>
      <![CDATA[Returns a view of {@code iterable} that skips its first {@code numberToSkip} elements. If
 {@code iterable} contains fewer than {@code numberToSkip} elements, the returned iterable skips
 all of its elements.

 <p>Modifications to the underlying {@link Iterable} before a call to {@code iterator()} are
 reflected in the returned iterator. That is, the iterator skips the first {@code numberToSkip}
 elements that exist when the {@code Iterator} is created, not when {@code skip()} is called.

 <p>The returned iterable's iterator supports {@code remove()} if the iterator of the underlying
 iterable supports it. Note that it is <i>not</i> possible to delete the last skipped element by
 immediately calling {@code remove()} on that iterator, as the {@code Iterator} contract states
 that a call to {@code remove()} before a call to {@code next()} will throw an {@link
 IllegalStateException}.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#skip}

 @since 3.0]]>
      </doc>
    </method>
    <method name="limit" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <param name="limitSize" type="int"/>
      <doc>
      <![CDATA[Returns a view of {@code iterable} containing its first {@code limitSize} elements. If {@code
 iterable} contains fewer than {@code limitSize} elements, the returned view contains all of its
 elements. The returned iterable's iterator supports {@code remove()} if {@code iterable}'s
 iterator does.

 <p><b>{@code Stream} equivalent:</b> {@link Stream#limit}

 @param iterable the iterable to limit
 @param limitSize the maximum number of elements in the returned iterable
 @throws IllegalArgumentException if {@code limitSize} is negative
 @since 3.0]]>
      </doc>
    </method>
    <method name="consumingIterable" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of the supplied iterable that wraps each generated {@link Iterator} through
 {@link Iterators#consumingIterator(Iterator)}.

 <p>Note: If {@code iterable} is a {@link Queue}, the returned iterable will instead use {@link
 Queue#isEmpty} and {@link Queue#remove()}, since {@link Queue}'s iteration order is undefined.
 Calling {@link Iterator#hasNext()} on a generated iterator from the returned iterable may cause
 an item to be immediately dequeued for return on a subsequent call to {@link Iterator#next()}.

 <p>Whether the input {@code iterable} is a {@link Queue} or not, the returned {@code Iterable}
 is not thread-safe.

 @param iterable the iterable to wrap
 @return a view of the supplied iterable that wraps each generated iterator through {@link
     Iterators#consumingIterator(Iterator)}; for queues, an iterable that generates iterators
     that return and consume the queue's elements in queue order
 @see Iterators#consumingIterator(Iterator)
 @since 2.0]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines if the given iterable contains no elements.

 <p>There is no precise {@link Iterator} equivalent to this method, since one can only ask an
 iterator whether it has any elements <i>remaining</i> (which one does using {@link
 Iterator#hasNext}).

 <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}

 @return {@code true} if the iterable contains no elements]]>
      </doc>
    </method>
    <method name="mergeSorted" return="java.lang.Iterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterables" type="java.lang.Iterable&lt;? extends java.lang.Iterable&lt;? extends T&gt;&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an iterable over the merged contents of all given {@code iterables}. Equivalent entries
 will not be de-duplicated.

 <p>Callers must ensure that the source {@code iterables} are in non-descending order as this
 method does not sort its input.

 <p>For any equivalent elements across all {@code iterables}, it is undefined which element is
 returned first.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An assortment of mainly legacy static utility methods that operate on or return objects of type
 {@code Iterable}. Except as noted, each method has a corresponding {@link Iterator}-based method
 in the {@link Iterators} class.

 <p><b>Java 8+ users:</b> several common uses for this class are now more comprehensively
 addressed by the new {@link java.util.stream.Stream} library. Read the method documentation below
 for comparisons. This class is not being deprecated, but we gently encourage you to migrate to
 streams.

 <p><i>Performance notes:</i> Unless otherwise noted, all of the iterables produced in this class
 are <i>lazy</i>, which means that their iterators only advance the backing iteration when
 absolutely necessary.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables">{@code
 Iterables}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Iterables -->
  <!-- start class com.google.common.collect.Iterators -->
  <class name="Iterators" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="unmodifiableIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of {@code iterator}.]]>
      </doc>
    </method>
    <method name="unmodifiableIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="iterator" type="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the number of elements remaining in {@code iterator}. The iterator will be left
 exhausted: its {@code hasNext()} method will return {@code false}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code iterator} contains {@code element}.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;?&gt;"/>
      <param name="elementsToRemove" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Traverses an iterator and removes every element that belongs to the provided collection. The
 iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param elementsToRemove the elements to remove
 @return {@code true} if any element was removed from {@code iterator}]]>
      </doc>
    </method>
    <method name="removeIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Removes every element that satisfies the provided predicate from the iterator. The iterator
 will be left exhausted: its {@code hasNext()} method will return {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param predicate a predicate that determines whether an element should be removed
 @return {@code true} if any elements were removed from the iterator
 @since 2.0]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="removeFrom" type="java.util.Iterator&lt;?&gt;"/>
      <param name="elementsToRetain" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Traverses an iterator and removes every element that does not belong to the provided
 collection. The iterator will be left exhausted: its {@code hasNext()} method will return
 {@code false}.

 @param removeFrom the iterator to (potentially) remove elements from
 @param elementsToRetain the elements to retain
 @return {@code true} if any element was removed from {@code iterator}]]>
      </doc>
    </method>
    <method name="elementsEqual" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator1" type="java.util.Iterator&lt;?&gt;"/>
      <param name="iterator2" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Determines whether two iterators contain equal elements in the same order. More specifically,
 this method returns {@code true} if {@code iterator1} and {@code iterator2} contain the same
 number of elements and every element of {@code iterator1} is equal to the corresponding element
 of {@code iterator2}.

 <p>Note that this will modify the supplied iterators, since they will have been advanced some
 number of elements forward.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a string representation of {@code iterator}, with the format {@code [e1, e2, ..., en]}.
 The iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterator}.

 @throws NoSuchElementException if the iterator is empty
 @throws IllegalArgumentException if the iterator contains multiple elements. The state of the
     iterator is unspecified.]]>
      </doc>
    </method>
    <method name="getOnlyElement" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the single element contained in {@code iterator}, or {@code defaultValue} if the
 iterator is empty.

 @throws IllegalArgumentException if the iterator contains multiple elements. The state of the
     iterator is unspecified.]]>
      </doc>
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Copies an iterator's elements into an array. The iterator will be left exhausted: its {@code
 hasNext()} method will return {@code false}.

 @param iterator the iterator to copy
 @param type the type of the elements
 @return a newly-allocated array into which all the elements of the iterator have been copied]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addTo" type="java.util.Collection&lt;T&gt;"/>
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Adds all elements in {@code iterator} to {@code collection}. The iterator will be left
 exhausted: its {@code hasNext()} method will return {@code false}.

 @return {@code true} if {@code collection} was modified as a result of this operation]]>
      </doc>
    </method>
    <method name="frequency" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Returns the number of elements in the specified iterator that equal the specified object. The
 iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.

 @see Collections#frequency]]>
      </doc>
    </method>
    <method name="cycle" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an iterator that cycles indefinitely over the elements of {@code iterable}.

 <p>The returned iterator supports {@code remove()} if the provided iterator does. After {@code
 remove()} is called, subsequent cycles omit the removed element, which is no longer in {@code
 iterable}. The iterator's {@code hasNext()} method returns {@code true} until {@code iterable}
 is empty.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You
 should use an explicit {@code break} or be certain that you will eventually remove all the
 elements.]]>
      </doc>
    </method>
    <method name="cycle" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterator that cycles indefinitely over the provided elements.

 <p>The returned iterator supports {@code remove()}. After {@code remove()} is called,
 subsequent cycles omit the removed element, but {@code elements} does not change. The
 iterator's {@code hasNext()} method returns {@code true} until all of the original elements
 have been removed.

 <p><b>Warning:</b> Typical uses of the resulting iterator may produce an infinite loop. You
 should use an explicit {@code break} or be certain that you will eventually remove all the
 elements.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines two iterators into a single iterator. The returned iterator iterates across the
 elements in {@code a}, followed by the elements in {@code b}. The source iterators are not
 polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding input iterator
 supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="c" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines three iterators into a single iterator. The returned iterator iterates across the
 elements in {@code a}, followed by the elements in {@code b}, followed by the elements in
 {@code c}. The source iterators are not polled until necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding input iterator
 supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="b" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="c" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="d" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Combines four iterators into a single iterator. The returned iterator iterates across the
 elements in {@code a}, followed by the elements in {@code b}, followed by the elements in
 {@code c}, followed by the elements in {@code d}. The source iterators are not polled until
 necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding input iterator
 supports it.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.util.Iterator[]"/>
      <doc>
      <![CDATA[Combines multiple iterators into a single iterator. The returned iterator iterates across the
 elements of each iterator in {@code inputs}. The input iterators are not polled until
 necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding input iterator
 supports it.

 @throws NullPointerException if any of the provided iterators is null]]>
      </doc>
    </method>
    <method name="concat" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputs" type="java.util.Iterator&lt;? extends java.util.Iterator&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Combines multiple iterators into a single iterator. The returned iterator iterates across the
 elements of each iterator in {@code inputs}. The input iterators are not polled until
 necessary.

 <p>The returned iterator supports {@code remove()} when the corresponding input iterator
 supports it. The methods of the returned iterator may throw {@code NullPointerException} if any
 of the input iterators is null.]]>
      </doc>
    </method>
    <method name="partition" return="com.google.common.collect.UnmodifiableIterator&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterator into unmodifiable sublists of the given size (the final list may be
 smaller). For example, partitioning an iterator containing {@code [a, b, c, d, e]} with a
 partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer iterator containing two
 inner lists of three and two elements, all in the original order.

 <p>The returned lists implement {@link java.util.RandomAccess}.

 <p><b>Note:</b> The current implementation eagerly allocates storage for {@code size} elements.
 As a consequence, passing values like {@code Integer.MAX_VALUE} can lead to {@link
 OutOfMemoryError}.

 @param iterator the iterator to return a partitioned view of
 @param size the desired size of each partition (the last may be smaller)
 @return an iterator of immutable lists containing the elements of {@code iterator} divided into
     partitions
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="paddedPartition" return="com.google.common.collect.UnmodifiableIterator&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Divides an iterator into unmodifiable sublists of the given size, padding the final iterator
 with null values if necessary. For example, partitioning an iterator containing {@code [a, b,
 c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e, null]]} -- an outer
 iterator containing two inner lists of three elements each, all in the original order.

 <p>The returned lists implement {@link java.util.RandomAccess}.

 @param iterator the iterator to return a partitioned view of
 @param size the desired size of each partition
 @return an iterator of immutable lists containing the elements of {@code iterator} divided into
     partitions (the final iterable may have trailing null elements)
 @throws IllegalArgumentException if {@code size} is nonpositive]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Iterator&lt;T&gt;"/>
      <param name="retainIfTrue" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a view of {@code unfiltered} containing all elements that satisfy the input predicate
 {@code retainIfTrue}.]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Iterator&lt;?&gt;"/>
      <param name="desiredType" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of {@code unfiltered} containing all elements that are of the type {@code
 desiredType}.]]>
      </doc>
    </method>
    <method name="any" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if one or more elements returned by {@code iterator} satisfy the given
 predicate.]]>
      </doc>
    </method>
    <method name="all" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element returned by {@code iterator} satisfies the given
 predicate. If {@code iterator} is empty, {@code true} is returned.]]>
      </doc>
    </method>
    <method name="find" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterator} that satisfies the given predicate; use this
 method only when such an element is known to exist. If no such element is found, the iterator
 will be left exhausted: its {@code hasNext()} method will return {@code false}. If it is
 possible that <i>no</i> element will match, use {@link #tryFind} or {@link #find(Iterator,
 Predicate, Object)} instead.

 @throws NoSuchElementException if no element in {@code iterator} matches the given predicate]]>
      </doc>
    </method>
    <method name="find" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Returns the first element in {@code iterator} that satisfies the given predicate. If no such
 element is found, {@code defaultValue} will be returned from this method and the iterator will
 be left exhausted: its {@code hasNext()} method will return {@code false}. Note that this can
 usually be handled more naturally using {@code tryFind(iterator, predicate).or(defaultValue)}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="tryFind" return="com.google.common.base.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an {@link Optional} containing the first element in {@code iterator} that satisfies the
 given predicate, if such an element exists. If no such element is found, an empty {@link
 Optional} will be returned from this method and the iterator will be left exhausted: its {@code
 hasNext()} method will return {@code false}.

 <p><b>Warning:</b> avoid using a {@code predicate} that matches {@code null}. If {@code null}
 is matched in {@code iterator}, a NullPointerException will be thrown.

 @since 11.0]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the index in {@code iterator} of the first element that satisfies the provided {@code
 predicate}, or {@code -1} if the Iterator has no such elements.

 <p>More formally, returns the lowest index {@code i} such that {@code
 predicate.apply(Iterators.get(iterator, i))} returns {@code true}, or {@code -1} if there is no
 such index.

 <p>If -1 is returned, the iterator will be left exhausted: its {@code hasNext()} method will
 return {@code false}. Otherwise, the iterator will be set to the element which satisfies the
 {@code predicate}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="transform" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromIterator" type="java.util.Iterator&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a view containing the result of applying {@code function} to each element of {@code
 fromIterator}.

 <p>The returned iterator supports {@code remove()} if {@code fromIterator} does. After a
 successful {@code remove()} call, {@code fromIterator} no longer contains the corresponding
 element.]]>
      </doc>
    </method>
    <method name="get" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Advances {@code iterator} {@code position + 1} times, returning the element at the {@code
 position}th position.

 @param position position of the element to return
 @return the element at the specified position in {@code iterator}
 @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to
     the number of elements remaining in {@code iterator}]]>
      </doc>
    </method>
    <method name="get" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="position" type="int"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Advances {@code iterator} {@code position + 1} times, returning the element at the {@code
 position}th position or {@code defaultValue} otherwise.

 @param position position of the element to return
 @param defaultValue the default value to return if the iterator is empty or if {@code position}
     is greater than the number of elements remaining in {@code iterator}
 @return the element at the specified position in {@code iterator} or {@code defaultValue} if
     {@code iterator} produces fewer than {@code position + 1} elements.
 @throws IndexOutOfBoundsException if {@code position} is negative
 @since 4.0]]>
      </doc>
    </method>
    <method name="getNext" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns the next element in {@code iterator} or {@code defaultValue} if the iterator is empty.
 The {@link Iterables} analog to this method is {@link Iterables#getFirst}.

 @param defaultValue the default value to return if the iterator is empty
 @return the next element of {@code iterator} or the default value
 @since 7.0]]>
      </doc>
    </method>
    <method name="getLast" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Advances {@code iterator} to the end, returning the last element.

 @return the last element of {@code iterator}
 @throws NoSuchElementException if the iterator is empty]]>
      </doc>
    </method>
    <method name="getLast" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <param name="defaultValue" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Advances {@code iterator} to the end, returning the last element or {@code defaultValue} if the
 iterator is empty.

 @param defaultValue the default value to return if the iterator is empty
 @return the last element of {@code iterator}
 @since 3.0]]>
      </doc>
    </method>
    <method name="advance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;?&gt;"/>
      <param name="numberToAdvance" type="int"/>
      <doc>
      <![CDATA[Calls {@code next()} on {@code iterator}, either {@code numberToAdvance} times or until {@code
 hasNext()} returns {@code false}, whichever comes first.

 @return the number of elements the iterator was advanced
 @since 13.0 (since 3.0 as {@code Iterators.skip})]]>
      </doc>
    </method>
    <method name="limit" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <param name="limitSize" type="int"/>
      <doc>
      <![CDATA[Returns a view containing the first {@code limitSize} elements of {@code iterator}. If {@code
 iterator} contains fewer than {@code limitSize} elements, the returned view contains all of its
 elements. The returned iterator supports {@code remove()} if {@code iterator} does.

 @param iterator the iterator to limit
 @param limitSize the maximum number of elements in the returned iterator
 @throws IllegalArgumentException if {@code limitSize} is negative
 @since 3.0]]>
      </doc>
    </method>
    <method name="consumingIterator" return="java.util.Iterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a view of the supplied {@code iterator} that removes each element from the supplied
 {@code iterator} as it is returned.

 <p>The provided iterator must support {@link Iterator#remove()} or else the returned iterator
 will fail on the first call to {@code next}. The returned {@link Iterator} is also not
 thread-safe.

 @param iterator the iterator to remove and return elements from
 @return an iterator that removes and returns elements from the supplied iterator
 @since 2.0]]>
      </doc>
    </method>
    <method name="forArray" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[Returns an iterator containing the elements of {@code array} in order. The returned iterator is
 a view of the array; subsequent changes to the array will be reflected in the iterator.

 <p><b>Note:</b> It is often preferable to represent your data using a collection type, for
 example using {@link Arrays#asList(Object[])}, making this method unnecessary.

 <p>The {@code Iterable} equivalent of this method is either {@link Arrays#asList(Object[])},
 {@link ImmutableList#copyOf(Object[])}}, or {@link ImmutableList#of}.]]>
      </doc>
    </method>
    <method name="singletonIterator" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns an iterator containing only {@code value}.

 <p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.]]>
      </doc>
    </method>
    <method name="forEnumeration" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumeration" type="java.util.Enumeration&lt;T&gt;"/>
      <doc>
      <![CDATA[Adapts an {@code Enumeration} to the {@code Iterator} interface.

 <p>This method has no equivalent in {@link Iterables} because viewing an {@code Enumeration} as
 an {@code Iterable} is impossible. However, the contents can be <i>copied</i> into a collection
 using {@link Collections#list}.

 <p><b>Java 9 users:</b> use {@code enumeration.asIterator()} instead, unless it is important to
 return an {@code UnmodifiableIterator} instead of a plain {@code Iterator}.]]>
      </doc>
    </method>
    <method name="asEnumeration" return="java.util.Enumeration&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Adapts an {@code Iterator} to the {@code Enumeration} interface.

 <p>The {@code Iterable} equivalent of this method is either {@link Collections#enumeration} (if
 you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.]]>
      </doc>
    </method>
    <method name="peekingIterator" return="com.google.common.collect.PeekingIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a {@code PeekingIterator} backed by the given iterator.

 <p>Calls to the {@code peek} method with no intervening calls to {@code next} do not affect the
 iteration, and hence return the same object each time. A subsequent call to {@code next} is
 guaranteed to return the same object again. For example:

 {@snippet :
 PeekingIterator<String> peekingIterator =
     Iterators.peekingIterator(Iterators.forArray("a", "b"));
 String a1 = peekingIterator.peek(); // returns "a"
 String a2 = peekingIterator.peek(); // also returns "a"
 String a3 = peekingIterator.next(); // also returns "a"
 }

 <p>Any structural changes to the underlying iteration (aside from those performed by the
 iterator's own {@link PeekingIterator#remove()} method) will leave the iterator in an undefined
 state.

 <p>The returned iterator does not support removal after peeking, as explained by {@link
 PeekingIterator#remove()}.

 <p>Note: If the given iterator is already a {@code PeekingIterator}, it <i>might</i> be
 returned to the caller, although this is neither guaranteed to occur nor required to be
 consistent. For example, this method <i>might</i> choose to pass through recognized
 implementations of {@code PeekingIterator} when the behavior of the implementation is known to
 meet the contract guaranteed by this method.

 <p>There is no {@link Iterable} equivalent to this method, so use this method to wrap each
 individual iterator as it is generated.

 @param iterator the backing iterator. The {@link PeekingIterator} assumes ownership of this
     iterator, so users should cease making direct calls to it after calling this method.
 @return a peeking iterator backed by that iterator. Apart from the additional {@link
     PeekingIterator#peek()} method, this iterator behaves exactly the same as {@code iterator}.]]>
      </doc>
    </method>
    <method name="peekingIterator" return="com.google.common.collect.PeekingIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="iterator" type="com.google.common.collect.PeekingIterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="mergeSorted" return="com.google.common.collect.UnmodifiableIterator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterators" type="java.lang.Iterable&lt;? extends java.util.Iterator&lt;? extends T&gt;&gt;"/>
      <param name="comparator" type="java.util.Comparator&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns an iterator over the merged contents of all given {@code iterators}, traversing every
 element of the input iterators. Equivalent entries will not be de-duplicated.

 <p>Callers must ensure that the source {@code iterators} are in non-descending order as this
 method does not sort its input.

 <p>For any equivalent elements across all {@code iterators}, elements are returned in the order
 of their source iterators. That is, if element A from iterator 1 and element B from iterator 2
 compare as equal, A will be returned before B if iterator 1 was passed before iterator 2.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class contains static utility methods that operate on or return objects of type {@link
 Iterator}. Except as noted, each method has a corresponding {@link Iterable}-based method in the
 {@link Iterables} class.

 <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators produced in this class
 are <i>lazy</i>, which means that they only advance the backing iteration when absolutely
 necessary.

 <p>See the Guava User Guide section on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables">{@code
 Iterators}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Iterators -->
  <!-- start class com.google.common.collect.LinkedHashMultimap -->
  <class name="LinkedHashMultimap" extends="com.google.common.collect.AbstractSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultimap} with the default initial capacities.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code LinkedHashMultimap} with enough capacity to hold the specified
 numbers of keys and values without rehashing.

 @param expectedKeys the expected number of distinct keys
 @param expectedValuesPerKey the expected average number of values per key
 @throws IllegalArgumentException if {@code expectedKeys} or {@code expectedValuesPerKey} is
     negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code LinkedHashMultimap} with the same mappings as the specified multimap. If a
 key-value mapping appears multiple times in the input multimap, it only appears once in the
 constructed multimap. The new multimap has the same {@link Multimap#entries()} iteration order
 as the input multimap, except for excluding duplicate mappings.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If {@code values} is not empty and the multimap already contains a mapping for {@code key},
 the {@code keySet()} ordering is unchanged. However, the provided values always come last in
 the {@link #entries()} and {@link #values()} iteration orderings.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of all key-value pairs. Changes to the returned set will update the underlying
 multimap, and vice versa. The entries set does not support the {@code add} or {@code addAll}
 operations.

 <p>The iterator generated by the returned set traverses the entries in the order they were
 added to the multimap.

 <p>Each entry is an immutable snapshot of a key-value mapping in the multimap, taken at the
 time the entry is returned by a method call to the collection or its iterator.]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view collection of all <i>distinct</i> keys contained in this multimap. Note that the
 key set contains a key if and only if this multimap maps that key to at least one value.

 <p>The iterator generated by the returned set traverses the keys in the order they were first
 added to the multimap.

 <p>Changes to the returned set will update the underlying multimap, and vice versa. However,
 <i>adding</i> to the returned set is not possible.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all values in the multimap. Changes to the returned collection will
 update the underlying multimap, and vice versa.

 <p>The iterator generated by the returned collection traverses the values in the order they
 were added to the multimap.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} that does not allow duplicate key-value entries and that
 returns collections whose iterators follow the ordering in which the data was added to the
 multimap.

 <p>The collections returned by {@code keySet}, {@code keys}, and {@code asMap} iterate through
 the keys in the order they were first added to the multimap. Similarly, {@code get}, {@code
 removeAll}, and {@code replaceValues} return collections that iterate through the values in the
 order they were added. The collections generated by {@code entries} and {@code values} iterate
 across the key-value mappings in the order they were added to the multimap.

 <p>The iteration ordering of the collections generated by {@code keySet}, {@code keys}, and
 {@code asMap} has a few subtleties. As long as the set of keys remains unchanged, adding or
 removing mappings does not affect the key iteration order. However, if you remove all values
 associated with a key and then add the key back to the multimap, that key will come last in the
 key iteration order.

 <p>The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an
 existing key-value pair has no effect.

 <p>Keys and values may be null. All optional multimap methods are supported, and all returned
 views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent
 read operations will work correctly. To allow concurrent update operations, wrap your multimap
 with a call to {@link Multimaps#synchronizedSetMultimap}.

 <p><b>Warning:</b> Do not modify either a key <i>or a value</i> of a {@code LinkedHashMultimap}
 in a way that affects its {@link Object#equals} behavior. Undefined behavior and bugs will
 result.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedHashMultimap -->
  <!-- start class com.google.common.collect.LinkedHashMultiset -->
  <class name="LinkedHashMultiset" extends="com.google.common.collect.AbstractMapBasedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultiset} using the default initial capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="distinctElements" type="int"/>
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedHashMultiset} with the specified expected number of distinct
 elements.

 @param distinctElements the expected number of distinct elements
 @throws IllegalArgumentException if {@code distinctElements} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedHashMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code LinkedHashMultiset} containing the specified elements.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.

 @param elements the elements that the multiset should contain]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multiset} implementation with predictable iteration order. Its iterator orders elements
 according to when the first occurrence of the element was added. When the multiset contains
 multiple instances of an element, those instances are consecutive in the iteration order. If all
 occurrences of an element are removed, after which that element is added to the multiset, the
 element will appear at the end of the iteration.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset">{@code Multiset}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedHashMultiset -->
  <!-- start class com.google.common.collect.LinkedListMultimap -->
  <class name="LinkedListMultimap" extends="com.google.common.collect.AbstractMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@code LinkedListMultimap} with the default initial capacity.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Constructs an empty {@code LinkedListMultimap} with enough capacity to hold the specified
 number of keys without rehashing.

 @param expectedKeys the expected number of distinct keys
 @throws IllegalArgumentException if {@code expectedKeys} is negative]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.LinkedListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code LinkedListMultimap} with the same mappings as the specified {@code
 Multimap}. The new multimap has the same {@link Multimap#entries()} iteration order as the
 input multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Stores a key-value pair in the multimap.

 @param key key to store in the multimap
 @param value value to store in the multimap
 @return {@code true} always]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If any entries for the specified {@code key} already exist in the multimap, their values are
 changed in-place without affecting the iteration order.

 <p>The returned list is immutable and implements {@link java.util.RandomAccess}.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The returned list is immutable and implements {@link java.util.RandomAccess}.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If the multimap is modified while an iteration over the list is in progress (except through
 the iterator's own {@code add}, {@code set} or {@code remove} operations) the results of the
 iteration are undefined.

 <p>The returned list is not serializable and does not have random access.]]>
      </doc>
    </method>
    <method name="values" return="java.util.List&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator generated by the returned collection traverses the values in the order they
 were added to the multimap. Because the values may have duplicates and follow the insertion
 ordering, this method returns a {@link List}, instead of the {@link Collection} specified in
 the {@link ListMultimap} interface.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.List&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator generated by the returned collection traverses the entries in the order they
 were added to the multimap. Because the entries may have duplicates and follow the insertion
 ordering, this method returns a {@link List}, instead of the {@link Collection} specified in
 the {@link ListMultimap} interface.

 <p>An entry's {@link Entry#getKey} method always returns the same key, regardless of what
 happens subsequently. As long as the corresponding key-value mapping is not removed from the
 multimap, {@link Entry#getValue} returns the value from the multimap, which may change over
 time, and {@link Entry#setValue} modifies that value. Removing the mapping from the multimap
 does not alter the value returned by {@code getValue()}, though a subsequent {@code setValue()}
 call won't update the multimap but will lead to a revised value being returned by {@code
 getValue()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of {@code ListMultimap} that supports deterministic iteration order for both
 keys and values. The iteration order is preserved across non-distinct key values. For example,
 for the following multimap definition:

 {@snippet :
 Multimap<K, V> multimap = LinkedListMultimap.create();
 multimap.put(key1, foo);
 multimap.put(key2, bar);
 multimap.put(key1, baz);
 }

 ... the iteration order for {@link #keys()} is {@code [key1, key2, key1]}, and similarly for
 {@link #entries()}. Unlike {@link LinkedHashMultimap}, the iteration order is kept consistent
 between keys, entries and values. For example, calling:

 {@snippet :
 multimap.remove(key1, foo);
 }

 <p>changes the entries iteration order to {@code [key2=bar, key1=baz]} and the key iteration
 order to {@code [key2, key1]}. The {@link #entries()} iterator returns mutable map entries, and
 {@link #replaceValues} attempts to preserve iteration order as much as possible.

 <p>The collections returned by {@link #keySet()} and {@link #asMap()} iterate through the keys in
 the order they were first added to the multimap. Similarly, {@link #get}, {@link #removeAll}, and
 {@link #replaceValues} return collections that iterate through the values in the order they were
 added. The collections generated by {@link #entries()}, {@link #keys()}, and {@link #values}
 iterate across the key-value mappings in the order they were added to the multimap.

 <p>The {@link #values()} and {@link #entries()} methods both return a {@code List}, instead of
 the {@code Collection} specified by the {@link ListMultimap} interface.

 <p>The methods {@link #get}, {@link #keySet()}, {@link #keys()}, {@link #values()}, {@link
 #entries()}, and {@link #asMap()} return collections that are views of the multimap. If the
 multimap is modified while an iteration over any of those collections is in progress, except
 through the iterator's methods, the results of the iteration are undefined.

 <p>Keys and values may be null. All optional multimap methods are supported, and all returned
 views are modifiable.

 <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent
 read operations will work correctly. To allow concurrent update operations, wrap your multimap
 with a call to {@link Multimaps#synchronizedListMultimap}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Mike Bostock
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.LinkedListMultimap -->
  <!-- start interface com.google.common.collect.ListMultimap -->
  <interface name="ListMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.List&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the insertion ordering,
 this method returns a {@link List}, instead of the {@link java.util.Collection} specified in
 the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.List&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the insertion ordering,
 this method returns a {@link List}, instead of the {@link java.util.Collection} specified in
 the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.List&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because the values for a given key may have duplicates and follow the insertion ordering,
 this method returns a {@link List}, instead of the {@link java.util.Collection} specified in
 the {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> The returned map's values are guaranteed to be of type {@link List}. To obtain
 this map with the more specific generic type {@code Map<K, List<V>>}, call {@link
 Multimaps#asMap(ListMultimap)} instead.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code ListMultimap} instances are equal if, for each key, they contain the same values
 in the same order. If the value orderings disagree, the multimaps will not be considered equal.

 <p>An empty {@code ListMultimap} is equal to any other empty {@code Multimap}, including an
 empty {@code SetMultimap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multimap} that can hold duplicate key-value pairs and that maintains the insertion
 ordering of values for a given key. See the {@link Multimap} documentation for information common
 to all multimaps.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods each return a {@link
 List} of values. Though the method signature doesn't say so explicitly, the map returned by
 {@link #asMap} has {@code List} values.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.ListMultimap -->
  <!-- start class com.google.common.collect.Lists -->
  <class name="Lists" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code ArrayList} instance.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableList#of()} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code ArrayList} {@linkplain ArrayList#ArrayList() constructor} directly, taking
 advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given elements.

 <p><b>Note:</b> essentially the only reason to use this method is when you will need to add or
 remove elements later. Otherwise, for non-null elements use {@link ImmutableList#of()} (for
 varargs) or {@link ImmutableList#copyOf(Object[])} (for an array) instead. If any elements
 might be null, or you need support for {@link List#set(int, Object)}, use {@link
 Arrays#asList}.

 <p>Note that even when you do need the ability to add or remove, this method provides only a
 tiny bit of syntactic sugar for {@code new ArrayList<>(}{@link Arrays#asList asList}{@code
 (...))}, or for creating an empty list then calling {@link Collections#addAll}. This method is
 not actually very useful.]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given elements; a very thin
 shortcut for creating an empty list then calling {@link Iterables#addAll}.

 <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link
 ImmutableList#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link
 FluentIterable} and call {@code elements.toList()}.)

 <p><b>Note:</b> if {@code elements} is a {@link Collection}, you don't need this method. Use
 the {@code ArrayList} {@linkplain ArrayList#ArrayList(Collection) constructor} directly, taking
 advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.]]>
      </doc>
    </method>
    <method name="newArrayList" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code ArrayList} instance containing the given elements; a very thin
 shortcut for creating an empty list and then calling {@link Iterators#addAll}.

 <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link
 ImmutableList#copyOf(Iterator)} instead.]]>
      </doc>
    </method>
    <method name="newArrayListWithCapacity" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialArraySize" type="int"/>
      <doc>
      <![CDATA[Creates an {@code ArrayList} instance backed by an array with the specified initial size;
 simply delegates to {@link ArrayList#ArrayList(int)}.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use {@code new }{@link ArrayList#ArrayList(int) ArrayList}{@code <>(int)} directly, taking
 advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>. (Unlike here, there is no risk of overload ambiguity, since the {@code ArrayList}
 constructors very wisely did not accept varargs.)

 @param initialArraySize the exact size of the initial backing array for the returned array list
     ({@code ArrayList} documentation calls this value the "capacity")
 @return a new, empty {@code ArrayList} which is guaranteed not to resize itself unless its size
     reaches {@code initialArraySize + 1}
 @throws IllegalArgumentException if {@code initialArraySize} is negative]]>
      </doc>
    </method>
    <method name="newArrayListWithExpectedSize" return="java.util.ArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="estimatedSize" type="int"/>
      <doc>
      <![CDATA[Creates an {@code ArrayList} instance to hold {@code estimatedSize} elements, <i>plus</i> an
 unspecified amount of padding; **don't do this**. Instead, use {@code new }{@link
 ArrayList#ArrayList(int) ArrayList}{@code <>(int)} directly and choose an explicit padding
 amount.

 @param estimatedSize an estimate of the eventual {@link List#size()} of the new list
 @return a new, empty {@code ArrayList}, sized appropriately to hold the estimated number of
     elements
 @throws IllegalArgumentException if {@code estimatedSize} is negative]]>
      </doc>
    </method>
    <method name="newLinkedList" return="java.util.LinkedList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code LinkedList} instance.

 <p><b>Note:</b> if you won't be adding any elements to the list, use {@link ImmutableList#of()}
 instead.

 <p><b>Performance note:</b> {@link ArrayList} and {@link java.util.ArrayDeque} consistently
 outperform {@code LinkedList} except in certain rare and specific situations. Unless you have
 spent a lot of time benchmarking your specific needs, use one of those instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code LinkedList} {@linkplain LinkedList#LinkedList() constructor} directly, taking
 advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.]]>
      </doc>
    </method>
    <method name="newLinkedList" return="java.util.LinkedList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code LinkedList} instance containing the given elements; a very thin
 shortcut for creating an empty list then calling {@link Iterables#addAll}.

 <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link
 ImmutableList#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link
 FluentIterable} and call {@code elements.toList()}.)

 <p><b>Performance note:</b> {@link ArrayList} and {@link java.util.ArrayDeque} consistently
 outperform {@code LinkedList} except in certain rare and specific situations. Unless you have
 spent a lot of time benchmarking your specific needs, use one of those instead.

 <p><b>Note:</b> if {@code elements} is a {@link Collection}, you don't need this method. Use
 the {@code LinkedList} {@linkplain LinkedList#LinkedList(Collection) constructor} directly,
 taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArrayList" return="java.util.concurrent.CopyOnWriteArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code CopyOnWriteArrayList} instance.

 <p><b>Note:</b> if you need an immutable empty {@link List}, use {@link Collections#emptyList}
 instead.

 @return a new, empty {@code CopyOnWriteArrayList}
 @since 12.0]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArrayList" return="java.util.concurrent.CopyOnWriteArrayList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code CopyOnWriteArrayList} instance containing the given elements.

 @param elements the elements that the list should contain, in order
 @return a new {@code CopyOnWriteArrayList} containing those elements
 @since 12.0]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="E extends java.lang.Object"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns an unmodifiable list containing the specified first element and backed by the specified
 array of additional elements. Changes to the {@code rest} array will be reflected in the
 returned list. Unlike {@link Arrays#asList}, the returned list is unmodifiable.

 <p>This is useful when a varargs method needs to use a signature such as {@code (Foo firstFoo,
 Foo... moreFoos)}, in order to avoid overload ambiguity or to enforce a minimum argument count.

 <p>The returned list is serializable and implements {@link RandomAccess}.

 @param first the first element
 @param rest an array of additional elements, possibly empty
 @return an unmodifiable list containing the specified elements]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="E extends java.lang.Object"/>
      <param name="second" type="E extends java.lang.Object"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns an unmodifiable list containing the specified first and second element, and backed by
 the specified array of additional elements. Changes to the {@code rest} array will be reflected
 in the returned list. Unlike {@link Arrays#asList}, the returned list is unmodifiable.

 <p>This is useful when a varargs method needs to use a signature such as {@code (Foo firstFoo,
 Foo secondFoo, Foo... moreFoos)}, in order to avoid overload ambiguity or to enforce a minimum
 argument count.

 <p>The returned list is serializable and implements {@link RandomAccess}.

 @param first the first element
 @param second the second element
 @param rest an array of additional elements, possibly empty
 @return an unmodifiable list containing the specified elements]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.List&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lists" type="java.util.List&lt;? extends java.util.List&lt;? extends B&gt;&gt;"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element from each of the given
 lists in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the lists. For example:

 {@snippet :
 Lists.cartesianProduct(ImmutableList.of(
     ImmutableList.of(1, 2),
     ImmutableList.of("A", "B", "C")))
 }

 <p>returns a list containing six lists in the following order:

 <ul>
   <li>{@code ImmutableList.of(1, "A")}
   <li>{@code ImmutableList.of(1, "B")}
   <li>{@code ImmutableList.of(1, "C")}
   <li>{@code ImmutableList.of(2, "A")}
   <li>{@code ImmutableList.of(2, "B")}
   <li>{@code ImmutableList.of(2, "C")}
 </ul>

 <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
 products that you would get from nesting for loops:

 {@snippet :
 for (B b0 : lists.get(0)) {
   for (B b1 : lists.get(1)) {
     ...
     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
     // operate on tuple
   }
 }
 }

 <p>Note that if any input list is empty, the Cartesian product will also be empty. If no lists
 at all are provided (an empty list), the resulting Cartesian product has one element, an empty
 list (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of lists of size {@code m, n, p} is a
 list of size {@code m x n x p}, its actual memory consumption is much smaller. When the
 cartesian product is constructed, the input lists are merely copied. Only as the resulting list
 is iterated are the individual lists created, and these are not retained after iteration.

 @param lists the lists to choose elements from, in the order that the elements chosen from
     those lists should appear in the resulting lists
 @param <B> any common base class shared by all axes (often just {@link Object})
 @return the Cartesian product, as an immutable list containing immutable lists
 @throws IllegalArgumentException if the size of the cartesian product would be greater than
     {@link Integer#MAX_VALUE}
 @throws NullPointerException if {@code lists}, any one of the {@code lists}, or any element of
     a provided list is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.List&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lists" type="java.util.List[]"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element from each of the given
 lists in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the lists. For example:

 {@snippet :
 Lists.cartesianProduct(ImmutableList.of(
     ImmutableList.of(1, 2),
     ImmutableList.of("A", "B", "C")))
 }

 <p>returns a list containing six lists in the following order:

 <ul>
   <li>{@code ImmutableList.of(1, "A")}
   <li>{@code ImmutableList.of(1, "B")}
   <li>{@code ImmutableList.of(1, "C")}
   <li>{@code ImmutableList.of(2, "A")}
   <li>{@code ImmutableList.of(2, "B")}
   <li>{@code ImmutableList.of(2, "C")}
 </ul>

 <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
 products that you would get from nesting for loops:

 {@snippet :
 for (B b0 : lists.get(0)) {
   for (B b1 : lists.get(1)) {
     ...
     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
     // operate on tuple
   }
 }
 }

 <p>Note that if any input list is empty, the Cartesian product will also be empty. If no lists
 at all are provided (an empty list), the resulting Cartesian product has one element, an empty
 list (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of lists of size {@code m, n, p} is a
 list of size {@code m x n x p}, its actual memory consumption is much smaller. When the
 cartesian product is constructed, the input lists are merely copied. Only as the resulting list
 is iterated are the individual lists created, and these are not retained after iteration.

 @param lists the lists to choose elements from, in the order that the elements chosen from
     those lists should appear in the resulting lists
 @param <B> any common base class shared by all axes (often just {@link Object})
 @return the Cartesian product, as an immutable list containing immutable lists
 @throws IllegalArgumentException if the size of the cartesian product would be greater than
     {@link Integer#MAX_VALUE}
 @throws NullPointerException if {@code lists}, any one of the {@code lists}, or any element of
     a provided list is null
 @since 19.0]]>
      </doc>
    </method>
    <method name="transform" return="java.util.List&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromList" type="java.util.List&lt;F&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a list that applies {@code function} to each element of {@code fromList}. The returned
 list is a transformed view of {@code fromList}; changes to {@code fromList} will be reflected
 in the returned list and vice versa.

 <p>Since functions are not reversible, the transform is one-way and new items cannot be stored
 in the returned list. The {@code add}, {@code addAll} and {@code set} methods are unsupported
 in the returned list.

 <p>The function is applied lazily, invoked when needed. This is necessary for the returned list
 to be a view, but it means that the function will be applied many times for bulk operations
 like {@link List#contains} and {@link List#hashCode}. For this to perform well, {@code
 function} should be fast. To avoid lazy evaluation when the returned list doesn't need to be a
 view, copy the returned list into a new list of your choosing.

 <p>If {@code fromList} implements {@link RandomAccess}, so will the returned list. The returned
 list is threadsafe if the supplied list and function are.

 <p>If only a {@code Collection} or {@code Iterable} input is available, use {@link
 Collections2#transform} or {@link Iterables#transform}.

 <p><b>Note:</b> serializing the returned list is implemented by serializing {@code fromList},
 its contents, and {@code function} -- <i>not</i> by serializing the transformed values. This
 can lead to surprising behavior, so serializing the returned list is <b>not recommended</b>.
 Instead, copy the list using {@link ImmutableList#copyOf(Collection)} (for example), then
 serialize the copy. Other methods similar to this do not implement serialization at all for
 this reason.

 <p><b>Java 8+ users:</b> many use cases for this method are better addressed by {@link
 java.util.stream.Stream#map}. This method is not being deprecated, but we gently encourage you
 to migrate to streams.]]>
      </doc>
    </method>
    <method name="partition" return="java.util.List&lt;java.util.List&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;T&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns consecutive {@linkplain List#subList(int, int) sublists} of a list, each of the same
 size (the final list may be smaller). For example, partitioning a list containing {@code [a, b,
 c, d, e]} with a partition size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list
 containing two inner lists of three and two elements, all in the original order.

 <p>The outer list is unmodifiable, but reflects the latest state of the source list. The inner
 lists are sublist views of the original list, produced on demand using {@link List#subList(int,
 int)}, and are subject to all the usual caveats about modification as explained in that API.

 @param list the list to return consecutive sublists of
 @param size the desired size of each sublist (the last may be smaller)
 @return a list of consecutive sublists
 @throws IllegalArgumentException if {@code partitionSize} is nonpositive]]>
      </doc>
    </method>
    <method name="charactersOf" return="com.google.common.collect.ImmutableList&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a view of the specified string as an immutable list of {@code Character} values.

 @since 7.0]]>
      </doc>
    </method>
    <method name="charactersOf" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a view of the specified {@code CharSequence} as a {@code List<Character>}, viewing
 {@code sequence} as a sequence of Unicode code units. The view does not support any
 modification operations, but reflects any changes to the underlying character sequence.

 @param sequence the character sequence to view as a {@code List} of characters
 @return an {@code List<Character>} view of the character sequence
 @since 7.0]]>
      </doc>
    </method>
    <method name="reverse" return="java.util.List&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a reversed view of the specified list. For example, {@code
 Lists.reverse(Arrays.asList(1, 2, 3))} returns a list containing {@code 3, 2, 1}. The returned
 list is backed by this list, so changes in the returned list are reflected in this list, and
 vice-versa. The returned list supports all of the optional list operations supported by this
 list.

 <p>The returned list is random-access if the specified list is random access.

 @since 7.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link List} instances. Also see this class's counterparts
 {@link Sets}, {@link Maps} and {@link Queues}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#lists">{@code Lists}</a>.

 @author Kevin Bourrillion
 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Lists -->
  <!-- start interface com.google.common.collect.MapDifference -->
  <interface name="MapDifference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="areEqual" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there are no differences between the two maps; that is, if the maps are
 equal.]]>
      </doc>
    </method>
    <method name="entriesOnlyOnLeft" return="java.util.Map&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries from the left map whose keys are not present
 in the right map.]]>
      </doc>
    </method>
    <method name="entriesOnlyOnRight" return="java.util.Map&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries from the right map whose keys are not
 present in the left map.]]>
      </doc>
    </method>
    <method name="entriesInCommon" return="java.util.Map&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map containing the entries that appear in both maps; that is, the
 intersection of the two maps.]]>
      </doc>
    </method>
    <method name="entriesDiffering" return="java.util.Map&lt;K, com.google.common.collect.MapDifference.ValueDifference&lt;V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable map describing keys that appear in both maps, but with different
 values.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Compares the specified object with this instance for equality. Returns {@code true} if the
 given object is also a {@code MapDifference} and the values returned by the {@link
 #entriesOnlyOnLeft()}, {@link #entriesOnlyOnRight()}, {@link #entriesInCommon()} and {@link
 #entriesDiffering()} of the two instances are equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this instance. This is defined as the hash code of

 {@snippet :
 Arrays.asList(entriesOnlyOnLeft(), entriesOnlyOnRight(),
     entriesInCommon(), entriesDiffering())
 }]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object representing the differences between two maps.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapDifference -->
  <!-- start interface com.google.common.collect.MapDifference.ValueDifference -->
  <interface name="MapDifference.ValueDifference"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="leftValue" return="V extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value from the left map (possibly null).]]>
      </doc>
    </method>
    <method name="rightValue" return="V extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value from the right map (possibly null).]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="Object"/>
      <doc>
      <![CDATA[Two instances are considered equal if their {@link #leftValue()} values are equal and their
 {@link #rightValue()} values are also equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hash code equals the value {@code Arrays.asList(leftValue(), rightValue()).hashCode()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A difference between the mappings from two maps with the same key. The {@link #leftValue} and
 {@link #rightValue} are not equal, and one but not both of them may be null.

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.MapDifference.ValueDifference -->
  <!-- start class com.google.common.collect.MapMaker -->
  <class name="MapMaker" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapMaker"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@code MapMaker} instance with default settings, including strong keys, strong
 values, and no automatic eviction of any kind.]]>
      </doc>
    </constructor>
    <method name="initialCapacity" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Sets the minimum total size for the internal hash tables. For example, if the initial capacity
 is {@code 60}, and the concurrency level is {@code 8}, then eight segments are created, each
 having a hash table of size eight. Providing a large enough estimate at construction time
 avoids the need for expensive resizing operations later, but setting this value unnecessarily
 high wastes memory.

 @throws IllegalArgumentException if {@code initialCapacity} is negative
 @throws IllegalStateException if an initial capacity was already set]]>
      </doc>
    </method>
    <method name="concurrencyLevel" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="concurrencyLevel" type="int"/>
      <doc>
      <![CDATA[Guides the allowed concurrency among update operations. Used as a hint for internal sizing. The
 table is internally partitioned to try to permit the indicated number of concurrent updates
 without contention. Because assignment of entries to these partitions is not necessarily
 uniform, the actual concurrency observed may vary. Ideally, you should choose a value to
 accommodate as many threads as will ever concurrently modify the table. Using a significantly
 higher value than you need can waste space and time, and a significantly lower value can lead
 to thread contention. But overestimates and underestimates within an order of magnitude do not
 usually have much noticeable impact. A value of one permits only one thread to modify the map
 at a time, but since read operations can proceed concurrently, this still yields higher
 concurrency than full synchronization. Defaults to 4.

 <p><b>Note:</b> Prior to Guava release 9.0, the default was 16. It is possible the default will
 change again in the future. If you care about this value, you should always choose it
 explicitly.

 @throws IllegalArgumentException if {@code concurrencyLevel} is nonpositive
 @throws IllegalStateException if a concurrency level was already set]]>
      </doc>
    </method>
    <method name="weakKeys" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each key (not value) stored in the map should be wrapped in a {@link
 WeakReference} (by default, strong references are used).

 <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})
 comparison to determine equality of keys, which is a technical violation of the {@link Map}
 specification, and may not be what you expect.

 @throws IllegalStateException if the key strength was already set
 @see WeakReference]]>
      </doc>
    </method>
    <method name="weakValues" return="com.google.common.collect.MapMaker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies that each value (not key) stored in the map should be wrapped in a {@link
 WeakReference} (by default, strong references are used).

 <p>Weak values will be garbage collected once they are weakly reachable. This makes them a poor
 candidate for caching.

 <p><b>Warning:</b> when this method is used, the resulting map will use identity ({@code ==})
 comparison to determine equality of values. This technically violates the specifications of the
 methods {@link Map#containsValue containsValue}, {@link ConcurrentMap#remove(Object, Object)
 remove(Object, Object)} and {@link ConcurrentMap#replace(Object, Object, Object) replace(K, V,
 V)}, and may not be what you expect.

 @throws IllegalStateException if the value strength was already set
 @see WeakReference]]>
      </doc>
    </method>
    <method name="makeMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a thread-safe map. This method does not alter the state of this {@code MapMaker}
 instance, so it can be invoked again to create multiple independent maps.

 <p>The bulk operations {@code putAll}, {@code equals}, and {@code clear} are not guaranteed to
 be performed atomically on the returned map. Additionally, {@code size} and {@code
 containsValue} are implemented as bulk read operations, and thus may fail to observe concurrent
 writes.

 @return a serializable concurrent map having the requested features]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation for this MapMaker instance. The exact form of the returned
 string is not specified.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder of {@link ConcurrentMap} instances that can have keys or values automatically wrapped
 in {@linkplain WeakReference weak} references.

 <p>Usage example:

 {@snippet :
 ConcurrentMap<Request, Stopwatch> timers = new MapMaker()
     .concurrencyLevel(4)
     .weakKeys()
     .makeMap();
 }

 <p>These features are all optional; {@code new MapMaker().makeMap()} returns a valid concurrent
 map that behaves similarly to a {@link ConcurrentHashMap}.

 <p>The returned map is implemented as a hash table with similar performance characteristics to
 {@link ConcurrentHashMap}. It supports all optional operations of the {@code ConcurrentMap}
 interface. It does not permit null keys or values.

 <p><b>Note:</b> by default, the returned map uses equality comparisons (the {@link Object#equals
 equals} method) to determine equality for keys or values. However, if {@link #weakKeys} was
 specified, the map uses identity ({@code ==}) comparisons instead for keys. Likewise, if {@link
 #weakValues} was specified, the map uses identity comparisons for values.

 <p>The view collections of the returned map have <i>weakly consistent iterators</i>. This means
 that they are safe for concurrent use, but if other threads modify the map after the iterator is
 created, it is undefined which of these changes, if any, are reflected in that iterator. These
 iterators never throw {@link ConcurrentModificationException}.

 <p>If {@link #weakKeys} or {@link #weakValues} are requested, it is possible for a key or value
 present in the map to be reclaimed by the garbage collector. Entries with reclaimed keys or
 values may be removed from the map on each map modification or on occasional map accesses; such
 entries may be counted by {@link Map#size}, but will never be visible to read or write
 operations. A partially-reclaimed entry is never exposed to the user. Any {@link Map.Entry}
 instance retrieved from the map's {@linkplain Map#entrySet entry set} is a snapshot of that
 entry's state at the time of retrieval; such entries do, however, support {@link
 Map.Entry#setValue}, which simply calls {@link Map#put} on the entry's key.

 <p>The maps produced by {@code MapMaker} are serializable, and the deserialized maps retain all
 the configuration properties of the original map. During deserialization, if the original map had
 used weak references, the entries are reconstructed as they were, but it's not unlikely they'll
 be quickly garbage-collected before they are ever accessed.

 <p>{@code new MapMaker().weakKeys().makeMap()} is a recommended replacement for {@link
 java.util.WeakHashMap}, but note that it compares keys using object identity whereas {@code
 WeakHashMap} uses {@link Object#equals}.

 @author Bob Lee
 @author Charles Fry
 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MapMaker -->
  <!-- start class com.google.common.collect.Maps -->
  <class name="Maps" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="immutableEnumMap" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map instance containing the given entries. Internally, the returned map
 will be backed by an {@link EnumMap}.

 <p>The iteration order of the returned map follows the enum's iteration order, not the order in
 which the elements appear in the given map.

 @param map the map to make an immutable copy of
 @return an immutable map containing those entries
 @since 14.0]]>
      </doc>
    </method>
    <method name="toImmutableEnumMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys
 and values are the result of applying the provided mapping functions to the input elements. The
 resulting implementation is specialized for enum key types. The returned map and its views will
 iterate over keys in their enum definition order, not encounter order.

 <p>If the mapped keys contain duplicates, an {@code IllegalArgumentException} is thrown when
 the collection operation is performed. (This differs from the {@code Collector} returned by
 {@link java.util.stream.Collectors#toMap(java.util.function.Function,
 java.util.function.Function) Collectors.toMap(Function, Function)}, which throws an {@code
 IllegalStateException}.)

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toImmutableEnumMap" return="java.util.stream.Collector&lt;T, ?, com.google.common.collect.ImmutableMap&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="mergeFunction" type="java.util.function.BinaryOperator&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys
 and values are the result of applying the provided mapping functions to the input elements. The
 resulting implementation is specialized for enum key types. The returned map and its views will
 iterate over keys in their enum definition order, not encounter order.

 <p>If the mapped keys contain duplicates, the values are merged using the specified merging
 function.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="newHashMap" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code HashMap} instance.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.

 <p><b>Note:</b> if {@code K} is an {@code enum} type, use {@link #newEnumMap} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code HashMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @return a new, empty {@code HashMap}]]>
      </doc>
    </method>
    <method name="newHashMap" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashMap} instance with the same mappings as the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.

 <p><b>Note:</b> if {@code K} is an {@link Enum} type, use {@link #newEnumMap} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code HashMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @param map the mappings to be placed in the new map
 @return a new {@code HashMap} initialized with the mappings from {@code map}]]>
      </doc>
    </method>
    <method name="newHashMapWithExpectedSize" return="java.util.HashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates a {@code HashMap} instance, with a high enough "initial capacity" that it <i>should</i>
 hold {@code expectedSize} elements without growth. This behavior cannot be broadly guaranteed,
 but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed that the method
 isn't inadvertently <i>oversizing</i> the returned map.

 @param expectedSize the number of entries you expect to add to the returned map
 @return a new, empty {@code HashMap} with enough capacity to hold {@code expectedSize} entries
     without resizing
 @throws IllegalArgumentException if {@code expectedSize} is negative]]>
      </doc>
    </method>
    <method name="newLinkedHashMap" return="java.util.LinkedHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty, insertion-ordered {@code LinkedHashMap} instance.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#of()} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code LinkedHashMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @return a new, empty {@code LinkedHashMap}]]>
      </doc>
    </method>
    <method name="newLinkedHashMap" return="java.util.LinkedHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, insertion-ordered {@code LinkedHashMap} instance with the same
 mappings as the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableMap#copyOf(Map)} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code LinkedHashMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @param map the mappings to be placed in the new map
 @return a new, {@code LinkedHashMap} initialized with the mappings from {@code map}]]>
      </doc>
    </method>
    <method name="newLinkedHashMapWithExpectedSize" return="java.util.LinkedHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates a {@code LinkedHashMap} instance, with a high enough "initial capacity" that it
 <i>should</i> hold {@code expectedSize} elements without growth. This behavior cannot be
 broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed
 that the method isn't inadvertently <i>oversizing</i> the returned map.

 @param expectedSize the number of entries you expect to add to the returned map
 @return a new, empty {@code LinkedHashMap} with enough capacity to hold {@code expectedSize}
     entries without resizing
 @throws IllegalArgumentException if {@code expectedSize} is negative
 @since 19.0]]>
      </doc>
    </method>
    <method name="newConcurrentMap" return="java.util.concurrent.ConcurrentMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new empty {@link ConcurrentHashMap} instance.

 @since 3.0]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeMap} instance using the natural ordering of its
 elements.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedMap#of()} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code TreeMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @return a new, empty {@code TreeMap}]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code TreeMap} instance with the same mappings as the specified map
 and using the same ordering as the specified map.

 <p><b>Note:</b> if mutability is not required, use {@link
 ImmutableSortedMap#copyOfSorted(SortedMap)} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code TreeMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @param map the sorted map whose mappings are to be placed in the new map and whose comparator
     is to be used to sort the new map
 @return a new {@code TreeMap} initialized with the mappings from {@code map} and using the
     comparator of {@code map}]]>
      </doc>
    </method>
    <method name="newTreeMap" return="java.util.TreeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="Comparator"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeMap} instance using the given comparator.

 <p><b>Note:</b> if mutability is not required, use {@code
 ImmutableSortedMap.orderedBy(comparator).build()} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code TreeMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @param comparator the comparator to sort the keys with
 @return a new, empty {@code TreeMap}]]>
      </doc>
    </method>
    <method name="newEnumMap" return="java.util.EnumMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;K&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumMap} instance.

 @param type the key type for this map
 @return a new, empty {@code EnumMap}]]>
      </doc>
    </method>
    <method name="newEnumMap" return="java.util.EnumMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumMap} with the same mappings as the specified map.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code EnumMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @param map the map from which to initialize this {@code EnumMap}
 @return a new {@code EnumMap} initialized with the mappings from {@code map}
 @throws IllegalArgumentException if {@code m} is not an {@code EnumMap} instance and contains
     no mappings]]>
      </doc>
    </method>
    <method name="newIdentityHashMap" return="java.util.IdentityHashMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an {@code IdentityHashMap} instance.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code IdentityHashMap} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @return a new, empty {@code IdentityHashMap}]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.MapDifference&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="right" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Computes the difference between two maps. This difference is an immutable snapshot of the state
 of the maps at the time this method is called. It will never change, even if the maps change at
 a later time.

 <p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps
 must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.

 <p><b>Note:</b>If you only need to know whether two maps have the same mappings, call {@code
 left.equals(right)} instead of this method.

 @param left the map to treat as the "left" map for purposes of comparison
 @param right the map to treat as the "right" map for purposes of comparison
 @return the difference between the two maps]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.MapDifference&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="right" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <param name="valueEquivalence" type="com.google.common.base.Equivalence&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Computes the difference between two maps. This difference is an immutable snapshot of the state
 of the maps at the time this method is called. It will never change, even if the maps change at
 a later time.

 <p>Since this method uses {@code HashMap} instances internally, the keys of the supplied maps
 must be well-behaved with respect to {@link Object#equals} and {@link Object#hashCode}.

 @param left the map to treat as the "left" map for purposes of comparison
 @param right the map to treat as the "right" map for purposes of comparison
 @param valueEquivalence the equivalence relationship to use to compare values
 @return the difference between the two maps
 @since 10.0]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.SortedMapDifference&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="java.util.SortedMap&lt;K, ? extends V&gt;"/>
      <param name="right" type="java.util.Map&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Computes the difference between two sorted maps, using the comparator of the left map, or
 {@code Ordering.natural()} if the left map uses the natural ordering of its elements. This
 difference is an immutable snapshot of the state of the maps at the time this method is called.
 It will never change, even if the maps change at a later time.

 <p>Since this method uses {@code TreeMap} instances internally, the keys of the right map must
 all compare as distinct according to the comparator of the left map.

 <p><b>Note:</b>If you only need to know whether two sorted maps have the same mappings, call
 {@code left.equals(right)} instead of this method.

 @param left the map to treat as the "left" map for purposes of comparison
 @param right the map to treat as the "right" map for purposes of comparison
 @return the difference between the two maps
 @since 11.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;K&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super K, V&gt;"/>
      <doc>
      <![CDATA[Returns a live {@link Map} view whose keys are the contents of {@code set} and whose values are
 computed on demand using {@code function}. To get an immutable <i>copy</i> instead, use {@link
 #toMap(Iterable, Function)}.

 <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping
 {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code
 entrySet} views of the returned map iterate in the same order as the backing set.

 <p>Modifications to the backing set are read through to the returned map. The returned map
 supports removal operations if the backing set does. Removal operations write through to the
 backing set. The returned map does not support put operations.

 <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the
 set does not contain {@code null}, because the view cannot stop {@code null} from being added
 to the set.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},
 {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for
 which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when
 calling methods on the resulting map view.

 @since 14.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.SortedSet&lt;K&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super K, V&gt;"/>
      <doc>
      <![CDATA[Returns a view of the sorted set as a map, mapping keys from the set according to the specified
 function.

 <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping
 {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code
 entrySet} views of the returned map iterate in the same order as the backing set.

 <p>Modifications to the backing set are read through to the returned map. The returned map
 supports removal operations if the backing set does. Removal operations write through to the
 backing set. The returned map does not support put operations.

 <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the
 set does not contain {@code null}, because the view cannot stop {@code null} from being added
 to the set.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},
 {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for
 which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when
 calling methods on the resulting map view.

 @since 14.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.NavigableSet&lt;K&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super K, V&gt;"/>
      <doc>
      <![CDATA[Returns a view of the navigable set as a map, mapping keys from the set according to the
 specified function.

 <p>Specifically, for each {@code k} in the backing set, the returned map has an entry mapping
 {@code k} to {@code function.apply(k)}. The {@code keySet}, {@code values}, and {@code
 entrySet} views of the returned map iterate in the same order as the backing set.

 <p>Modifications to the backing set are read through to the returned map. The returned map
 supports removal operations if the backing set does. Removal operations write through to the
 backing set. The returned map does not support put operations.

 <p><b>Warning:</b> If the function rejects {@code null}, caution is required to make sure the
 set does not contain {@code null}, because the view cannot stop {@code null} from being added
 to the set.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of key type {@code K},
 {@code k.equals(k2)} implies that {@code k2} is also of type {@code K}. Using a key type for
 which this may not hold, such as {@code ArrayList}, may risk a {@code ClassCastException} when
 calling methods on the resulting map view.

 @since 14.0]]>
      </doc>
    </method>
    <method name="toMap" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;K&gt;"/>
      <param name="valueFunction" type="com.google.common.base.Function&lt;? super K, V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value
 for each key was computed by {@code valueFunction}. The map's iteration order is the order of
 the first appearance of each key in {@code keys}.

 <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code
 valueFunction} will be applied to more than one instance of that key and, if it is, which
 result will be mapped to that key in the returned map.

 <p>If {@code keys} is a {@link Set}, a live view can be obtained instead of a copy using {@link
 Maps#asMap(Set, Function)}.

 <p><b>Note:</b> on Java 8+, it is usually better to use streams. For example:

 {@snippet :
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
 ...
 ImmutableMap<Color, String> colorNames =
     allColors.stream().collect(toImmutableMap(c -> c, c -> c.toString()));
 }

 <p>Streams provide a more standard and flexible API and the lambdas make it clear what the keys
 and values in the map are.

 @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code
     valueFunction} produces {@code null} for any key
 @since 14.0]]>
      </doc>
    </method>
    <method name="toMap" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.util.Iterator&lt;K&gt;"/>
      <param name="valueFunction" type="com.google.common.base.Function&lt;? super K, V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable map whose keys are the distinct elements of {@code keys} and whose value
 for each key was computed by {@code valueFunction}. The map's iteration order is the order of
 the first appearance of each key in {@code keys}.

 <p>When there are multiple instances of a key in {@code keys}, it is unspecified whether {@code
 valueFunction} will be applied to more than one instance of that key and, if it is, which
 result will be mapped to that key in the returned map.

 @throws NullPointerException if any element of {@code keys} is {@code null}, or if {@code
     valueFunction} produces {@code null} for any key
 @since 14.0]]>
      </doc>
    </method>
    <method name="uniqueIndex" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Returns a map with the given {@code values}, indexed by keys derived from those values. In
 other words, each input value produces an entry in the map whose key is the result of applying
 {@code keyFunction} to that value. These entries appear in the same order as the input values.
 Example usage:

 {@snippet :
 Color red = new Color("red", 255, 0, 0);
 ...
 ImmutableSet<Color> allColors = ImmutableSet.of(red, green, blue);

 ImmutableMap<String, Color> colorForName =
     uniqueIndex(allColors, c -> c.toString());
 assertThat(colorForName).containsEntry("red", red);
 }

 <p>If your index may associate multiple values with each key, use {@link
 Multimaps#index(Iterable, Function) Multimaps.index}.

 <p><b>Note:</b> on Java 8+, it is usually better to use streams. For example:

 {@snippet :
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
 ...
 ImmutableMap<String, Color> colorForName =
     allColors.stream().collect(toImmutableMap(c -> c.toString(), c -> c));
 }

 <p>Streams provide a more standard and flexible API and the lambdas make it clear what the keys
 and values in the map are.

 @param values the values to use when constructing the {@code Map}
 @param keyFunction the function used to produce the key for each value
 @return a map mapping the result of evaluating the function {@code keyFunction} on each value
     in the input collection to that value
 @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one
     value in the input collection
 @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code
     keyFunction} produces {@code null} for any value]]>
      </doc>
    </method>
    <method name="uniqueIndex" return="com.google.common.collect.ImmutableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Iterator&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Returns a map with the given {@code values}, indexed by keys derived from those values. In
 other words, each input value produces an entry in the map whose key is the result of applying
 {@code keyFunction} to that value. These entries appear in the same order as the input values.
 Example usage:

 {@snippet :
 Color red = new Color("red", 255, 0, 0);
 ...
 Iterator<Color> allColors = ImmutableSet.of(red, green, blue).iterator();

 Map<String, Color> colorForName =
     uniqueIndex(allColors, toStringFunction());
 assertThat(colorForName).containsEntry("red", red);
 }

 <p>If your index may associate multiple values with each key, use {@link
 Multimaps#index(Iterator, Function) Multimaps.index}.

 @param values the values to use when constructing the {@code Map}
 @param keyFunction the function used to produce the key for each value
 @return a map mapping the result of evaluating the function {@code keyFunction} on each value
     in the input collection to that value
 @throws IllegalArgumentException if {@code keyFunction} produces the same key for more than one
     value in the input collection
 @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code
     keyFunction} produces {@code null} for any value
 @since 10.0]]>
      </doc>
    </method>
    <method name="fromProperties" return="com.google.common.collect.ImmutableMap&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates an {@code ImmutableMap<String, String>} from a {@code Properties} instance. Properties
 normally derive from {@code Map<Object, Object>}, but they typically contain strings, which is
 awkward. This method lets you get a plain-old-{@code Map} out of a {@code Properties}.

 @param properties a {@code Properties} object to be converted
 @return an immutable map containing all the entries in {@code properties}
 @throws ClassCastException if any key in {@code properties} is not a {@code String}
 @throws NullPointerException if any key or value in {@code properties} is null]]>
      </doc>
    </method>
    <method name="immutableEntry" return="java.util.Map.Entry&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns an immutable map entry with the specified key and value. The {@link Entry#setValue}
 operation throws an {@link UnsupportedOperationException}.

 <p>The returned entry is serializable.

 <p><b>Java 9 users:</b> consider using {@code java.util.Map.entry(key, value)} if the key and
 value are non-null and the entry does not need to be serializable.

 @param key the key to be associated with the returned entry
 @param value the value to be associated with the returned entry]]>
      </doc>
    </method>
    <method name="asConverter" return="com.google.common.base.Converter&lt;A, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bimap" type="com.google.common.collect.BiMap&lt;A, B&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Converter} that converts values using {@link BiMap#get bimap.get()}, and whose
 inverse view converts values using {@link BiMap#inverse bimap.inverse()}{@code .get()}.

 <p>To use a plain {@link Map} as a {@link Function}, see {@link
 com.google.common.base.Functions#forMap(Map)} or {@link
 com.google.common.base.Functions#forMap(Map, Object)}.

 @since 16.0]]>
      </doc>
    </method>
    <method name="synchronizedBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bimap" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) bimap backed by the specified bimap. In order to guarantee
 serial access, it is critical that <b>all</b> access to the backing bimap is accomplished
 through the returned bimap.

 <p>It is imperative that the user manually synchronize on the returned map when accessing any
 of its collection views:

 {@snippet :
 BiMap<Long, String> map = Maps.synchronizedBiMap(
     HashBiMap.<Long, String>create());
 ...
 Set<Long> set = map.keySet();  // Needn't be in synchronized block
 ...
 synchronized (map) {  // Synchronizing on map, not set!
   Iterator<Long> it = set.iterator(); // Must be in synchronized block
   while (it.hasNext()) {
     foo(it.next());
   }
 }
 }

 <p>Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned bimap will be serializable if the specified bimap is serializable.

 @param bimap the bimap to be wrapped in a synchronized view
 @return a synchronized view of the specified bimap]]>
      </doc>
    </method>
    <method name="unmodifiableBiMap" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bimap" type="com.google.common.collect.BiMap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified bimap. This method allows modules to provide
 users with "read-only" access to internal bimaps. Query operations on the returned bimap "read
 through" to the specified bimap, and attempts to modify the returned map, whether direct or via
 its collection views, result in an {@code UnsupportedOperationException}.

 <p>The returned bimap will be serializable if the specified bimap is serializable.

 @param bimap the bimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified bimap]]>
      </doc>
    </method>
    <method name="transformValues" return="java.util.Map&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.Map&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a map where each value is transformed by a function. All other properties of
 the map, such as iteration order, are left intact. For example, the code:

 {@snippet :
 Map<String, Integer> map = ImmutableMap.of("a", 4, "b", 9);
 Function<Integer, Double> sqrt = (Integer in) -> Math.sqrt((int) in);
 Map<String, Double> transformed = Maps.transformValues(map, sqrt);
 System.out.println(transformed);
 }

 ... prints {@code {a=2.0, b=3.0}}.

 <p>Changes in the underlying map are reflected in this view. Conversely, this view supports
 removal operations, and these are reflected in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys, and even null values provided
 that the function is capable of accepting null input. The transformed map might contain null
 values, if the function sometimes gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the underlying map is.

 <p>The function is applied lazily, invoked when needed. This is necessary for the returned map
 to be a view, but it means that the function will be applied many times for bulk operations
 like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code
 function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a
 view, copy the returned map into a new map of your choosing.]]>
      </doc>
    </method>
    <method name="transformValues" return="java.util.SortedMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.SortedMap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a sorted map where each value is transformed by a function. All other
 properties of the map, such as iteration order, are left intact. For example, the code:

 {@snippet :
 SortedMap<String, Integer> map = ImmutableSortedMap.of("a", 4, "b", 9);
 Function<Integer, Double> sqrt = (Integer in) -> Math.sqrt((int) in);
 SortedMap<String, Double> transformed =
      Maps.transformValues(map, sqrt);
 System.out.println(transformed);
 }

 ... prints {@code {a=2.0, b=3.0}}.

 <p>Changes in the underlying map are reflected in this view. Conversely, this view supports
 removal operations, and these are reflected in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys, and even null values provided
 that the function is capable of accepting null input. The transformed map might contain null
 values, if the function sometimes gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the underlying map is.

 <p>The function is applied lazily, invoked when needed. This is necessary for the returned map
 to be a view, but it means that the function will be applied many times for bulk operations
 like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code
 function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a
 view, copy the returned map into a new map of your choosing.

 @since 11.0]]>
      </doc>
    </method>
    <method name="transformValues" return="java.util.NavigableMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.NavigableMap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a navigable map where each value is transformed by a function. All other
 properties of the map, such as iteration order, are left intact. For example, the code:

 {@snippet :
 NavigableMap<String, Integer> map = Maps.newTreeMap();
 map.put("a", 4);
 map.put("b", 9);
 Function<Integer, Double> sqrt = (Integer in) -> Math.sqrt((int) in);
 NavigableMap<String, Double> transformed =
      Maps.transformNavigableValues(map, sqrt);
 System.out.println(transformed);
 }

 ... prints {@code {a=2.0, b=3.0}}.

 <p>Changes in the underlying map are reflected in this view. Conversely, this view supports
 removal operations, and these are reflected in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys, and even null values provided
 that the function is capable of accepting null input. The transformed map might contain null
 values, if the function sometimes gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the underlying map is.

 <p>The function is applied lazily, invoked when needed. This is necessary for the returned map
 to be a view, but it means that the function will be applied many times for bulk operations
 like {@link Map#containsValue} and {@code Map.toString()}. For this to perform well, {@code
 function} should be fast. To avoid lazy evaluation when the returned map doesn't need to be a
 view, copy the returned map into a new map of your choosing.

 @since 13.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="java.util.Map&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.Map&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a map whose values are derived from the original map's entries. In contrast
 to {@link #transformValues}, this method's entry-transformation logic may depend on the key as
 well as the value.

 <p>All other properties of the transformed map, such as iteration order, are left intact. For
 example, the code:

 {@snippet :
 Map<String, Boolean> options =
     ImmutableMap.of("verbose", true, "sort", false);
 EntryTransformer<String, Boolean, String> flagPrefixer =
     new EntryTransformer<String, Boolean, String>() {
       public String transformEntry(String key, Boolean value) {
         return value ? key : "no" + key;
       }
     };
 Map<String, String> transformed =
     Maps.transformEntries(options, flagPrefixer);
 System.out.println(transformed);
 }

 ... prints {@code {verbose=verbose, sort=nosort}}.

 <p>Changes in the underlying map are reflected in this view. Conversely, this view supports
 removal operations, and these are reflected in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys and null values provided that
 the transformer is capable of accepting null inputs. The transformed map might contain null
 values if the transformer sometimes gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the underlying map is.

 <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned
 map to be a view, but it means that the transformer will be applied many times for bulk
 operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform
 well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map
 doesn't need to be a view, copy the returned map into a new map of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code
 EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of
 type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as
 {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the
 transformed map.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="java.util.SortedMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.SortedMap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a sorted map whose values are derived from the original sorted map's entries.
 In contrast to {@link #transformValues}, this method's entry-transformation logic may depend on
 the key as well as the value.

 <p>All other properties of the transformed map, such as iteration order, are left intact. For
 example, the code:

 {@snippet :
 Map<String, Boolean> options =
     ImmutableSortedMap.of("verbose", true, "sort", false);
 EntryTransformer<String, Boolean, String> flagPrefixer =
     new EntryTransformer<String, Boolean, String>() {
       public String transformEntry(String key, Boolean value) {
         return value ? key : "yes" + key;
       }
     };
 SortedMap<String, String> transformed =
     Maps.transformEntries(options, flagPrefixer);
 System.out.println(transformed);
 }

 ... prints {@code {sort=yessort, verbose=verbose}}.

 <p>Changes in the underlying map are reflected in this view. Conversely, this view supports
 removal operations, and these are reflected in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys and null values provided that
 the transformer is capable of accepting null inputs. The transformed map might contain null
 values if the transformer sometimes gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the underlying map is.

 <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned
 map to be a view, but it means that the transformer will be applied many times for bulk
 operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform
 well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map
 doesn't need to be a view, copy the returned map into a new map of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code
 EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of
 type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as
 {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the
 transformed map.

 @since 11.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="java.util.NavigableMap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="java.util.NavigableMap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a navigable map whose values are derived from the original navigable map's
 entries. In contrast to {@link #transformValues}, this method's entry-transformation logic may
 depend on the key as well as the value.

 <p>All other properties of the transformed map, such as iteration order, are left intact. For
 example, the code:

 {@snippet :
 NavigableMap<String, Boolean> options = Maps.newTreeMap();
 options.put("verbose", false);
 options.put("sort", true);
 EntryTransformer<String, Boolean, String> flagPrefixer =
     new EntryTransformer<String, Boolean, String>() {
       public String transformEntry(String key, Boolean value) {
         return value ? key : ("yes" + key);
       }
     };
 NavigableMap<String, String> transformed =
     LabsMaps.transformNavigableEntries(options, flagPrefixer);
 System.out.println(transformed);
 }

 ... prints {@code {sort=yessort, verbose=verbose}}.

 <p>Changes in the underlying map are reflected in this view. Conversely, this view supports
 removal operations, and these are reflected in the underlying map.

 <p>It's acceptable for the underlying map to contain null keys and null values provided that
 the transformer is capable of accepting null inputs. The transformed map might contain null
 values if the transformer sometimes gives a null result.

 <p>The returned map is not thread-safe or serializable, even if the underlying map is.

 <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned
 map to be a view, but it means that the transformer will be applied many times for bulk
 operations like {@link Map#containsValue} and {@link Object#toString}. For this to perform
 well, {@code transformer} should be fast. To avoid lazy evaluation when the returned map
 doesn't need to be a view, copy the returned map into a new map of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code
 EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of
 type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as
 {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the
 transformed map.

 @since 13.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} whose keys satisfy a predicate. The
 returned map is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and
 {@code putAll()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings whose keys satisfy the filter will be removed from the underlying
 map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.]]>
      </doc>
    </method>
    <method name="filterKeys" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedMap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a sorted map containing the mappings in {@code unfiltered} whose keys satisfy a
 predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the
 other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and
 {@code putAll()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings whose keys satisfy the filter will be removed from the underlying
 map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.NavigableMap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a navigable map containing the mappings in {@code unfiltered} whose keys satisfy a
 predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the
 other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a key that doesn't satisfy the predicate, the map's {@code put()} and
 {@code putAll()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings whose keys satisfy the filter will be removed from the underlying
 map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a bimap containing the mappings in {@code unfiltered} whose keys satisfy a predicate.
 The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the bimap
 and its views. When given a key that doesn't satisfy the predicate, the bimap's {@code put()},
 {@code forcePut()} and {@code putAll()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 bimap or its views, only mappings that satisfy the filter will be removed from the underlying
 bimap.

 <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key in
 the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i>
 needed, it may be faster to copy the filtered bimap and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented
 at {@link Predicate#apply}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterValues" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} whose values satisfy a predicate.
 The returned map is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},
 {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings whose values satisfy the filter will be removed from the underlying
 map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.]]>
      </doc>
    </method>
    <method name="filterValues" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedMap&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a sorted map containing the mappings in {@code unfiltered} whose values satisfy a
 predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the
 other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},
 {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings whose values satisfy the filter will be removed from the underlying
 map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterValues" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.NavigableMap&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a navigable map containing the mappings in {@code unfiltered} whose values satisfy a
 predicate. The returned map is a live view of {@code unfiltered}; changes to one affect the
 other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a value that doesn't satisfy the predicate, the map's {@code put()},
 {@code putAll()}, and {@link Entry#setValue} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings whose values satisfy the filter will be removed from the underlying
 map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterValues" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a bimap containing the mappings in {@code unfiltered} whose values satisfy a predicate.
 The returned bimap is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the bimap
 and its views. When given a value that doesn't satisfy the predicate, the bimap's {@code
 put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link
 IllegalArgumentException}. Similarly, the map's entries have a {@link Entry#setValue} method
 that throws an {@link IllegalArgumentException} when the provided value doesn't satisfy the
 predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 bimap or its views, only mappings that satisfy the filter will be removed from the underlying
 bimap.

 <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every value in
 the underlying bimap and determine which satisfy the filter. When a live view is <i>not</i>
 needed, it may be faster to copy the filtered bimap and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented
 at {@link Predicate#apply}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterEntries" return="java.util.Map&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Map&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a map containing the mappings in {@code unfiltered} that satisfy a predicate. The
 returned map is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code
 put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the
 map's entries have a {@link Entry#setValue} method that throws an {@link
 IllegalArgumentException} when the existing key and the provided value don't satisfy the
 predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings that satisfy the filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}.]]>
      </doc>
    </method>
    <method name="filterEntries" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedMap&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.
 The returned map is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code
 put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the
 map's entries have a {@link Entry#setValue} method that throws an {@link
 IllegalArgumentException} when the existing key and the provided value don't satisfy the
 predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings that satisfy the filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterEntries" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.NavigableMap&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a sorted map containing the mappings in {@code unfiltered} that satisfy a predicate.
 The returned map is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting map's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the map
 and its views. When given a key/value pair that doesn't satisfy the predicate, the map's {@code
 put()} and {@code putAll()} methods throw an {@link IllegalArgumentException}. Similarly, the
 map's entries have a {@link Entry#setValue} method that throws an {@link
 IllegalArgumentException} when the existing key and the provided value don't satisfy the
 predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered map
 or its views, only mappings that satisfy the filter will be removed from the underlying map.

 <p>The returned map isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered map's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying map and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered map and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterEntries" return="com.google.common.collect.BiMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.BiMap&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a bimap containing the mappings in {@code unfiltered} that satisfy a predicate. The
 returned bimap is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting bimap's {@code keySet()}, {@code entrySet()}, and {@code values()} views have
 iterators that don't support {@code remove()}, but all other methods are supported by the bimap
 and its views. When given a key/value pair that doesn't satisfy the predicate, the bimap's
 {@code put()}, {@code forcePut()} and {@code putAll()} methods throw an {@link
 IllegalArgumentException}. Similarly, the map's entries have an {@link Entry#setValue} method
 that throws an {@link IllegalArgumentException} when the existing key and the provided value
 don't satisfy the predicate.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 bimap or its views, only mappings that satisfy the filter will be removed from the underlying
 bimap.

 <p>The returned bimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered bimap's methods, such as {@code size()}, iterate across every key/value
 mapping in the underlying bimap and determine which satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy the filtered bimap and use the copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals </i>, as documented
 at {@link Predicate#apply}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="unmodifiableNavigableMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.NavigableMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified navigable map. Query operations on the returned
 map read through to the specified map, and attempts to modify the returned map, whether direct
 or via its views, result in an {@code UnsupportedOperationException}.

 <p>The returned navigable map will be serializable if the specified navigable map is
 serializable.

 <p>This method's signature will not permit you to convert a {@code NavigableMap<? extends K,
 V>} to a {@code NavigableMap<K, V>}. If it permitted this, the returned map's {@code
 comparator()} method might return a {@code Comparator<? extends K>}, which works only on a
 particular subtype of {@code K}, but promise that it's a {@code Comparator<? super K>}, which
 must work on any type of {@code K}.

 @param map the navigable map for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified navigable map
 @since 12.0]]>
      </doc>
    </method>
    <method name="synchronizedNavigableMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="navigableMap" type="java.util.NavigableMap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In
 order to guarantee serial access, it is critical that <b>all</b> access to the backing
 navigable map is accomplished through the returned navigable map (or its views).

 <p>It is imperative that the user manually synchronize on the returned navigable map when
 iterating over any of its collection views, or the collections views of any of its {@code
 descendingMap}, {@code subMap}, {@code headMap} or {@code tailMap} views.

 {@snippet :
 NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());

 // Needn't be in synchronized block
 NavigableSet<K> set = map.navigableKeySet();

 synchronized (map) { // Synchronizing on map, not set!
   Iterator<K> it = set.iterator(); // Must be in synchronized block
   while (it.hasNext()) {
     foo(it.next());
   }
 }
 }

 <p>or:

 {@snippet :
 NavigableMap<K, V> map = synchronizedNavigableMap(new TreeMap<K, V>());
 NavigableMap<K, V> map2 = map.subMap(foo, false, bar, true);

 // Needn't be in synchronized block
 NavigableSet<K> set2 = map2.descendingKeySet();

 synchronized (map) { // Synchronizing on map, not map2 or set2!
   Iterator<K> it = set2.iterator(); // Must be in synchronized block
   while (it.hasNext()) {
     foo(it.next());
   }
 }
 }

 <p>Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned navigable map will be serializable if the specified navigable map is
 serializable.

 @param navigableMap the navigable map to be "wrapped" in a synchronized navigable map.
 @return a synchronized view of the specified navigable map.
 @since 13.0]]>
      </doc>
    </method>
    <method name="subMap" return="java.util.NavigableMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.NavigableMap&lt;K, V&gt;"/>
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a view of the portion of {@code map} whose keys are contained by {@code range}.

 <p>This method delegates to the appropriate methods of {@link NavigableMap} (namely {@link
 NavigableMap#subMap(Object, boolean, Object, boolean) subMap()}, {@link
 NavigableMap#tailMap(Object, boolean) tailMap()}, and {@link NavigableMap#headMap(Object,
 boolean) headMap()}) to actually construct the view. Consult these methods for a full
 description of the returned view's behavior.

 <p><b>Warning:</b> {@code Range}s always represent a range of values using the values' natural
 ordering. {@code NavigableMap} on the other hand can specify a custom ordering via a {@link
 Comparator}, which can violate the natural ordering. Using this method (or in general using
 {@code Range}) with unnaturally-ordered maps can lead to unexpected and undefined behavior.

 @since 20.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Map} instances (including instances of {@link
 SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts {@link Lists}, {@link Sets}
 and {@link Queues}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps">{@code Maps}</a>.

 @author Kevin Bourrillion
 @author Mike Bostock
 @author Isaac Shum
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Maps -->
  <!-- start interface com.google.common.collect.Maps.EntryTransformer -->
  <interface name="Maps.EntryTransformer"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transformEntry" return="V2 extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V1 extends java.lang.Object"/>
      <doc>
      <![CDATA[Determines an output value based on a key-value pair. This method is <i>generally
 expected</i>, but not absolutely required, to have the following properties:

 <ul>
   <li>Its execution does not cause any observable side effects.
   <li>The computation is <i>consistent with equals</i>; that is, {@link Objects#equals
       Objects.equals}{@code (k1, k2) &&} {@link Objects#equals Objects.equals}{@code (v1,
       v2)} implies that {@code Objects.equals(transformer.transform(k1, v1),
       transformer.transform(k2, v2))}.
 </ul>

 @throws NullPointerException if the key or value is null and this transformer does not accept
     null arguments]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A transformation of the value of a key-value pair, using both key and value as inputs. To apply
 the transformation to a map, use {@link Maps#transformEntries(Map, EntryTransformer)}.

 @param <K> the key type of the input and output entries
 @param <V1> the value type of the input entry
 @param <V2> the value type of the output entry
 @since 7.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Maps.EntryTransformer -->
  <!-- start class com.google.common.collect.MinMaxPriorityQueue -->
  <class name="MinMaxPriorityQueue" extends="java.util.AbstractQueue&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new min-max priority queue with default settings: natural order, no maximum size, no
 initial contents, and an initial expected size of 11.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialContents" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a new min-max priority queue using natural order, no maximum size, and initially
 containing the given elements.]]>
      </doc>
    </method>
    <method name="orderedBy" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;B&gt;"/>
      <doc>
      <![CDATA[Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances
 that use {@code comparator} to determine the least and greatest elements.]]>
      </doc>
    </method>
    <method name="expectedSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;java.lang.Comparable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances
 sized appropriately to hold {@code expectedSize} elements.]]>
      </doc>
    </method>
    <method name="maximumSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;java.lang.Comparable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maximumSize" type="int"/>
      <doc>
      <![CDATA[Creates and returns a new builder, configured to build {@code MinMaxPriorityQueue} instances
 that are limited to {@code maximumSize} elements. Each time a queue grows beyond this bound, it
 immediately removes its greatest element (according to its comparator), which might be the
 element that was just added.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds the given element to this queue. If this queue has a maximum size, after adding {@code
 element} the queue will automatically evict its greatest element (according to its comparator),
 which may be {@code element} itself.

 @return {@code true} always]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Adds the given element to this queue. If this queue has a maximum size, after adding {@code
 element} the queue will automatically evict its greatest element (according to its comparator),
 which may be {@code element} itself.]]>
      </doc>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peek" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the least element of this queue, or returns {@code null} if the queue is
 empty.]]>
      </doc>
    </method>
    <method name="removeFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the least element of this queue.

 @throws NoSuchElementException if the queue is empty]]>
      </doc>
    </method>
    <method name="peekFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves, but does not remove, the least element of this queue, or returns {@code null} if the
 queue is empty.]]>
      </doc>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the greatest element of this queue, or returns {@code null} if the queue is
 empty.]]>
      </doc>
    </method>
    <method name="removeLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the greatest element of this queue.

 @throws NoSuchElementException if the queue is empty]]>
      </doc>
    </method>
    <method name="peekLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves, but does not remove, the greatest element of this queue, or returns {@code null} if
 the queue is empty.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an iterator over the elements contained in this collection, <i>in no particular
 order</i>.

 <p>The iterator is <i>fail-fast</i>: If the MinMaxPriorityQueue is modified at any time after
 the iterator is created, in any way except through the iterator's own remove method, the
 iterator will generally throw a {@link ConcurrentModificationException}. Thus, in the face of
 concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary,
 non-deterministic behavior at an undetermined time in the future.

 <p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally
 speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent
 modification. Fail-fast iterators throw {@code ConcurrentModificationException} on a
 best-effort basis. Therefore, it would be wrong to write a program that depended on this
 exception for its correctness: <i>the fail-fast behavior of iterators should be used only to
 detect bugs.</i>

 @return an iterator over the elements contained in this collection]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator used to order the elements in this queue. Obeys the general contract of
 {@link PriorityQueue#comparator}, but returns {@link Ordering#natural} instead of {@code null}
 to indicate natural ordering.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A double-ended priority queue, which provides constant-time access to both its least element and
 its greatest element, as determined by the queue's specified comparator. If no comparator is
 given at creation time, the natural order of elements is used. If no maximum size is given at
 creation time, the queue is unbounded.

 <p>Usage example:

 {@snippet :
 MinMaxPriorityQueue<User> users = MinMaxPriorityQueue.orderedBy(userComparator)
     .maximumSize(1000)
     .create();
 }

 <p>As a {@link Queue} it functions exactly as a {@link PriorityQueue}: its head element -- the
 implicit target of the methods {@link #peek()}, {@link #poll()} and {@link #remove()} -- is
 defined as the <i>least</i> element in the queue according to the queue's comparator. But unlike
 a regular priority queue, the methods {@link #peekLast}, {@link #pollLast} and {@link
 #removeLast} are also provided, to act on the <i>greatest</i> element in the queue instead.

 <p>A min-max priority queue can be configured with a maximum size. If so, each time the size of
 the queue exceeds that value, the queue automatically removes its greatest element according to
 its comparator (which might be the element that was just added). This is different from
 conventional bounded queues, which either block or reject new elements when full.

 <p>This implementation is based on the <a
 href="http://portal.acm.org/citation.cfm?id=6621">min-max heap</a> developed by Atkinson, et al.
 Unlike many other double-ended priority queues, it stores elements in a single array, as compact
 as the traditional heap data structure used in {@link PriorityQueue}.

 <p>This class is not thread-safe, and does not accept null elements.

 <p><i>Performance notes:</i>

 <ul>
   <li>If you only access one end of the queue, and do use a maximum size, this class will perform
       significantly worse than a {@code PriorityQueue} with manual eviction above the maximum
       size. In many cases {@link Ordering#leastOf} may work for your use case with significantly
       improved (and asymptotically superior) performance.
   <li>The retrieval operations {@link #peek}, {@link #peekFirst}, {@link #peekLast}, {@link
       #element}, and {@link #size} are constant-time.
   <li>The enqueuing and dequeuing operations ({@link #offer}, {@link #add}, and all the forms of
       {@link #poll} and {@link #remove()}) run in {@code O(log n) time}.
   <li>The {@link #remove(Object)} and {@link #contains} operations require linear ({@code O(n)})
       time.
   <li>If you only access one end of the queue, and don't use a maximum size, this class is
       functionally equivalent to {@link PriorityQueue}, but significantly slower.
 </ul>

 @author Sverre Sundsdal
 @author Torbjorn Gannholm
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MinMaxPriorityQueue -->
  <!-- start class com.google.common.collect.MinMaxPriorityQueue.Builder -->
  <class name="MinMaxPriorityQueue.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="expectedSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Configures this builder to build min-max priority queues with an initial expected size of
 {@code expectedSize}.]]>
      </doc>
    </method>
    <method name="maximumSize" return="com.google.common.collect.MinMaxPriorityQueue.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maximumSize" type="int"/>
      <doc>
      <![CDATA[Configures this builder to build {@code MinMaxPriorityQueue} instances that are limited to
 {@code maximumSize} elements. Each time a queue grows beyond this bound, it immediately
 removes its greatest element (according to its comparator), which might be the element that
 was just added.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new min-max priority queue using the previously specified options, and having no
 initial contents.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MinMaxPriorityQueue&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialContents" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Builds a new min-max priority queue using the previously specified options, and having the
 given initial elements.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The builder class used in creation of min-max priority queues. Instead of constructing one
 directly, use {@link MinMaxPriorityQueue#orderedBy(Comparator)}, {@link
 MinMaxPriorityQueue#expectedSize(int)} or {@link MinMaxPriorityQueue#maximumSize(int)}.

 @param <B> the upper bound on the eventual type that can be produced by this builder (for
     example, a {@code Builder<Number>} can produce a {@code Queue<Number>} or {@code
     Queue<Integer>} but not a {@code Queue<Object>}).
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MinMaxPriorityQueue.Builder -->
  <!-- start class com.google.common.collect.MoreCollectors -->
  <class name="MoreCollectors" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toOptional" return="java.util.stream.Collector&lt;T, ?, java.util.Optional&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A collector that converts a stream of zero or one elements to an {@code Optional}.

 @throws IllegalArgumentException if the stream consists of two or more elements.
 @throws NullPointerException if any element in the stream is {@code null}.
 @return {@code Optional.of(onlyElement)} if the stream has exactly one element (must not be
     {@code null}) and returns {@code Optional.empty()} if it has none.]]>
      </doc>
    </method>
    <method name="onlyElement" return="java.util.stream.Collector&lt;T, ?, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A collector that takes a stream containing exactly one element and returns that element. The
 returned collector throws an {@code IllegalArgumentException} if the stream consists of two or
 more elements, and a {@code NoSuchElementException} if the stream is empty.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collectors not present in {@code java.util.stream.Collectors} that are not otherwise associated
 with a {@code com.google.common} type.

 @author Louis Wasserman
 @since 33.2.0 (available since 21.0 in guava-jre)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MoreCollectors -->
  <!-- start interface com.google.common.collect.Multimap -->
  <interface name="Multimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value pairs in this multimap.

 <p><b>Note:</b> this method does not return the number of <i>distinct keys</i> in the multimap,
 which is given by {@code keySet().size()} or {@code asMap().size()}. See the opening section of
 the {@link Multimap} class documentation for clarification.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this multimap contains no key-value pairs. Equivalent to {@code size()
 == 0}, but can in some cases be more efficient.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if this multimap contains at least one key-value pair with the key {@code
 key}.]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if this multimap contains at least one key-value pair with the value
 {@code value}.]]>
      </doc>
    </method>
    <method name="containsEntry" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if this multimap contains at least one key-value pair with the key {@code
 key} and the value {@code value}.]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Stores a key-value pair in this multimap.

 <p>Some multimap implementations allow duplicate key-value pairs, in which case {@code put}
 always adds a new key-value pair and increases the multimap size by 1. Other implementations
 prohibit duplicates, and storing a key-value pair that's already in the multimap has no effect.

 @return {@code true} if the method increased the size of the multimap, or {@code false} if the
     multimap already contained the key-value pair and doesn't allow duplicates]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Removes a single key-value pair with the key {@code key} and the value {@code value} from this
 multimap, if such exists. If multiple key-value pairs in the multimap fit this description,
 which one is removed is unspecified.

 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a key-value pair in this multimap for each of {@code values}, all using the same key,
 {@code key}. Equivalent to (but expected to be more efficient than):

 {@snippet :
 for (V value : values) {
   put(key, value);
 }
 }

 <p>In particular, this is a no-op if {@code values} is empty.

 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="putAll" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Stores all key-value pairs of {@code multimap} in this multimap, in the order returned by
 {@code multimap.entries()}.

 @return {@code true} if the multimap changed]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Collection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key, replacing any existing values for that key.

 <p>If {@code values} is empty, this is equivalent to {@link #removeAll(Object) removeAll(key)}.

 @return the collection of replaced values, or an empty collection if no values were previously
     associated with the key. The collection <i>may</i> be modifiable, but updating it will have
     no effect on the multimap.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.Collection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[Removes all values associated with the key {@code key}.

 <p>Once this method returns, {@code key} will not be mapped to any values, so it will not
 appear in {@link #keySet()}, {@link #asMap()}, or any other views.

 @return the values that were removed (possibly empty). The returned collection <i>may</i> be
     modifiable, but updating it will have no effect on the multimap.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all key-value pairs from the multimap, leaving it {@linkplain #isEmpty empty}.]]>
      </doc>
    </method>
    <method name="get" return="java.util.Collection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a view collection of the values associated with {@code key} in this multimap, if any.
 Note that when {@code containsKey(key)} is false, this returns an empty collection, not {@code
 null}.

 <p>Changes to the returned collection will update the underlying multimap, and vice versa.]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set&lt;K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view collection of all <i>distinct</i> keys contained in this multimap. Note that the
 key set contains a key if and only if this multimap maps that key to at least one value.

 <p>Changes to the returned set will update the underlying multimap, and vice versa. However,
 <i>adding</i> to the returned set is not possible.]]>
      </doc>
    </method>
    <method name="keys" return="com.google.common.collect.Multiset&lt;K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view collection containing the key from each key-value pair in this multimap,
 <i>without</i> collapsing duplicates. This collection has the same size as this multimap, and
 {@code keys().count(k) == get(k).size()} for all {@code k}.

 <p>Changes to the returned multiset will update the underlying multimap, and vice versa.
 However, <i>adding</i> to the returned collection is not possible.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view collection containing the <i>value</i> from each key-value pair contained in
 this multimap, without collapsing duplicates (so {@code values().size() == size()}).

 <p>Changes to the returned collection will update the underlying multimap, and vice versa.
 However, <i>adding</i> to the returned collection is not possible.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Collection&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view collection of all key-value pairs contained in this multimap, as {@link Entry}
 instances.

 <p>Changes to the returned collection or the entries it contains will update the underlying
 multimap, and vice versa. However, <i>adding</i> to the returned collection is not possible.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of this multimap as a {@code Map} from each distinct key to the nonempty
 collection of that key's associated values. Note that {@code this.asMap().get(k)} is equivalent
 to {@code this.get(k)} only when {@code k} is a key contained in the multimap; otherwise it
 returns {@code null} as opposed to an empty collection.

 <p>Changes to the returned map or the collections that serve as its values will update the
 underlying multimap, and vice versa. The map does not support {@code put} or {@code putAll},
 nor do its entries support {@link Entry#setValue setValue}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Compares the specified object with this multimap for equality. Two multimaps are equal when
 their map views, as returned by {@link #asMap}, are also equal.

 <p>In general, two multimaps with identical key-value mappings may or may not be equal,
 depending on the implementation. For example, two {@link SetMultimap} instances with the same
 key-value mappings are equal, but equality of two {@link ListMultimap} instances depends on the
 ordering of the values for each key.

 <p>A non-empty {@link SetMultimap} cannot be equal to a non-empty {@link ListMultimap}, since
 their {@link #asMap} views contain unequal collections as values. However, any two empty
 multimaps are equal, because they both have empty {@link #asMap} views.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multimap.

 <p>The hash code of a multimap is defined as the hash code of the map view, as returned by
 {@link Multimap#asMap}.

 <p>In general, two multimaps with identical key-value mappings may or may not have the same
 hash codes, depending on the implementation. For example, two {@link SetMultimap} instances
 with the same key-value mappings will have the same {@code hashCode}, but the {@code hashCode}
 of {@link ListMultimap} instances depends on the ordering of the values for each key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection that maps keys to values, similar to {@link Map}, but in which each key may be
 associated with <i>multiple</i> values. You can visualize the contents of a multimap either as a
 map from keys to <i>nonempty</i> collections of values:

 <ul>
   <li>a # 1, 2
   <li>b # 3
 </ul>

 ... or as a single "flattened" collection of key-value pairs:

 <ul>
   <li>a # 1
   <li>a # 2
   <li>b # 3
 </ul>

 <p><b>Important:</b> although the first interpretation resembles how most multimaps are
 <i>implemented</i>, the design of the {@code Multimap} API is based on the <i>second</i> form.
 So, using the multimap shown above as an example, the {@link #size} is {@code 3}, not {@code 2},
 and the {@link #values} collection is {@code [1, 2, 3]}, not {@code [[1, 2], [3]]}. For those
 times when the first style is more useful, use the multimap's {@link #asMap} view (or create a
 {@code Map<K, Collection<V>>} in the first place).

 <h3>Example</h3>

 <p>The following code:

 {@snippet :
 ListMultimap<String, String> multimap = ArrayListMultimap.create();
 for (President pres : US_PRESIDENTS_IN_ORDER) {
   multimap.put(pres.firstName(), pres.lastName());
 }
 for (String firstName : multimap.keySet()) {
   List<String> lastNames = multimap.get(firstName);
   out.println(firstName + ": " + lastNames);
 }
 }

 ... produces output such as:

 {@snippet :
 Zachary: [Taylor]
 John: [Adams, Adams, Tyler, Kennedy]  // Remember, Quincy!
 George: [Washington, Bush, Bush]
 Grover: [Cleveland, Cleveland]        // Two, non-consecutive terms, rep'ing NJ!
 ...
 }

 <h3>Views</h3>

 <p>Much of the power of the multimap API comes from the <i>view collections</i> it provides.
 These always reflect the latest state of the multimap itself. When they support modification, the
 changes are <i>write-through</i> (they automatically update the backing multimap). These view
 collections are:

 <ul>
   <li>{@link #asMap}, mentioned above
   <li>{@link #keys}, {@link #keySet}, {@link #values}, {@link #entries}, which are similar to the
       corresponding view collections of {@link Map}
   <li>and, notably, even the collection returned by {@link #get get(key)} is an active view of
       the values corresponding to {@code key}
 </ul>

 <p>The collections returned by the {@link #replaceValues replaceValues} and {@link #removeAll
 removeAll} methods, which contain values that have just been removed from the multimap, are
 naturally <i>not</i> views.

 <h3>Subinterfaces</h3>

 <p>Instead of using the {@code Multimap} interface directly, prefer the subinterfaces {@link
 ListMultimap} and {@link SetMultimap}. These take their names from the fact that the collections
 they return from {@code get} behave like (and, of course, implement) {@link List} and {@link
 Set}, respectively.

 <p>For example, the "presidents" code snippet above used a {@code ListMultimap}; if it had used a
 {@code SetMultimap} instead, two presidents would have vanished, and last names might or might
 not appear in chronological order.

 <p><b>Warning:</b> instances of type {@code Multimap} may not implement {@link Object#equals} in
 the way you expect. Multimaps containing the same key-value pairs, even in the same order, may or
 may not be equal and may or may not have the same {@code hashCode}. The recommended subinterfaces
 provide much stronger guarantees.

 <h3>Comparison to a map of collections</h3>

 <p>Multimaps are commonly used in places where a {@code Map<K, Collection<V>>} would otherwise
 have appeared. The differences include:

 <ul>
   <li>There is no need to populate an empty collection before adding an entry with {@link #put
       put}.
   <li>{@code get} never returns {@code null}, only an empty collection.
   <li>A key is contained in the multimap if and only if it maps to at least one value. Any
       operation that causes a key to have zero associated values has the effect of
       <i>removing</i> that key from the multimap.
   <li>The total entry count is available as {@link #size}.
   <li>Many complex operations become easier; for example, {@code
       Collections.min(multimap.values())} finds the smallest value across all keys.
 </ul>

 <h3>Implementations</h3>

 <ul>
   <li>{@link ImmutableListMultimap}
   <li>{@link ImmutableSetMultimap}
   <li>Configure your own mutable multimap with {@link MultimapBuilder}
   <li>{@link LinkedListMultimap} (for one unusual kind of mutable {@code Multimap})
 </ul>

 Guava contains a number of other multimap implementations, such as {@link ArrayListMultimap}. In
 new code, we recommend using {@link MultimapBuilder} instead: It provides better control of how
 keys and values are stored.

 <h3>Other Notes</h3>

 <p>As with {@code Map}, the behavior of a {@code Multimap} is not specified if key objects
 already present in the multimap change in a manner that affects {@code equals} comparisons. Use
 caution if mutable objects are used as keys in a {@code Multimap}.

 <p>All methods that modify the multimap are optional. The view collections returned by the
 multimap may or may not be modifiable. Any modification method that is not supported will throw
 {@link UnsupportedOperationException}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multimap -->
  <!-- start class com.google.common.collect.MultimapBuilder -->
  <class name="MultimapBuilder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hashKeys" return="com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses a hash table to map keys to value collections.]]>
      </doc>
    </method>
    <method name="hashKeys" return="com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Uses a hash table to map keys to value collections, initialized to expect the specified number
 of keys.

 @throws IllegalArgumentException if {@code expectedKeys < 0}]]>
      </doc>
    </method>
    <method name="linkedHashKeys" return="com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses a hash table to map keys to value collections.

 <p>The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
 Multimap#asMap()} will iterate through the keys in the order that they were first added to the
 multimap, save that if all values associated with a key are removed and then the key is added
 back into the multimap, that key will come last in the key iteration order.]]>
      </doc>
    </method>
    <method name="linkedHashKeys" return="com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedKeys" type="int"/>
      <doc>
      <![CDATA[Uses an hash table to map keys to value collections, initialized to expect the specified number
 of keys.

 <p>The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
 Multimap#asMap()} will iterate through the keys in the order that they were first added to the
 multimap, save that if all values associated with a key are removed and then the key is added
 back into the multimap, that key will come last in the key iteration order.]]>
      </doc>
    </method>
    <method name="treeKeys" return="com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys&lt;java.lang.Comparable&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses a naturally-ordered {@link TreeMap} to map keys to value collections.

 <p>The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
 Multimap#asMap()} will iterate through the keys in sorted order.

 <p>For all multimaps generated by the resulting builder, the {@link Multimap#keySet()} can be
 safely cast to a {@link java.util.SortedSet}, and the {@link Multimap#asMap()} can safely be
 cast to a {@link java.util.SortedMap}.]]>
      </doc>
    </method>
    <method name="treeKeys" return="com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys&lt;K0&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;K0&gt;"/>
      <doc>
      <![CDATA[Uses a {@link TreeMap} sorted by the specified comparator to map keys to value collections.

 <p>The collections returned by {@link Multimap#keySet()}, {@link Multimap#keys()}, and {@link
 Multimap#asMap()} will iterate through the keys in sorted order.

 <p>For all multimaps generated by the resulting builder, the {@link Multimap#keySet()} can be
 safely cast to a {@link java.util.SortedSet}, and the {@link Multimap#asMap()} can safely be
 cast to a {@link java.util.SortedMap}.

 <p>Multimaps generated by the resulting builder will not be serializable if {@code comparator}
 is not serializable.]]>
      </doc>
    </method>
    <method name="enumKeys" return="com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys&lt;K0&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyClass" type="java.lang.Class&lt;K0&gt;"/>
      <doc>
      <![CDATA[Uses an {@link EnumMap} to map keys to value collections.

 @since 16.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty {@code Multimap} with the specified implementation.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Multimap} with the specified implementation, initialized with the entries of
 {@code multimap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable builder for {@link Multimap} instances, letting you independently select the desired
 behaviors (for example, ordering) of the backing map and value-collections. Example:

 {@snippet :
 ListMultimap<UserId, ErrorResponse> errorsByUser =
     MultimapBuilder.linkedHashKeys().arrayListValues().build();
 SortedSetMultimap<String, Method> methodsForName =
     MultimapBuilder.treeKeys().treeSetValues(this::compareMethods).build();
 }

 <p>{@code MultimapBuilder} instances are immutable. Invoking a configuration method has no effect
 on the receiving instance; you must store and use the new builder instance it returns instead.

 <p>The generated multimaps are serializable if the key and value types are serializable, unless
 stated otherwise in one of the configuration methods.

 @author Louis Wasserman
 @param <K0> An upper bound on the key type of the generated multimap.
 @param <V0> An upper bound on the value type of the generated multimap.
 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MultimapBuilder -->
  <!-- start class com.google.common.collect.MultimapBuilder.ListMultimapBuilder -->
  <class name="MultimapBuilder.ListMultimapBuilder" extends="com.google.common.collect.MultimapBuilder&lt;K0, V0&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="build" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A specialization of {@link MultimapBuilder} that generates {@link ListMultimap} instances.

 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MultimapBuilder.ListMultimapBuilder -->
  <!-- start class com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys -->
  <class name="MultimapBuilder.MultimapBuilderWithKeys" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="arrayListValues" return="com.google.common.collect.MultimapBuilder.ListMultimapBuilder&lt;K0, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses an {@link ArrayList} to store value collections.]]>
      </doc>
    </method>
    <method name="arrayListValues" return="com.google.common.collect.MultimapBuilder.ListMultimapBuilder&lt;K0, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Uses an {@link ArrayList} to store value collections, initialized to expect the specified
 number of values per key.

 @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}]]>
      </doc>
    </method>
    <method name="linkedListValues" return="com.google.common.collect.MultimapBuilder.ListMultimapBuilder&lt;K0, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses a {@link LinkedList} to store value collections.

 <p><b>Performance note:</b> {@link ArrayList} and {@link java.util.ArrayDeque} consistently
 outperform {@code LinkedList} except in certain rare and specific situations. Unless you have
 spent a lot of time benchmarking your specific needs, use one of those instead. (However, we
 do not currently offer a {@link Multimap} implementation based on {@link
 java.util.ArrayDeque}.)]]>
      </doc>
    </method>
    <method name="hashSetValues" return="com.google.common.collect.MultimapBuilder.SetMultimapBuilder&lt;K0, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses a hash-based {@code Set} to store value collections.]]>
      </doc>
    </method>
    <method name="hashSetValues" return="com.google.common.collect.MultimapBuilder.SetMultimapBuilder&lt;K0, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Uses a hash-based {@code Set} to store value collections, initialized to expect the specified
 number of values per key.

 @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}]]>
      </doc>
    </method>
    <method name="linkedHashSetValues" return="com.google.common.collect.MultimapBuilder.SetMultimapBuilder&lt;K0, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses an insertion-ordered hash-based {@code Set} to store value collections.]]>
      </doc>
    </method>
    <method name="linkedHashSetValues" return="com.google.common.collect.MultimapBuilder.SetMultimapBuilder&lt;K0, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedValuesPerKey" type="int"/>
      <doc>
      <![CDATA[Uses an insertion-ordered hash-based {@code Set} to store value collections, initialized to
 expect the specified number of values per key.

 @throws IllegalArgumentException if {@code expectedValuesPerKey < 0}]]>
      </doc>
    </method>
    <method name="treeSetValues" return="com.google.common.collect.MultimapBuilder.SortedSetMultimapBuilder&lt;K0, java.lang.Comparable&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Uses a naturally-ordered {@link TreeSet} to store value collections.]]>
      </doc>
    </method>
    <method name="treeSetValues" return="com.google.common.collect.MultimapBuilder.SortedSetMultimapBuilder&lt;K0, V0&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;V0&gt;"/>
      <doc>
      <![CDATA[Uses a {@link TreeSet} ordered by the specified comparator to store value collections.

 <p>Multimaps generated by the resulting builder will not be serializable if {@code
 comparator} is not serializable.]]>
      </doc>
    </method>
    <method name="enumSetValues" return="com.google.common.collect.MultimapBuilder.SetMultimapBuilder&lt;K0, V0&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueClass" type="java.lang.Class&lt;V0&gt;"/>
      <doc>
      <![CDATA[Uses an {@link EnumSet} to store value collections.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An intermediate stage in a {@link MultimapBuilder} in which the key-value collection map
 implementation has been specified, but the value collection implementation has not.

 @param <K0> The upper bound on the key type of the generated multimap.
 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MultimapBuilder.MultimapBuilderWithKeys -->
  <!-- start class com.google.common.collect.MultimapBuilder.SetMultimapBuilder -->
  <class name="MultimapBuilder.SetMultimapBuilder" extends="com.google.common.collect.MultimapBuilder&lt;K0, V0&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="build" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A specialization of {@link MultimapBuilder} that generates {@link SetMultimap} instances.

 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MultimapBuilder.SetMultimapBuilder -->
  <!-- start class com.google.common.collect.MultimapBuilder.SortedSetMultimapBuilder -->
  <class name="MultimapBuilder.SortedSetMultimapBuilder" extends="com.google.common.collect.MultimapBuilder.SetMultimapBuilder&lt;K0, V0&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="build" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A specialization of {@link MultimapBuilder} that generates {@link SortedSetMultimap} instances.

 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MultimapBuilder.SortedSetMultimapBuilder -->
  <!-- start class com.google.common.collect.Multimaps -->
  <class name="Multimaps" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toMultimap" return="java.util.stream.Collector&lt;T, ?, M&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="multimapSupplier" type="java.util.function.Supplier&lt;M&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} accumulating entries into a {@code Multimap} generated from the
 specified supplier. The keys and values of the entries are the result of applying the provided
 mapping functions to the input elements, accumulated in the encounter order of the stream.

 <p>Example:

 {@snippet :
 static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP =
     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
         .collect(
             toMultimap(
                  str -> str.charAt(0),
                  str -> str.substring(1),
                  MultimapBuilder.treeKeys().arrayListValues()::build));

 // is equivalent to

 static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP;

 static {
     FIRST_LETTER_MULTIMAP = MultimapBuilder.treeKeys().arrayListValues().build();
     FIRST_LETTER_MULTIMAP.put('b', "anana");
     FIRST_LETTER_MULTIMAP.put('a', "pple");
     FIRST_LETTER_MULTIMAP.put('a', "sparagus");
     FIRST_LETTER_MULTIMAP.put('c', "arrot");
     FIRST_LETTER_MULTIMAP.put('c', "herry");
 }
 }

 <p>To collect to an {@link ImmutableMultimap}, use either {@link
 ImmutableSetMultimap#toImmutableSetMultimap} or {@link
 ImmutableListMultimap#toImmutableListMultimap}.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="flatteningToMultimap" return="java.util.stream.Collector&lt;T, ?, M&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyFunction" type="java.util.function.Function&lt;? super T, ? extends K&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends java.util.stream.Stream&lt;? extends V&gt;&gt;"/>
      <param name="multimapSupplier" type="java.util.function.Supplier&lt;M&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} accumulating entries into a {@code Multimap} generated from the
 specified supplier. Each input element is mapped to a key and a stream of values, each of which
 are put into the resulting {@code Multimap}, in the encounter order of the stream and the
 encounter order of the streams of values.

 <p>Example:

 {@snippet :
 static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =
     Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
         .collect(
             flatteningToMultimap(
                  str -> str.charAt(0),
                  str -> str.substring(1).chars().mapToObj(c -> (char) c),
                  MultimapBuilder.linkedHashKeys().arrayListValues()::build));

 // is equivalent to

 static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP;

 static {
     FIRST_LETTER_MULTIMAP = MultimapBuilder.linkedHashKeys().arrayListValues().build();
     FIRST_LETTER_MULTIMAP.putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'));
     FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('p', 'p', 'l', 'e'));
     FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'));
     FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'));
     FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'));
 }
 }

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="newMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Collection&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code Multimap} backed by {@code map}, whose internal value collections are
 generated by {@code factory}. Most users should prefer {@link MultimapBuilder}, though a small
 number of users will need this method to cover map or collection types that {@link
 MultimapBuilder} does not support.

 <p><b>Warning: do not use</b> this method when the collections returned by {@code factory}
 implement either {@link List} or {@code Set}! Use the more specific method {@link
 #newListMultimap}, {@link #newSetMultimap} or {@link #newSortedSetMultimap} instead, to avoid
 very surprising behavior from {@link Multimap#equals}.

 <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration
 order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code
 toString} methods for the multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()} does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the collections generated by
 {@code factory}, and the multimap contents are all serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if
 {@code map} and the instances generated by {@code factory} are. Concurrent read operations will
 work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link
 #synchronizedMultimap}.

 <p>Call this method only when the simpler methods {@link ArrayListMultimap#create()}, {@link
 HashMultimap#create()}, {@link LinkedHashMultimap#create()}, {@link
 LinkedListMultimap#create()}, {@link TreeMultimap#create()}, and {@link
 TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and the collections
 returned by {@code factory}. Those objects should not be manually updated and they should not
 use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty collections that will each hold all values for a given
     key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.List&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListMultimap} that uses the provided map and factory. It can generate a
 multimap based on arbitrary {@link Map} and {@link List} classes. Most users should prefer
 {@link MultimapBuilder}, though a small number of users will need this method to cover map or
 collection types that {@link MultimapBuilder} does not support.

 <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration
 order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code
 toString} methods for the multimap and its returned views. The multimap's {@code get}, {@code
 removeAll}, and {@code replaceValues} methods return {@code RandomAccess} lists if the factory
 does. However, the multimap's {@code get} method returns instances of a different class than
 does {@code factory.get()}.

 <p>The multimap is serializable if {@code map}, {@code factory}, the lists generated by {@code
 factory}, and the multimap contents are all serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if
 {@code map} and the instances generated by {@code factory} are. Concurrent read operations will
 work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link
 #synchronizedListMultimap}.

 <p>Call this method only when the simpler methods {@link ArrayListMultimap#create()} and {@link
 LinkedListMultimap#create()} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and the lists returned by
 {@code factory}. Those objects should not be manually updated, they should be empty when
 provided, and they should not use soft, weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty lists that will each hold all values for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Set&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code SetMultimap} that uses the provided map and factory. It can generate a
 multimap based on arbitrary {@link Map} and {@link Set} classes. Most users should prefer
 {@link MultimapBuilder}, though a small number of users will need this method to cover map or
 collection types that {@link MultimapBuilder} does not support.

 <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration
 order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code
 toString} methods for the multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()} does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code
 factory}, and the multimap contents are all serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if
 {@code map} and the instances generated by {@code factory} are. Concurrent read operations will
 work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link
 #synchronizedSetMultimap}.

 <p>Call this method only when the simpler methods {@link HashMultimap#create()}, {@link
 LinkedHashMultimap#create()}, {@link TreeMultimap#create()}, and {@link
 TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by
 {@code factory}. Those objects should not be manually updated and they should not use soft,
 weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty sets that will each hold all values for a given key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="newSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.SortedSet&lt;V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code SortedSetMultimap} that uses the provided map and factory. It can generate
 a multimap based on arbitrary {@link Map} and {@link SortedSet} classes.

 <p>The {@code factory}-generated and {@code map} classes determine the multimap iteration
 order. They also specify the behavior of the {@code equals}, {@code hashCode}, and {@code
 toString} methods for the multimap and its returned views. However, the multimap's {@code get}
 method returns instances of a different class than {@code factory.get()} does.

 <p>The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code
 factory}, and the multimap contents are all serializable.

 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if
 {@code map} and the instances generated by {@code factory} are. Concurrent read operations will
 work correctly. To allow concurrent update operations, wrap the multimap with a call to {@link
 #synchronizedSortedSetMultimap}.

 <p>Call this method only when the simpler methods {@link TreeMultimap#create()} and {@link
 TreeMultimap#create(Comparator, Comparator)} won't suffice.

 <p>Note: the multimap assumes complete ownership over of {@code map} and the sets returned by
 {@code factory}. Those objects should not be manually updated and they should not use soft,
 weak, or phantom references.

 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty sorted sets that will each hold all values for a given
     key
 @throws IllegalArgumentException if {@code map} is not empty]]>
      </doc>
    </method>
    <method name="invertFrom" return="M extends com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="com.google.common.collect.Multimap&lt;? extends V, ? extends K&gt;"/>
      <param name="dest" type="M extends com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Copies each key-value mapping in {@code source} into {@code dest}, with its key and value
 reversed.

 <p>If {@code source} is an {@link ImmutableMultimap}, consider using {@link
 ImmutableMultimap#inverse} instead.

 @param source any multimap
 @param dest the multimap to copy into; usually empty
 @return {@code dest}]]>
      </doc>
    </method>
    <method name="synchronizedMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) multimap backed by the specified multimap. In order to
 guarantee serial access, it is critical that <b>all</b> access to the backing multimap is
 accomplished through the returned multimap.

 <p>It is imperative that the user manually synchronize on the returned multimap when accessing
 any of its collection views:

 {@snippet :
 Multimap<K, V> multimap = Multimaps.synchronizedMultimap(
     HashMultimap.<K, V>create());
 ...
 Collection<V> values = multimap.get(key);  // Needn't be in synchronized block
 ...
 synchronized (multimap) {  // Synchronizing on multimap, not values!
   Iterator<V> i = values.iterator(); // Must be in synchronized block
   while (i.hasNext()) {
     foo(i.next());
   }
 }
 }

 <p>Failure to follow this advice may result in non-deterministic behavior.

 <p>Note that the generated multimap's {@link Multimap#removeAll} and {@link
 Multimap#replaceValues} methods return collections that aren't synchronized.

 <p>The returned multimap will be serializable if the specified multimap is serializable.

 @param multimap the multimap to be wrapped in a synchronized view
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified multimap. Query operations on the returned
 multimap "read through" to the specified multimap, and attempts to modify the returned
 multimap, either directly or through the multimap's views, result in an {@code
 UnsupportedOperationException}.

 <p>The returned multimap will be serializable if the specified multimap is serializable.

 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableMultimap" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="delegate" type="com.google.common.collect.ImmutableMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="synchronizedSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code SetMultimap} backed by the specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 <p>The returned multimap will be serializable if the specified multimap is serializable.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code SetMultimap}. Query operations on the
 returned multimap "read through" to the specified multimap, and attempts to modify the returned
 multimap, either directly or through the multimap's views, result in an {@code
 UnsupportedOperationException}.

 <p>The returned multimap will be serializable if the specified multimap is serializable.

 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSetMultimap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="delegate" type="com.google.common.collect.ImmutableSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="synchronizedSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code SortedSetMultimap} backed by the specified
 multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 <p>The returned multimap will be serializable if the specified multimap is serializable.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableSortedSetMultimap" return="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code SortedSetMultimap}. Query operations on
 the returned multimap "read through" to the specified multimap, and attempts to modify the
 returned multimap, either directly or through the multimap's views, result in an {@code
 UnsupportedOperationException}.

 <p>The returned multimap will be serializable if the specified multimap is serializable.

 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="synchronizedListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) {@code ListMultimap} backed by the specified multimap.

 <p>You must follow the warnings described in {@link #synchronizedMultimap}.

 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified {@code ListMultimap}. Query operations on the
 returned multimap "read through" to the specified multimap, and attempts to modify the returned
 multimap, either directly or through the multimap's views, result in an {@code
 UnsupportedOperationException}.

 <p>The returned multimap will be serializable if the specified multimap is serializable.

 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap]]>
      </doc>
    </method>
    <method name="unmodifiableListMultimap" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="delegate" type="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns {@link ListMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,
 Collection<V>>} to {@code Map<K, List<V>>}.

 @since 15.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Set&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns {@link SetMultimap#asMap multimap.asMap()}, with its type corrected from {@code Map<K,
 Collection<V>>} to {@code Map<K, Set<V>>}.

 @since 15.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.SortedSet&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.SortedSetMultimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns {@link SortedSetMultimap#asMap multimap.asMap()}, with its type corrected from {@code
 Map<K, Collection<V>>} to {@code Map<K, SortedSet<V>>}.

 @since 15.0]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns {@link Multimap#asMap multimap.asMap()}. This is provided for parity with the other
 more strongly-typed {@code asMap()} implementations.

 @since 15.0]]>
      </doc>
    </method>
    <method name="forMap" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;K, V&gt;"/>
      <doc>
      <![CDATA[Returns a multimap view of the specified map. The multimap is backed by the map, so changes to
 the map are reflected in the multimap, and vice versa. If the map is modified while an
 iteration over one of the multimap's collection views is in progress (except through the
 iterator's own {@code remove} operation, or through the {@code setValue} operation on a map
 entry returned by the iterator), the results of the iteration are undefined.

 <p>The multimap supports mapping removal, which removes the corresponding mapping from the map.
 It does not support any operations which might add mappings, such as {@code put}, {@code
 putAll} or {@code replaceValues}.

 <p>The returned multimap will be serializable if the specified map is serializable.

 @param map the backing map for the returned multimap view]]>
      </doc>
    </method>
    <method name="transformValues" return="com.google.common.collect.Multimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMultimap" type="com.google.common.collect.Multimap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a multimap where each value is transformed by a function. All other
 properties of the multimap, such as iteration order, are left intact. For example, the code:

 {@snippet :
 Multimap<String, Integer> multimap =
     ImmutableSetMultimap.of("a", 2, "b", -3, "b", -3, "a", 4, "c", 6);
 Function<Integer, String> square = new Function<Integer, String>() {
     public String apply(Integer in) {
       return Integer.toString(in * in);
     }
 };
 Multimap<String, String> transformed =
     Multimaps.transformValues(multimap, square);
   System.out.println(transformed);
 }

 ... prints {@code {a=[4, 16], b=[9, 9], c=[36]}}.

 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
 supports removal operations, and these are reflected in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys, and even null values
 provided that the function is capable of accepting null input. The transformed multimap might
 contain null values, if the function sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
 is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,
 since there is not a definition of {@code equals} or {@code hashCode} for general collections,
 and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a
 {@code Set}.

 <p>The function is applied lazily, invoked when needed. This is necessary for the returned
 multimap to be a view, but it means that the function will be applied many times for bulk
 operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to
 perform well, {@code function} should be fast. To avoid lazy evaluation when the returned
 multimap doesn't need to be a view, copy the returned multimap into a new multimap of your
 choosing.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformValues" return="com.google.common.collect.ListMultimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMultimap" type="com.google.common.collect.ListMultimap&lt;K, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a {@code ListMultimap} where each value is transformed by a function. All
 other properties of the multimap, such as iteration order, are left intact. For example, the
 code:

 {@snippet :
 ListMultimap<String, Integer> multimap =
      ImmutableListMultimap.of("a", 4, "a", 16, "b", 9);
 Function<Integer, Double> sqrt = (Integer in) -> Math.sqrt((int) in);
 ListMultimap<String, Double> transformed = Multimaps.transformValues(map,
     sqrt);
 System.out.println(transformed);
 }

 ... prints {@code {a=[2.0, 4.0], b=[3.0]}}.

 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
 supports removal operations, and these are reflected in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys, and even null values
 provided that the function is capable of accepting null input. The transformed multimap might
 contain null values, if the function sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
 is.

 <p>The function is applied lazily, invoked when needed. This is necessary for the returned
 multimap to be a view, but it means that the function will be applied many times for bulk
 operations like {@link Multimap#containsValue} and {@code Multimap.toString()}. For this to
 perform well, {@code function} should be fast. To avoid lazy evaluation when the returned
 multimap doesn't need to be a view, copy the returned multimap into a new multimap of your
 choosing.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="com.google.common.collect.Multimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="com.google.common.collect.Multimap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a multimap whose values are derived from the original multimap's entries. In
 contrast to {@link #transformValues}, this method's entry-transformation logic may depend on
 the key as well as the value.

 <p>All other properties of the transformed multimap, such as iteration order, are left intact.
 For example, the code:

 {@snippet :
 SetMultimap<String, Integer> multimap =
     ImmutableSetMultimap.of("a", 1, "a", 4, "b", -6);
 EntryTransformer<String, Integer, String> transformer =
     new EntryTransformer<String, Integer, String>() {
       public String transformEntry(String key, Integer value) {
          return (value >= 0) ? key : "no" + key;
       }
     };
 Multimap<String, String> transformed =
     Multimaps.transformEntries(multimap, transformer);
 System.out.println(transformed);
 }

 ... prints {@code {a=[a, a], b=[nob]}}.

 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
 supports removal operations, and these are reflected in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys and null values provided
 that the transformer is capable of accepting null inputs. The transformed multimap might
 contain null values if the transformer sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
 is. The {@code equals} and {@code hashCode} methods of the returned multimap are meaningless,
 since there is not a definition of {@code equals} or {@code hashCode} for general collections,
 and {@code get()} will return a general {@code Collection} as opposed to a {@code List} or a
 {@code Set}.

 <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned
 multimap to be a view, but it means that the transformer will be applied many times for bulk
 operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform
 well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap
 doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code
 EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of
 type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as
 {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the
 transformed multimap.

 @since 7.0]]>
      </doc>
    </method>
    <method name="transformEntries" return="com.google.common.collect.ListMultimap&lt;K, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromMap" type="com.google.common.collect.ListMultimap&lt;K, V1&gt;"/>
      <param name="transformer" type="com.google.common.collect.Maps.EntryTransformer&lt;? super K, ? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a {@code ListMultimap} whose values are derived from the original multimap's
 entries. In contrast to {@link #transformValues(ListMultimap, Function)}, this method's
 entry-transformation logic may depend on the key as well as the value.

 <p>All other properties of the transformed multimap, such as iteration order, are left intact.
 For example, the code:

 {@snippet :
 Multimap<String, Integer> multimap =
     ImmutableMultimap.of("a", 1, "a", 4, "b", 6);
 EntryTransformer<String, Integer, String> transformer =
     new EntryTransformer<String, Integer, String>() {
       public String transformEntry(String key, Integer value) {
         return key + value;
       }
     };
 Multimap<String, String> transformed =
     Multimaps.transformEntries(multimap, transformer);
 System.out.println(transformed);
 }

 ... prints {@code {"a"=["a1", "a4"], "b"=["b6"]}}.

 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
 supports removal operations, and these are reflected in the underlying multimap.

 <p>It's acceptable for the underlying multimap to contain null keys and null values provided
 that the transformer is capable of accepting null inputs. The transformed multimap might
 contain null values if the transformer sometimes gives a null result.

 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
 is.

 <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned
 multimap to be a view, but it means that the transformer will be applied many times for bulk
 operations like {@link Multimap#containsValue} and {@link Object#toString}. For this to perform
 well, {@code transformer} should be fast. To avoid lazy evaluation when the returned multimap
 doesn't need to be a view, copy the returned multimap into a new multimap of your choosing.

 <p><b>Warning:</b> This method assumes that for any instance {@code k} of {@code
 EntryTransformer} key type {@code K}, {@code k.equals(k2)} implies that {@code k2} is also of
 type {@code K}. Using an {@code EntryTransformer} key type for which this may not hold, such as
 {@code ArrayList}, may risk a {@code ClassCastException} when calling methods on the
 transformed multimap.

 @since 7.0]]>
      </doc>
    </method>
    <method name="index" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Creates an index {@code ImmutableListMultimap} that contains the results of applying a
 specified function to each item in an {@code Iterable} of values. Each value will be stored as
 a value in the resulting multimap, yielding a multimap with the same size as the input
 iterable. The key used to store that value in the multimap will be the result of calling the
 function on that value. The resulting multimap is created as an immutable snapshot. In the
 returned multimap, keys appear in the order they are first encountered, and the values
 corresponding to each key appear in the same order as they are encountered.

 <p>For example,

 {@snippet :
 List<String> badGuys =
     Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
 Function<String, Integer> stringLengthFunction = ...;
 Multimap<Integer, String> index =
     Multimaps.index(badGuys, stringLengthFunction);
 System.out.println(index);
 }

 <p>prints

 {@snippet :
 {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}
 }

 <p>The returned multimap is serializable if its keys and values are all serializable.

 @param values the values to use when constructing the {@code ImmutableListMultimap}
 @param keyFunction the function used to produce the key for each value
 @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code
     keyFunction} on each value in the input collection to that value
 @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code
     keyFunction} produces {@code null} for any key]]>
      </doc>
    </method>
    <method name="index" return="com.google.common.collect.ImmutableListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Iterator&lt;V&gt;"/>
      <param name="keyFunction" type="com.google.common.base.Function&lt;? super V, K&gt;"/>
      <doc>
      <![CDATA[Creates an index {@code ImmutableListMultimap} that contains the results of applying a
 specified function to each item in an {@code Iterator} of values. Each value will be stored as
 a value in the resulting multimap, yielding a multimap with the same size as the input
 iterator. The key used to store that value in the multimap will be the result of calling the
 function on that value. The resulting multimap is created as an immutable snapshot. In the
 returned multimap, keys appear in the order they are first encountered, and the values
 corresponding to each key appear in the same order as they are encountered.

 <p>For example,

 {@snippet :
 List<String> badGuys =
     Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
 Function<String, Integer> stringLengthFunction = ...;
 Multimap<Integer, String> index =
     Multimaps.index(badGuys.iterator(), stringLengthFunction);
 System.out.println(index);
 }

 <p>prints

 {@snippet :
 {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]}
 }

 <p>The returned multimap is serializable if its keys and values are all serializable.

 @param values the values to use when constructing the {@code ImmutableListMultimap}
 @param keyFunction the function used to produce the key for each value
 @return {@code ImmutableListMultimap} mapping the result of evaluating the function {@code
     keyFunction} on each value in the input collection to that value
 @throws NullPointerException if any element of {@code values} is {@code null}, or if {@code
     keyFunction} produces {@code null} for any key
 @since 10.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a
 predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect
 the other.

 <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all
 other methods are supported by the multimap and its views. When adding a key that doesn't
 satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code
 replaceValues()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 multimap or its views, only mappings whose keys satisfy the filter will be removed from the
 underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every
 key/value mapping in the underlying multimap and determine which satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
 copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a
 predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect
 the other.

 <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all
 other methods are supported by the multimap and its views. When adding a key that doesn't
 satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code
 replaceValues()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 multimap or its views, only mappings whose keys satisfy the filter will be removed from the
 underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every
 key/value mapping in the underlying multimap and determine which satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
 copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterKeys" return="com.google.common.collect.ListMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.ListMultimap&lt;K, V&gt;"/>
      <param name="keyPredicate" type="com.google.common.base.Predicate&lt;? super K&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} whose keys satisfy a
 predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect
 the other.

 <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all
 other methods are supported by the multimap and its views. When adding a key that doesn't
 satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code
 replaceValues()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 multimap or its views, only mappings whose keys satisfy the filter will be removed from the
 underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every
 key/value mapping in the underlying multimap and determine which satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
 copy.

 <p><b>Warning:</b> {@code keyPredicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterValues" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a
 predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect
 the other.

 <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all
 other methods are supported by the multimap and its views. When adding a value that doesn't
 satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code
 replaceValues()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 multimap or its views, only mappings whose value satisfy the filter will be removed from the
 underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every
 key/value mapping in the underlying multimap and determine which satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
 copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterValues" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <param name="valuePredicate" type="com.google.common.base.Predicate&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} whose values satisfy a
 predicate. The returned multimap is a live view of {@code unfiltered}; changes to one affect
 the other.

 <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all
 other methods are supported by the multimap and its views. When adding a value that doesn't
 satisfy the predicate, the multimap's {@code put()}, {@code putAll()}, and {@code
 replaceValues()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 multimap or its views, only mappings whose value satisfy the filter will be removed from the
 underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every
 key/value mapping in the underlying multimap and determine which satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
 copy.

 <p><b>Warning:</b> {@code valuePredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals.

 @since 14.0]]>
      </doc>
    </method>
    <method name="filterEntries" return="com.google.common.collect.Multimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.Multimap&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The
 returned multimap is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all
 other methods are supported by the multimap and its views. When adding a key/value pair that
 doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code
 replaceValues()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 multimap or its views, only mappings whose keys satisfy the filter will be removed from the
 underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every
 key/value mapping in the underlying multimap and determine which satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
 copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="filterEntries" return="com.google.common.collect.SetMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
      <param name="entryPredicate" type="com.google.common.base.Predicate&lt;? super java.util.Map.Entry&lt;K, V&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a multimap containing the mappings in {@code unfiltered} that satisfy a predicate. The
 returned multimap is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting multimap's views have iterators that don't support {@code remove()}, but all
 other methods are supported by the multimap and its views. When adding a key/value pair that
 doesn't satisfy the predicate, multimap's {@code put()}, {@code putAll()}, and {@code
 replaceValues()} methods throw an {@link IllegalArgumentException}.

 <p>When methods such as {@code removeAll()} and {@code clear()} are called on the filtered
 multimap or its views, only mappings whose keys satisfy the filter will be removed from the
 underlying multimap.

 <p>The returned multimap isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multimap's methods, such as {@code size()}, iterate across every
 key/value mapping in the underlying multimap and determine which satisfy the filter. When a
 live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
 copy.

 <p><b>Warning:</b> {@code entryPredicate} must be <i>consistent with equals</i>, as documented
 at {@link Predicate#apply}.

 @since 14.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods acting on or generating a {@code Multimap}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps">{@code
 Multimaps}</a>.

 @author Jared Levy
 @author Robert Konigsberg
 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Multimaps -->
  <!-- start interface com.google.common.collect.Multiset -->
  <interface name="Multiset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Collection&lt;E&gt;"/>
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of all occurrences of all elements in this multiset.

 <p><b>Note:</b> this method does not return the number of <i>distinct elements</i> in the
 multiset, which is given by {@code entrySet().size()}.]]>
      </doc>
    </method>
    <method name="count" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Returns the number of occurrences of an element in this multiset (the <i>count</i> of the
 element). Note that for an {@link Object#equals}-based multiset, this gives the same result as
 {@link Collections#frequency} (which would presumably perform more poorly).

 <p><b>Note:</b> the utility method {@link Iterables#frequency} generalizes this operation; it
 correctly delegates to this method when dealing with a multiset, but it can also accept any
 other iterable type.

 @param element the element to count occurrences of
 @return the number of occurrences of the element in this multiset; possibly zero but never
     negative]]>
      </doc>
    </method>
    <method name="add" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Adds a number of occurrences of an element to this multiset. Note that if {@code occurrences ==
 1}, this method has the identical effect to {@link #add(Object)}. This method is functionally
 equivalent (except in the case of overflow) to the call {@code
 addAll(Collections.nCopies(element, occurrences))}, which would presumably perform much more
 poorly.

 @param element the element to add occurrences of; may be null only if explicitly allowed by the
     implementation
 @param occurrences the number of occurrences of the element to add. May be zero, in which case
     no change will be made.
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative, or if this operation would
     result in more than {@link Integer#MAX_VALUE} occurrences of the element
 @throws NullPointerException if {@code element} is null and this implementation does not permit
     null elements. Note that if {@code occurrences} is zero, the implementation may opt to
     return normally.]]>
      </doc>
    </method>
    <method name="add" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[Adds a single occurrence of the specified element to this multiset.

 <p>This method refines {@link Collection#add}, which only <i>ensures</i> the presence of the
 element, to further specify that a successful call must always increment the count of the
 element, and the overall size of the collection, by one.

 <p>To both add the element and obtain the previous count of that element, use {@link
 #add(Object, int) add}{@code (element, 1)} instead.

 @param element the element to add one occurrence of; may be null only if explicitly allowed by
     the implementation
 @return {@code true} always, since this call is required to modify the multiset, unlike other
     {@link Collection} types
 @throws NullPointerException if {@code element} is null and this implementation does not permit
     null elements
 @throws IllegalArgumentException if {@link Integer#MAX_VALUE} occurrences of {@code element}
     are already contained in this multiset]]>
      </doc>
    </method>
    <method name="remove" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <param name="occurrences" type="int"/>
      <doc>
      <![CDATA[Removes a number of occurrences of the specified element from this multiset. If the multiset
 contains fewer than this number of occurrences to begin with, all occurrences will be removed.
 Note that if {@code occurrences == 1}, this is functionally equivalent to the call {@code
 remove(element)}.

 @param element the element to conditionally remove occurrences of
 @param occurrences the number of occurrences of the element to remove. May be zero, in which
     case no change will be made.
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code occurrences} is negative]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Removes a <i>single</i> occurrence of the specified element from this multiset, if present.

 <p>This method refines {@link Collection#remove} to further specify that it <b>may not</b>
 throw an exception in response to {@code element} being null or of the wrong type.

 <p>To both remove the element and obtain the previous count of that element, use {@link
 #remove(Object, int) remove}{@code (element, 1)} instead.

 @param element the element to remove one occurrence of
 @return {@code true} if an occurrence was found and removed]]>
      </doc>
    </method>
    <method name="setCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Adds or removes the necessary occurrences of an element such that the element attains the
 desired count.

 @param element the element to add or remove occurrences of; may be null only if explicitly
     allowed by the implementation
 @param count the desired count of the element in this multiset
 @return the count of the element before the operation; possibly zero
 @throws IllegalArgumentException if {@code count} is negative
 @throws NullPointerException if {@code element} is null and this implementation does not permit
     null elements. Note that if {@code count} is zero, the implementor may optionally return
     zero instead.]]>
      </doc>
    </method>
    <method name="setCount" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
      <doc>
      <![CDATA[Conditionally sets the count of an element to a new value, as described in {@link
 #setCount(Object, int)}, provided that the element has the expected current count. If the
 current count is not {@code oldCount}, no change is made.

 @param element the element to conditionally set the count of; may be null only if explicitly
     allowed by the implementation
 @param oldCount the expected present count of the element in this multiset
 @param newCount the desired count of the element in this multiset
 @return {@code true} if the condition for modification was met. This implies that the multiset
     was indeed modified, unless {@code oldCount == newCount}.
 @throws IllegalArgumentException if {@code oldCount} or {@code newCount} is negative
 @throws NullPointerException if {@code element} is null and the implementation does not permit
     null elements. Note that if {@code oldCount} and {@code newCount} are both zero, the
     implementor may optionally return {@code true} instead.]]>
      </doc>
    </method>
    <method name="elementSet" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of distinct elements contained in this multiset. The element set is backed by
 the same data as the multiset, so any change to either is immediately reflected in the other.
 The order of the elements in the element set is unspecified.

 <p>If the element set supports any removal operations, these necessarily cause <b>all</b>
 occurrences of the removed element(s) to be removed from the multiset. Implementations are not
 expected to support the add operations, although this is possible.

 <p>A common use for the element set is to find the number of distinct elements in the multiset:
 {@code elementSet().size()}.

 @return a view of the set of distinct elements in this multiset]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of the contents of this multiset, grouped into {@code Multiset.Entry} instances,
 each providing an element of the multiset and the count of that element. This set contains
 exactly one entry for each distinct element in the multiset (thus it always has the same size
 as the {@link #elementSet}). The order of the elements in the element set is unspecified.

 <p>The entry set is backed by the same data as the multiset, so any change to either is
 immediately reflected in the other. However, multiset changes may or may not be reflected in
 any {@code Entry} instances already retrieved from the entry set (this is
 implementation-dependent). Furthermore, implementations are not required to support
 modifications to the entry set at all, and the {@code Entry} instances themselves don't even
 have methods for modification. See the specific implementation class for more details on how
 its entry set handles modifications.

 @return a set of entries representing the data of this multiset]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Compares the specified object with this multiset for equality. Returns {@code true} if the
 given object is also a multiset and contains equal elements with equal counts, regardless of
 order.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this multiset. This is defined as the sum of

 {@snippet :
 ((element == null) ? 0 : element.hashCode()) ^ count(element)
 }

 <p>over all distinct elements in the multiset. It follows that a multiset and its entry set
 always have the same hash code.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>It is recommended, though not mandatory, that this method return the result of invoking
 {@link #toString} on the {@link #entrySet}, yielding a result such as {@code [a x 3, c, d x 2,
 e]}.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Elements that occur multiple times in the multiset will appear multiple times in this
 iterator, though not necessarily sequentially.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <doc>
      <![CDATA[Determines whether this multiset contains the specified element.

 <p>This method refines {@link Collection#contains} to further specify that it <b>may not</b>
 throw an exception in response to {@code element} being null or of the wrong type.

 @param element the element to check for
 @return {@code true} if this multiset contains at least one occurrence of the element]]>
      </doc>
    </method>
    <method name="containsAll" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if this multiset contains at least one occurrence of each element in the
 specified collection.

 <p>This method refines {@link Collection#containsAll} to further specify that it <b>may not</b>
 throw an exception in response to any of {@code elements} being null or of the wrong type.

 <p><b>Note:</b> this method does not take into account the occurrence count of an element in
 the two collections; it may still return {@code true} even if {@code elements} contains several
 occurrences of an element and this multiset contains only one. This is no different than any
 other collection type like {@link List}, but it may be unexpected to the user of a multiset.

 @param elements the collection of elements to be checked for containment in this multiset
 @return {@code true} if this multiset contains at least one occurrence of each element
     contained in {@code elements}
 @throws NullPointerException if {@code elements} is null]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This method ignores how often any element might appear in {@code c}, and only
 cares whether or not an element appears at all. If you wish to remove one occurrence in this
 multiset for every occurrence in {@code c}, see {@link Multisets#removeOccurrences(Multiset,
 Multiset)}.

 <p>This method refines {@link Collection#removeAll} to further specify that it <b>may not</b>
 throw an exception in response to any of {@code elements} being null or of the wrong type.]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This method ignores how often any element might appear in {@code c}, and only
 cares whether or not an element appears at all. If you wish to remove one occurrence in this
 multiset for every occurrence in {@code c}, see {@link Multisets#retainOccurrences(Multiset,
 Multiset)}.

 <p>This method refines {@link Collection#retainAll} to further specify that it <b>may not</b>
 throw an exception in response to any of {@code elements} being null or of the wrong type.

 @see Multisets#retainOccurrences(Multiset, Multiset)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection that supports order-independent equality, like {@link Set}, but may have duplicate
 elements. A multiset is also sometimes called a <i>bag</i>.

 <p>Elements of a multiset that are equal to one another are referred to as <i>occurrences</i> of
 the same single element. The total number of occurrences of an element in a multiset is called
 the <i>count</i> of that element (the terms "frequency" and "multiplicity" are equivalent, but
 not used in this API). Since the count of an element is represented as an {@code int}, a multiset
 may never contain more than {@link Integer#MAX_VALUE} occurrences of any one element.

 <p>{@code Multiset} refines the specifications of several methods from {@code Collection}. It
 also defines an additional query operation, {@link #count}, which returns the count of an
 element. There are five new bulk-modification operations, for example {@link #add(Object, int)},
 to add or remove multiple occurrences of an element at once, or to set the count of an element to
 a specific value. These modification operations are optional, but implementations which support
 the standard collection operations {@link #add(Object)} or {@link #remove(Object)} are encouraged
 to implement the related methods as well. Finally, two collection views are provided: {@link
 #elementSet} contains the distinct elements of the multiset "with duplicates collapsed", and
 {@link #entrySet} is similar but contains {@link Entry Multiset.Entry} instances, each providing
 both a distinct element and the count of that element.

 <p>In addition to these required methods, implementations of {@code Multiset} are expected to
 provide two {@code static} creation methods: {@code create()}, returning an empty multiset, and
 {@code create(Iterable<? extends E>)}, returning a multiset containing the given initial
 elements. This is simply a refinement of {@code Collection}'s constructor recommendations.

 <p>As with other collection types, the modification operations are optional, and should throw
 {@link UnsupportedOperationException} when they are not implemented. Most implementations should
 support either all add operations or none of them, all removal operations or none of them, and if
 and only if all of these are supported, the {@code setCount} methods as well.

 <p>A multiset uses {@link Object#equals} to determine whether two instances should be considered
 "the same," <i>unless specified otherwise</i> by the implementation.

 <p><b>Warning:</b> as with normal {@link Set}s, it is almost always a bad idea to modify an
 element (in a way that affects its {@link Object#equals} behavior) while it is contained in a
 multiset. Undefined behavior and bugs will result.

 <h3>Implementations</h3>

 <ul>
   <li>{@link ImmutableMultiset}
   <li>{@link ImmutableSortedMultiset}
   <li>{@link HashMultiset}
   <li>{@link LinkedHashMultiset}
   <li>{@link TreeMultiset}
   <li>{@link EnumMultiset}
   <li>{@link ConcurrentHashMultiset}
 </ul>

 <p>If your values may be zero, negative, or outside the range of an int, you may wish to use
 {@link com.google.common.util.concurrent.AtomicLongMap} instead. Note, however, that unlike
 {@code Multiset}, {@code AtomicLongMap} does not automatically remove zeros.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset">{@code Multiset}</a>.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multiset -->
  <!-- start interface com.google.common.collect.Multiset.Entry -->
  <interface name="Multiset.Entry"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getElement" return="E extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the multiset element corresponding to this entry. Multiple calls to this method
 always return the same instance.

 @return the element corresponding to this entry]]>
      </doc>
    </method>
    <method name="getCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the count of the associated element in the underlying multiset. This count may either
 be an unchanging snapshot of the count at the time the entry was retrieved, or a live view of
 the current count of the element in the multiset, depending on the implementation. Note that
 in the former case, this method can never return zero, while in the latter, it will return
 zero if all occurrences of the element were since removed from the multiset.

 @return the count of the element; never negative]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Returns {@code true} if the given object is also a multiset entry and the two entries
 represent the same element and count. That is, two entries {@code a} and {@code b} are equal
 if:

 {@snippet :
 Objects.equals(a.getElement(), b.getElement())
     && a.getCount() == b.getCount()
 }]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The hash code of a multiset entry for element {@code element} and count {@code count} is
 defined as:

 {@snippet :
 ((element == null) ? 0 : element.hashCode()) ^ count
 }]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the canonical string representation of this entry, defined as follows. If the count
 for this entry is one, this is simply the string representation of the corresponding element.
 Otherwise, it is the string representation of the element, followed by the three characters
 {@code " x "} (space, letter x, space), followed by the count.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An unmodifiable element-count pair for a multiset. The {@link Multiset#entrySet} method returns
 a view of the multiset whose elements are of this class. A multiset implementation may return
 Entry instances that are either live "read-through" views to the Multiset, or immutable
 snapshots. Note that this type is unrelated to the similarly-named type {@code Map.Entry}.

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Multiset.Entry -->
  <!-- start class com.google.common.collect.Multisets -->
  <class name="Multisets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toMultiset" return="java.util.stream.Collector&lt;T, ?, M&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementFunction" type="java.util.function.Function&lt;? super T, E&gt;"/>
      <param name="countFunction" type="java.util.function.ToIntFunction&lt;? super T&gt;"/>
      <param name="multisetSupplier" type="java.util.function.Supplier&lt;M&gt;"/>
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates elements into a multiset created via the specified
 {@code Supplier}, whose elements are the result of applying {@code elementFunction} to the
 inputs, with counts equal to the result of applying {@code countFunction} to the inputs.
 Elements are added in encounter order.

 <p>If the mapped elements contain duplicates (according to {@link Object#equals}), the element
 will be added more than once, with the count summed over all appearances of the element.

 <p>Note that {@code stream.collect(toMultiset(function, e -> 1, supplier))} is equivalent to
 {@code stream.map(function).collect(Collectors.toCollection(supplier))}.

 <p>To collect to an {@link ImmutableMultiset}, use {@link
 ImmutableMultiset#toImmutableMultiset}.

 @since 33.2.0 (available since 22.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="unmodifiableMultiset" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset" type="com.google.common.collect.Multiset&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified multiset. Query operations on the returned
 multiset "read through" to the specified multiset, and attempts to modify the returned multiset
 result in an {@link UnsupportedOperationException}.

 <p>The returned multiset will be serializable if the specified multiset is serializable.

 @param multiset the multiset for which an unmodifiable view is to be generated
 @return an unmodifiable view of the multiset]]>
      </doc>
    </method>
    <method name="unmodifiableMultiset" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="multiset" type="com.google.common.collect.ImmutableMultiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 10.0]]>
      </doc>
    </method>
    <method name="unmodifiableSortedMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sortedMultiset" type="com.google.common.collect.SortedMultiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified sorted multiset. Query operations on the returned
 multiset "read through" to the specified multiset, and attempts to modify the returned multiset
 result in an {@link UnsupportedOperationException}.

 <p>The returned multiset will be serializable if the specified multiset is serializable.

 @param sortedMultiset the sorted multiset for which an unmodifiable view is to be generated
 @return an unmodifiable view of the multiset
 @since 11.0]]>
      </doc>
    </method>
    <method name="immutableEntry" return="com.google.common.collect.Multiset.Entry&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E extends java.lang.Object"/>
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns an immutable multiset entry with the specified element and count. The entry will be
 serializable if {@code e} is.

 @param e the element to be associated with the returned entry
 @param n the count to be associated with the returned entry
 @throws IllegalArgumentException if {@code n} is negative]]>
      </doc>
    </method>
    <method name="filter" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns a view of the elements of {@code unfiltered} that satisfy a predicate. The returned
 multiset is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting multiset's iterators, and those of its {@code entrySet()} and {@code
 elementSet()}, do not support {@code remove()}. However, all other multiset methods supported
 by {@code unfiltered} are supported by the returned multiset. When given an element that
 doesn't satisfy the predicate, the multiset's {@code add()} and {@code addAll()} methods throw
 an {@link IllegalArgumentException}. When methods such as {@code removeAll()} and {@code
 clear()} are called on the filtered multiset, only elements that satisfy the filter will be
 removed from the underlying multiset.

 <p>The returned multiset isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered multiset's methods, such as {@code size()}, iterate across every
 element in the underlying multiset and determine which elements satisfy the filter. When a live
 view is <i>not</i> needed, it may be faster to copy the returned multiset and use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
 Iterables#filter(Iterable, Class)} for related functionality.)

 @since 14.0]]>
      </doc>
    </method>
    <method name="union" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset1" type="com.google.common.collect.Multiset&lt;? extends E&gt;"/>
      <param name="multiset2" type="com.google.common.collect.Multiset&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the union of two multisets. In the returned multiset, the count
 of each element is the <i>maximum</i> of its counts in the two backing multisets. The iteration
 order of the returned multiset matches that of the element set of {@code multiset1} followed by
 the members of the element set of {@code multiset2} that are not contained in {@code
 multiset1}, with repeated occurrences of the same element appearing consecutively.

 <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
 equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).

 @since 14.0]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset1" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <param name="multiset2" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the intersection of two multisets. In the returned multiset,
 the count of each element is the <i>minimum</i> of its counts in the two backing multisets,
 with elements that would have a count of 0 not included. The iteration order of the returned
 multiset matches that of the element set of {@code multiset1}, with repeated occurrences of the
 same element appearing consecutively.

 <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
 equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).

 @since 2.0]]>
      </doc>
    </method>
    <method name="sum" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset1" type="com.google.common.collect.Multiset&lt;? extends E&gt;"/>
      <param name="multiset2" type="com.google.common.collect.Multiset&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the sum of two multisets. In the returned multiset, the count
 of each element is the <i>sum</i> of its counts in the two backing multisets. The iteration
 order of the returned multiset matches that of the element set of {@code multiset1} followed by
 the members of the element set of {@code multiset2} that are not contained in {@code
 multiset1}, with repeated occurrences of the same element appearing consecutively.

 <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
 equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).

 @since 14.0]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.Multiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset1" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <param name="multiset2" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the difference of two multisets. In the returned multiset, the
 count of each element is the result of the <i>zero-truncated subtraction</i> of its count in
 the second multiset from its count in the first multiset, with elements that would have a count
 of 0 not included. The iteration order of the returned multiset matches that of the element set
 of {@code multiset1}, with repeated occurrences of the same element appearing consecutively.

 <p>Results are undefined if {@code multiset1} and {@code multiset2} are based on different
 equivalence relations (as {@code HashMultiset} and {@code TreeMultiset} are).

 @since 14.0]]>
      </doc>
    </method>
    <method name="containsOccurrences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="superMultiset" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <param name="subMultiset" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code subMultiset.count(o) <= superMultiset.count(o)} for all {@code
 o}.

 @since 10.0]]>
      </doc>
    </method>
    <method name="retainOccurrences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multisetToModify" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <param name="multisetToRetain" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code
 multisetToRetain.count(e)}.

 <p>To be precise, {@code multisetToModify.count(e)} is set to {@code
 Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link
 #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},
 but mutates {@code multisetToModify} instead of returning a view.

 <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of
 elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all
 other elements.

 @return {@code true} if {@code multisetToModify} was changed as a result of this operation
 @since 10.0]]>
      </doc>
    </method>
    <method name="removeOccurrences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multisetToModify" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <param name="occurrencesToRemove" type="java.lang.Iterable&lt;?&gt;"/>
      <doc>
      <![CDATA[For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
 occurrence of {@code e} in {@code multisetToModify}.

 <p>Equivalently, this method modifies {@code multisetToModify} so that {@code
 multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
 Iterables.frequency(occurrencesToRemove, e))}.

 <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll
 removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
 in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit
 sometimes more efficient than, the following:

 {@snippet :
 for (E e : occurrencesToRemove) {
   multisetToModify.remove(e);
 }
 }

 @return {@code true} if {@code multisetToModify} was changed as a result of this operation
 @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code
     Multiset})]]>
      </doc>
    </method>
    <method name="removeOccurrences" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multisetToModify" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <param name="occurrencesToRemove" type="com.google.common.collect.Multiset&lt;?&gt;"/>
      <doc>
      <![CDATA[For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one
 occurrence of {@code e} in {@code multisetToModify}.

 <p>Equivalently, this method modifies {@code multisetToModify} so that {@code
 multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -
 occurrencesToRemove.count(e))}.

 <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll
 removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear
 in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit
 sometimes more efficient than, the following:

 {@snippet :
 for (E e : occurrencesToRemove) {
   multisetToModify.remove(e);
 }
 }

 @return {@code true} if {@code multisetToModify} was changed as a result of this operation
 @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)]]>
      </doc>
    </method>
    <method name="copyHighestCountFirst" return="com.google.common.collect.ImmutableMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multiset" type="com.google.common.collect.Multiset&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a copy of {@code multiset} as an {@link ImmutableMultiset} whose iteration order puts
 the highest count first, with ties broken by the iteration order of the original multiset.

 @since 11.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static utility methods for creating and working with {@link Multiset} instances.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multisets">{@code
 Multisets}</a>.

 @author Kevin Bourrillion
 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Multisets -->
  <!-- start class com.google.common.collect.MutableClassToInstanceMap -->
  <class name="MutableClassToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.ClassToInstanceMap&lt;B&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.MutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@code MutableClassToInstanceMap} instance backed by a {@link HashMap} using the
 default initial capacity and load factor.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.MutableClassToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code MutableClassToInstanceMap} instance backed by a given empty {@code
 backingMap}. The caller surrenders control of the backing map, and thus should not allow any
 direct references to it to remain accessible.]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Map&lt;java.lang.Class&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;java.lang.Class&lt;? extends B&gt;, B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Class&lt;? extends B&gt;"/>
      <param name="value" type="B extends java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.Class&lt;? extends B&gt;, ? extends B&gt;"/>
    </method>
    <method name="putInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A mutable class-to-instance map backed by an arbitrary user-provided map. See also {@link
 ImmutableClassToInstanceMap}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#classtoinstancemap">{@code
 ClassToInstanceMap}</a>.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.MutableClassToInstanceMap -->
  <!-- start class com.google.common.collect.ObjectArrays -->
  <class name="ObjectArrays" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a new array of the given length with the specified component type.

 @param type the component type
 @param length the length of the new array]]>
      </doc>
    </method>
    <method name="newArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Returns a new array of the given length with the same type as a reference array.

 @param reference any array of the desired type
 @param length the length of the new array]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="T[]"/>
      <param name="second" type="T[]"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new array that contains the concatenated contents of two arrays.

 @param first the first array of elements to concatenate
 @param second the second array of elements to concatenate
 @param type the component type of the returned array]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="T extends java.lang.Object"/>
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[Returns a new array that prepends {@code element} to {@code array}.

 @param element the element to prepend to the front of {@code array}
 @param array the array of elements to append
 @return an array whose size is one larger than {@code array}, with {@code element} occupying
     the first position, and the elements of {@code array} occupying the remaining elements.]]>
      </doc>
    </method>
    <method name="concat" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <param name="element" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a new array that appends {@code element} to {@code array}.

 @param array the array of elements to prepend
 @param element the element to append to the end
 @return an array whose size is one larger than {@code array}, with the same contents as {@code
     array}, plus {@code element} occupying the last position.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to object arrays.

 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.ObjectArrays -->
  <!-- start class com.google.common.collect.Ordering -->
  <class name="Ordering" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator&lt;T&gt;"/>
    <constructor name="Ordering"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance of this class (only invokable by the subclass constructor, typically
 implicit).]]>
      </doc>
    </constructor>
    <method name="natural" return="com.google.common.collect.Ordering&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable ordering that uses the natural order of the values. The ordering throws
 a {@link NullPointerException} when passed a null parameter.

 <p>The type specification is {@code <C extends Comparable>}, instead of the technically correct
 {@code <C extends Comparable<? super C>>}, to support legacy types from before Java 5.

 <p><b>Java 8+ users:</b> use {@link Comparator#naturalOrder} instead.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an ordering based on an <i>existing</i> comparator instance. Note that it is
 unnecessary to create a <i>new</i> anonymous inner class implementing {@code Comparator} just
 to pass it in here. Instead, simply subclass {@code Ordering} and implement its {@code compare}
 method directly.

 <p>The returned object is serializable if {@code comparator} is serializable.

 <p><b>Java 8+ users:</b> this class is now obsolete as explained in the class documentation, so
 there is no need to use this method.

 @param comparator the comparator that defines the order
 @return comparator itself if it is already an {@code Ordering}; otherwise an ordering that
     wraps that comparator]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="ordering" type="com.google.common.collect.Ordering&lt;T&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this]]>
      </doc>
    </method>
    <method name="explicit" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valuesInOrder" type="java.util.List&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an ordering that compares objects according to the order in which they appear in the
 given list. Only objects present in the list (according to {@link Object#equals}) may be
 compared. This comparator imposes a "partial ordering" over the type {@code T}. Subsequent
 changes to the {@code valuesInOrder} list will have no effect on the returned comparator. Null
 values in the list are not supported.

 <p>The returned comparator throws a {@link ClassCastException} when it receives an input
 parameter that isn't among the provided values.

 <p>The generated comparator is serializable if all the provided values are serializable.

 @param valuesInOrder the values that the returned comparator will be able to compare, in the
     order the comparator should induce
 @return the comparator described above
 @throws NullPointerException if any of the provided values is null
 @throws IllegalArgumentException if {@code valuesInOrder} contains any duplicate values
     (according to {@link Object#equals})]]>
      </doc>
    </method>
    <method name="explicit" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leastValue" type="T"/>
      <param name="remainingValuesInOrder" type="T[]"/>
      <doc>
      <![CDATA[Returns an ordering that compares objects according to the order in which they are given to
 this method. Only objects present in the argument list (according to {@link Object#equals}) may
 be compared. This comparator imposes a "partial ordering" over the type {@code T}. Null values
 in the argument list are not supported.

 <p>The returned comparator throws a {@link ClassCastException} when it receives an input
 parameter that isn't among the provided values.

 <p>The generated comparator is serializable if all the provided values are serializable.

 @param leastValue the value which the returned comparator should consider the "least" of all
     values
 @param remainingValuesInOrder the rest of the values that the returned comparator will be able
     to compare, in the order the comparator should follow
 @return the comparator described above
 @throws NullPointerException if any of the provided values is null
 @throws IllegalArgumentException if any duplicate values (according to {@link
     Object#equals(Object)}) are present among the method arguments]]>
      </doc>
    </method>
    <method name="allEqual" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering which treats all values as equal, indicating "no ordering." Passing this
 ordering to any <i>stable</i> sort algorithm results in no change to the order of elements.
 Note especially that {@link #sortedCopy} and {@link #immutableSortedCopy} are stable, and in
 the returned instance these are implemented by simply copying the source list.

 <p>Example:

 {@snippet :
 Ordering.allEqual().nullsLast().sortedCopy(
     asList(t, null, e, s, null, t, null))
 }

 <p>Assuming {@code t}, {@code e} and {@code s} are non-null, this returns {@code [t, e, s, t,
 null, null, null]} regardless of the true comparison order of those three values (which might
 not even implement {@link Comparable} at all).

 <p><b>Warning:</b> by definition, this comparator is not <i>consistent with equals</i> (as
 defined {@linkplain Comparator here}). Avoid its use in APIs, such as {@link
 TreeSet#TreeSet(Comparator)}, where such consistency is expected.

 <p>The returned comparator is serializable.

 <p><b>Java 8+ users:</b> Use the lambda expression {@code (a, b) -> 0} instead (in certain
 cases you may need to cast that to {@code Comparator<YourType>}).

 @since 13.0]]>
      </doc>
    </method>
    <method name="usingToString" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that compares objects by the natural ordering of their string
 representations as returned by {@code toString()}. It does not support null values.

 <p>The comparator is serializable.

 <p><b>Java 8+ users:</b> Use {@code Comparator.comparing(Object::toString)} instead.]]>
      </doc>
    </method>
    <method name="arbitrary" return="com.google.common.collect.Ordering&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary ordering over all objects, for which {@code compare(a, b) == 0} implies
 {@code a == b} (identity equality). There is no meaning whatsoever to the order imposed, but it
 is constant for the life of the VM.

 <p>Because the ordering is identity-based, it is not "consistent with {@link
 Object#equals(Object)}" as defined by {@link Comparator}. Use caution when building a {@link
 SortedSet} or {@link SortedMap} from it, as the resulting collection will not behave exactly
 according to spec.

 <p>This ordering is not serializable, as its implementation relies on {@link
 System#identityHashCode(Object)}, so its behavior cannot be preserved across serialization.

 @since 2.0]]>
      </doc>
    </method>
    <method name="reverse" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the reverse of this ordering; the {@code Ordering} equivalent to {@link
 Collections#reverseOrder(Comparator)}.

 <p><b>Java 8+ users:</b> Use {@code thisComparator.reversed()} instead.]]>
      </doc>
    </method>
    <method name="nullsFirst" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that treats {@code null} as less than all other values and uses {@code
 this} to compare non-null values.

 <p>The returned object is serializable if this object is serializable.

 <p><b>Java 8+ users:</b> Use {@code Comparator.nullsFirst(thisComparator)} instead.]]>
      </doc>
    </method>
    <method name="nullsLast" return="com.google.common.collect.Ordering&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an ordering that treats {@code null} as greater than all other values and uses this
 ordering to compare non-null values.

 <p>The returned object is serializable if this object is serializable.

 <p><b>Java 8+ users:</b> Use {@code Comparator.nullsLast(thisComparator)} instead.]]>
      </doc>
    </method>
    <method name="onResultOf" return="com.google.common.collect.Ordering&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;F, ? extends T&gt;"/>
      <doc>
      <![CDATA[Returns a new ordering on {@code F} which orders elements by first applying a function to them,
 then comparing those results using {@code this}. For example, to compare objects by their
 string forms, in a case-insensitive manner, use:

 {@snippet :
 Ordering.from(String.CASE_INSENSITIVE_ORDER)
     .onResultOf(Functions.toStringFunction())
 }

 <p><b>Java 8+ users:</b> Use {@code Comparator.comparing(function, thisComparator)} instead
 (you can omit the comparator if it is the natural order).]]>
      </doc>
    </method>
    <method name="compound" return="com.google.common.collect.Ordering&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="secondaryComparator" type="java.util.Comparator&lt;? super U&gt;"/>
      <doc>
      <![CDATA[Returns an ordering which first uses the ordering {@code this}, but which in the event of a
 "tie", then delegates to {@code secondaryComparator}. For example, to sort a bug list first by
 status and second by priority, you might use {@code byStatus.compound(byPriority)}. For a
 compound ordering with three or more components, simply chain multiple calls to this method.

 <p>An ordering produced by this method, or a chain of calls to this method, is equivalent to
 one created using {@link Ordering#compound(Iterable)} on the same component comparators.

 <p>The returned object is serializable if this object and {@code secondaryComparator} are both
 serializable.

 <p><b>Java 8+ users:</b> Use {@code thisComparator.thenComparing(secondaryComparator)} instead.
 Depending on what {@code secondaryComparator} is, one of the other overloads of {@code
 thenComparing} may be even more useful.]]>
      </doc>
    </method>
    <method name="compound" return="com.google.common.collect.Ordering&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparators" type="java.lang.Iterable&lt;? extends java.util.Comparator&lt;? super T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns an ordering which tries each given comparator in order until a non-zero result is
 found, returning that result, and returning zero only if all comparators return zero. The
 returned ordering is based on the state of the {@code comparators} iterable at the time it was
 provided to this method.

 <p>The returned ordering is equivalent to that produced using {@code
 Ordering.from(comp1).compound(comp2).compound(comp3) . . .}.

 <p>The returned object is serializable if each of the {@code comparators} is serializable.

 <p><b>Warning:</b> Supplying an argument with undefined iteration order, such as a {@link
 HashSet}, will produce non-deterministic results.

 <p><b>Java 8+ users:</b> Use a chain of calls to {@link Comparator#thenComparing(Comparator)},
 or {@code comparatorCollection.stream().reduce(Comparator::thenComparing).get()} (if the
 collection might be empty, also provide a default comparator as the {@code identity} parameter
 to {@code reduce}).

 @param comparators the comparators to try in order]]>
      </doc>
    </method>
    <method name="lexicographical" return="com.google.common.collect.Ordering&lt;java.lang.Iterable&lt;S&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new ordering which sorts iterables by comparing corresponding elements pairwise until
 a nonzero result is found; imposes "dictionary order". If the end of one iterable is reached,
 but not the other, the shorter iterable is considered to be less than the longer one. For
 example, a lexicographical natural ordering over integers considers {@code [] < [1] < [1, 1] <
 [1, 2] < [2]}.

 <p>Note that {@code ordering.lexicographical().reverse()} is not equivalent to {@code
 ordering.reverse().lexicographical()} (consider how each would order {@code [1]} and {@code [1,
 1]}).

 <p><b>Java 8+ users:</b> Use {@link Comparators#lexicographical(Comparator)} instead.

 @since 2.0]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="left" type="T extends java.lang.Object"/>
      <param name="right" type="T extends java.lang.Object"/>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the least of the specified values according to this ordering. If there are multiple
 least values, the first of those is returned. The iterator will be left exhausted: its {@code
 hasNext()} method will return {@code false}.

 <p><b>Java 8+ users:</b> Use {@code Streams.stream(iterator).min(thisComparator).get()} instead
 (but note that it does not guarantee which tied minimum element is returned).

 @param iterator the iterator whose minimum element is to be determined
 @throws NoSuchElementException if {@code iterator} is empty
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.
 @since 11.0]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the least of the specified values according to this ordering. If there are multiple
 least values, the first of those is returned.

 <p><b>Java 8+ users:</b> If {@code iterable} is a {@link Collection}, use {@code
 Collections.min(collection, thisComparator)} instead. Otherwise, use {@code
 Streams.stream(iterable).min(thisComparator).get()} instead. Note that these alternatives do
 not guarantee which tied minimum element is returned.

 @param iterable the iterable whose minimum element is to be determined
 @throws NoSuchElementException if {@code iterable} is empty
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <doc>
      <![CDATA[Returns the lesser of the two values according to this ordering. If the values compare as 0,
 the first is returned.

 <p><b>Implementation note:</b> this method is invoked by the default implementations of the
 other {@code min} overloads, so overriding it will affect their behavior.

 <p><b>Note:</b> Consider using {@code Comparators.min(a, b, thisComparator)} instead. If {@code
 thisComparator} is {@link Ordering#natural}, then use {@code Comparators.min(a, b)}.

 @param a value to compare, returned if less than or equal to b.
 @param b value to compare.
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.]]>
      </doc>
    </method>
    <method name="min" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <param name="c" type="E extends T"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns the least of the specified values according to this ordering. If there are multiple
 least values, the first of those is returned.

 <p><b>Java 8+ users:</b> Use {@code Collections.min(Arrays.asList(a, b, c...), thisComparator)}
 instead (but note that it does not guarantee which tied minimum element is returned).

 @param a value to compare, returned if less than or equal to the rest.
 @param b value to compare
 @param c value to compare
 @param rest values to compare
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the greatest of the specified values according to this ordering. If there are multiple
 greatest values, the first of those is returned. The iterator will be left exhausted: its
 {@code hasNext()} method will return {@code false}.

 <p><b>Java 8+ users:</b> Use {@code Streams.stream(iterator).max(thisComparator).get()} instead
 (but note that it does not guarantee which tied maximum element is returned).

 @param iterator the iterator whose maximum element is to be determined
 @throws NoSuchElementException if {@code iterator} is empty
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.
 @since 11.0]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the greatest of the specified values according to this ordering. If there are multiple
 greatest values, the first of those is returned.

 <p><b>Java 8+ users:</b> If {@code iterable} is a {@link Collection}, use {@code
 Collections.max(collection, thisComparator)} instead. Otherwise, use {@code
 Streams.stream(iterable).max(thisComparator).get()} instead. Note that these alternatives do
 not guarantee which tied maximum element is returned.

 @param iterable the iterable whose maximum element is to be determined
 @throws NoSuchElementException if {@code iterable} is empty
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <doc>
      <![CDATA[Returns the greater of the two values according to this ordering. If the values compare as 0,
 the first is returned.

 <p><b>Implementation note:</b> this method is invoked by the default implementations of the
 other {@code max} overloads, so overriding it will affect their behavior.

 <p><b>Note:</b> Consider using {@code Comparators.max(a, b, thisComparator)} instead. If {@code
 thisComparator} is {@link Ordering#natural}, then use {@code Comparators.max(a, b)}.

 @param a value to compare, returned if greater than or equal to b.
 @param b value to compare.
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.]]>
      </doc>
    </method>
    <method name="max" return="E extends T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="E extends T"/>
      <param name="b" type="E extends T"/>
      <param name="c" type="E extends T"/>
      <param name="rest" type="E[]"/>
      <doc>
      <![CDATA[Returns the greatest of the specified values according to this ordering. If there are multiple
 greatest values, the first of those is returned.

 <p><b>Java 8+ users:</b> Use {@code Collections.max(Arrays.asList(a, b, c...), thisComparator)}
 instead (but note that it does not guarantee which tied maximum element is returned).

 @param a value to compare, returned if greater than or equal to the rest.
 @param b value to compare
 @param c value to compare
 @param rest values to compare
 @throws ClassCastException if the parameters are not <i>mutually comparable</i> under this
     ordering.]]>
      </doc>
    </method>
    <method name="leastOf" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code k} least elements of the given iterable according to this ordering, in order
 from least to greatest. If there are fewer than {@code k} elements present, all will be
 included.

 <p>The implementation does not necessarily use a <i>stable</i> sorting algorithm; when multiple
 elements are equivalent, it is undefined which will come first.

 <p><b>Java 8+ users:</b> Use {@code Streams.stream(iterable).collect(Comparators.least(k,
 thisComparator))} instead.

 @return an immutable {@code RandomAccess} list of the {@code k} least elements in ascending
     order
 @throws IllegalArgumentException if {@code k} is negative
 @since 8.0]]>
      </doc>
    </method>
    <method name="leastOf" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;E&gt;"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code k} least elements from the given iterator according to this ordering, in
 order from least to greatest. If there are fewer than {@code k} elements present, all will be
 included.

 <p>The implementation does not necessarily use a <i>stable</i> sorting algorithm; when multiple
 elements are equivalent, it is undefined which will come first.

 <p><b>Java 8+ users:</b> Use {@code Streams.stream(iterator).collect(Comparators.least(k,
 thisComparator))} instead.

 @return an immutable {@code RandomAccess} list of the {@code k} least elements in ascending
     order
 @throws IllegalArgumentException if {@code k} is negative
 @since 14.0]]>
      </doc>
    </method>
    <method name="greatestOf" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code k} greatest elements of the given iterable according to this ordering, in
 order from greatest to least. If there are fewer than {@code k} elements present, all will be
 included.

 <p>The implementation does not necessarily use a <i>stable</i> sorting algorithm; when multiple
 elements are equivalent, it is undefined which will come first.

 <p><b>Java 8+ users:</b> Use {@code Streams.stream(iterable).collect(Comparators.greatest(k,
 thisComparator))} instead.

 @return an immutable {@code RandomAccess} list of the {@code k} greatest elements in
     <i>descending order</i>
 @throws IllegalArgumentException if {@code k} is negative
 @since 8.0]]>
      </doc>
    </method>
    <method name="greatestOf" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;E&gt;"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code k} greatest elements from the given iterator according to this ordering, in
 order from greatest to least. If there are fewer than {@code k} elements present, all will be
 included.

 <p>The implementation does not necessarily use a <i>stable</i> sorting algorithm; when multiple
 elements are equivalent, it is undefined which will come first.

 <p><b>Java 8+ users:</b> Use {@code Streams.stream(iterator).collect(Comparators.greatest(k,
 thisComparator))} instead.

 @return an immutable {@code RandomAccess} list of the {@code k} greatest elements in
     <i>descending order</i>
 @throws IllegalArgumentException if {@code k} is negative
 @since 14.0]]>
      </doc>
    </method>
    <method name="sortedCopy" return="java.util.List&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a <b>mutable</b> list containing {@code elements} sorted by this ordering; use this
 only when the resulting list may need further modification, or may contain {@code null}. The
 input is not modified. The returned list is serializable and has random access.

 <p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard elements that are
 duplicates according to the comparator. The sort performed is <i>stable</i>, meaning that such
 elements will appear in the returned list in the same order they appeared in {@code elements}.

 <p><b>Performance note:</b> According to our
 benchmarking
 on Open JDK 7, {@link #immutableSortedCopy} generally performs better (in both time and space)
 than this method, and this method in turn generally performs better than copying the list and
 calling {@link Collections#sort(List)}.]]>
      </doc>
    </method>
    <method name="immutableSortedCopy" return="com.google.common.collect.ImmutableList&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an <b>immutable</b> list containing {@code elements} sorted by this ordering. The input
 is not modified.

 <p>Unlike {@link Sets#newTreeSet(Iterable)}, this method does not discard elements that are
 duplicates according to the comparator. The sort performed is <i>stable</i>, meaning that such
 elements will appear in the returned list in the same order they appeared in {@code elements}.

 <p><b>Performance note:</b> According to our
 benchmarking
 on Open JDK 7, this method is the most efficient way to make a sorted copy of a collection.

 @throws NullPointerException if any element of {@code elements} is {@code null}
 @since 3.0]]>
      </doc>
    </method>
    <method name="isOrdered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is greater than or
 equal to the element that preceded it, according to this ordering. Note that this is always
 true when the iterable has fewer than two elements.

 <p><b>Java 8+ users:</b> Use the equivalent {@link Comparators#isInOrder(Iterable, Comparator)}
 instead, since the rest of {@code Ordering} is mostly obsolete (as explained in the class
 documentation).]]>
      </doc>
    </method>
    <method name="isStrictlyOrdered" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if each element in {@code iterable} after the first is <i>strictly</i>
 greater than the element that preceded it, according to this ordering. Note that this is always
 true when the iterable has fewer than two elements.

 <p><b>Java 8+ users:</b> Use the equivalent {@link Comparators#isInStrictOrder(Iterable,
 Comparator)} instead, since the rest of {@code Ordering} is mostly obsolete (as explained in
 the class documentation).]]>
      </doc>
    </method>
    <method name="binarySearch" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link Collections#binarySearch(List, Object, Comparator)} directly.">
      <param name="sortedList" type="java.util.List&lt;? extends T&gt;"/>
      <param name="key" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[{@link Collections#binarySearch(List, Object, Comparator) Searches} {@code sortedList} for
 {@code key} using the binary search algorithm. The list must be sorted using this ordering.

 @param sortedList the list to be searched
 @param key the key to be searched for
 @deprecated Use {@link Collections#binarySearch(List, Object, Comparator)} directly.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A comparator, with additional methods to support common operations. This is an "enriched" version
 of {@code Comparator} for pre-Java-8 users, in the same sense that {@link FluentIterable} is an
 enriched {@link Iterable} for pre-Java-8 users.

 <h3>Three types of methods</h3>

 Like other fluent types, there are three types of methods present: methods for <i>acquiring</i>,
 <i>chaining</i>, and <i>using</i>.

 <h4>Acquiring</h4>

 <p>The common ways to get an instance of {@code Ordering} are:

 <ul>
   <li>Subclass it and implement {@link #compare} instead of implementing {@link Comparator}
       directly
   <li>Pass a <i>pre-existing</i> {@link Comparator} instance to {@link #from(Comparator)}
   <li>Use the natural ordering, {@link Ordering#natural}
 </ul>

 <h4>Chaining</h4>

 <p>Then you can use the <i>chaining</i> methods to get an altered version of that {@code
 Ordering}, including:

 <ul>
   <li>{@link #reverse}
   <li>{@link #compound(Comparator)}
   <li>{@link #onResultOf(Function)}
   <li>{@link #nullsFirst} / {@link #nullsLast}
 </ul>

 <h4>Using</h4>

 <p>Finally, use the resulting {@code Ordering} anywhere a {@link Comparator} is required, or use
 any of its special operations, such as:

 <ul>
   <li>{@link #immutableSortedCopy}
   <li>{@link #isOrdered} / {@link #isStrictlyOrdered}
   <li>{@link #min} / {@link #max}
 </ul>

 <h3>Understanding complex orderings</h3>

 <p>Complex chained orderings like the following example can be challenging to understand.

 {@snippet :
 Ordering<Foo> ordering =
     Ordering.natural()
         .nullsFirst()
         .onResultOf(getBarFunction)
         .nullsLast();
 }

 Note that each chaining method returns a new ordering instance which is backed by the previous
 instance, but has the chance to act on values <i>before</i> handing off to that backing instance.
 As a result, it usually helps to read chained ordering expressions <i>backwards</i>. For example,
 when {@code compare} is called on the above ordering:

 <ol>
   <li>First, if only one {@code Foo} is null, that null value is treated as <i>greater</i>
   <li>Next, non-null {@code Foo} values are passed to {@code getBarFunction} (we will be
       comparing {@code Bar} values from now on)
   <li>Next, if only one {@code Bar} is null, that null value is treated as <i>lesser</i>
   <li>Finally, natural ordering is used (i.e. the result of {@code Bar.compareTo(Bar)} is
       returned)
 </ol>

 <p>Alas, {@link #reverse} is a little different. As you read backwards through a chain and
 encounter a call to {@code reverse}, continue working backwards until a result is determined, and
 then reverse that result.

 <h3>Additional notes</h3>

 <p>Except as noted, the orderings returned by the factory methods of this class are serializable
 if and only if the provided instances that back them are. For example, if {@code ordering} and
 {@code function} can themselves be serialized, then {@code ordering.onResultOf(function)} can as
 well.

 <h3>Java 8+ users</h3>

 <p>If you are using Java 8+, this class is now obsolete. Most of its functionality is now
 provided by {@link java.util.stream.Stream Stream} and by {@link Comparator} itself, and the rest
 can now be found as static methods in our new {@link Comparators} class. See each method below
 for further instructions. Whenever possible, you should change any references of type {@code
 Ordering} to be of type {@code Comparator} instead. However, at this time we have no plan to
 <i>deprecate</i> this class.

 <p>Many replacements involve adopting {@code Stream}, and these changes can sometimes make your
 code verbose. Whenever following this advice, you should check whether {@code Stream} could be
 adopted more comprehensively in your code; the end result may be quite a bit simpler.

 <h3>See also</h3>

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/OrderingExplained">{@code Ordering}</a>.

 @author Jesse Wilson
 @author Kevin Bourrillion
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Ordering -->
  <!-- start interface com.google.common.collect.PeekingIterator -->
  <interface name="PeekingIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <method name="peek" return="E extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the next element in the iteration, without advancing the iteration.

 <p>Calls to {@code peek()} should not change the state of the iteration, except that it
 <i>may</i> prevent removal of the most recent element via {@link #remove()}.

 @throws NoSuchElementException if the iteration has no more elements according to {@link
     #hasNext()}]]>
      </doc>
    </method>
    <method name="next" return="E extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The objects returned by consecutive calls to {@link #peek()} then {@link #next()} are
 guaranteed to be equal to each other.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Implementations may or may not support removal when a call to {@link #peek()} has occurred
 since the most recent call to {@link #next()}.

 @throws IllegalStateException if there has been a call to {@link #peek()} since the most recent
     call to {@link #next()} and this implementation does not support this sequence of calls
     (optional)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator that supports a one-element lookahead while iterating.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionHelpersExplained#peekingiterator">{@code
 PeekingIterator}</a>.

 @author Mick Killianey
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.PeekingIterator -->
  <!-- start class com.google.common.collect.Queues -->
  <class name="Queues" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newArrayBlockingQueue" return="java.util.concurrent.ArrayBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capacity" type="int"/>
      <doc>
      <![CDATA[Creates an empty {@code ArrayBlockingQueue} with the given (fixed) capacity and nonfair access
 policy.]]>
      </doc>
    </method>
    <method name="newArrayDeque" return="java.util.ArrayDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code ArrayDeque}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="newArrayDeque" return="java.util.ArrayDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code ArrayDeque} containing the elements of the specified iterable, in the order
 they are returned by the iterable's iterator.

 @since 12.0]]>
      </doc>
    </method>
    <method name="newConcurrentLinkedQueue" return="java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code ConcurrentLinkedQueue}.]]>
      </doc>
    </method>
    <method name="newConcurrentLinkedQueue" return="java.util.concurrent.ConcurrentLinkedQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code ConcurrentLinkedQueue} containing the elements of the specified iterable, in
 the order they are returned by the iterable's iterator.]]>
      </doc>
    </method>
    <method name="newLinkedBlockingDeque" return="java.util.concurrent.LinkedBlockingDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code LinkedBlockingDeque} with a capacity of {@link Integer#MAX_VALUE}.

 @since 12.0]]>
      </doc>
    </method>
    <method name="newLinkedBlockingDeque" return="java.util.concurrent.LinkedBlockingDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capacity" type="int"/>
      <doc>
      <![CDATA[Creates an empty {@code LinkedBlockingDeque} with the given (fixed) capacity.

 @throws IllegalArgumentException if {@code capacity} is less than 1
 @since 12.0]]>
      </doc>
    </method>
    <method name="newLinkedBlockingDeque" return="java.util.concurrent.LinkedBlockingDeque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code LinkedBlockingDeque} with a capacity of {@link Integer#MAX_VALUE}, containing
 the elements of the specified iterable, in the order they are returned by the iterable's
 iterator.

 @since 12.0]]>
      </doc>
    </method>
    <method name="newLinkedBlockingQueue" return="java.util.concurrent.LinkedBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE}.]]>
      </doc>
    </method>
    <method name="newLinkedBlockingQueue" return="java.util.concurrent.LinkedBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capacity" type="int"/>
      <doc>
      <![CDATA[Creates an empty {@code LinkedBlockingQueue} with the given (fixed) capacity.

 @throws IllegalArgumentException if {@code capacity} is less than 1]]>
      </doc>
    </method>
    <method name="newLinkedBlockingQueue" return="java.util.concurrent.LinkedBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code LinkedBlockingQueue} with a capacity of {@link Integer#MAX_VALUE}, containing
 the elements of the specified iterable, in the order they are returned by the iterable's
 iterator.

 @param elements the elements that the queue should contain, in order
 @return a new {@code LinkedBlockingQueue} containing those elements]]>
      </doc>
    </method>
    <method name="newPriorityBlockingQueue" return="java.util.concurrent.PriorityBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code PriorityBlockingQueue} with the ordering given by its elements' natural
 ordering.

 @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
     in 15.0)]]>
      </doc>
    </method>
    <method name="newPriorityBlockingQueue" return="java.util.concurrent.PriorityBlockingQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code PriorityBlockingQueue} containing the given elements.

 <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},
 this priority queue will be ordered according to the same ordering.

 @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
     in 15.0)]]>
      </doc>
    </method>
    <method name="newPriorityQueue" return="java.util.PriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code PriorityQueue} with the ordering given by its elements' natural
 ordering.

 @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
     in 15.0)]]>
      </doc>
    </method>
    <method name="newPriorityQueue" return="java.util.PriorityQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code PriorityQueue} containing the given elements.

 <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},
 this priority queue will be ordered according to the same ordering.

 @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
     in 15.0)]]>
      </doc>
    </method>
    <method name="newSynchronousQueue" return="java.util.concurrent.SynchronousQueue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code SynchronousQueue} with nonfair access policy.]]>
      </doc>
    </method>
    <method name="drain" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="q" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="buffer" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="numElements" type="int"/>
      <param name="timeout" type="java.time.Duration"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested {@code
 numElements} elements are not available, it will wait for them up to the specified timeout.

 @param q the blocking queue to be drained
 @param buffer where to add the transferred elements
 @param numElements the number of elements to be waited for
 @param timeout how long to wait before giving up
 @return the number of elements transferred
 @throws InterruptedException if interrupted while waiting
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="drain" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="q" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="buffer" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="numElements" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Drains the queue as {@link BlockingQueue#drainTo(Collection, int)}, but if the requested {@code
 numElements} elements are not available, it will wait for them up to the specified timeout.

 @param q the blocking queue to be drained
 @param buffer where to add the transferred elements
 @param numElements the number of elements to be waited for
 @param timeout how long to wait before giving up, in units of {@code unit}
 @param unit a {@code TimeUnit} determining how to interpret the timeout parameter
 @return the number of elements transferred
 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="drainUninterruptibly" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="q" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="buffer" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="numElements" type="int"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Drains the queue as {@linkplain #drain(BlockingQueue, Collection, int, Duration)}, but with a
 different behavior in case it is interrupted while waiting. In that case, the operation will
 continue as usual, and in the end the thread's interruption status will be set (no {@code
 InterruptedException} is thrown).

 @param q the blocking queue to be drained
 @param buffer where to add the transferred elements
 @param numElements the number of elements to be waited for
 @param timeout how long to wait before giving up
 @return the number of elements transferred
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="drainUninterruptibly" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="q" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="buffer" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="numElements" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Drains the queue as {@linkplain #drain(BlockingQueue, Collection, int, long, TimeUnit)}, but
 with a different behavior in case it is interrupted while waiting. In that case, the operation
 will continue as usual, and in the end the thread's interruption status will be set (no {@code
 InterruptedException} is thrown).

 @param q the blocking queue to be drained
 @param buffer where to add the transferred elements
 @param numElements the number of elements to be waited for
 @param timeout how long to wait before giving up, in units of {@code unit}
 @param unit a {@code TimeUnit} determining how to interpret the timeout parameter
 @return the number of elements transferred]]>
      </doc>
    </method>
    <method name="synchronizedQueue" return="java.util.Queue&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queue" type="java.util.Queue&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) queue backed by the specified queue. In order to guarantee
 serial access, it is critical that <b>all</b> access to the backing queue is accomplished
 through the returned queue.

 <p>It is imperative that the user manually synchronize on the returned queue when accessing the
 queue's iterator:

 {@snippet :
 Queue<E> queue = Queues.synchronizedQueue(MinMaxPriorityQueue.<E>create());
 ...
 queue.add(element);  // Needn't be in synchronized block
 ...
 synchronized (queue) {  // Must synchronize on queue!
   Iterator<E> i = queue.iterator(); // Must be in synchronized block
   while (i.hasNext()) {
     foo(i.next());
   }
 }
 }

 <p>Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned queue will be serializable if the specified queue is serializable.

 @param queue the queue to be wrapped in a synchronized view
 @return a synchronized view of the specified queue
 @since 14.0]]>
      </doc>
    </method>
    <method name="synchronizedDeque" return="java.util.Deque&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deque" type="java.util.Deque&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) deque backed by the specified deque. In order to guarantee
 serial access, it is critical that <b>all</b> access to the backing deque is accomplished
 through the returned deque.

 <p>It is imperative that the user manually synchronize on the returned deque when accessing any
 of the deque's iterators:

 {@snippet :
 Deque<E> deque = Queues.synchronizedDeque(Queues.<E>newArrayDeque());
 ...
 deque.add(element);  // Needn't be in synchronized block
 ...
 synchronized (deque) {  // Must synchronize on deque!
   Iterator<E> i = deque.iterator(); // Must be in synchronized block
   while (i.hasNext()) {
     foo(i.next());
   }
 }
 }

 <p>Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned deque will be serializable if the specified deque is serializable.

 @param deque the deque to be wrapped in a synchronized view
 @return a synchronized view of the specified deque
 @since 15.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Queue} and {@link Deque} instances. Also see this
 class's counterparts {@link Lists}, {@link Sets}, and {@link Maps}.

 @author Kurt Alfred Kluever
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Queues -->
  <!-- start class com.google.common.collect.Range -->
  <class name="Range" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Predicate&lt;C&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="open" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly greater than {@code lower} and strictly less
 than {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than <i>or equal to</i> {@code
     upper}
 @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
 @since 14.0]]>
      </doc>
    </method>
    <method name="closed" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values greater than or equal to {@code lower} and less than
 or equal to {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
 @since 14.0]]>
      </doc>
    </method>
    <method name="closedOpen" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values greater than or equal to {@code lower} and strictly
 less than {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
 @since 14.0]]>
      </doc>
    </method>
    <method name="openClosed" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly greater than {@code lower} and less than or
 equal to {@code upper}.

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
 @since 14.0]]>
      </doc>
    </method>
    <method name="range" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lower" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="lowerType" type="com.google.common.collect.BoundType"/>
      <param name="upper" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="upperType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a range that contains any value from {@code lower} to {@code upper}, where each
 endpoint may be either inclusive (closed) or exclusive (open).

 @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
 @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
 @since 14.0]]>
      </doc>
    </method>
    <method name="lessThan" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly less than {@code endpoint}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="atMost" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values less than or equal to {@code endpoint}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="upTo" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a range with no lower bound up to the given endpoint, which may be either inclusive
 (closed) or exclusive (open).

 @since 14.0]]>
      </doc>
    </method>
    <method name="greaterThan" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values strictly greater than {@code endpoint}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="atLeast" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that contains all values greater than or equal to {@code endpoint}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="downTo" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoint" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a range from the given endpoint, which may be either inclusive (closed) or exclusive
 (open), with no upper bound.

 @since 14.0]]>
      </doc>
    </method>
    <method name="all" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a range that contains every value of type {@code C}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="singleton" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a range that {@linkplain Range#contains(Comparable) contains} only the given value. The
 returned range is {@linkplain BoundType#CLOSED closed} on both ends.

 @since 14.0]]>
      </doc>
    </method>
    <method name="encloseAll" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the minimal range that {@linkplain Range#contains(Comparable) contains} all of the
 given values. The returned range is {@linkplain BoundType#CLOSED closed} on both ends.

 @throws ClassCastException if the values are not mutually comparable
 @throws NoSuchElementException if {@code values} is empty
 @throws NullPointerException if any of {@code values} is null
 @since 14.0]]>
      </doc>
    </method>
    <method name="hasLowerBound" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this range has a lower endpoint.]]>
      </doc>
    </method>
    <method name="lowerEndpoint" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lower endpoint of this range.

 @throws IllegalStateException if this range is unbounded below (that is, {@link
     #hasLowerBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="lowerBoundType" return="com.google.common.collect.BoundType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of this range's lower bound: {@link BoundType#CLOSED} if the range includes
 its lower endpoint, {@link BoundType#OPEN} if it does not.

 @throws IllegalStateException if this range is unbounded below (that is, {@link
     #hasLowerBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="hasUpperBound" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this range has an upper endpoint.]]>
      </doc>
    </method>
    <method name="upperEndpoint" return="C extends java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the upper endpoint of this range.

 @throws IllegalStateException if this range is unbounded above (that is, {@link
     #hasUpperBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="upperBoundType" return="com.google.common.collect.BoundType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of this range's upper bound: {@link BoundType#CLOSED} if the range includes
 its upper endpoint, {@link BoundType#OPEN} if it does not.

 @throws IllegalStateException if this range is unbounded above (that is, {@link
     #hasUpperBound()} returns {@code false})]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this range is of the form {@code [v..v)} or {@code (v..v]}. (This does
 not encompass ranges of the form {@code (v..v)}, because such ranges are <i>invalid</i> and
 can't be constructed at all.)

 <p>Note that certain discrete ranges such as the integer range {@code (3..4)} are <b>not</b>
 considered empty, even though they contain no actual values. In these cases, it may be helpful
 to preprocess ranges with {@link #canonical(DiscreteDomain)}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code value} is within the bounds of this range. For example, on the
 range {@code [0..2)}, {@code contains(1)} returns {@code true}, while {@code contains(2)}
 returns {@code false}.]]>
      </doc>
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Provided only to satisfy the {@link Predicate} interface; use {@link #contains}
     instead.">
      <param name="input" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[@deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #contains}
     instead.]]>
      </doc>
    </method>
    <method name="containsAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;? extends C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if every element in {@code values} is {@linkplain #contains contained} in
 this range.]]>
      </doc>
    </method>
    <method name="encloses" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if the bounds of {@code other} do not extend outside the bounds of this
 range. Examples:

 <ul>
   <li>{@code [3..6]} encloses {@code [4..5]}
   <li>{@code (3..6)} encloses {@code (3..6)}
   <li>{@code [3..6]} encloses {@code [4..4)} (even though the latter is empty)
   <li>{@code (3..6]} does not enclose {@code [3..6]}
   <li>{@code [4..5]} does not enclose {@code (3..6)} (even though it contains every value
       contained by the latter range)
   <li>{@code [3..6]} does not enclose {@code (1..1]} (even though it contains every value
       contained by the latter range)
 </ul>

 <p>Note that if {@code a.encloses(b)}, then {@code b.contains(v)} implies {@code
 a.contains(v)}, but as the last two examples illustrate, the converse is not always true.

 <p>Being reflexive, antisymmetric and transitive, the {@code encloses} relation defines a
 <i>partial order</i> over ranges. There exists a unique {@linkplain Range#all maximal} range
 according to this relation, and also numerous {@linkplain #isEmpty minimal} ranges. Enclosure
 also implies {@linkplain #isConnected connectedness}.]]>
      </doc>
    </method>
    <method name="isConnected" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if there exists a (possibly empty) range which is {@linkplain #encloses
 enclosed} by both this range and {@code other}.

 <p>For example,

 <ul>
   <li>{@code [2, 4)} and {@code [5, 7)} are not connected
   <li>{@code [2, 4)} and {@code [3, 5)} are connected, because both enclose {@code [3, 4)}
   <li>{@code [2, 4)} and {@code [4, 6)} are connected, because both enclose the empty range
       {@code [4, 4)}
 </ul>

 <p>Note that this range and {@code other} have a well-defined {@linkplain #span union} and
 {@linkplain #intersection intersection} (as a single, possibly-empty range) if and only if this
 method returns {@code true}.

 <p>The connectedness relation is both reflexive and symmetric, but does not form an {@linkplain
 Equivalence equivalence relation} as it is not transitive.

 <p>Note that certain discrete ranges are not considered connected, even though there are no
 elements "between them." For example, {@code [3, 5]} is not considered connected to {@code [6,
 10]}. In these cases, it may be desirable for both input ranges to be preprocessed with {@link
 #canonical(DiscreteDomain)} before testing for connectedness.]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="connectedRange" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the maximal range {@linkplain #encloses enclosed} by both this range and {@code
 connectedRange}, if such a range exists.

 <p>For example, the intersection of {@code [1..5]} and {@code (3..7)} is {@code (3..5]}. The
 resulting range may be empty; for example, {@code [1..5)} intersected with {@code [5..7)}
 yields the empty range {@code [5..5)}.

 <p>The intersection exists if and only if the two ranges are {@linkplain #isConnected
 connected}.

 <p>The intersection operation is commutative, associative and idempotent, and its identity
 element is {@link Range#all}).

 @throws IllegalArgumentException if {@code isConnected(connectedRange)} is {@code false}]]>
      </doc>
    </method>
    <method name="gap" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherRange" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the maximal range lying between this range and {@code otherRange}, if such a range
 exists. The resulting range may be empty if the two ranges are adjacent but non-overlapping.

 <p>For example, the gap of {@code [1..5]} and {@code (7..10)} is {@code (5..7]}. The resulting
 range may be empty; for example, the gap between {@code [1..5)} {@code [5..7)} yields the empty
 range {@code [5..5)}.

 <p>The gap exists if and only if the two ranges are either disconnected or immediately adjacent
 (any intersection must be an empty range).

 <p>The gap operation is commutative.

 @throws IllegalArgumentException if this range and {@code otherRange} have a nonempty
     intersection
 @since 27.0]]>
      </doc>
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the minimal range that {@linkplain #encloses encloses} both this range and {@code
 other}. For example, the span of {@code [1..3]} and {@code (5..7)} is {@code [1..7)}.

 <p><i>If</i> the input ranges are {@linkplain #isConnected connected}, the returned range can
 also be called their <i>union</i>. If they are not, note that the span might contain values
 that are not contained in either input range.

 <p>Like {@link #intersection(Range) intersection}, this operation is commutative, associative
 and idempotent. Unlike it, it is always well-defined for any two input ranges.]]>
      </doc>
    </method>
    <method name="canonical" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="com.google.common.collect.DiscreteDomain&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns the canonical form of this range in the given domain. The canonical form has the
 following properties:

 <ul>
   <li>equivalence: {@code a.canonical().contains(v) == a.contains(v)} for all {@code v} (in
       other words, {@code ContiguousSet.create(a.canonical(domain), domain).equals(
       ContiguousSet.create(a, domain))}
   <li>uniqueness: unless {@code a.isEmpty()}, {@code ContiguousSet.create(a,
       domain).equals(ContiguousSet.create(b, domain))} implies {@code
       a.canonical(domain).equals(b.canonical(domain))}
   <li>idempotence: {@code a.canonical(domain).canonical(domain).equals(a.canonical(domain))}
 </ul>

 <p>Furthermore, this method guarantees that the range returned will be one of the following
 canonical forms:

 <ul>
   <li>[start..end)
   <li>[start..+#)
   <li>(-#..end) (only if type {@code C} is unbounded below)
   <li>(-#..+#) (only if type {@code C} is unbounded below)
 </ul>]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is a range having the same endpoints and bound types as
 this range. Note that discrete ranges such as {@code (1..4)} and {@code [2..3]} are <b>not</b>
 equal to one another, despite the fact that they each contain precisely the same set of values.
 Similarly, empty ranges are not equal unless they have exactly the same representation, so
 {@code [3..3)}, {@code (3..3]}, {@code (4..4]} are all unequal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code for this range.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this range, such as {@code "[3..5)"} (other examples are
 listed in the class documentation).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A range (or "interval") defines the <i>boundaries</i> around a contiguous span of values of some
 {@code Comparable} type; for example, "integers from 1 to 100 inclusive." Note that it is not
 possible to <i>iterate</i> over these contained values. To do so, pass this range instance and an
 appropriate {@link DiscreteDomain} to {@link ContiguousSet#create}.

 <h3>Types of ranges</h3>

 <p>Each end of the range may be bounded or unbounded. If bounded, there is an associated
 <i>endpoint</i> value, and the range is considered to be either <i>open</i> (does not include the
 endpoint) or <i>closed</i> (includes the endpoint) on that side. With three possibilities on each
 side, this yields nine basic types of ranges, enumerated below. (Notation: a square bracket
 ({@code [ ]}) indicates that the range is closed on that side; a parenthesis ({@code ( )}) means
 it is either open or unbounded. The construct {@code {x | statement}} is read "the set of all
 <i>x</i> such that <i>statement</i>.")

 <blockquote>

 <table>
 <caption>Range Types</caption>
 <tr><th>Notation        <th>Definition               <th>Factory method
 <tr><td>{@code (a..b)}  <td>{@code {x | a < x < b}}  <td>{@link Range#open open}
 <tr><td>{@code [a..b]}  <td>{@code {x | a <= x <= b}}<td>{@link Range#closed closed}
 <tr><td>{@code (a..b]}  <td>{@code {x | a < x <= b}} <td>{@link Range#openClosed openClosed}
 <tr><td>{@code [a..b)}  <td>{@code {x | a <= x < b}} <td>{@link Range#closedOpen closedOpen}
 <tr><td>{@code (a..+#)} <td>{@code {x | x > a}}      <td>{@link Range#greaterThan greaterThan}
 <tr><td>{@code [a..+#)} <td>{@code {x | x >= a}}     <td>{@link Range#atLeast atLeast}
 <tr><td>{@code (-#..b)} <td>{@code {x | x < b}}      <td>{@link Range#lessThan lessThan}
 <tr><td>{@code (-#..b]} <td>{@code {x | x <= b}}     <td>{@link Range#atMost atMost}
 <tr><td>{@code (-#..+#)}<td>{@code {x}}              <td>{@link Range#all all}
 </table>

 </blockquote>

 <p>When both endpoints exist, the upper endpoint may not be less than the lower. The endpoints
 may be equal only if at least one of the bounds is closed:

 <ul>
   <li>{@code [a..a]} : a singleton range
   <li>{@code [a..a); (a..a]} : {@linkplain #isEmpty empty} ranges; also valid
   <li>{@code (a..a)} : <b>invalid</b>; an exception will be thrown
 </ul>

 <h3>Warnings</h3>

 <ul>
   <li>Use immutable value types only, if at all possible. If you must use a mutable type, <b>do
       not</b> allow the endpoint instances to mutate after the range is created!
   <li>Your value type's comparison method should be {@linkplain Comparable consistent with
       equals} if at all possible. Otherwise, be aware that concepts used throughout this
       documentation such as "equal", "same", "unique" and so on actually refer to whether {@link
       Comparable#compareTo compareTo} returns zero, not whether {@link Object#equals equals}
       returns {@code true}.
   <li>A class which implements {@code Comparable<UnrelatedType>} is very broken, and will cause
       undefined horrible things to happen in {@code Range}. For now, the Range API does not
       prevent its use, because this would also rule out all ungenerified (pre-JDK1.5) data types.
       <b>This may change in the future.</b>
 </ul>

 <h3>Other notes</h3>

 <ul>
   <li>All ranges are shallow-immutable.
   <li>Instances of this type are obtained using the static factory methods in this class.
   <li>Ranges are <i>convex</i>: whenever two values are contained, all values in between them
       must also be contained. More formally, for any {@code c1 <= c2 <= c3} of type {@code C},
       {@code r.contains(c1) && r.contains(c3)} implies {@code r.contains(c2)}). This means that a
       {@code Range<Integer>} can never be used to represent, say, "all <i>prime</i> numbers from
       1 to 100."
   <li>When evaluated as a {@link Predicate}, a range yields the same result as invoking {@link
       #contains}.
   <li>Terminology note: a range {@code a} is said to be the <i>maximal</i> range having property
       <i>P</i> if, for all ranges {@code b} also having property <i>P</i>, {@code a.encloses(b)}.
       Likewise, {@code a} is <i>minimal</i> when {@code b.encloses(a)} for all {@code b} having
       property <i>P</i>. See, for example, the definition of {@link #intersection intersection}.
   <li>A {@code Range} is serializable if it has no bounds, or if each bound is serializable.
 </ul>

 <h3>Further reading</h3>

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/RangesExplained">{@code Range}</a>.

 @author Kevin Bourrillion
 @author Gregory Kick
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Range -->
  <!-- start interface com.google.common.collect.RangeMap -->
  <interface name="RangeMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns the value associated with the specified key, or {@code null} if there is no such value.

 <p>Specifically, if any range in this range map contains the specified key, the value
 associated with that range is returned.]]>
      </doc>
    </method>
    <method name="getEntry" return="Map.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns the range containing this key and its associated value, if such a range is present in
 the range map, or {@code null} otherwise.]]>
      </doc>
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;K&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the minimal range {@linkplain Range#encloses(Range) enclosing} the ranges in this
 {@code RangeMap}.

 @throws NoSuchElementException if this range map is empty]]>
      </doc>
    </method>
    <method name="put"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Maps a range to a specified value (optional operation).

 <p>Specifically, after a call to {@code put(range, value)}, if {@link
 Range#contains(Comparable) range.contains(k)}, then {@link #get(Comparable) get(k)} will return
 {@code value}.

 <p>If {@code range} {@linkplain Range#isEmpty() is empty}, then this is a no-op.]]>
      </doc>
    </method>
    <method name="putCoalescing"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Maps a range to a specified value, coalescing this range with any existing ranges with the same
 value that are {@linkplain Range#isConnected connected} to this range.

 <p>The behavior of {@link #get(Comparable) get(k)} after calling this method is identical to
 the behavior described in {@link #put(Range, Object) put(range, value)}, however the ranges
 returned from {@link #asMapOfRanges} will be different if there were existing entries which
 connect to the given range and value.

 <p>Even if the input range is empty, if it is connected on both sides by ranges mapped to the
 same value those two ranges will be coalesced.

 <p><b>Note:</b> coalescing requires calling {@code .equals()} on any connected values, which
 may be expensive depending on the value type. Using this method on range maps with large values
 such as {@link Collection} types is discouraged.

 @since 22.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeMap" type="com.google.common.collect.RangeMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Puts all the associations from {@code rangeMap} into this range map (optional operation).]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all associations from this range map (optional operation).]]>
      </doc>
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <doc>
      <![CDATA[Removes all associations from this range map in the specified range (optional operation).

 <p>If {@code !range.contains(k)}, {@link #get(Comparable) get(k)} will return the same result
 before and after a call to {@code remove(range)}. If {@code range.contains(k)}, then after a
 call to {@code remove(range)}, {@code get(k)} will return {@code null}.]]>
      </doc>
    </method>
    <method name="asMapOfRanges" return="java.util.Map&lt;com.google.common.collect.Range&lt;K&gt;, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of this range map as an unmodifiable {@code Map<Range<K>, V>}. Modifications to
 this range map are guaranteed to read through to the returned {@code Map}.

 <p>The returned {@code Map} iterates over entries in ascending order of the bounds of the
 {@code Range} entries.

 <p>It is guaranteed that no empty ranges will be in the returned {@code Map}.]]>
      </doc>
    </method>
    <method name="asDescendingMapOfRanges" return="java.util.Map&lt;com.google.common.collect.Range&lt;K&gt;, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of this range map as an unmodifiable {@code Map<Range<K>, V>}. Modifications to
 this range map are guaranteed to read through to the returned {@code Map}.

 <p>The returned {@code Map} iterates over entries in descending order of the bounds of the
 {@code Range} entries.

 <p>It is guaranteed that no empty ranges will be in the returned {@code Map}.

 @since 19.0]]>
      </doc>
    </method>
    <method name="subRangeMap" return="com.google.common.collect.RangeMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a view of the part of this range map that intersects with {@code range}.

 <p>For example, if {@code rangeMap} had the entries {@code [1, 5] => "foo", (6, 8) => "bar",
 (10, #) => "baz"} then {@code rangeMap.subRangeMap(Range.open(3, 12))} would return a range map
 with the entries {@code (3, 5] => "foo", (6, 8) => "bar", (10, 12) => "baz"}.

 <p>The returned range map supports all optional operations that this range map supports, except
 for {@code asMapOfRanges().iterator().remove()}.

 <p>The returned range map will throw an {@link IllegalArgumentException} on an attempt to
 insert a range not {@linkplain Range#encloses(Range) enclosed} by {@code range}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code obj} is another {@code RangeMap} that has an equivalent {@link
 #asMapOfRanges()}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code asMapOfRanges().hashCode()}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a readable string representation of this range map.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mapping from disjoint nonempty ranges to non-null values. Queries look up the value associated
 with the range (if any) that contains a specified key.

 <p>In contrast to {@link RangeSet}, no "coalescing" is done of {@linkplain
 Range#isConnected(Range) connected} ranges, even if they are mapped to the same value.

 @author Louis Wasserman
 @since 14.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.RangeMap -->
  <!-- start interface com.google.common.collect.RangeSet -->
  <interface name="RangeSet"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Determines whether any of this range set's member ranges contains {@code value}.]]>
      </doc>
    </method>
    <method name="rangeContaining" return="Range"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable"/>
      <doc>
      <![CDATA[Returns the unique range from this range set that {@linkplain Range#contains contains} {@code
 value}, or {@code null} if this range set does not contain {@code value}.]]>
      </doc>
    </method>
    <method name="intersects" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherRange" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if there exists a non-empty range enclosed by both a member range in this
 range set and the specified range. This is equivalent to calling {@code
 subRangeSet(otherRange)} and testing whether the resulting range set is non-empty.

 @since 20.0]]>
      </doc>
    </method>
    <method name="encloses" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="otherRange" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if there exists a member range in this range set which {@linkplain
 Range#encloses encloses} the specified range.]]>
      </doc>
    </method>
    <method name="enclosesAll" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if for each member range in {@code other} there exists a member range in
 this range set which {@linkplain Range#encloses encloses} it. It follows that {@code
 this.contains(value)} whenever {@code other.contains(value)}. Returns {@code true} if {@code
 other} is empty.

 <p>This is equivalent to checking if this range set {@link #encloses} each of the ranges in
 {@code other}.]]>
      </doc>
    </method>
    <method name="enclosesAll" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if for each range in {@code other} there exists a member range in this
 range set which {@linkplain Range#encloses encloses} it. Returns {@code true} if {@code other}
 is empty.

 <p>This is equivalent to checking if this range set {@link #encloses} each range in {@code
 other}.

 @since 21.0]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this range set contains no ranges.]]>
      </doc>
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the minimal range which {@linkplain Range#encloses(Range) encloses} all ranges in this
 range set.

 @throws NoSuchElementException if this range set is {@linkplain #isEmpty() empty}]]>
      </doc>
    </method>
    <method name="asRanges" return="java.util.Set&lt;com.google.common.collect.Range&lt;C&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of the {@linkplain Range#isConnected disconnected} ranges that make up this
 range set. The returned set may be empty. The iterators returned by its {@link
 Iterable#iterator} method return the ranges in increasing order of lower bound (equivalently,
 of upper bound).]]>
      </doc>
    </method>
    <method name="asDescendingSetOfRanges" return="java.util.Set&lt;com.google.common.collect.Range&lt;C&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a descending view of the {@linkplain Range#isConnected disconnected} ranges that make
 up this range set. The returned set may be empty. The iterators returned by its {@link
 Iterable#iterator} method return the ranges in decreasing order of lower bound (equivalently,
 of upper bound).

 @since 19.0]]>
      </doc>
    </method>
    <method name="complement" return="com.google.common.collect.RangeSet&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view of the complement of this {@code RangeSet}.

 <p>The returned view supports the {@link #add} operation if this {@code RangeSet} supports
 {@link #remove}, and vice versa.]]>
      </doc>
    </method>
    <method name="subRangeSet" return="com.google.common.collect.RangeSet&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a view of the intersection of this {@code RangeSet} with the specified range.

 <p>The returned view supports all optional operations supported by this {@code RangeSet}, with
 the caveat that an {@link IllegalArgumentException} is thrown on an attempt to {@linkplain
 #add(Range) add} any range not {@linkplain Range#encloses(Range) enclosed} by {@code view}.]]>
      </doc>
    </method>
    <method name="add"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Adds the specified range to this {@code RangeSet} (optional operation). That is, for equal
 range sets a and b, the result of {@code a.add(range)} is that {@code a} will be the minimal
 range set for which both {@code a.enclosesAll(b)} and {@code a.encloses(range)}.

 <p>Note that {@code range} will be {@linkplain Range#span(Range) coalesced} with any ranges in
 the range set that are {@linkplain Range#isConnected(Range) connected} with it. Moreover, if
 {@code range} is empty, this is a no-op.

 @throws UnsupportedOperationException if this range set does not support the {@code add}
     operation]]>
      </doc>
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
      <doc>
      <![CDATA[Removes the specified range from this {@code RangeSet} (optional operation). After this
 operation, if {@code range.contains(c)}, {@code this.contains(c)} will return {@code false}.

 <p>If {@code range} is empty, this is a no-op.

 @throws UnsupportedOperationException if this range set does not support the {@code remove}
     operation]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all ranges from this {@code RangeSet} (optional operation). After this operation,
 {@code this.contains(c)} will return false for all {@code c}.

 <p>This is equivalent to {@code remove(Range.all())}.

 @throws UnsupportedOperationException if this range set does not support the {@code clear}
     operation]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Adds all of the ranges from the specified range set to this range set (optional operation).
 After this operation, this range set is the minimal range set that {@linkplain
 #enclosesAll(RangeSet) encloses} both the original range set and {@code other}.

 <p>This is equivalent to calling {@link #add} on each of the ranges in {@code other} in turn.

 @throws UnsupportedOperationException if this range set does not support the {@code addAll}
     operation]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Adds all of the specified ranges to this range set (optional operation). After this operation,
 this range set is the minimal range set that {@linkplain #enclosesAll(RangeSet) encloses} both
 the original range set and each range in {@code other}.

 <p>This is equivalent to calling {@link #add} on each of the ranges in {@code other} in turn.

 @throws UnsupportedOperationException if this range set does not support the {@code addAll}
     operation
 @since 21.0]]>
      </doc>
    </method>
    <method name="removeAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Removes all of the ranges from the specified range set from this range set (optional
 operation). After this operation, if {@code other.contains(c)}, {@code this.contains(c)} will
 return {@code false}.

 <p>This is equivalent to calling {@link #remove} on each of the ranges in {@code other} in
 turn.

 @throws UnsupportedOperationException if this range set does not support the {@code removeAll}
     operation]]>
      </doc>
    </method>
    <method name="removeAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Removes all of the specified ranges from this range set (optional operation).

 <p>This is equivalent to calling {@link #remove} on each of the ranges in {@code other} in
 turn.

 @throws UnsupportedOperationException if this range set does not support the {@code removeAll}
     operation
 @since 21.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code obj} is another {@code RangeSet} that contains the same ranges
 according to {@link Range#equals(Object)}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code asRanges().hashCode()}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a readable string representation of this range set. For example, if this {@code
 RangeSet} consisted of {@code Range.closed(1, 3)} and {@code Range.greaterThan(4)}, this might
 return {@code " [1..3](4..+#)}"}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A set comprising zero or more {@linkplain Range#isEmpty nonempty}, {@linkplain
 Range#isConnected(Range) disconnected} ranges of type {@code C}.

 <p>Implementations that choose to support the {@link #add(Range)} operation are required to
 ignore empty ranges and coalesce connected ranges. For example:

 {@snippet :
 RangeSet<Integer> rangeSet = TreeRangeSet.create();
 rangeSet.add(Range.closed(1, 10)); // {[1, 10]}
 rangeSet.add(Range.closedOpen(11, 15)); // disconnected range; {[1, 10], [11, 15)}
 rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)}
 rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)}
 rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)}
 }

 <p>Note that the behavior of {@link Range#isEmpty()} and {@link Range#isConnected(Range)} may not
 be as expected on discrete ranges. See the Javadoc of those methods for details.

 <p>For a {@link Set} whose contents are specified by a {@link Range}, see {@link ContiguousSet}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#rangeset">RangeSets</a>.

 @author Kevin Bourrillion
 @author Louis Wasserman
 @since 14.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.RangeSet -->
  <!-- start interface com.google.common.collect.RowSortedTable -->
  <interface name="RowSortedTable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Table&lt;R, C, V&gt;"/>
    <method name="rowKeySet" return="java.util.SortedSet&lt;R&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a {@link SortedSet}, instead of the {@code Set} specified in the {@link
 Table} interface.]]>
      </doc>
    </method>
    <method name="rowMap" return="java.util.SortedMap&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>This method returns a {@link SortedMap}, instead of the {@code Map} specified in the {@link
 Table} interface.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface that extends {@code Table} and whose rows are sorted.

 <p>The {@link #rowKeySet} method returns a {@link SortedSet} and the {@link #rowMap} method
 returns a {@link SortedMap}, instead of the {@link Set} and {@link Map} specified by the {@link
 Table} interface.

 @author Warren Dukes
 @since 8.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.RowSortedTable -->
  <!-- start interface com.google.common.collect.SetMultimap -->
  <interface name="SetMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.Multimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.Set&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a
 {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap}
 interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.Set&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a
 {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap}
 interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.Set&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a
 {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap}
 interface.

 <p>Any duplicates in {@code values} will be stored in the multimap once.]]>
      </doc>
    </method>
    <method name="entries" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code SetMultimap} has unique values for a given key, this method returns a
 {@link Set}, instead of the {@link java.util.Collection} specified in the {@link Multimap}
 interface.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> The returned map's values are guaranteed to be of type {@link Set}. To obtain
 this map with the more specific generic type {@code Map<K, Set<V>>}, call {@link
 Multimaps#asMap(SetMultimap)} instead.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Compares the specified object to this multimap for equality.

 <p>Two {@code SetMultimap} instances are equal if, for each key, they contain the same values.
 Equality does not depend on the ordering of keys or values.

 <p>An empty {@code SetMultimap} is equal to any other empty {@code Multimap}, including an
 empty {@code ListMultimap}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code Multimap} that cannot hold duplicate key-value pairs. Adding a key-value pair that's
 already in the multimap has no effect. See the {@link Multimap} documentation for information
 common to all multimaps.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods each return a {@link
 Set} of values, while {@link #entries} returns a {@code Set} of map entries. Though the method
 signature doesn't say so explicitly, the map returned by {@link #asMap} has {@code Set} values.

 <p>If the values corresponding to a single key should be ordered according to a {@link
 java.util.Comparator} (or the natural order), see the {@link SortedSetMultimap} subinterface.

 <p>Since the value collections are sets, the behavior of a {@code SetMultimap} is not specified
 if key <em>or value</em> objects already present in the multimap change in a manner that affects
 {@code equals} comparisons. Use caution if mutable objects are used as keys or values in a {@code
 SetMultimap}.

 <p><b>Warning:</b> Do not modify either a key <i>or a value</i> of a {@code SetMultimap} in a way
 that affects its {@link Object#equals} behavior. Undefined behavior and bugs will result.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SetMultimap -->
  <!-- start class com.google.common.collect.Sets -->
  <class name="Sets" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="immutableEnumSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="anElement" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="otherElements" type="E[]"/>
      <doc>
      <![CDATA[Returns an immutable set instance containing the given enum elements. Internally, the returned
 set will be backed by an {@link EnumSet}.

 <p>The iteration order of the returned set follows the enum's iteration order, not the order in
 which the elements are provided to the method.

 @param anElement one of the elements the set should contain
 @param otherElements the rest of the elements the set should contain
 @return an immutable set containing those elements, minus duplicates]]>
      </doc>
    </method>
    <method name="immutableEnumSet" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable set instance containing the given enum elements. Internally, the returned
 set will be backed by an {@link EnumSet}.

 <p>The iteration order of the returned set follows the enum's iteration order, not the order in
 which the elements appear in the given collection.

 @param elements the elements, all of the same {@code enum} type, that the set should contain
 @return an immutable set containing those elements, minus duplicates]]>
      </doc>
    </method>
    <method name="toImmutableEnumSet" return="java.util.stream.Collector&lt;E, ?, com.google.common.collect.ImmutableSet&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code Collector} that accumulates the input elements into a new {@code ImmutableSet}
 with an implementation specialized for enums. Unlike {@link ImmutableSet#toImmutableSet}, the
 resulting set will iterate over elements in their enum definition order, not encounter order.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="newEnumSet" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;E&gt;"/>
      <param name="elementType" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a new, <i>mutable</i> {@code EnumSet} instance containing the given elements in their
 natural order. This method behaves identically to {@link EnumSet#copyOf(Collection)}, but also
 accepts non-{@code Collection} iterables and empty iterables.]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, initially empty {@code HashSet} instance.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead. If {@code
 E} is an {@link Enum} type, use {@link EnumSet#noneOf} instead. Otherwise, strongly consider
 using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get
 deterministic iteration behavior.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code HashSet} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="E[]"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance initially containing the given elements.

 <p><b>Note:</b> if elements are non-null and won't be added or removed after this point, use
 {@link ImmutableSet#of()} or {@link ImmutableSet#copyOf(Object[])} instead. If {@code E} is an
 {@link Enum} type, use {@link EnumSet#of(Enum, Enum[])} instead. Otherwise, strongly consider
 using a {@code LinkedHashSet} instead, at the cost of increased memory footprint, to get
 deterministic iteration behavior.

 <p>This method is just a small convenience, either for {@code newHashSet(}{@link Arrays#asList
 asList}{@code (...))}, or for creating an empty set then calling {@link Collections#addAll}.
 This method is not actually very useful and will likely be deprecated in the future.]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin
 convenience for creating an empty set then calling {@link Collection#addAll} or {@link
 Iterables#addAll}.

 <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link
 ImmutableSet#copyOf(Iterable)} instead. (Or, change {@code elements} to be a {@link
 FluentIterable} and call {@code elements.toSet()}.)

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, use {@link #newEnumSet(Iterable, Class)}
 instead.

 <p><b>Note:</b> if {@code elements} is a {@link Collection}, you don't need this method.
 Instead, use the {@code HashSet} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 <p>Overall, this method is not very useful and will likely be deprecated in the future.]]>
      </doc>
    </method>
    <method name="newHashSet" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.util.Iterator&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code HashSet} instance containing the given elements. A very thin
 convenience for creating an empty set and then calling {@link Iterators#addAll}.

 <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link
 ImmutableSet#copyOf(Iterator)} instead.

 <p><b>Note:</b> if {@code E} is an {@link Enum} type, you should create an {@link EnumSet}
 instead.

 <p>Overall, this method is not very useful and will likely be deprecated in the future.]]>
      </doc>
    </method>
    <method name="newHashSetWithExpectedSize" return="java.util.HashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Returns a new hash set using the smallest initial table size that can hold {@code expectedSize}
 elements without resizing. Note that this is not what {@link HashSet#HashSet(int)} does, but it
 is what most users want and expect it to do.

 <p>This behavior can't be broadly guaranteed, but has been tested with OpenJDK 1.7 and 1.8.

 @param expectedSize the number of elements you expect to add to the returned set
 @return a new, empty hash set with enough capacity to hold {@code expectedSize} elements
     without resizing
 @throws IllegalArgumentException if {@code expectedSize} is negative]]>
      </doc>
    </method>
    <method name="newConcurrentHashSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a thread-safe set backed by a hash map. The set is backed by a {@link
 ConcurrentHashMap} instance, and thus carries the same concurrency guarantees.

 <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The
 set is serializable.

 @return a new, empty thread-safe {@code Set}
 @since 15.0]]>
      </doc>
    </method>
    <method name="newConcurrentHashSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a thread-safe set backed by a hash map and containing the given elements. The set is
 backed by a {@link ConcurrentHashMap} instance, and thus carries the same concurrency
 guarantees.

 <p>Unlike {@code HashSet}, this class does NOT allow {@code null} to be used as an element. The
 set is serializable.

 @param elements the elements that the set should contain
 @return a new thread-safe set containing those elements (minus duplicates)
 @throws NullPointerException if {@code elements} or any of its contents is null
 @since 15.0]]>
      </doc>
    </method>
    <method name="newLinkedHashSet" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code LinkedHashSet} instance.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableSet#of()} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code LinkedHashSet} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @return a new, empty {@code LinkedHashSet}]]>
      </doc>
    </method>
    <method name="newLinkedHashSet" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code LinkedHashSet} instance containing the given elements in order.

 <p><b>Note:</b> if mutability is not required and the elements are non-null, use {@link
 ImmutableSet#copyOf(Iterable)} instead.

 <p><b>Note:</b> if {@code elements} is a {@link Collection}, you don't need this method.
 Instead, use the {@code LinkedHashSet} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 <p>Overall, this method is not very useful and will likely be deprecated in the future.

 @param elements the elements that the set should contain, in order
 @return a new {@code LinkedHashSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newLinkedHashSetWithExpectedSize" return="java.util.LinkedHashSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedSize" type="int"/>
      <doc>
      <![CDATA[Creates a {@code LinkedHashSet} instance, with a high enough "initial capacity" that it
 <i>should</i> hold {@code expectedSize} elements without growth. This behavior cannot be
 broadly guaranteed, but it is observed to be true for OpenJDK 1.7. It also can't be guaranteed
 that the method isn't inadvertently <i>oversizing</i> the returned set.

 @param expectedSize the number of elements you expect to add to the returned set
 @return a new, empty {@code LinkedHashSet} with enough capacity to hold {@code expectedSize}
     elements without resizing
 @throws IllegalArgumentException if {@code expectedSize} is negative
 @since 11.0]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeSet} instance sorted by the natural sort ordering of
 its elements.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedSet#of()} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code TreeSet} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 @return a new, empty {@code TreeSet}]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i> {@code TreeSet} instance containing the given elements sorted by their
 natural ordering.

 <p><b>Note:</b> if mutability is not required, use {@link ImmutableSortedSet#copyOf(Iterable)}
 instead.

 <p><b>Note:</b> If {@code elements} is a {@code SortedSet} with an explicit comparator, this
 method has different behavior than {@link TreeSet#TreeSet(SortedSet)}, which returns a {@code
 TreeSet} with that comparator.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code TreeSet} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>.

 <p>This method is just a small convenience for creating an empty set and then calling {@link
 Iterables#addAll}. This method is not very useful and will likely be deprecated in the future.

 @param elements the elements that the set should contain
 @return a new {@code TreeSet} containing those elements (minus duplicates)]]>
      </doc>
    </method>
    <method name="newTreeSet" return="java.util.TreeSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Creates a <i>mutable</i>, empty {@code TreeSet} instance with the given comparator.

 <p><b>Note:</b> if mutability is not required, use {@code
 ImmutableSortedSet.orderedBy(comparator).build()} instead.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Instead,
 use the {@code TreeSet} constructor directly, taking advantage of <a
 href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html#type-inference-instantiation">"diamond"
 syntax</a>. One caveat to this is that the {@code TreeSet} constructor uses a null {@code
 Comparator} to mean "natural ordering," whereas this factory rejects null. Clean your code
 accordingly.

 @param comparator the comparator to use to sort the set
 @return a new, empty {@code TreeSet}
 @throws NullPointerException if {@code comparator} is null]]>
      </doc>
    </method>
    <method name="newIdentityHashSet" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code Set} that uses identity to determine equality. It compares object
 references, instead of calling {@code equals}, to determine whether a provided object matches
 an element in the set. For example, {@code contains} returns {@code false} when passed an
 object that equals a set member, but isn't the same instance. This behavior is similar to the
 way {@code IdentityHashMap} handles key lookups.

 @since 8.0]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArraySet" return="java.util.concurrent.CopyOnWriteArraySet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code CopyOnWriteArraySet} instance.

 <p><b>Note:</b> if you need an immutable empty {@link Set}, use {@link Collections#emptySet}
 instead.

 @return a new, empty {@code CopyOnWriteArraySet}
 @since 12.0]]>
      </doc>
    </method>
    <method name="newCopyOnWriteArraySet" return="java.util.concurrent.CopyOnWriteArraySet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates a {@code CopyOnWriteArraySet} instance containing the given elements.

 @param elements the elements that the set should contain, in order
 @return a new {@code CopyOnWriteArraySet} containing those elements
 @since 12.0]]>
      </doc>
    </method>
    <method name="complementOf" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumSet} consisting of all enum values that are not in the specified
 collection. If the collection is an {@link EnumSet}, this method has the same behavior as
 {@link EnumSet#complementOf}. Otherwise, the specified collection must contain at least one
 element, in order to determine the element type. If the collection could be empty, use {@link
 #complementOf(Collection, Class)} instead of this method.

 @param collection the collection whose complement should be stored in the enum set
 @return a new, modifiable {@code EnumSet} containing all values of the enum that aren't present
     in the given collection
 @throws IllegalArgumentException if {@code collection} is not an {@code EnumSet} instance and
     contains no elements]]>
      </doc>
    </method>
    <method name="complementOf" return="java.util.EnumSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;E&gt;"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Creates an {@code EnumSet} consisting of all enum values that are not in the specified
 collection. This is equivalent to {@link EnumSet#complementOf}, but can act on any input
 collection, as long as the elements are of enum type.

 @param collection the collection whose complement should be stored in the {@code EnumSet}
 @param type the type of the elements in the set
 @return a new, modifiable {@code EnumSet} initially containing all the values of the enum not
     present in the given collection]]>
      </doc>
    </method>
    <method name="newSetFromMap" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link Collections#newSetFromMap} instead.">
      <param name="map" type="java.util.Map&lt;E, java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Returns a set backed by the specified map. The resulting set displays the same ordering,
 concurrency, and performance characteristics as the backing map. In essence, this factory
 method provides a {@link Set} implementation corresponding to any {@link Map} implementation.
 There is no need to use this method on a {@link Map} implementation that already has a
 corresponding {@link Set} implementation (such as {@link java.util.HashMap} or {@link
 java.util.TreeMap}).

 <p>Each method invocation on the set returned by this method results in exactly one method
 invocation on the backing map or its {@code keySet} view, with one exception. The {@code
 addAll} method is implemented as a sequence of {@code put} invocations on the backing map.

 <p>The specified map must be empty at the time this method is invoked, and should not be
 accessed directly after this method returns. These conditions are ensured if the map is created
 empty, passed directly to this method, and no reference to the map is retained, as illustrated
 in the following code fragment:

 {@snippet :
 Set<Object> identityHashSet = Sets.newSetFromMap(
     new IdentityHashMap<Object, Boolean>());
 }

 <p>The returned set is serializable if the backing map is.

 @param map the backing map
 @return the set backed by the map
 @throws IllegalArgumentException if {@code map} is not empty
 @deprecated Use {@link Collections#newSetFromMap} instead.]]>
      </doc>
    </method>
    <method name="union" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;? extends E&gt;"/>
      <param name="set2" type="java.util.Set&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the union of two sets. The returned set contains all
 elements that are contained in either backing set. Iterating over the returned set iterates
 first over all the elements of {@code set1}, then over each element of {@code set2}, in order,
 that is not contained in {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based on different
 equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
 {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.]]>
      </doc>
    </method>
    <method name="intersection" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;E&gt;"/>
      <param name="set2" type="java.util.Set&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the intersection of two sets. The returned set contains
 all elements that are contained by both backing sets. The iteration order of the returned set
 matches that of {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based on different
 equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
 {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.

 <p><b>Note:</b> The returned view performs slightly better when {@code set1} is the smaller of
 the two sets. If you have reason to believe one of your sets will generally be smaller than the
 other, pass it first. Unfortunately, since this method sets the generic type of the returned
 set based on the type of the first set passed, this could in rare cases force you to make a
 cast, for example:

 {@snippet :
 Set<Object> aFewBadObjects = ...
 Set<String> manyBadStrings = ...

 // impossible for a non-String to be in the intersection
 SuppressWarnings("unchecked")
 Set<String> badStrings = (Set) Sets.intersection(
     aFewBadObjects, manyBadStrings);
 }

 <p>This is unfortunate, but should come up only very rarely.]]>
      </doc>
    </method>
    <method name="difference" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;E&gt;"/>
      <param name="set2" type="java.util.Set&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the difference of two sets. The returned set contains
 all elements that are contained by {@code set1} and not contained by {@code set2}. {@code set2}
 may also contain elements not present in {@code set1}; these are simply ignored. The iteration
 order of the returned set matches that of {@code set1}.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based on different
 equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
 {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.]]>
      </doc>
    </method>
    <method name="symmetricDifference" return="com.google.common.collect.Sets.SetView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set1" type="java.util.Set&lt;? extends E&gt;"/>
      <param name="set2" type="java.util.Set&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable <b>view</b> of the symmetric difference of two sets. The returned set
 contains all elements that are contained in either {@code set1} or {@code set2} but not in
 both. The iteration order of the returned set is undefined.

 <p>Results are undefined if {@code set1} and {@code set2} are sets based on different
 equivalence relations, for example if {@code set1} is a {@link HashSet} and {@code set2} is a
 {@link TreeSet} or the {@link Map#keySet} of an {@code IdentityHashMap}.

 @since 3.0]]>
      </doc>
    </method>
    <method name="filter" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.Set&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of {@code unfiltered} that satisfy a predicate. The returned set is a live
 view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting set's iterator does not support {@code remove()}, but all other set methods
 are supported. When given an element that doesn't satisfy the predicate, the set's {@code
 add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods
 such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements
 that satisfy the filter will be removed from the underlying set.

 <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in
 the underlying set and determine which elements satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and
 use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
 Iterables#filter(Iterable, Class)} for related functionality.)

 <p><b>Java 8+ users:</b> many use cases for this method are better addressed by {@link
 java.util.stream.Stream#filter}. This method is not being deprecated, but we gently encourage
 you to migrate to streams.]]>
      </doc>
    </method>
    <method name="filter" return="java.util.SortedSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.SortedSet&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of a {@code SortedSet}, {@code unfiltered}, that satisfy a predicate. The
 returned set is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting set's iterator does not support {@code remove()}, but all other set methods
 are supported. When given an element that doesn't satisfy the predicate, the set's {@code
 add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods
 such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements
 that satisfy the filter will be removed from the underlying set.

 <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in
 the underlying set and determine which elements satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and
 use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
 Iterables#filter(Iterable, Class)} for related functionality.)

 @since 11.0]]>
      </doc>
    </method>
    <method name="filter" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unfiltered" type="java.util.NavigableSet&lt;E&gt;"/>
      <param name="predicate" type="com.google.common.base.Predicate&lt;? super E&gt;"/>
      <doc>
      <![CDATA[Returns the elements of a {@code NavigableSet}, {@code unfiltered}, that satisfy a predicate.
 The returned set is a live view of {@code unfiltered}; changes to one affect the other.

 <p>The resulting set's iterator does not support {@code remove()}, but all other set methods
 are supported. When given an element that doesn't satisfy the predicate, the set's {@code
 add()} and {@code addAll()} methods throw an {@link IllegalArgumentException}. When methods
 such as {@code removeAll()} and {@code clear()} are called on the filtered set, only elements
 that satisfy the filter will be removed from the underlying set.

 <p>The returned set isn't threadsafe or serializable, even if {@code unfiltered} is.

 <p>Many of the filtered set's methods, such as {@code size()}, iterate across every element in
 the underlying set and determine which elements satisfy the filter. When a live view is
 <i>not</i> needed, it may be faster to copy {@code Iterables.filter(unfiltered, predicate)} and
 use the copy.

 <p><b>Warning:</b> {@code predicate} must be <i>consistent with equals</i>, as documented at
 {@link Predicate#apply}. Do not provide a predicate such as {@code
 Predicates.instanceOf(ArrayList.class)}, which is inconsistent with equals. (See {@link
 Iterables#filter(Iterable, Class)} for related functionality.)

 @since 14.0]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.Set&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sets" type="java.util.List&lt;? extends java.util.Set&lt;? extends B&gt;&gt;"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element from each of the given
 sets in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the sets. For example:

 {@snippet :
 Sets.cartesianProduct(ImmutableList.of(
     ImmutableSet.of(1, 2),
     ImmutableSet.of("A", "B", "C")))
 }

 <p>returns a set containing six lists:

 <ul>
   <li>{@code ImmutableList.of(1, "A")}
   <li>{@code ImmutableList.of(1, "B")}
   <li>{@code ImmutableList.of(1, "C")}
   <li>{@code ImmutableList.of(2, "A")}
   <li>{@code ImmutableList.of(2, "B")}
   <li>{@code ImmutableList.of(2, "C")}
 </ul>

 <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
 products that you would get from nesting for loops:

 {@snippet :
 for (B b0 : sets.get(0)) {
   for (B b1 : sets.get(1)) {
     ...
     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
     // operate on tuple
   }
 }
 }

 <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
 all are provided (an empty list), the resulting Cartesian product has one element, an empty
 list (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a
 set of size {@code m x n x p}, its actual memory consumption is much smaller. When the
 cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
 iterated are the individual lists created, and these are not retained after iteration.

 @param sets the sets to choose elements from, in the order that the elements chosen from those
     sets should appear in the resulting lists
 @param <B> any common base class shared by all axes (often just {@link Object})
 @return the Cartesian product, as an immutable set containing immutable lists
 @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a
     provided set is null
 @throws IllegalArgumentException if the cartesian product size exceeds the {@code int} range
 @since 2.0]]>
      </doc>
    </method>
    <method name="cartesianProduct" return="java.util.Set&lt;java.util.List&lt;B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sets" type="java.util.Set[]"/>
      <doc>
      <![CDATA[Returns every possible list that can be formed by choosing one element from each of the given
 sets in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
 product</a>" of the sets. For example:

 {@snippet :
 Sets.cartesianProduct(
     ImmutableSet.of(1, 2),
     ImmutableSet.of("A", "B", "C"))
 }

 <p>returns a set containing six lists:

 <ul>
   <li>{@code ImmutableList.of(1, "A")}
   <li>{@code ImmutableList.of(1, "B")}
   <li>{@code ImmutableList.of(1, "C")}
   <li>{@code ImmutableList.of(2, "A")}
   <li>{@code ImmutableList.of(2, "B")}
   <li>{@code ImmutableList.of(2, "C")}
 </ul>

 <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
 products that you would get from nesting for loops:

 {@snippet :
 for (B b0 : sets.get(0)) {
   for (B b1 : sets.get(1)) {
     ...
     ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
     // operate on tuple
   }
 }
 }

 <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
 all are provided (an empty list), the resulting Cartesian product has one element, an empty
 list (counter-intuitive, but mathematically consistent).

 <p><i>Performance notes:</i> while the cartesian product of sets of size {@code m, n, p} is a
 set of size {@code m x n x p}, its actual memory consumption is much smaller. When the
 cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
 iterated are the individual lists created, and these are not retained after iteration.

 @param sets the sets to choose elements from, in the order that the elements chosen from those
     sets should appear in the resulting lists
 @param <B> any common base class shared by all axes (often just {@link Object})
 @return the Cartesian product, as an immutable set containing immutable lists
 @throws NullPointerException if {@code sets}, any one of the {@code sets}, or any element of a
     provided set is null
 @throws IllegalArgumentException if the cartesian product size exceeds the {@code int} range
 @since 2.0]]>
      </doc>
    </method>
    <method name="powerSet" return="java.util.Set&lt;java.util.Set&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns the set of all possible subsets of {@code set}. For example, {@code
 powerSet(ImmutableSet.of(1, 2))} returns the set {@code {{}, {1}, {2}, {1, 2}}}.

 <p>Elements appear in these subsets in the same iteration order as they appeared in the input
 set. The order in which these subsets appear in the outer set is undefined. Note that the power
 set of the empty set is not the empty set, but a one-element set containing the empty set.

 <p>The returned set and its constituent sets use {@code equals} to decide whether two elements
 are identical, even if the input set uses a different concept of equivalence.

 <p><i>Performance notes:</i> while the power set of a set with size {@code n} is of size {@code
 2^n}, its memory usage is only {@code O(n)}. When the power set is constructed, the input set
 is merely copied. Only as the power set is iterated are the individual subsets created, and
 these subsets themselves occupy only a small constant amount of memory.

 @param set the set of elements to construct a power set from
 @return the power set, as an immutable set of immutable sets
 @throws IllegalArgumentException if {@code set} has more than 30 unique elements (causing the
     power set size to exceed the {@code int} range)
 @throws NullPointerException if {@code set} is or contains {@code null}
 @see <a href="http://en.wikipedia.org/wiki/Power_set">Power set article at Wikipedia</a>
 @since 4.0]]>
      </doc>
    </method>
    <method name="combinations" return="java.util.Set&lt;java.util.Set&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;E&gt;"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns the set of all subsets of {@code set} of size {@code size}. For example, {@code
 combinations(ImmutableSet.of(1, 2, 3), 2)} returns the set {@code {{1, 2}, {1, 3}, {2, 3}}}.

 <p>Elements appear in these subsets in the same iteration order as they appeared in the input
 set. The order in which these subsets appear in the outer set is undefined.

 <p>The returned set and its constituent sets use {@code equals} to decide whether two elements
 are identical, even if the input set uses a different concept of equivalence.

 <p><i>Performance notes:</i> the memory usage of the returned set is only {@code O(n)}. When
 the result set is constructed, the input set is merely copied. Only as the result set is
 iterated are the individual subsets created. Each of these subsets occupies an additional O(n)
 memory but only for as long as the user retains a reference to it. That is, the set returned by
 {@code combinations} does not retain the individual subsets.

 @param set the set of elements to take combinations of
 @param size the number of elements per combination
 @return the set of all combinations of {@code size} elements from {@code set}
 @throws IllegalArgumentException if {@code size} is not between 0 and {@code set.size()}
     inclusive
 @throws NullPointerException if {@code set} is or contains {@code null}
 @since 23.0]]>
      </doc>
    </method>
    <method name="unmodifiableNavigableSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.NavigableSet&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified navigable set. This method allows modules to
 provide users with "read-only" access to internal navigable sets. Query operations on the
 returned set "read through" to the specified set, and attempts to modify the returned set,
 whether direct or via its collection views, result in an {@code UnsupportedOperationException}.

 <p>The returned navigable set will be serializable if the specified navigable set is
 serializable.

 <p><b>Java 8+ users and later:</b> Prefer {@link Collections#unmodifiableNavigableSet}.

 @param set the navigable set for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified navigable set
 @since 12.0]]>
      </doc>
    </method>
    <method name="synchronizedNavigableSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="navigableSet" type="java.util.NavigableSet&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In
 order to guarantee serial access, it is critical that <b>all</b> access to the backing
 navigable set is accomplished through the returned navigable set (or its views).

 <p>It is imperative that the user manually synchronize on the returned sorted set when
 iterating over it or any of its {@code descendingSet}, {@code subSet}, {@code headSet}, or
 {@code tailSet} views.

 {@snippet :
 NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());
  ...
 synchronized (set) {
   // Must be in the synchronized block
   Iterator<E> it = set.iterator();
   while (it.hasNext()) {
     foo(it.next());
   }
 }
 }

 <p>or:

 {@snippet :
 NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());
 NavigableSet<E> set2 = set.descendingSet().headSet(foo);
  ...
 synchronized (set) { // Note: set, not set2!!!
   // Must be in the synchronized block
   Iterator<E> it = set2.descendingIterator();
   while (it.hasNext()) {
     foo(it.next());
   }
 }
 }

 <p>Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned navigable set will be serializable if the specified navigable set is
 serializable.

 <p><b>Java 8+ users and later:</b> Prefer {@link Collections#synchronizedNavigableSet}.

 @param navigableSet the navigable set to be "wrapped" in a synchronized navigable set.
 @return a synchronized view of the specified navigable set.
 @since 13.0]]>
      </doc>
    </method>
    <method name="subSet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="java.util.NavigableSet&lt;K&gt;"/>
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <doc>
      <![CDATA[Returns a view of the portion of {@code set} whose elements are contained by {@code range}.

 <p>This method delegates to the appropriate methods of {@link NavigableSet} (namely {@link
 NavigableSet#subSet(Object, boolean, Object, boolean) subSet()}, {@link
 NavigableSet#tailSet(Object, boolean) tailSet()}, and {@link NavigableSet#headSet(Object,
 boolean) headSet()}) to actually construct the view. Consult these methods for a full
 description of the returned view's behavior.

 <p><b>Warning:</b> {@code Range}s always represent a range of values using the values' natural
 ordering. {@code NavigableSet} on the other hand can specify a custom ordering via a {@link
 Comparator}, which can violate the natural ordering. Using this method (or in general using
 {@code Range}) with unnaturally-ordered sets can lead to unexpected and undefined behavior.

 @since 20.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Set} instances. Also see this class's counterparts
 {@link Lists}, {@link Maps} and {@link Queues}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets">{@code Sets}</a>.

 @author Kevin Bourrillion
 @author Jared Levy
 @author Chris Povirk
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Sets -->
  <!-- start class com.google.common.collect.Sets.SetView -->
  <class name="Sets.SetView" extends="java.util.AbstractSet&lt;E&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="immutableCopy" return="com.google.common.collect.ImmutableSet&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable copy of the current contents of this set view. Does not support null
 elements.

 <p><b>Warning:</b> this may have unexpected results if a backing set of this view uses a
 nonstandard notion of equivalence, for example if it is a {@link TreeSet} using a comparator
 that is inconsistent with {@link Object#equals(Object)}.]]>
      </doc>
    </method>
    <method name="copyInto" return="S extends java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="S extends java.util.Set&lt;E&gt;"/>
      <doc>
      <![CDATA[Copies the current contents of this set view into an existing set. This method has equivalent
 behavior to {@code set.addAll(this)}, assuming that all the sets involved are based on the
 same notion of equivalence.

 @return a reference to {@code set}, for convenience]]>
      </doc>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="addAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="newElements" type="java.util.Collection&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="removeAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="oldElements" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="retainAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="elementsToKeep" type="java.util.Collection&lt;?&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the collection unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Scope the return type to {@link UnmodifiableIterator} to ensure this is an unmodifiable view.

 @since 20.0 (present with return type {@link Iterator} since 2.0)]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <doc>
    <![CDATA[An unmodifiable view of a set which may be backed by other sets; this view will change as the
 backing sets do. Contains methods to copy the data into a new set which will then remain
 stable. There is usually no reason to retain a reference of type {@code SetView}; typically,
 you either use it as a plain {@link Set}, or immediately invoke {@link #immutableCopy} or
 {@link #copyInto} and forget the {@code SetView} itself.

 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Sets.SetView -->
  <!-- start interface com.google.common.collect.SortedMapDifference -->
  <interface name="SortedMapDifference"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.MapDifference&lt;K, V&gt;"/>
    <method name="entriesOnlyOnLeft" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entriesOnlyOnRight" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entriesInCommon" return="java.util.SortedMap&lt;K, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="entriesDiffering" return="java.util.SortedMap&lt;K, com.google.common.collect.MapDifference.ValueDifference&lt;V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An object representing the differences between two sorted maps.

 @author Louis Wasserman
 @since 8.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SortedMapDifference -->
  <!-- start interface com.google.common.collect.SortedMultiset -->
  <interface name="SortedMultiset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SortedMultisetBridge&lt;E&gt;"/>
    <implements name="com.google.common.collect.SortedIterable&lt;E&gt;"/>
    <method name="comparator" return="java.util.Comparator&lt;? super E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders this multiset, or {@link Ordering#natural()} if the natural
 ordering of the elements is used.]]>
      </doc>
    </method>
    <method name="firstEntry" return="Multiset.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entry of the first element in this multiset, or {@code null} if this multiset is
 empty.]]>
      </doc>
    </method>
    <method name="lastEntry" return="Multiset.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the entry of the last element in this multiset, or {@code null} if this multiset is
 empty.]]>
      </doc>
    </method>
    <method name="pollFirstEntry" return="Multiset.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns and removes the entry associated with the lowest element in this multiset, or returns
 {@code null} if this multiset is empty.]]>
      </doc>
    </method>
    <method name="pollLastEntry" return="Multiset.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns and removes the entry associated with the greatest element in this multiset, or returns
 {@code null} if this multiset is empty.]]>
      </doc>
    </method>
    <method name="elementSet" return="java.util.NavigableSet&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link NavigableSet} view of the distinct elements in this multiset.

 @since 14.0 (present with return type {@code SortedSet} since 11.0)]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set&lt;com.google.common.collect.Multiset.Entry&lt;E&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The {@code entrySet}'s iterator returns entries in ascending element order according to this
 multiset's comparator.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The iterator returns the elements in ascending order according to this multiset's
 comparator.]]>
      </doc>
    </method>
    <method name="descendingMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a descending view of this multiset. Modifications made to either map will be reflected
 in the other.]]>
      </doc>
    </method>
    <method name="headMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperBound" type="E extends java.lang.Object"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a view of this multiset restricted to the elements less than {@code upperBound},
 optionally including {@code upperBound} itself. The returned multiset is a view of this
 multiset, so changes to one will be reflected in the other. The returned multiset supports all
 operations that this multiset supports.

 <p>The returned multiset will throw an {@link IllegalArgumentException} on attempts to add
 elements outside its range.]]>
      </doc>
    </method>
    <method name="subMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E extends java.lang.Object"/>
      <param name="lowerBoundType" type="com.google.common.collect.BoundType"/>
      <param name="upperBound" type="E extends java.lang.Object"/>
      <param name="upperBoundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a view of this multiset restricted to the range between {@code lowerBound} and {@code
 upperBound}. The returned multiset is a view of this multiset, so changes to one will be
 reflected in the other. The returned multiset supports all operations that this multiset
 supports.

 <p>The returned multiset will throw an {@link IllegalArgumentException} on attempts to add
 elements outside its range.

 <p>This method is equivalent to {@code tailMultiset(lowerBound,
 lowerBoundType).headMultiset(upperBound, upperBoundType)}.]]>
      </doc>
    </method>
    <method name="tailMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E extends java.lang.Object"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
      <doc>
      <![CDATA[Returns a view of this multiset restricted to the elements greater than {@code lowerBound},
 optionally including {@code lowerBound} itself. The returned multiset is a view of this
 multiset, so changes to one will be reflected in the other. The returned multiset supports all
 operations that this multiset supports.

 <p>The returned multiset will throw an {@link IllegalArgumentException} on attempts to add
 elements outside its range.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Multiset} which maintains the ordering of its elements, according to either their
 natural order or an explicit {@link Comparator}. This order is reflected when iterating over the
 sorted multiset, either directly, or through its {@code elementSet} or {@code entrySet} views. In
 all cases, this implementation uses {@link Comparable#compareTo} or {@link Comparator#compare}
 instead of {@link Object#equals} to determine equivalence of instances.

 <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the
 {@link Comparable} class specification. Otherwise, the resulting multiset will violate the {@link
 Collection} contract, which is specified in terms of {@link Object#equals}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset">{@code Multiset}</a>.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SortedMultiset -->
  <!-- start interface com.google.common.collect.SortedSetMultimap -->
  <interface name="SortedSetMultimap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.SetMultimap&lt;K, V&gt;"/>
    <method name="get" return="java.util.SortedSet&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a collection view of all values associated with a key. If no mappings in the multimap
 have the provided key, an empty collection is returned.

 <p>Changes to the returned collection will update the underlying multimap, and vice versa.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given key, this method
 returns a {@link SortedSet}, instead of the {@link java.util.Collection} specified in the
 {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="removeAll" return="java.util.SortedSet&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="Object"/>
      <doc>
      <![CDATA[Removes all values associated with a given key.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given key, this method
 returns a {@link SortedSet}, instead of the {@link java.util.Collection} specified in the
 {@link Multimap} interface.]]>
      </doc>
    </method>
    <method name="replaceValues" return="java.util.SortedSet&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <param name="values" type="java.lang.Iterable&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Stores a collection of values with the same key, replacing any existing values for that key.

 <p>Because a {@code SortedSetMultimap} has unique sorted values for a given key, this method
 returns a {@link SortedSet}, instead of the {@link java.util.Collection} specified in the
 {@link Multimap} interface.

 <p>Any duplicates in {@code values} will be stored in the multimap once.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a map view that associates each key with the corresponding values in the multimap.
 Changes to the returned map, such as element removal, will update the underlying multimap. The
 map does not support {@code setValue()} on its entries, {@code put}, or {@code putAll}.

 <p>When passed a key that is present in the map, {@code asMap().get(Object)} has the same
 behavior as {@link #get}, returning a live collection. When passed a key that is not present,
 however, {@code asMap().get(Object)} returns {@code null} instead of an empty collection.

 <p><b>Note:</b> The returned map's values are guaranteed to be of type {@link SortedSet}. To
 obtain this map with the more specific generic type {@code Map<K, SortedSet<V>>}, call {@link
 Multimaps#asMap(SortedSetMultimap)} instead. <b>However</b>, the returned map <i>itself</i> is
 not necessarily a {@link SortedMap}: A {@code SortedSetMultimap} must expose the <i>values</i>
 for a given key in sorted order, but it need not expose the <i>keys</i> in sorted order.
 Individual {@code SortedSetMultimap} implementations, like those built with {@link
 MultimapBuilder#treeKeys()}, may make additional guarantees.]]>
      </doc>
    </method>
    <method name="valueComparator" return="Comparator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the comparator that orders the multimap values, with {@code null} indicating that
 natural ordering is used.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code SetMultimap} whose set of values for a given key are kept sorted; that is, they comprise
 a {@link SortedSet}. It cannot hold duplicate key-value pairs; adding a key-value pair that's
 already in the multimap has no effect. This interface does not specify the ordering of the
 multimap's keys. See the {@link Multimap} documentation for information common to all multimaps.

 <p>The {@link #get}, {@link #removeAll}, and {@link #replaceValues} methods each return a {@link
 SortedSet} of values, while {@link Multimap#entries()} returns a {@link Set} of map entries.
 Though the method signature doesn't say so explicitly, the map returned by {@link #asMap} has
 {@code SortedSet} values.

 <p><b>Warning:</b> As in all {@link SetMultimap}s, do not modify either a key <i>or a value</i>
 of a {@code SortedSetMultimap} in a way that affects its {@link Object#equals} behavior (or its
 position in the order of the values). Undefined behavior and bugs will result.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.SortedSetMultimap -->
  <!-- start class com.google.common.collect.Streams -->
  <class name="Streams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="stream" return="java.util.stream.Stream&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a sequential {@link Stream} of the contents of {@code iterable}, delegating to {@link
 Collection#stream} if possible.]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.Stream&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="There is no reason to use this; just invoke {@code collection.stream()} directly.">
      <param name="collection" type="java.util.Collection&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns {@link Collection#stream}.

 @deprecated There is no reason to use this; just invoke {@code collection.stream()} directly.]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.Stream&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a sequential {@link Stream} of the remaining contents of {@code iterator}. Do not use
 {@code iterator} directly after passing it to this method.]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.Stream&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optional" type="com.google.common.base.Optional&lt;T&gt;"/>
      <doc>
      <![CDATA[If a value is present in {@code optional}, returns a stream containing only that element,
 otherwise returns an empty stream.]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.Stream&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optional" type="java.util.Optional&lt;T&gt;"/>
      <doc>
      <![CDATA[If a value is present in {@code optional}, returns a stream containing only that element,
 otherwise returns an empty stream.

 <p><b>Java 9 users:</b> use {@code optional.stream()} instead.]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.IntStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optional" type="java.util.OptionalInt"/>
      <doc>
      <![CDATA[If a value is present in {@code optional}, returns a stream containing only that element,
 otherwise returns an empty stream.

 <p><b>Java 9 users:</b> use {@code optional.stream()} instead.]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.LongStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optional" type="java.util.OptionalLong"/>
      <doc>
      <![CDATA[If a value is present in {@code optional}, returns a stream containing only that element,
 otherwise returns an empty stream.

 <p><b>Java 9 users:</b> use {@code optional.stream()} instead.]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.DoubleStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optional" type="java.util.OptionalDouble"/>
      <doc>
      <![CDATA[If a value is present in {@code optional}, returns a stream containing only that element,
 otherwise returns an empty stream.

 <p><b>Java 9 users:</b> use {@code optional.stream()} instead.]]>
      </doc>
    </method>
    <method name="concat" return="java.util.stream.Stream&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="streams" type="java.util.stream.Stream[]"/>
      <doc>
      <![CDATA[Returns a {@link Stream} containing the elements of the first stream, followed by the elements
 of the second stream, and so on.

 <p>This is equivalent to {@code Stream.of(streams).flatMap(stream -> stream)}, but the returned
 stream may perform better.

 @see Stream#concat(Stream, Stream)]]>
      </doc>
    </method>
    <method name="concat" return="java.util.stream.IntStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="streams" type="java.util.stream.IntStream[]"/>
      <doc>
      <![CDATA[Returns an {@link IntStream} containing the elements of the first stream, followed by the
 elements of the second stream, and so on.

 <p>This is equivalent to {@code Stream.of(streams).flatMapToInt(stream -> stream)}, but the
 returned stream may perform better.

 @see IntStream#concat(IntStream, IntStream)]]>
      </doc>
    </method>
    <method name="concat" return="java.util.stream.LongStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="streams" type="java.util.stream.LongStream[]"/>
      <doc>
      <![CDATA[Returns a {@link LongStream} containing the elements of the first stream, followed by the
 elements of the second stream, and so on.

 <p>This is equivalent to {@code Stream.of(streams).flatMapToLong(stream -> stream)}, but the
 returned stream may perform better.

 @see LongStream#concat(LongStream, LongStream)]]>
      </doc>
    </method>
    <method name="concat" return="java.util.stream.DoubleStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="streams" type="java.util.stream.DoubleStream[]"/>
      <doc>
      <![CDATA[Returns a {@link DoubleStream} containing the elements of the first stream, followed by the
 elements of the second stream, and so on.

 <p>This is equivalent to {@code Stream.of(streams).flatMapToDouble(stream -> stream)}, but the
 returned stream may perform better.

 @see DoubleStream#concat(DoubleStream, DoubleStream)]]>
      </doc>
    </method>
    <method name="zip" return="java.util.stream.Stream&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="streamA" type="java.util.stream.Stream&lt;A&gt;"/>
      <param name="streamB" type="java.util.stream.Stream&lt;B&gt;"/>
      <param name="function" type="java.util.function.BiFunction&lt;? super A, ? super B, R&gt;"/>
      <doc>
      <![CDATA[Returns a stream in which each element is the result of passing the corresponding element of
 each of {@code streamA} and {@code streamB} to {@code function}.

 <p>For example:

 {@snippet :
 Streams.zip(
   Stream.of("foo1", "foo2", "foo3"),
   Stream.of("bar1", "bar2"),
   (arg1, arg2) -> arg1 + ":" + arg2)
 }

 <p>will return {@code Stream.of("foo1:bar1", "foo2:bar2")}.

 <p>The resulting stream will only be as long as the shorter of the two input streams; if one
 stream is longer, its extra elements will be ignored.

 <p>Note that if you are calling {@link Stream#forEach} on the resulting stream, you might want
 to consider using {@link #forEachPair} instead of this method.

 <p><b>Performance note:</b> The resulting stream is not <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>.
 This may harm parallel performance.]]>
      </doc>
    </method>
    <method name="forEachPair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="streamA" type="java.util.stream.Stream&lt;A&gt;"/>
      <param name="streamB" type="java.util.stream.Stream&lt;B&gt;"/>
      <param name="consumer" type="java.util.function.BiConsumer&lt;? super A, ? super B&gt;"/>
      <doc>
      <![CDATA[Invokes {@code consumer} once for each pair of <i>corresponding</i> elements in {@code streamA}
 and {@code streamB}. If one stream is longer than the other, the extra elements are silently
 ignored. Elements passed to the consumer are guaranteed to come from the same position in their
 respective source streams. For example:

 {@snippet :
 Streams.forEachPair(
   Stream.of("foo1", "foo2", "foo3"),
   Stream.of("bar1", "bar2"),
   (arg1, arg2) -> System.out.println(arg1 + ":" + arg2)
 }

 <p>will print:

 {@snippet :
 foo1:bar1
 foo2:bar2
 }

 <p><b>Warning:</b> If either supplied stream is a parallel stream, the same correspondence
 between elements will be made, but the order in which those pairs of elements are passed to the
 consumer is <i>not</i> defined.

 <p>Note that many usages of this method can be replaced with simpler calls to {@link #zip}.
 This method behaves equivalently to {@linkplain #zip zipping} the stream elements into
 temporary pair objects and then using {@link Stream#forEach} on that stream.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="mapWithIndex" return="java.util.stream.Stream&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.Stream&lt;T&gt;"/>
      <param name="function" type="com.google.common.collect.Streams.FunctionWithIndex&lt;? super T, ? extends R&gt;"/>
      <doc>
      <![CDATA[Returns a stream consisting of the results of applying the given function to the elements of
 {@code stream} and their indices in the stream. For example,

 {@snippet :
 mapWithIndex(
     Stream.of("a", "b", "c"),
     (e, index) -> index + ":" + e)
 }

 <p>would return {@code Stream.of("0:a", "1:b", "2:c")}.

 <p>The resulting stream is <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 if and only if {@code stream} was efficiently splittable and its underlying spliterator
 reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream
 comes from a data structure supporting efficient indexed random access, typically an array or
 list.

 <p>The order of the resulting stream is defined if and only if the order of the original stream
 was defined.]]>
      </doc>
    </method>
    <method name="mapWithIndex" return="java.util.stream.Stream&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.IntStream"/>
      <param name="function" type="com.google.common.collect.Streams.IntFunctionWithIndex&lt;R&gt;"/>
      <doc>
      <![CDATA[Returns a stream consisting of the results of applying the given function to the elements of
 {@code stream} and their indexes in the stream. For example,

 {@snippet :
 mapWithIndex(
     IntStream.of(10, 11, 12),
     (e, index) -> index + ":" + e)
 }

 <p>...would return {@code Stream.of("0:10", "1:11", "2:12")}.

 <p>The resulting stream is <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 if and only if {@code stream} was efficiently splittable and its underlying spliterator
 reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream
 comes from a data structure supporting efficient indexed random access, typically an array or
 list.

 <p>The order of the resulting stream is defined if and only if the order of the original stream
 was defined.]]>
      </doc>
    </method>
    <method name="mapWithIndex" return="java.util.stream.Stream&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.LongStream"/>
      <param name="function" type="com.google.common.collect.Streams.LongFunctionWithIndex&lt;R&gt;"/>
      <doc>
      <![CDATA[Returns a stream consisting of the results of applying the given function to the elements of
 {@code stream} and their indexes in the stream. For example,

 {@snippet :
 mapWithIndex(
     LongStream.of(10, 11, 12),
     (e, index) -> index + ":" + e)
 }

 <p>...would return {@code Stream.of("0:10", "1:11", "2:12")}.

 <p>The resulting stream is <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 if and only if {@code stream} was efficiently splittable and its underlying spliterator
 reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream
 comes from a data structure supporting efficient indexed random access, typically an array or
 list.

 <p>The order of the resulting stream is defined if and only if the order of the original stream
 was defined.]]>
      </doc>
    </method>
    <method name="mapWithIndex" return="java.util.stream.Stream&lt;R&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.DoubleStream"/>
      <param name="function" type="com.google.common.collect.Streams.DoubleFunctionWithIndex&lt;R&gt;"/>
      <doc>
      <![CDATA[Returns a stream consisting of the results of applying the given function to the elements of
 {@code stream} and their indexes in the stream. For example,

 {@snippet :
 mapWithIndex(
     DoubleStream.of(0.0, 1.0, 2.0)
     (e, index) -> index + ":" + e)
 }

 <p>...would return {@code Stream.of("0:0.0", "1:1.0", "2:2.0")}.

 <p>The resulting stream is <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 if and only if {@code stream} was efficiently splittable and its underlying spliterator
 reported {@link Spliterator#SUBSIZED}. This is generally the case if the underlying stream
 comes from a data structure supporting efficient indexed random access, typically an array or
 list.

 <p>The order of the resulting stream is defined if and only if the order of the original stream
 was defined.]]>
      </doc>
    </method>
    <method name="findLast" return="java.util.Optional&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.Stream&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the last element of the specified stream, or {@link java.util.Optional#empty} if the
 stream is empty.

 <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This
 method's runtime will be between O(log n) and O(n), performing better on <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 streams.

 <p>If the stream has nondeterministic order, this has equivalent semantics to {@link
 Stream#findAny} (which you might as well use).

 @see Stream#findFirst()
 @throws NullPointerException if the last element of the stream is null]]>
      </doc>
    </method>
    <method name="findLast" return="java.util.OptionalInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.IntStream"/>
      <doc>
      <![CDATA[Returns the last element of the specified stream, or {@link OptionalInt#empty} if the stream is
 empty.

 <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This
 method's runtime will be between O(log n) and O(n), performing better on <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 streams.

 @see IntStream#findFirst()
 @throws NullPointerException if the last element of the stream is null]]>
      </doc>
    </method>
    <method name="findLast" return="java.util.OptionalLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.LongStream"/>
      <doc>
      <![CDATA[Returns the last element of the specified stream, or {@link OptionalLong#empty} if the stream
 is empty.

 <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This
 method's runtime will be between O(log n) and O(n), performing better on <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 streams.

 @see LongStream#findFirst()
 @throws NullPointerException if the last element of the stream is null]]>
      </doc>
    </method>
    <method name="findLast" return="java.util.OptionalDouble"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.DoubleStream"/>
      <doc>
      <![CDATA[Returns the last element of the specified stream, or {@link OptionalDouble#empty} if the stream
 is empty.

 <p>Equivalent to {@code stream.reduce((a, b) -> b)}, but may perform significantly better. This
 method's runtime will be between O(log n) and O(n), performing better on <a
 href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">efficiently splittable</a>
 streams.

 @see DoubleStream#findFirst()
 @throws NullPointerException if the last element of the stream is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods related to {@code Stream} instances.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Streams -->
  <!-- start interface com.google.common.collect.Streams.DoubleFunctionWithIndex -->
  <interface name="Streams.DoubleFunctionWithIndex"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="R extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="double"/>
      <param name="index" type="long"/>
      <doc>
      <![CDATA[Applies this function to the given argument and its index within a stream.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An analogue of {@link java.util.function.DoubleFunction} also accepting an index.

 <p>This interface is only intended for use by callers of {@link #mapWithIndex(DoubleStream,
 DoubleFunctionWithIndex)}.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Streams.DoubleFunctionWithIndex -->
  <!-- start interface com.google.common.collect.Streams.FunctionWithIndex -->
  <interface name="Streams.FunctionWithIndex"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="R extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="T extends java.lang.Object"/>
      <param name="index" type="long"/>
      <doc>
      <![CDATA[Applies this function to the given argument and its index within a stream.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An analogue of {@link java.util.function.Function} also accepting an index.

 <p>This interface is only intended for use by callers of {@link #mapWithIndex(Stream,
 FunctionWithIndex)}.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Streams.FunctionWithIndex -->
  <!-- start interface com.google.common.collect.Streams.IntFunctionWithIndex -->
  <interface name="Streams.IntFunctionWithIndex"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="R extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="int"/>
      <param name="index" type="long"/>
      <doc>
      <![CDATA[Applies this function to the given argument and its index within a stream.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An analogue of {@link java.util.function.IntFunction} also accepting an index.

 <p>This interface is only intended for use by callers of {@link #mapWithIndex(IntStream,
 IntFunctionWithIndex)}.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Streams.IntFunctionWithIndex -->
  <!-- start interface com.google.common.collect.Streams.LongFunctionWithIndex -->
  <interface name="Streams.LongFunctionWithIndex"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="R extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="long"/>
      <param name="index" type="long"/>
      <doc>
      <![CDATA[Applies this function to the given argument and its index within a stream.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An analogue of {@link java.util.function.LongFunction} also accepting an index.

 <p>This interface is only intended for use by callers of {@link #mapWithIndex(LongStream,
 LongFunctionWithIndex)}.

 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Streams.LongFunctionWithIndex -->
  <!-- start interface com.google.common.collect.Table -->
  <interface name="Table"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified row and column keys.

 @param rowKey key of row to search for
 @param columnKey key of column to search for]]>
      </doc>
    </method>
    <method name="containsRow" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified row key.

 @param rowKey key of row to search for]]>
      </doc>
    </method>
    <method name="containsColumn" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified column.

 @param columnKey key of column to search for]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the table contains a mapping with the specified value.

 @param value value to search for]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Returns the value corresponding to the given row and column keys, or {@code null} if no such
 mapping exists.

 @param rowKey key of row to search for
 @param columnKey key of column to search for]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if the table contains no mappings.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of row key / column key / value mappings in the table.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Compares the specified object with this table for equality. Two tables are equal when their
 cell views, as returned by {@link #cellSet}, are equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this table. The hash code of a table is defined as the hash code of
 its cell view, as returned by {@link #cellSet}.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all mappings from the table.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R extends java.lang.Object"/>
      <param name="columnKey" type="C extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Associates the specified value with the specified keys. If the table already contained a
 mapping for those keys, the old value is replaced with the specified value.

 @param rowKey row key that the value should be associated with
 @param columnKey column key that the value should be associated with
 @param value value to be associated with the specified keys
 @return the value previously associated with the keys, or {@code null} if no mapping existed
     for the keys]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Copies all mappings from the specified table to this table. The effect is equivalent to calling
 {@link #put} with each row key / column key / value mapping in {@code table}.

 @param table the table to add to this table]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="Object"/>
      <param name="columnKey" type="Object"/>
      <doc>
      <![CDATA[Removes the mapping, if any, associated with the given keys.

 @param rowKey row key of mapping to be removed
 @param columnKey column key of mapping to be removed
 @return the value previously associated with the keys, or {@code null} if no such value existed]]>
      </doc>
    </method>
    <method name="row" return="java.util.Map&lt;C, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given row key. For each row key / column key /
 value mapping in the table with that row key, the returned map associates the column key with
 the value. If no mappings in the table have the provided row key, an empty map is returned.

 <p>Changes to the returned map will update the underlying table, and vice versa.

 @param rowKey key of row to search for in the table
 @return the corresponding map from column keys to values]]>
      </doc>
    </method>
    <method name="column" return="java.util.Map&lt;R, V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnKey" type="C extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns a view of all mappings that have the given column key. For each row key / column key /
 value mapping in the table with that column key, the returned map associates the row key with
 the value. If no mappings in the table have the provided column key, an empty map is returned.

 <p>Changes to the returned map will update the underlying table, and vice versa.

 @param columnKey key of column to search for in the table
 @return the corresponding map from row keys to values]]>
      </doc>
    </method>
    <method name="cellSet" return="java.util.Set&lt;com.google.common.collect.Table.Cell&lt;R, C, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of all row key / column key / value triplets. Changes to the returned set will
 update the underlying table, and vice versa. The cell set does not support the {@code add} or
 {@code addAll} methods.

 @return set of table cells consisting of row key / column key / value triplets]]>
      </doc>
    </method>
    <method name="rowKeySet" return="java.util.Set&lt;R&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of row keys that have one or more values in the table. Changes to the set will
 update the underlying table, and vice versa.

 @return set of row keys]]>
      </doc>
    </method>
    <method name="columnKeySet" return="java.util.Set&lt;C&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a set of column keys that have one or more values in the table. Changes to the set will
 update the underlying table, and vice versa.

 @return set of column keys]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a collection of all values, which may contain duplicates. Changes to the returned
 collection will update the underlying table, and vice versa.

 @return collection of values]]>
      </doc>
    </method>
    <method name="rowMap" return="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view that associates each row key with the corresponding map from column keys to
 values. Changes to the returned map will update this table. The returned map does not support
 {@code put()} or {@code putAll()}, or {@code setValue()} on its entries.

 <p>In contrast, the maps returned by {@code rowMap().get()} have the same behavior as those
 returned by {@link #row}. Those maps may support {@code setValue()}, {@code put()}, and {@code
 putAll()}.

 @return a map view from each row key to a secondary map from column keys to values]]>
      </doc>
    </method>
    <method name="columnMap" return="java.util.Map&lt;C, java.util.Map&lt;R, V&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a view that associates each column key with the corresponding map from row keys to
 values. Changes to the returned map will update this table. The returned map does not support
 {@code put()} or {@code putAll()}, or {@code setValue()} on its entries.

 <p>In contrast, the maps returned by {@code columnMap().get()} have the same behavior as those
 returned by {@link #column}. Those maps may support {@code setValue()}, {@code put()}, and
 {@code putAll()}.

 @return a map view from each column key to a secondary map from row keys to values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection that associates an ordered pair of keys, called a row key and a column key, with a
 single value. A table may be sparse, with only a small fraction of row key / column key pairs
 possessing a corresponding value.

 <p>The mappings corresponding to a given row key may be viewed as a {@link Map} whose keys are
 the columns. The reverse is also available, associating a column with a row key / value map. Note
 that, in some implementations, data access by column key may have fewer supported operations or
 worse performance than data access by row key.

 <p>The methods returning collections or maps always return views of the underlying table.
 Updating the table can change the contents of those collections, and updating the collections
 will change the table.

 <p>All methods that modify the table are optional, and the views returned by the table may or may
 not be modifiable. When modification isn't supported, those methods will throw an {@link
 UnsupportedOperationException}.

 <h3>Implementations</h3>

 <ul>
   <li>{@link ImmutableTable}
   <li>{@link HashBasedTable}
   <li>{@link TreeBasedTable}
   <li>{@link ArrayTable}
   <li>{@link Tables#newCustomTable Tables.newCustomTable}
 </ul>

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#table">{@code Table}</a>.

 @author Jared Levy
 @param <R> the type of the table row keys
 @param <C> the type of the table column keys
 @param <V> the type of the mapped values
 @since 7.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Table -->
  <!-- start interface com.google.common.collect.Table.Cell -->
  <interface name="Table.Cell"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRowKey" return="R extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the row key of this cell.]]>
      </doc>
    </method>
    <method name="getColumnKey" return="C extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the column key of this cell.]]>
      </doc>
    </method>
    <method name="getValue" return="V extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this cell.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Compares the specified object with this cell for equality. Two cells are equal when they have
 equal row keys, column keys, and values.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code of this cell.

 <p>The hash code of a table cell is equal to {@link Objects#hashCode}{@code (e.getRowKey(),
 e.getColumnKey(), e.getValue())}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Row key / column key / value triplet corresponding to a mapping in a table.

 @since 7.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.collect.Table.Cell -->
  <!-- start class com.google.common.collect.Tables -->
  <class name="Tables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toTable" return="java.util.stream.Collector&lt;T, ?, I&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowFunction" type="java.util.function.Function&lt;? super T, ? extends R&gt;"/>
      <param name="columnFunction" type="java.util.function.Function&lt;? super T, ? extends C&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="tableSupplier" type="java.util.function.Supplier&lt;I&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into a {@code Table} created using the
 specified supplier, whose cells are generated by applying the provided mapping functions to the
 input elements. Cells are inserted into the generated {@code Table} in encounter order.

 <p>If multiple input elements map to the same row and column, an {@code IllegalStateException}
 is thrown when the collection operation is performed.

 <p>To collect to an {@link ImmutableTable}, use {@link ImmutableTable#toImmutableTable}.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="toTable" return="java.util.stream.Collector&lt;T, ?, I&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowFunction" type="java.util.function.Function&lt;? super T, ? extends R&gt;"/>
      <param name="columnFunction" type="java.util.function.Function&lt;? super T, ? extends C&gt;"/>
      <param name="valueFunction" type="java.util.function.Function&lt;? super T, ? extends V&gt;"/>
      <param name="mergeFunction" type="java.util.function.BinaryOperator&lt;V&gt;"/>
      <param name="tableSupplier" type="java.util.function.Supplier&lt;I&gt;"/>
      <doc>
      <![CDATA[Returns a {@link Collector} that accumulates elements into a {@code Table} created using the
 specified supplier, whose cells are generated by applying the provided mapping functions to the
 input elements. Cells are inserted into the generated {@code Table} in encounter order.

 <p>If multiple input elements map to the same row and column, the specified merging function is
 used to combine the values. Like {@link
 java.util.stream.Collectors#toMap(java.util.function.Function, java.util.function.Function,
 BinaryOperator, java.util.function.Supplier)}, this Collector throws a {@code
 NullPointerException} on null values returned from {@code valueFunction}, and treats nulls
 returned from {@code mergeFunction} as removals of that row/column pair.

 @since 33.2.0 (available since 21.0 in guava-jre)]]>
      </doc>
    </method>
    <method name="immutableCell" return="com.google.common.collect.Table.Cell&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R extends java.lang.Object"/>
      <param name="columnKey" type="C extends java.lang.Object"/>
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns an immutable cell with the specified row key, column key, and value.

 <p>The returned cell is serializable.

 @param rowKey the row key to be associated with the returned cell
 @param columnKey the column key to be associated with the returned cell
 @param value the value to be associated with the returned cell]]>
      </doc>
    </method>
    <method name="transpose" return="com.google.common.collect.Table&lt;C, R, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;R, C, V&gt;"/>
      <doc>
      <![CDATA[Creates a transposed view of a given table that flips its row and column keys. In other words,
 calling {@code get(columnKey, rowKey)} on the generated table always returns the same value as
 calling {@code get(rowKey, columnKey)} on the original table. Updating the original table
 changes the contents of the transposed table and vice versa.

 <p>The returned table supports update operations as long as the input table supports the
 analogous operation with swapped rows and columns. For example, in a {@link HashBasedTable}
 instance, {@code rowKeySet().iterator()} supports {@code remove()} but {@code
 columnKeySet().iterator()} doesn't. With a transposed {@link HashBasedTable}, it's the other
 way around.]]>
      </doc>
    </method>
    <method name="newCustomTable" return="com.google.common.collect.Table&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map&lt;R, java.util.Map&lt;C, V&gt;&gt;"/>
      <param name="factory" type="com.google.common.base.Supplier&lt;? extends java.util.Map&lt;C, V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a table that uses the specified backing map and factory. It can generate a table based
 on arbitrary {@link Map} classes.

 <p>The {@code factory}-generated and {@code backingMap} classes determine the table iteration
 order. However, the table's {@code row()} method returns instances of a different class than
 {@code factory.get()} does.

 <p>Call this method only when the simpler factory methods in classes like {@link
 HashBasedTable} and {@link TreeBasedTable} won't suffice.

 <p>The views returned by the {@code Table} methods {@link Table#column}, {@link
 Table#columnKeySet}, and {@link Table#columnMap} have iterators that don't support {@code
 remove()}. Otherwise, all optional operations are supported. Null row keys, columns keys, and
 values are not supported.

 <p>Lookups by row key are often faster than lookups by column key, because the data is stored
 in a {@code Map<R, Map<C, V>>}. A method call like {@code column(columnKey).get(rowKey)} still
 runs quickly, since the row key is provided. However, {@code column(columnKey).size()} takes
 longer, since an iteration across all row keys occurs.

 <p>Note that this implementation is not synchronized. If multiple threads access this table
 concurrently and one of the threads modifies the table, it must be synchronized externally.

 <p>The table is serializable if {@code backingMap}, {@code factory}, the maps generated by
 {@code factory}, and the table contents are all serializable.

 <p>Note: the table assumes complete ownership over of {@code backingMap} and the maps returned
 by {@code factory}. Those objects should not be manually updated and they should not use soft,
 weak, or phantom references.

 @param backingMap place to store the mapping from each row key to its corresponding column key
     / value map
 @param factory supplier of new, empty maps that will each hold all column key / value mappings
     for a given row key
 @throws IllegalArgumentException if {@code backingMap} is not empty
 @since 10.0]]>
      </doc>
    </method>
    <method name="transformValues" return="com.google.common.collect.Table&lt;R, C, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromTable" type="com.google.common.collect.Table&lt;R, C, V1&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super V1, V2&gt;"/>
      <doc>
      <![CDATA[Returns a view of a table where each value is transformed by a function. All other properties
 of the table, such as iteration order, are left intact.

 <p>Changes in the underlying table are reflected in this view. Conversely, this view supports
 removal operations, and these are reflected in the underlying table.

 <p>It's acceptable for the underlying table to contain null keys, and even null values provided
 that the function is capable of accepting null input. The transformed table might contain null
 values, if the function sometimes gives a null result.

 <p>The returned table is not thread-safe or serializable, even if the underlying table is.

 <p>The function is applied lazily, invoked when needed. This is necessary for the returned
 table to be a view, but it means that the function will be applied many times for bulk
 operations like {@link Table#containsValue} and {@code Table.toString()}. For this to perform
 well, {@code function} should be fast. To avoid lazy evaluation when the returned table doesn't
 need to be a view, copy the returned table into a new table of your choosing.

 @since 10.0]]>
      </doc>
    </method>
    <method name="unmodifiableTable" return="com.google.common.collect.Table&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;? extends R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified table. This method allows modules to provide
 users with "read-only" access to internal tables. Query operations on the returned table "read
 through" to the specified table, and attempts to modify the returned table, whether direct or
 via its collection views, result in an {@code UnsupportedOperationException}.

 <p>The returned table will be serializable if the specified table is serializable.

 <p>Consider using an {@link ImmutableTable}, which is guaranteed never to change.

 @since 11.0]]>
      </doc>
    </method>
    <method name="unmodifiableRowSortedTable" return="com.google.common.collect.RowSortedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.RowSortedTable&lt;R, ? extends C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable view of the specified row-sorted table. This method allows modules to
 provide users with "read-only" access to internal tables. Query operations on the returned
 table "read through" to the specified table, and attempts to modify the returned table, whether
 direct or via its collection views, result in an {@code UnsupportedOperationException}.

 <p>The returned table will be serializable if the specified table is serializable.

 @param table the row-sorted table for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified table
 @since 11.0]]>
      </doc>
    </method>
    <method name="synchronizedTable" return="com.google.common.collect.Table&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.Table&lt;R, C, V&gt;"/>
      <doc>
      <![CDATA[Returns a synchronized (thread-safe) table backed by the specified table. In order to guarantee
 serial access, it is critical that <b>all</b> access to the backing table is accomplished
 through the returned table.

 <p>It is imperative that the user manually synchronize on the returned table when accessing any
 of its collection views:

 {@snippet :
 Table<R, C, V> table = Tables.synchronizedTable(HashBasedTable.<R, C, V>create());
 ...
 Map<C, V> row = table.row(rowKey);  // Needn't be in synchronized block
 ...
 synchronized (table) {  // Synchronizing on table, not row!
   Iterator<Entry<C, V>> i = row.entrySet().iterator(); // Must be in synchronized block
   while (i.hasNext()) {
     foo(i.next());
   }
 }
 }

 <p>Failure to follow this advice may result in non-deterministic behavior.

 <p>The returned table will be serializable if the specified table is serializable.

 @param table the table to be wrapped in a synchronized view
 @return a synchronized view of the specified table
 @since 22.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides static methods that involve a {@code Table}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/CollectionUtilitiesExplained#tables">{@code Tables}</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.Tables -->
  <!-- start class com.google.common.collect.TreeBasedTable -->
  <class name="TreeBasedTable" extends="com.google.common.collect.StandardRowSortedTable&lt;R, C, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.TreeBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code TreeBasedTable} that uses the natural orderings of both row and column
 keys.

 <p>The method signature specifies {@code R extends Comparable} with a raw {@link Comparable},
 instead of {@code R extends Comparable<? super R>}, and the same for {@code C}. That's
 necessary to support classes defined without generics.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowComparator" type="java.util.Comparator&lt;? super R&gt;"/>
      <param name="columnComparator" type="java.util.Comparator&lt;? super C&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code TreeBasedTable} that is ordered by the specified comparators.

 @param rowComparator the comparator that orders the row keys
 @param columnComparator the comparator that orders the column keys]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeBasedTable&lt;R, C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="table" type="com.google.common.collect.TreeBasedTable&lt;R, C, ? extends V&gt;"/>
      <doc>
      <![CDATA[Creates a {@code TreeBasedTable} with the same mappings and sort order as the specified {@code
 TreeBasedTable}.]]>
      </doc>
    </method>
    <method name="rowComparator" return="java.util.Comparator&lt;? super R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Use {@code table.rowKeySet().comparator()} instead.">
      <doc>
      <![CDATA[Returns the comparator that orders the rows. With natural ordering, {@link Ordering#natural()}
 is returned.

 @deprecated Use {@code table.rowKeySet().comparator()} instead.]]>
      </doc>
    </method>
    <method name="columnComparator" return="java.util.Comparator&lt;? super C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Store the {@link Comparator} alongside the {@link Table}. Or, if you know that the
     {@link Table} contains at least one value, you can retrieve the {@link Comparator} with:
     {@code ((SortedMaplEsS_tHaNC, V>) table.rowMap().values().iterator().next()).comparator();}.">
      <doc>
      <![CDATA[Returns the comparator that orders the columns. With natural ordering, {@link
 Ordering#natural()} is returned.

 @deprecated Store the {@link Comparator} alongside the {@link Table}. Or, if you know that the
     {@link Table} contains at least one value, you can retrieve the {@link Comparator} with:
     {@code ((SortedMap<C, V>) table.rowMap().values().iterator().next()).comparator();}.]]>
      </doc>
    </method>
    <method name="row" return="java.util.SortedMap&lt;C, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowKey" type="R"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeBasedTable} has unique sorted values for a given row, this method
 returns a {@link SortedMap}, instead of the {@link Map} specified in the {@link Table}
 interface.

 @since 10.0 (<a href="https://github.com/google/guava/wiki/Compatibility" >mostly
     source-compatible</a> since 7.0)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Table} whose row keys and column keys are ordered by their natural
 ordering or by supplied comparators. When constructing a {@code TreeBasedTable}, you may provide
 comparators for the row keys and the column keys, or you may use natural ordering for both.

 <p>The {@link #rowKeySet} method returns a {@link SortedSet} and the {@link #rowMap} method
 returns a {@link SortedMap}, instead of the {@link Set} and {@link Map} specified by the {@link
 Table} interface.

 <p>The views returned by {@link #column}, {@link #columnKeySet()}, and {@link #columnMap()} have
 iterators that don't support {@code remove()}. Otherwise, all optional operations are supported.
 Null row keys, columns keys, and values are not supported.

 <p>Lookups by row key are often faster than lookups by column key, because the data is stored in
 a {@code Map<R, Map<C, V>>}. A method call like {@code column(columnKey).get(rowKey)} still runs
 quickly, since the row key is provided. However, {@code column(columnKey).size()} takes longer,
 since an iteration across all row keys occurs.

 <p>Because a {@code TreeBasedTable} has unique sorted values for a given row, both {@code
 row(rowKey)} and {@code rowMap().get(rowKey)} are {@link SortedMap} instances, instead of the
 {@link Map} specified in the {@link Table} interface.

 <p>Note that this implementation is not synchronized. If multiple threads access this table
 concurrently and one of the threads modifies the table, it must be synchronized externally.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#table">{@code Table}</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 7.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeBasedTable -->
  <!-- start class com.google.common.collect.TreeMultimap -->
  <class name="TreeMultimap" extends="com.google.common.collect.AbstractSortedKeySortedSetMultimap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code TreeMultimap} ordered by the natural ordering of its keys and values.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyComparator" type="java.util.Comparator&lt;? super K&gt;"/>
      <param name="valueComparator" type="java.util.Comparator&lt;? super V&gt;"/>
      <doc>
      <![CDATA[Creates an empty {@code TreeMultimap} instance using explicit comparators. Neither comparator
 may be null; use {@link Ordering#natural()} to specify natural order.

 @param keyComparator the comparator that determines the key ordering
 @param valueComparator the comparator that determines the value ordering]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultimap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="multimap" type="com.google.common.collect.Multimap&lt;? extends K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Constructs a {@code TreeMultimap}, ordered by the natural ordering of its keys and values, with
 the same mappings as the specified multimap.

 @param multimap the multimap whose contents are copied to this multimap]]>
      </doc>
    </method>
    <method name="keyComparator" return="java.util.Comparator&lt;? super K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@code ((NavigableSetlEsS_tHaNK>) multimap.keySet()).comparator()} instead.">
      <doc>
      <![CDATA[Returns the comparator that orders the multimap keys.

 @deprecated Use {@code ((NavigableSet<K>) multimap.keySet()).comparator()} instead.]]>
      </doc>
    </method>
    <method name="valueComparator" return="java.util.Comparator&lt;? super V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.util.NavigableSet&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Object"/>
      <doc>
      <![CDATA[@since 14.0 (present with return type {@code SortedSet} since 2.0)]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.NavigableSet&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeMultimap} has unique sorted keys, this method returns a {@link
 NavigableSet}, instead of the {@link java.util.Set} specified in the {@link Multimap}
 interface.

 @since 14.0 (present with return type {@code SortedSet} since 2.0)]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.NavigableMap&lt;K, java.util.Collection&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p>Because a {@code TreeMultimap} has unique sorted keys, this method returns a {@link
 NavigableMap}, instead of the {@link java.util.Map} specified in the {@link Multimap}
 interface.

 @since 14.0 (present with return type {@code SortedMap} since 2.0)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementation of {@code Multimap} whose keys and values are ordered by their natural ordering or
 by supplied comparators. In all cases, this implementation uses {@link Comparable#compareTo} or
 {@link Comparator#compare} instead of {@link Object#equals} to determine equivalence of
 instances.

 <p><b>Warning:</b> The comparators or comparables used must be <i>consistent with equals</i> as
 explained by the {@link Comparable} class specification. Otherwise, the resulting multiset will
 violate the general contract of {@link SetMultimap}, which is specified in terms of {@link
 Object#equals}.

 <p>The collections returned by {@code keySet} and {@code asMap} iterate through the keys
 according to the key comparator ordering or the natural ordering of the keys. Similarly, {@code
 get}, {@code removeAll}, and {@code replaceValues} return collections that iterate through the
 values according to the value comparator ordering or the natural ordering of the values. The
 collections generated by {@code entries}, {@code keys}, and {@code values} iterate across the
 keys according to the above key ordering, and for each key they iterate across the values
 according to the value ordering.

 <p>The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an
 existing key-value pair has no effect.

 <p>Null keys and values are permitted (provided, of course, that the respective comparators
 support them). All optional multimap methods are supported, and all returned views are
 modifiable.

 <p>This class is not threadsafe when any concurrent operations update the multimap. Concurrent
 read operations will work correctly. To allow concurrent update operations, wrap your multimap
 with a call to {@link Multimaps#synchronizedSortedSetMultimap}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">{@code Multimap}</a>.

 @author Jared Levy
 @author Louis Wasserman
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeMultimap -->
  <!-- start class com.google.common.collect.TreeMultiset -->
  <class name="TreeMultiset" extends="com.google.common.collect.AbstractSortedMultiset&lt;E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty multiset, sorted according to the elements' natural order. All elements
 inserted into the multiset must implement the {@code Comparable} interface. Furthermore, all
 such elements must be <i>mutually comparable</i>: {@code e1.compareTo(e2)} must not throw a
 {@code ClassCastException} for any elements {@code e1} and {@code e2} in the multiset. If the
 user attempts to add an element to the multiset that violates this constraint (for example, the
 user attempts to add a string element to a set whose elements are integers), the {@code
 add(Object)} call will throw a {@code ClassCastException}.

 <p>The type specification is {@code <E extends Comparable>}, instead of the more specific
 {@code <E extends Comparable<? super E>>}, to support classes defined without generics.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="Comparator"/>
      <doc>
      <![CDATA[Creates a new, empty multiset, sorted according to the specified comparator. All elements
 inserted into the multiset must be <i>mutually comparable</i> by the specified comparator:
 {@code comparator.compare(e1, e2)} must not throw a {@code ClassCastException} for any elements
 {@code e1} and {@code e2} in the multiset. If the user attempts to add an element to the
 multiset that violates this constraint, the {@code add(Object)} call will throw a {@code
 ClassCastException}.

 @param comparator the comparator that will be used to sort this multiset. A null value
     indicates that the elements' <i>natural ordering</i> should be used.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends E&gt;"/>
      <doc>
      <![CDATA[Creates an empty multiset containing the given initial elements, sorted according to the
 elements' natural order.

 <p>This implementation is highly efficient when {@code elements} is itself a {@link Multiset}.

 <p>The type specification is {@code <E extends Comparable>}, instead of the more specific
 {@code <E extends Comparable<? super E>>}, to support classes defined without generics.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="count" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
    </method>
    <method name="add" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="remove" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="Object"/>
      <param name="occurrences" type="int"/>
    </method>
    <method name="setCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="count" type="int"/>
    </method>
    <method name="setCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E extends java.lang.Object"/>
      <param name="oldCount" type="int"/>
      <param name="newCount" type="int"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="upperBound" type="E extends java.lang.Object"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <method name="tailMultiset" return="com.google.common.collect.SortedMultiset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowerBound" type="E extends java.lang.Object"/>
      <param name="boundType" type="com.google.common.collect.BoundType"/>
    </method>
    <doc>
    <![CDATA[A multiset which maintains the ordering of its elements, according to either their natural order
 or an explicit {@link Comparator}. In all cases, this implementation uses {@link
 Comparable#compareTo} or {@link Comparator#compare} instead of {@link Object#equals} to determine
 equivalence of instances.

 <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the
 {@link Comparable} class specification. Otherwise, the resulting multiset will violate the {@link
 java.util.Collection} contract, which is specified in terms of {@link Object#equals}.

 <p>See the Guava User Guide article on <a href=
 "https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset">{@code Multiset}</a>.

 @author Louis Wasserman
 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeMultiset -->
  <!-- start class com.google.common.collect.TreeRangeMap -->
  <class name="TreeRangeMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.collect.RangeMap&lt;K, V&gt;"/>
    <method name="create" return="com.google.common.collect.TreeRangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty {@link TreeRangeMap}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.collect.TreeRangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeMap" type="com.google.common.collect.RangeMap&lt;K, ? extends V&gt;"/>
      <doc>
      <![CDATA[Returns a new {@link TreeRangeMap} containing the same ranges as the given {@code RangeMap}.

 @since 33.4.0]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Comparable"/>
    </method>
    <method name="getEntry" return="Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K extends java.lang.Comparable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
    </method>
    <method name="putCoalescing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;K&gt;"/>
      <param name="value" type="V"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeMap" type="com.google.common.collect.RangeMap&lt;K, ? extends V&gt;"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeToRemove" type="com.google.common.collect.Range&lt;K&gt;"/>
    </method>
    <method name="asMapOfRanges" return="java.util.Map&lt;com.google.common.collect.Range&lt;K&gt;, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asDescendingMapOfRanges" return="java.util.Map&lt;com.google.common.collect.Range&lt;K&gt;, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subRangeMap" return="com.google.common.collect.RangeMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subRange" type="com.google.common.collect.Range&lt;K&gt;"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An implementation of {@code RangeMap} based on a {@code TreeMap}, supporting all optional
 operations.

 <p>Like all {@code RangeMap} implementations, this supports neither null keys nor null values.

 @author Louis Wasserman
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeRangeMap -->
  <!-- start class com.google.common.collect.TreeRangeSet -->
  <class name="TreeRangeSet" extends="com.google.common.collect.AbstractRangeSet&lt;C&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.collect.TreeRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an empty {@code TreeRangeSet} instance.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeSet" type="com.google.common.collect.RangeSet&lt;C&gt;"/>
      <doc>
      <![CDATA[Returns a {@code TreeRangeSet} initialized with the ranges in the specified range set.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.collect.TreeRangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.lang.Iterable&lt;com.google.common.collect.Range&lt;C&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a {@code TreeRangeSet} representing the union of the specified ranges.

 <p>This is the smallest {@code RangeSet} which encloses each of the specified ranges. An
 element will be contained in this {@code RangeSet} if and only if it is contained in at least
 one {@code Range} in {@code ranges}.

 @since 21.0]]>
      </doc>
    </method>
    <method name="asRanges" return="java.util.Set&lt;com.google.common.collect.Range&lt;C&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asDescendingSetOfRanges" return="java.util.Set&lt;com.google.common.collect.Range&lt;C&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="rangeContaining" return="Range"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="C extends java.lang.Comparable&lt;?&gt;"/>
    </method>
    <method name="intersects" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
    </method>
    <method name="encloses" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="range" type="com.google.common.collect.Range&lt;C&gt;"/>
    </method>
    <method name="span" return="com.google.common.collect.Range&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeToAdd" type="com.google.common.collect.Range&lt;C&gt;"/>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rangeToRemove" type="com.google.common.collect.Range&lt;C&gt;"/>
    </method>
    <method name="complement" return="com.google.common.collect.RangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subRangeSet" return="com.google.common.collect.RangeSet&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="com.google.common.collect.Range&lt;C&gt;"/>
    </method>
    <doc>
    <![CDATA[An implementation of {@link RangeSet} backed by a {@link TreeMap}.

 @author Louis Wasserman
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeRangeSet -->
  <!-- start class com.google.common.collect.TreeTraverser -->
  <class name="TreeTraverser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Use {@link com.google.common.graph.Traverser} instead. All instance methods have
     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}
     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be
     the same lambda function as passed into {@link #using(Function)}.
     lEsS_tHaNp>This class is scheduled to be removed in October 2019.">
    <constructor name="TreeTraverser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="using" return="com.google.common.collect.TreeTraverser&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link com.google.common.graph.Traverser#forTree} instead. If you are using a
     lambda, these methods have exactly the same signature.">
      <param name="nodeToChildrenFunction" type="com.google.common.base.Function&lt;T, ? extends java.lang.Iterable&lt;T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a tree traverser that uses the given function to navigate from a node to its children.
 This is useful if the function instance already exists, or so that you can supply a lambda
 expressions. If those circumstances don't apply, you probably don't need to use this; subclass
 {@code TreeTraverser} and implement its {@link #children} method directly.

 @since 20.0
 @deprecated Use {@link com.google.common.graph.Traverser#forTree} instead. If you are using a
     lambda, these methods have exactly the same signature.]]>
      </doc>
    </method>
    <method name="children" return="java.lang.Iterable&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="root" type="T"/>
      <doc>
      <![CDATA[Returns the children of the specified node. Must not contain null.]]>
      </doc>
    </method>
    <method name="preOrderTraversal" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Use {@link com.google.common.graph.Traverser#depthFirstPreOrder} instead, which has
     the same behavior.">
      <param name="root" type="T"/>
      <doc>
      <![CDATA[Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order traversal.
 That is, each node's subtrees are traversed after the node itself is returned.

 <p>No guarantees are made about the behavior of the traversal when nodes change while iteration
 is in progress or when the iterators generated by {@link #children} are advanced.

 @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPreOrder} instead, which has
     the same behavior.]]>
      </doc>
    </method>
    <method name="postOrderTraversal" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Use {@link com.google.common.graph.Traverser#depthFirstPostOrder} instead, which
     has the same behavior.">
      <param name="root" type="T"/>
      <doc>
      <![CDATA[Returns an unmodifiable iterable over the nodes in a tree structure, using post-order
 traversal. That is, each node's subtrees are traversed before the node itself is returned.

 <p>No guarantees are made about the behavior of the traversal when nodes change while iteration
 is in progress or when the iterators generated by {@link #children} are advanced.

 @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPostOrder} instead, which
     has the same behavior.]]>
      </doc>
    </method>
    <method name="breadthFirstTraversal" return="com.google.common.collect.FluentIterable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Use {@link com.google.common.graph.Traverser#breadthFirst} instead, which has the
     same behavior.">
      <param name="root" type="T"/>
      <doc>
      <![CDATA[Returns an unmodifiable iterable over the nodes in a tree structure, using breadth-first
 traversal. That is, all the nodes of depth 0 are returned, then depth 1, then 2, and so on.

 <p>No guarantees are made about the behavior of the traversal when nodes change while iteration
 is in progress or when the iterators generated by {@link #children} are advanced.

 @deprecated Use {@link com.google.common.graph.Traverser#breadthFirst} instead, which has the
     same behavior.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Views elements of a type {@code T} as nodes in a tree, and provides methods to traverse the trees
 induced by this traverser.

 <p>For example, the tree

 {@snippet :
        h
      / | \
     /  e  \
    d       g
   /|\      |
  / | \     f
 a  b  c
 }

 <p>can be iterated over in preorder (hdabcegf), postorder (abcdefgh), or breadth-first order
 (hdegabcf).

 <p>Null nodes are strictly forbidden.

 <p>Because this is an abstract class, not an interface, you can't use a lambda expression to
 implement it:

 {@snippet :
 // won't work
 TreeTraverser<NodeType> traverser = node -> node.getChildNodes();
 }

 Instead, you can pass a lambda expression to the {@code using} factory method:

 {@snippet :
 TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());
 }

 @author Louis Wasserman
 @since 15.0
 @deprecated Use {@link com.google.common.graph.Traverser} instead. All instance methods have
     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}
     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be
     the same lambda function as passed into {@link #using(Function)}.
     <p>This class is scheduled to be removed in October 2019.]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.TreeTraverser -->
  <!-- start class com.google.common.collect.UnmodifiableIterator -->
  <class name="UnmodifiableIterator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <constructor name="UnmodifiableIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the underlying data unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator that does not support {@link #remove}.

 <p>{@code UnmodifiableIterator} is used primarily in conjunction with implementations of {@link
 ImmutableCollection}, such as {@link ImmutableList}. You can, however, convert an existing
 iterator to an {@code UnmodifiableIterator} using {@link Iterators#unmodifiableIterator}.

 @author Jared Levy
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.UnmodifiableIterator -->
  <!-- start class com.google.common.collect.UnmodifiableListIterator -->
  <class name="UnmodifiableListIterator" extends="com.google.common.collect.UnmodifiableIterator&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.ListIterator&lt;E&gt;"/>
    <constructor name="UnmodifiableListIterator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the underlying data unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Unsupported operation.">
      <param name="e" type="E extends java.lang.Object"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the underlying data unmodified.

 @throws UnsupportedOperationException always
 @deprecated Unsupported operation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A list iterator that does not support {@link #remove}, {@link #add}, or {@link #set}.

 @since 7.0
 @author Louis Wasserman]]>
    </doc>
  </class>
  <!-- end class com.google.common.collect.UnmodifiableListIterator -->
</package>
<package name="com.google.common.escape">
  <!-- start class com.google.common.escape.ArrayBasedCharEscaper -->
  <class name="ArrayBasedCharEscaper" extends="com.google.common.escape.CharEscaper"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayBasedCharEscaper" type="java.util.Map&lt;java.lang.Character, java.lang.String&gt;, char, char"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ArrayBasedCharEscaper instance with the given replacement map and specified safe
 range. If {@code safeMax < safeMin} then no characters are considered safe.

 <p>If a character has no mapped replacement then it is checked against the safe range. If it
 lies outside that, then {@link #escapeUnsafe} is called, otherwise no escaping is performed.

 @param replacementMap a map of characters to their escaped representations
 @param safeMin the lowest character value in the safe range
 @param safeMax the highest character value in the safe range]]>
      </doc>
    </constructor>
    <constructor name="ArrayBasedCharEscaper" type="com.google.common.escape.ArrayBasedEscaperMap, char, char"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ArrayBasedCharEscaper instance with the given replacement map and specified safe
 range. If {@code safeMax < safeMin} then no characters are considered safe. This initializer is
 useful when explicit instances of ArrayBasedEscaperMap are used to allow the sharing of large
 replacement mappings.

 <p>If a character has no mapped replacement then it is checked against the safe range. If it
 lies outside that, then {@link #escapeUnsafe} is called, otherwise no escaping is performed.

 @param escaperMap the mapping of characters to be escaped
 @param safeMin the lowest character value in the safe range
 @param safeMax the highest character value in the safe range]]>
      </doc>
    </constructor>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="escape" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Escapes a single character using the replacement array and safe range values. If the given
 character does not have an explicit replacement and lies outside the safe range then {@link
 #escapeUnsafe} is called.

 @return the replacement characters, or {@code null} if no escaping was required]]>
      </doc>
    </method>
    <method name="escapeUnsafe" return="char"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Escapes a {@code char} value that has no direct explicit value in the replacement array and
 lies outside the stated safe range. Subclasses should override this method to provide
 generalized escaping for characters.

 <p>Note that arrays returned by this method must not be modified once they have been returned.
 However it is acceptable to return the same array multiple times (even for different input
 characters).

 @param c the character to escape
 @return the replacement characters, or {@code null} if no escaping was required]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link CharEscaper} that uses an array to quickly look up replacement characters for a given
 {@code char} value. An additional safe range is provided that determines whether {@code char}
 values without specific replacements are to be considered safe and left unescaped or should be
 escaped in a general way.

 <p>A good example of usage of this class is for Java source code escaping where the replacement
 array contains information about special ASCII characters such as {@code \\t} and {@code \\n}
 while {@link #escapeUnsafe} is overridden to handle general escaping of the form {@code \\uxxxx}.

 <p>The size of the data structure used by {@link ArrayBasedCharEscaper} is proportional to the
 highest valued character that requires escaping. For example a replacement map containing the
 single character '{@code \}{@code u1000}' will require approximately 16K of memory. If you need
 to create multiple escaper instances that have the same character replacement mapping consider
 using {@link ArrayBasedEscaperMap}.

 @author Sven Mawson
 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.ArrayBasedCharEscaper -->
  <!-- start class com.google.common.escape.ArrayBasedEscaperMap -->
  <class name="ArrayBasedEscaperMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.escape.ArrayBasedEscaperMap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="replacements" type="java.util.Map&lt;java.lang.Character, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Returns a new ArrayBasedEscaperMap for creating ArrayBasedCharEscaper or
 ArrayBasedUnicodeEscaper instances.

 @param replacements a map of characters to their escaped representations]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation-specific parameter class suitable for initializing {@link
 ArrayBasedCharEscaper} or {@link ArrayBasedUnicodeEscaper} instances. This class should be used
 when more than one escaper is created using the same character replacement mapping to allow the
 underlying (implementation specific) data structures to be shared.

 <p>The size of the data structure used by ArrayBasedCharEscaper and ArrayBasedUnicodeEscaper is
 proportional to the highest valued character that has a replacement. For example a replacement
 map containing the single character '{@literal \}u1000' will require approximately 16K of memory.
 As such sharing this data structure between escaper instances is the primary goal of this class.

 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.ArrayBasedEscaperMap -->
  <!-- start class com.google.common.escape.ArrayBasedUnicodeEscaper -->
  <class name="ArrayBasedUnicodeEscaper" extends="com.google.common.escape.UnicodeEscaper"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayBasedUnicodeEscaper" type="java.util.Map&lt;java.lang.Character, java.lang.String&gt;, int, int, String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ArrayBasedUnicodeEscaper instance with the given replacement map and specified
 safe range. If {@code safeMax < safeMin} then no code points are considered safe.

 <p>If a code point has no mapped replacement then it is checked against the safe range. If it
 lies outside that, then {@link #escapeUnsafe} is called, otherwise no escaping is performed.

 @param replacementMap a map of characters to their escaped representations
 @param safeMin the lowest character value in the safe range
 @param safeMax the highest character value in the safe range
 @param unsafeReplacement the default replacement for unsafe characters or null if no default
     replacement is required]]>
      </doc>
    </constructor>
    <constructor name="ArrayBasedUnicodeEscaper" type="com.google.common.escape.ArrayBasedEscaperMap, int, int, String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ArrayBasedUnicodeEscaper instance with the given replacement map and specified
 safe range. If {@code safeMax < safeMin} then no code points are considered safe. This
 initializer is useful when explicit instances of ArrayBasedEscaperMap are used to allow the
 sharing of large replacement mappings.

 <p>If a code point has no mapped replacement then it is checked against the safe range. If it
 lies outside that, then {@link #escapeUnsafe} is called, otherwise no escaping is performed.

 @param escaperMap the map of replacements
 @param safeMin the lowest character value in the safe range
 @param safeMax the highest character value in the safe range
 @param unsafeReplacement the default replacement for unsafe characters or null if no default
     replacement is required]]>
      </doc>
    </constructor>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="escape" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Escapes a single Unicode code point using the replacement array and safe range values. If the
 given character does not have an explicit replacement and lies outside the safe range then
 {@link #escapeUnsafe} is called.

 @return the replacement characters, or {@code null} if no escaping was required]]>
      </doc>
    </method>
    <method name="nextEscapeIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
    </method>
    <method name="escapeUnsafe" return="char"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Escapes a code point that has no direct explicit value in the replacement array and lies
 outside the stated safe range. Subclasses should override this method to provide generalized
 escaping for code points if required.

 <p>Note that arrays returned by this method must not be modified once they have been returned.
 However it is acceptable to return the same array multiple times (even for different input
 characters).

 @param cp the Unicode code point to escape
 @return the replacement characters, or {@code null} if no escaping was required]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link UnicodeEscaper} that uses an array to quickly look up replacement characters for a given
 code point. An additional safe range is provided that determines whether code points without
 specific replacements are to be considered safe and left unescaped or should be escaped in a
 general way.

 <p>A good example of usage of this class is for HTML escaping where the replacement array
 contains information about the named HTML entities such as {@code &amp;} and {@code &quot;} while
 {@link #escapeUnsafe} is overridden to handle general escaping of the form {@code &#NNNNN;}.

 <p>The size of the data structure used by {@link ArrayBasedUnicodeEscaper} is proportional to the
 highest valued code point that requires escaping. For example a replacement map containing the
 single character '{@code \}{@code u1000}' will require approximately 16K of memory. If you need
 to create multiple escaper instances that have the same character replacement mapping consider
 using {@link ArrayBasedEscaperMap}.

 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.ArrayBasedUnicodeEscaper -->
  <!-- start class com.google.common.escape.CharEscaper -->
  <class name="CharEscaper" extends="com.google.common.escape.Escaper"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharEscaper"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.

 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null]]>
      </doc>
    </method>
    <method name="escape" return="char"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Returns the escaped form of the given character, or {@code null} if this character does not
 need to be escaped. If an empty array is returned, this effectively strips the input character
 from the resulting text.

 <p>If the character does not need to be escaped, this method should return {@code null}, rather
 than a one-character array containing the character itself. This enables the escaping algorithm
 to perform more efficiently.

 <p>An escaper is expected to be able to deal with any {@code char} value, so this method should
 not throw any exceptions.

 @param c the character to escape if necessary
 @return the replacement characters, or {@code null} if no escaping was needed]]>
      </doc>
    </method>
    <method name="escapeSlow" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string, starting at the given index. This method is
 called by the {@link #escape(String)} method when it discovers that escaping is required. It is
 protected to allow subclasses to override the fastpath escaping function to inline their
 escaping test. See {@link CharEscaperBuilder} for an example usage.

 @param s the literal string to be escaped
 @param index the index to start escaping from
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that converts literal text into a format safe for inclusion in a particular context
 (such as an XML document). Typically (but not always), the inverse process of "unescaping" the
 text is performed automatically by the relevant parser.

 <p>For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into {@code
 "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
 resulting XML document is parsed, the parser API will return this text as the original literal
 string {@code "Foo<Bar>"}.

 <p>A {@code CharEscaper} instance is required to be stateless, and safe when used concurrently by
 multiple threads.

 <p>Popular escapers are defined as constants in classes like {@link
 com.google.common.html.HtmlEscapers} and {@link com.google.common.xml.XmlEscapers}. To create
 your own escapers extend this class and implement the {@link #escape(char)} method.

 @author Sven Mawson
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.CharEscaper -->
  <!-- start class com.google.common.escape.CharEscaperBuilder -->
  <class name="CharEscaperBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharEscaperBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new sparse array builder.]]>
      </doc>
    </constructor>
    <method name="addEscape" return="com.google.common.escape.CharEscaperBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="r" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a new mapping from an index to an object to the escaping.]]>
      </doc>
    </method>
    <method name="addEscapes" return="com.google.common.escape.CharEscaperBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="char[]"/>
      <param name="r" type="java.lang.String"/>
      <doc>
      <![CDATA[Add multiple mappings at once for a particular index.]]>
      </doc>
    </method>
    <method name="toArray" return="char[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert this builder into an array of char[]s where the maximum index is the value of the
 highest character that has been seen. The array will be sparse in the sense that any unseen
 index will default to null.

 @return a "sparse" array that holds the replacement mappings.]]>
      </doc>
    </method>
    <method name="toEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert this builder into a char escaper which is just a decorator around the underlying array
 of replacement char[]s.

 @return an escaper that escapes based on the underlying array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple helper class to build a "sparse" array of objects based on the indexes that were added to
 it. The array will be from 0 to the maximum index given. All non-set indexes will contain null
 (so it's not really a sparse array, just a pseudo sparse array). The builder can also return a
 CharEscaper based on the generated array.

 @author Sven Mawson
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.CharEscaperBuilder -->
  <!-- start class com.google.common.escape.Escaper -->
  <class name="Escaper" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Escaper"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="escape" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.

 <p>Note that this method may treat input characters differently depending on the specific
 escaper implementation.

 <ul>
   <li>{@link UnicodeEscaper} handles <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>
       correctly, including surrogate character pairs. If the input is badly formed the escaper
       should throw {@link IllegalArgumentException}.
   <li>{@link CharEscaper} handles Java characters independently and does not verify the input
       for well formed characters. A {@code CharEscaper} should not be used in situations where
       input is not guaranteed to be restricted to the Basic Multilingual Plane (BMP).
 </ul>

 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if {@code string} contains badly formed UTF-16 or cannot be
     escaped for any other reason]]>
      </doc>
    </method>
    <method name="asFunction" return="com.google.common.base.Function&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Function} that invokes {@link #escape(String)} on this escaper.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that converts literal text into a format safe for inclusion in a particular context
 (such as an XML document). Typically (but not always), the inverse process of "unescaping" the
 text is performed automatically by the relevant parser.

 <p>For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into {@code
 "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
 resulting XML document is parsed, the parser API will return this text as the original literal
 string {@code "Foo<Bar>"}.

 <p>An {@code Escaper} instance is required to be stateless, and safe when used concurrently by
 multiple threads.

 <p>Because, in general, escaping operates on the code points of a string and not on its
 individual {@code char} values, it is not safe to assume that {@code escape(s)} is equivalent to
 {@code escape(s.substring(0, n)) + escape(s.substring(n))} for arbitrary {@code n}. This is
 because of the possibility of splitting a surrogate pair. The only case in which it is safe to
 escape strings and concatenate the results is if you can rule out this possibility, either by
 splitting an existing long string into short strings adaptively around {@linkplain
 Character#isHighSurrogate surrogate} {@linkplain Character#isLowSurrogate pairs}, or by starting
 with short strings already known to be free of unpaired surrogates.

 <p>The two primary implementations of this interface are {@link CharEscaper} and {@link
 UnicodeEscaper}. They are heavily optimized for performance and greatly simplify the task of
 implementing new escapers. It is strongly recommended that when implementing a new escaper you
 extend one of these classes. If you find that you are unable to achieve the desired behavior
 using either of these classes, please contact the Java libraries team for advice.

 <p>Popular escapers are defined as constants in classes like {@link
 com.google.common.html.HtmlEscapers} and {@link com.google.common.xml.XmlEscapers}. To create
 your own escapers, use {@link CharEscaperBuilder}, or extend {@code CharEscaper} or {@code
 UnicodeEscaper}.

 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.Escaper -->
  <!-- start class com.google.common.escape.Escapers -->
  <class name="Escapers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="nullEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Escaper} that does no escaping, passing all character data through unchanged.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.escape.Escapers.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a builder for creating simple, fast escapers. A builder instance can be reused and each
 escaper that is created will be a snapshot of the current builder state. Builders are not
 thread safe.

 <p>The initial state of the builder is such that:

 <ul>
   <li>There are no replacement mappings
   <li>{@code safeMin == Character.MIN_VALUE}
   <li>{@code safeMax == Character.MAX_VALUE}
   <li>{@code unsafeReplacement == null}
 </ul>

 <p>For performance reasons escapers created by this builder are not Unicode aware and will not
 validate the well-formedness of their input.]]>
      </doc>
    </method>
    <method name="computeReplacement" return="String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="escaper" type="com.google.common.escape.CharEscaper"/>
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Returns a string that would replace the given character in the specified escaper, or {@code
 null} if no replacement should be made. This method is intended for use in tests through the
 {@code EscaperAsserts} class; production users of {@link CharEscaper} should limit themselves
 to its public interface.

 @param c the character to escape if necessary
 @return the replacement string, or {@code null} if no escaping was needed]]>
      </doc>
    </method>
    <method name="computeReplacement" return="String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="escaper" type="com.google.common.escape.UnicodeEscaper"/>
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Returns a string that would replace the given character in the specified escaper, or {@code
 null} if no replacement should be made. This method is intended for use in tests through the
 {@code EscaperAsserts} class; production users of {@link UnicodeEscaper} should limit
 themselves to its public interface.

 @param cp the Unicode code point to escape if necessary
 @return the replacement string, or {@code null} if no escaping was needed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link Escaper} instances.

 @author Sven Mawson
 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.Escapers -->
  <!-- start class com.google.common.escape.Escapers.Builder -->
  <class name="Escapers.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="setSafeRange" return="com.google.common.escape.Escapers.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="safeMin" type="char"/>
      <param name="safeMax" type="char"/>
      <doc>
      <![CDATA[Sets the safe range of characters for the escaper. Characters in this range that have no
 explicit replacement are considered 'safe' and remain unescaped in the output. If {@code
 safeMax < safeMin} then the safe range is empty.

 @param safeMin the lowest 'safe' character
 @param safeMax the highest 'safe' character
 @return the builder instance]]>
      </doc>
    </method>
    <method name="setUnsafeReplacement" return="com.google.common.escape.Escapers.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unsafeReplacement" type="String"/>
      <doc>
      <![CDATA[Sets the replacement string for any characters outside the 'safe' range that have no explicit
 replacement. If {@code unsafeReplacement} is {@code null} then no replacement will occur, if
 it is {@code ""} then the unsafe characters are removed from the output.

 @param unsafeReplacement the string to replace unsafe characters
 @return the builder instance]]>
      </doc>
    </method>
    <method name="addEscape" return="com.google.common.escape.Escapers.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="replacement" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a replacement string for the given input character. The specified character will be
 replaced by the given string whenever it occurs in the input, irrespective of whether it lies
 inside or outside the 'safe' range.

 @param c the character to be replaced
 @param replacement the string to replace the given character
 @return the builder instance
 @throws NullPointerException if {@code replacement} is null]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new escaper based on the current state of the builder.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for simple, fast escapers.

 <p>Typically an escaper needs to deal with the escaping of high valued characters or code
 points. In these cases it is necessary to extend either {@link ArrayBasedCharEscaper} or {@link
 ArrayBasedUnicodeEscaper} to provide the desired behavior. However this builder is suitable for
 creating escapers that replace a relative small set of characters.

 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.Escapers.Builder -->
  <!-- start class com.google.common.escape.UnicodeEscaper -->
  <class name="UnicodeEscaper" extends="com.google.common.escape.Escaper"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnicodeEscaper"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="escape" return="char"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of the given Unicode code point, or {@code null} if this code point
 does not need to be escaped. When called as part of an escaping operation, the given code point
 is guaranteed to be in the range {@code 0 <= cp <= Character#MAX_CODE_POINT}.

 <p>If an empty array is returned, this effectively strips the input character from the
 resulting text.

 <p>If the character does not need to be escaped, this method should return {@code null}, rather
 than an array containing the character representation of the code point. This enables the
 escaping algorithm to perform more efficiently.

 <p>If the implementation of this method cannot correctly handle a particular code point then it
 should either throw an appropriate runtime exception or return a suitable replacement
 character. It must never silently discard invalid input as this may constitute a security risk.

 @param cp the Unicode code point to escape if necessary
 @return the replacement characters, or {@code null} if no escaping was needed]]>
      </doc>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.

 <p>If you are escaping input in arbitrary successive chunks, then it is not generally safe to
 use this method. If an input string ends with an unmatched high surrogate character, then this
 method will throw {@link IllegalArgumentException}. You should ensure your input is valid <a
 href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> before calling this method.

 <p><b>Note:</b> When implementing an escaper it is a good idea to override this method for
 efficiency by inlining the implementation of {@link #nextEscapeIndex(CharSequence, int, int)}
 directly. Doing this for {@link com.google.common.net.PercentEscaper} more than doubled the
 performance for unescaped strings (as measured by {@code CharEscapersBenchmark}).

 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are encountered]]>
      </doc>
    </method>
    <method name="nextEscapeIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Scans a sub-sequence of characters from a given {@link CharSequence}, returning the index of
 the next character that requires escaping.

 <p><b>Note:</b> When implementing an escaper, it is a good idea to override this method for
 efficiency. The base class implementation determines successive Unicode code points and invokes
 {@link #escape(int)} for each of them. If the semantics of your escaper are such that code
 points in the supplementary range are either all escaped or all unescaped, this method can be
 implemented more efficiently using {@link CharSequence#charAt(int)}.

 <p>Note however that if your escaper does not escape characters in the supplementary range, you
 should either continue to validate the correctness of any surrogate characters encountered or
 provide a clear warning to users that your escaper does not validate its input.

 <p>See {@link com.google.common.net.PercentEscaper} for an example.

 @param csq a sequence of characters
 @param start the index of the first character to be scanned
 @param end the index immediately after the last character to be scanned
 @throws IllegalArgumentException if the scanned sub-sequence of {@code csq} contains invalid
     surrogate pairs]]>
      </doc>
    </method>
    <method name="escapeSlow" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string, starting at the given index. This method is
 called by the {@link #escape(String)} method when it discovers that escaping is required. It is
 protected to allow subclasses to override the fastpath escaping function to inline their
 escaping test. See {@link CharEscaperBuilder} for an example usage.

 <p>This method is not reentrant and may only be invoked by the top level {@link
 #escape(String)} method.

 @param s the literal string to be escaped
 @param index the index to start escaping from
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are encountered]]>
      </doc>
    </method>
    <method name="codePointAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Returns the Unicode code point of the character at the given index.

 <p>Unlike {@link Character#codePointAt(CharSequence, int)} or {@link String#codePointAt(int)}
 this method will never fail silently when encountering an invalid surrogate pair.

 <p>The behaviour of this method is as follows:

 <ol>
   <li>If {@code index >= end}, {@link IndexOutOfBoundsException} is thrown.
   <li><b>If the character at the specified index is not a surrogate, it is returned.</b>
   <li>If the first character was a high surrogate value, then an attempt is made to read the
       next character.
       <ol>
         <li><b>If the end of the sequence was reached, the negated value of the trailing high
             surrogate is returned.</b>
         <li><b>If the next character was a valid low surrogate, the code point value of the
             high/low surrogate pair is returned.</b>
         <li>If the next character was not a low surrogate value, then {@link
             IllegalArgumentException} is thrown.
       </ol>
   <li>If the first character was a low surrogate value, {@link IllegalArgumentException} is
       thrown.
 </ol>

 @param seq the sequence of characters from which to decode the code point
 @param index the index of the first character to decode
 @param end the index beyond the last valid character to decode
 @return the Unicode code point for the given index or the negated value of the trailing high
     surrogate character at the end of the sequence]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link Escaper} that converts literal text into a format safe for inclusion in a particular
 context (such as an XML document). Typically (but not always), the inverse process of
 "unescaping" the text is performed automatically by the relevant parser.

 <p>For example, an XML escaper would convert the literal string {@code "Foo<Bar>"} into {@code
 "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from being confused with an XML tag. When the
 resulting XML document is parsed, the parser API will return this text as the original literal
 string {@code "Foo<Bar>"}.

 <p><b>Note:</b> This class is similar to {@link CharEscaper} but with one very important
 difference. A CharEscaper can only process Java <a
 href="http://en.wikipedia.org/wiki/UTF-16">UTF16</a> characters in isolation and may not cope
 when it encounters surrogate pairs. This class facilitates the correct escaping of all Unicode
 characters.

 <p>As there are important reasons, including potential security issues, to handle Unicode
 correctly if you are considering implementing a new escaper you should favor using UnicodeEscaper
 wherever possible.

 <p>A {@code UnicodeEscaper} instance is required to be stateless, and safe when used concurrently
 by multiple threads.

 <p>Popular escapers are defined as constants in classes like {@link
 com.google.common.html.HtmlEscapers} and {@link com.google.common.xml.XmlEscapers}. To create
 your own escapers extend this class and implement the {@link #escape(int)} method.

 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.escape.UnicodeEscaper -->
</package>
<package name="com.google.common.eventbus">
  <!-- start class com.google.common.eventbus.AllowConcurrentEvents -->
  <class name="AllowConcurrentEvents"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks an event subscriber method as being thread-safe. This annotation indicates that EventBus
 may invoke the event subscriber simultaneously from multiple threads.

 <p>This does not mark the method, and so should be used in combination with {@link Subscribe}.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.AllowConcurrentEvents -->
  <!-- start class com.google.common.eventbus.AsyncEventBus -->
  <class name="AsyncEventBus" extends="com.google.common.eventbus.EventBus"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AsyncEventBus" type="java.lang.String, java.util.concurrent.Executor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new AsyncEventBus that will use {@code executor} to dispatch events. Assigns {@code
 identifier} as the bus's name for logging purposes.

 @param identifier short name for the bus, for logging purposes.
 @param executor Executor to use to dispatch events. It is the caller's responsibility to shut
     down the executor after the last event has been posted to this event bus.]]>
      </doc>
    </constructor>
    <constructor name="AsyncEventBus" type="java.util.concurrent.Executor, com.google.common.eventbus.SubscriberExceptionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new AsyncEventBus that will use {@code executor} to dispatch events.

 @param executor Executor to use to dispatch events. It is the caller's responsibility to shut
     down the executor after the last event has been posted to this event bus.
 @param subscriberExceptionHandler Handler used to handle exceptions thrown from subscribers.
     See {@link SubscriberExceptionHandler} for more information.
 @since 16.0]]>
      </doc>
    </constructor>
    <constructor name="AsyncEventBus" type="java.util.concurrent.Executor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new AsyncEventBus that will use {@code executor} to dispatch events.

 @param executor Executor to use to dispatch events. It is the caller's responsibility to shut
     down the executor after the last event has been posted to this event bus.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An {@link EventBus} that takes the Executor of your choice and uses it to dispatch events,
 allowing dispatch to occur asynchronously.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.AsyncEventBus -->
  <!-- start class com.google.common.eventbus.DeadEvent -->
  <class name="DeadEvent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DeadEvent" type="java.lang.Object, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new DeadEvent.

 @param source object broadcasting the DeadEvent (generally the {@link EventBus}).
 @param event the event that could not be delivered.]]>
      </doc>
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the object that originated this event (<em>not</em> the object that originated the
 wrapped event). This is generally an {@link EventBus}.

 @return the source of this event.]]>
      </doc>
    </method>
    <method name="getEvent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the wrapped, 'dead' event, which the system was unable to deliver to any registered
 subscriber.

 @return the 'dead' event that could not be delivered.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Wraps an event that was posted, but which had no subscribers and thus could not be delivered.

 <p>Registering a DeadEvent subscriber is useful for debugging or logging, as it can detect
 misconfigurations in a system's event distribution.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.DeadEvent -->
  <!-- start class com.google.common.eventbus.EventBus -->
  <class name="EventBus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EventBus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new EventBus named "default".]]>
      </doc>
    </constructor>
    <constructor name="EventBus" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new EventBus with the given {@code identifier}.

 @param identifier a brief name for this bus, for logging purposes. Should be a valid Java
     identifier.]]>
      </doc>
    </constructor>
    <constructor name="EventBus" type="com.google.common.eventbus.SubscriberExceptionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new EventBus with the given {@link SubscriberExceptionHandler}.

 @param exceptionHandler Handler for subscriber exceptions.
 @since 16.0]]>
      </doc>
    </constructor>
    <method name="identifier" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the identifier for this event bus.

 @since 19.0]]>
      </doc>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Registers all subscriber methods on {@code object} to receive events.

 @param object object whose subscriber methods should be registered.]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Unregisters all subscriber methods on a registered {@code object}.

 @param object object whose subscriber methods should be unregistered.
 @throws IllegalArgumentException if the object was not previously registered.]]>
      </doc>
    </method>
    <method name="post"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="java.lang.Object"/>
      <doc>
      <![CDATA[Posts an event to all registered subscribers. This method will return successfully after the
 event has been posted to all subscribers, and regardless of any exceptions thrown by
 subscribers.

 <p>If no subscribers have been subscribed for {@code event}'s class, and {@code event} is not
 already a {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.

 @param event event to post.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Dispatches events to listeners, and provides ways for listeners to register themselves.

 <h2>Avoid EventBus</h2>

 <p><b>We recommend against using EventBus.</b> It was designed many years ago, and newer
 libraries offer better ways to decouple components and react to events.

 <p>To decouple components, we recommend a dependency-injection framework. For Android code, most
 apps use <a href="https://dagger.dev">Dagger</a>. For server code, common options include <a
 href="https://github.com/google/guice/wiki/Motivation">Guice</a> and <a
 href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction">Spring</a>.
 Frameworks typically offer a way to register multiple listeners independently and then request
 them together as a set (<a href="https://dagger.dev/dev-guide/multibindings">Dagger</a>, <a
 href="https://github.com/google/guice/wiki/Multibindings">Guice</a>, <a
 href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation">Spring</a>).

 <p>To react to events, we recommend a reactive-streams framework like <a
 href="https://github.com/ReactiveX/RxJava/wiki">RxJava</a> (supplemented with its <a
 href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a> extension if you are building for
 Android) or <a href="https://projectreactor.io/">Project Reactor</a>. (For the basics of
 translating code from using an event bus to using a reactive-streams framework, see these two
 guides: <a href="https://blog.jkl.gg/implementing-an-event-bus-with-rxjava-rxbus/">1</a>, <a
 href="https://lorentzos.com/rxjava-as-event-bus-the-right-way-10a36bdd49ba">2</a>.) Some usages
 of EventBus may be better written using <a
 href="https://kotlinlang.org/docs/coroutines-guide.html">Kotlin coroutines</a>, including <a
 href="https://kotlinlang.org/docs/flow.html">Flow</a> and <a
 href="https://kotlinlang.org/docs/channels.html">Channels</a>. Yet other usages are better served
 by individual libraries that provide specialized support for particular use cases.

 <p>Disadvantages of EventBus include:

 <ul>
   <li>It makes the cross-references between producer and subscriber harder to find. This can
       complicate debugging, lead to unintentional reentrant calls, and force apps to eagerly
       initialize all possible subscribers at startup time.
   <li>It uses reflection in ways that break when code is processed by optimizers/minimizers like
       <a href="https://developer.android.com/studio/build/shrink-code">R8 and Proguard</a>.
   <li>It doesn't offer a way to wait for multiple events before taking action. For example, it
       doesn't offer a way to wait for multiple producers to all report that they're "ready," nor
       does it offer a way to batch multiple events from a single producer together.
   <li>It doesn't support backpressure and other features needed for resilience.
   <li>It doesn't provide much control of threading.
   <li>It doesn't offer much monitoring.
   <li>It doesn't propagate exceptions, so apps don't have a way to react to them.
   <li>It doesn't interoperate well with RxJava, coroutines, and other more commonly used
       alternatives.
   <li>It imposes requirements on the lifecycle of its subscribers. For example, if an event
       occurs between when one subscriber is removed and the next subscriber is added, the event
       is dropped.
   <li>Its performance is suboptimal, especially under Android.
   <li>It <a href="https://github.com/google/guava/issues/1431">doesn't support parameterized
       types</a>.
   <li>With the introduction of lambdas in Java 8, EventBus went from less verbose than listeners
       to <a href="https://github.com/google/guava/issues/3311">more verbose</a>.
 </ul>

 <h2>EventBus Summary</h2>

 <p>The EventBus allows publish-subscribe-style communication between components without requiring
 the components to explicitly register with one another (and thus be aware of each other). It is
 designed exclusively to replace traditional Java in-process event distribution using explicit
 registration. It is <em>not</em> a general-purpose publish-subscribe system, nor is it intended
 for interprocess communication.

 <h2>Receiving Events</h2>

 <p>To receive events, an object should:

 <ol>
   <li>Expose a public method, known as the <i>event subscriber</i>, which accepts a single
       argument of the type of event desired;
   <li>Mark it with a {@link Subscribe} annotation;
   <li>Pass itself to an EventBus instance's {@link #register(Object)} method.
 </ol>

 <h2>Posting Events</h2>

 <p>To post an event, simply provide the event object to the {@link #post(Object)} method. The
 EventBus instance will determine the type of event and route it to all registered listeners.

 <p>Events are routed based on their type &mdash; an event will be delivered to any subscriber for
 any type to which the event is <em>assignable.</em> This includes implemented interfaces, all
 superclasses, and all interfaces implemented by superclasses.

 <p>When {@code post} is called, all registered subscribers for an event are run in sequence, so
 subscribers should be reasonably quick. If an event may trigger an extended process (such as a
 database load), spawn a thread or queue it for later. (For a convenient way to do this, use an
 {@link AsyncEventBus}.)

 <h2>Subscriber Methods</h2>

 <p>Event subscriber methods must accept only one argument: the event.

 <p>Subscribers should not, in general, throw. If they do, the EventBus will catch and log the
 exception. This is rarely the right solution for error handling and should not be relied upon; it
 is intended solely to help find problems during development.

 <p>The EventBus guarantees that it will not call a subscriber method from multiple threads
 simultaneously, unless the method explicitly allows it by bearing the {@link
 AllowConcurrentEvents} annotation. If this annotation is not present, subscriber methods need not
 worry about being reentrant, unless also called from outside the EventBus.

 <h2>Dead Events</h2>

 <p>If an event is posted, but no registered subscribers can accept it, it is considered "dead."
 To give the system a second chance to handle dead events, they are wrapped in an instance of
 {@link DeadEvent} and reposted.

 <p>If a subscriber for a supertype of all events (such as Object) is registered, no event will
 ever be considered dead, and no DeadEvents will be generated. Accordingly, while DeadEvent
 extends {@link Object}, a subscriber registered to receive any Object will never receive a
 DeadEvent.

 <p>This class is safe for concurrent use.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/EventBusExplained">{@code EventBus}</a>.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.EventBus -->
  <!-- start class com.google.common.eventbus.Subscribe -->
  <class name="Subscribe"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a method as an event subscriber.

 <p>The type of event will be indicated by the method's first (and only) parameter, which cannot
 be primitive. If this annotation is applied to methods with zero parameters, or more than one
 parameter, the object containing the method will not be able to register for event delivery from
 the {@link EventBus}.

 <p>Unless also annotated with @{@link AllowConcurrentEvents}, event subscriber methods will be
 invoked serially by each event bus that they are registered with.

 @author Cliff Biffle
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.Subscribe -->
  <!-- start class com.google.common.eventbus.SubscriberExceptionContext -->
  <class name="SubscriberExceptionContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEventBus" return="com.google.common.eventbus.EventBus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link EventBus} that handled the event and the subscriber. Useful for broadcasting
 a new event based on the error.]]>
      </doc>
    </method>
    <method name="getEvent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the event object that caused the subscriber to throw.]]>
      </doc>
    </method>
    <method name="getSubscriber" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the object context that the subscriber was called on.]]>
      </doc>
    </method>
    <method name="getSubscriberMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the subscribed method that threw the exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Context for an exception thrown by a subscriber.

 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.eventbus.SubscriberExceptionContext -->
  <!-- start interface com.google.common.eventbus.SubscriberExceptionHandler -->
  <interface name="SubscriberExceptionHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handleException"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Throwable"/>
      <param name="context" type="com.google.common.eventbus.SubscriberExceptionContext"/>
      <doc>
      <![CDATA[Handles exceptions thrown by subscribers.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Handler for exceptions thrown by event subscribers.

 @since 16.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.eventbus.SubscriberExceptionHandler -->
</package>
<package name="com.google.common.graph">
  <!-- start class com.google.common.graph.AbstractGraph -->
  <class name="AbstractGraph" extends="com.google.common.graph.AbstractBaseGraph&lt;N&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.Graph&lt;N&gt;"/>
    <constructor name="AbstractGraph"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of {@link Graph}. It is recommended to extend this
 class rather than implement {@link Graph} directly.

 @author James Sexton
 @param <N> Node parameter type
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.AbstractGraph -->
  <!-- start class com.google.common.graph.AbstractNetwork -->
  <class name="AbstractNetwork" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.Network&lt;N, E&gt;"/>
    <constructor name="AbstractNetwork"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="asGraph" return="com.google.common.graph.Graph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="degree" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
    </method>
    <method name="inDegree" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
    </method>
    <method name="outDegree" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
    </method>
    <method name="adjacentEdges" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="E"/>
    </method>
    <method name="edgesConnecting" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
    </method>
    <method name="edgesConnecting" return="java.util.Set&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
    </method>
    <method name="edgeConnectingOrNull" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
    </method>
    <method name="edgeConnectingOrNull" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
    </method>
    <method name="validateEndpoints"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;?&gt;"/>
      <doc>
      <![CDATA[Throws an IllegalArgumentException if the ordering of {@code endpoints} is not compatible with
 the directionality of this graph.]]>
      </doc>
    </method>
    <method name="isOrderingCompatible" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;?&gt;"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this network.]]>
      </doc>
    </method>
    <method name="edgeInvalidatableSet" return="java.util.Set&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;T&gt;"/>
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Returns a {@link Set} whose methods throw {@link IllegalStateException} when the given edge is
 not present in this network.

 @since 33.1.0]]>
      </doc>
    </method>
    <method name="nodeInvalidatableSet" return="java.util.Set&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;T&gt;"/>
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a {@link Set} whose methods throw {@link IllegalStateException} when the given node is
 not present in this network.

 @since 33.1.0]]>
      </doc>
    </method>
    <method name="nodePairInvalidatableSet" return="java.util.Set&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="set" type="java.util.Set&lt;T&gt;"/>
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Returns a {@link Set} whose methods throw {@link IllegalStateException} when either of the
 given nodes is not present in this network.

 @since 33.1.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of {@link Network}. It is recommended to extend
 this class rather than implement {@link Network} directly.

 <p>The methods implemented in this class should not be overridden unless the subclass admits a
 more efficient implementation.

 @author James Sexton
 @param <N> Node parameter type
 @param <E> Edge parameter type
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.AbstractNetwork -->
  <!-- start class com.google.common.graph.AbstractValueGraph -->
  <class name="AbstractValueGraph" extends="com.google.common.graph.AbstractBaseGraph&lt;N&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.ValueGraph&lt;N, V&gt;"/>
    <constructor name="AbstractValueGraph"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="asGraph" return="com.google.common.graph.Graph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this graph.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides a skeletal implementation of {@link ValueGraph}. It is recommended to extend
 this class rather than implement {@link ValueGraph} directly.

 <p>The methods implemented in this class should not be overridden unless the subclass admits a
 more efficient implementation.

 @author James Sexton
 @param <N> Node parameter type
 @param <V> Value parameter type
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.AbstractValueGraph -->
  <!-- start class com.google.common.graph.ElementOrder -->
  <class name="ElementOrder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="unordered" return="com.google.common.graph.ElementOrder&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance which specifies that no ordering is guaranteed.]]>
      </doc>
    </method>
    <method name="stable" return="com.google.common.graph.ElementOrder&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance which specifies that ordering is guaranteed to be always be the same across
 iterations, and across releases. Some methods may have stronger guarantees.

 <p>This instance is only useful in combination with {@code incidentEdgeOrder}, e.g. {@code
 graphBuilder.incidentEdgeOrder(ElementOrder.stable())}.

 <h3>In combination with {@code incidentEdgeOrder}</h3>

 <p>{@code incidentEdgeOrder(ElementOrder.stable())} guarantees the ordering of the returned
 collections of the following methods:

 <ul>
   <li>For {@link Graph} and {@link ValueGraph}:
       <ul>
         <li>{@code edges()}: Stable order
         <li>{@code adjacentNodes(node)}: Connecting edge insertion order
         <li>{@code predecessors(node)}: Connecting edge insertion order
         <li>{@code successors(node)}: Connecting edge insertion order
         <li>{@code incidentEdges(node)}: Edge insertion order
       </ul>
   <li>For {@link Network}:
       <ul>
         <li>{@code adjacentNodes(node)}: Stable order
         <li>{@code predecessors(node)}: Connecting edge insertion order
         <li>{@code successors(node)}: Connecting edge insertion order
         <li>{@code incidentEdges(node)}: Stable order
         <li>{@code inEdges(node)}: Edge insertion order
         <li>{@code outEdges(node)}: Edge insertion order
         <li>{@code adjacentEdges(edge)}: Stable order
         <li>{@code edgesConnecting(nodeU, nodeV)}: Edge insertion order
       </ul>
 </ul>

 @since 29.0]]>
      </doc>
    </method>
    <method name="insertion" return="com.google.common.graph.ElementOrder&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance which specifies that insertion ordering is guaranteed.]]>
      </doc>
    </method>
    <method name="natural" return="com.google.common.graph.ElementOrder&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an instance which specifies that the natural ordering of the elements is guaranteed.]]>
      </doc>
    </method>
    <method name="sorted" return="com.google.common.graph.ElementOrder&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="comparator" type="java.util.Comparator&lt;S&gt;"/>
      <doc>
      <![CDATA[Returns an instance which specifies that the ordering of the elements is guaranteed to be
 determined by {@code comparator}.]]>
      </doc>
    </method>
    <method name="type" return="com.google.common.graph.ElementOrder.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of ordering used.]]>
      </doc>
    </method>
    <method name="comparator" return="java.util.Comparator&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Comparator} used.

 @throws UnsupportedOperationException if comparator is not defined]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Used to represent the order of elements in a data structure that supports different options for
 iteration order guarantees.

 <p>Example usage:

 {@snippet :
 MutableGraph<Integer> graph =
     GraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();
 }

 @author Joshua O'Madadhain
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ElementOrder -->
  <!-- start class com.google.common.graph.ElementOrder.Type -->
  <class name="ElementOrder.Type" extends="java.lang.Enum&lt;com.google.common.graph.ElementOrder.Type&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.graph.ElementOrder.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.graph.ElementOrder.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The type of ordering that this object specifies.

 <ul>
   <li>UNORDERED: no order is guaranteed.
   <li>STABLE: ordering is guaranteed to follow a pattern that won't change between releases.
       Some methods may have stronger guarantees.
   <li>INSERTION: insertion ordering is guaranteed.
   <li>SORTED: ordering according to a supplied comparator is guaranteed.
 </ul>]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ElementOrder.Type -->
  <!-- start class com.google.common.graph.EndpointPair -->
  <class name="EndpointPair" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;N&gt;"/>
    <method name="ordered" return="com.google.common.graph.EndpointPair&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="N"/>
      <param name="target" type="N"/>
      <doc>
      <![CDATA[Returns an {@link EndpointPair} representing the endpoints of a directed edge.]]>
      </doc>
    </method>
    <method name="unordered" return="com.google.common.graph.EndpointPair&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Returns an {@link EndpointPair} representing the endpoints of an undirected edge.]]>
      </doc>
    </method>
    <method name="source" return="N"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this {@link EndpointPair} {@link #isOrdered()}, returns the node which is the source.

 @throws UnsupportedOperationException if this {@link EndpointPair} is not ordered]]>
      </doc>
    </method>
    <method name="target" return="N"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this {@link EndpointPair} {@link #isOrdered()}, returns the node which is the target.

 @throws UnsupportedOperationException if this {@link EndpointPair} is not ordered]]>
      </doc>
    </method>
    <method name="nodeU" return="N"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this {@link EndpointPair} {@link #isOrdered()} returns the {@link #source()}; otherwise,
 returns an arbitrary (but consistent) endpoint of the origin edge.]]>
      </doc>
    </method>
    <method name="nodeV" return="N"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the node {@link #adjacentNode(Object) adjacent} to {@link #nodeU()} along the origin
 edge. If this {@link EndpointPair} {@link #isOrdered()}, this is equal to {@link #target()}.]]>
      </doc>
    </method>
    <method name="adjacentNode" return="N"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the node that is adjacent to {@code node} along the origin edge.

 @throws IllegalArgumentException if this {@link EndpointPair} does not contain {@code node}
 @since 20.0 (but the argument type was changed from {@code Object} to {@code N} in 31.0)]]>
      </doc>
    </method>
    <method name="isOrdered" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this {@link EndpointPair} is an ordered pair (i.e. represents the
 endpoints of a directed edge).]]>
      </doc>
    </method>
    <method name="iterator" return="com.google.common.collect.UnmodifiableIterator&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Iterates in the order {@link #nodeU()}, {@link #nodeV()}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[Two ordered {@link EndpointPair}s are equal if their {@link #source()} and {@link #target()}
 are equal. Two unordered {@link EndpointPair}s are equal if they contain the same nodes. An
 ordered {@link EndpointPair} is never equal to an unordered {@link EndpointPair}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hashcode of an ordered {@link EndpointPair} is equal to {@code Objects.hash(source(),
 target())}. The hashcode of an unordered {@link EndpointPair} is equal to {@code
 nodeU().hashCode() + nodeV().hashCode()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable pair representing the two endpoints of an edge in a graph. The {@link EndpointPair}
 of a directed edge is an ordered pair of nodes ({@link #source()} and {@link #target()}). The
 {@link EndpointPair} of an undirected edge is an unordered pair of nodes ({@link #nodeU()} and
 {@link #nodeV()}).

 <p>The edge is a self-loop if, and only if, the two endpoints are equal.

 @author James Sexton
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.EndpointPair -->
  <!-- start interface com.google.common.graph.Graph -->
  <interface name="Graph"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.BaseGraph&lt;N&gt;"/>
    <method name="nodes" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}.]]>
      </doc>
    </method>
    <method name="edges" return="java.util.Set&lt;com.google.common.graph.EndpointPair&lt;N&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all edges in this graph.]]>
      </doc>
    </method>
    <method name="isDirected" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the edges in this graph are directed. Directed edges connect a {@link
 EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while
 undirected edges connect a pair of nodes to each other.]]>
      </doc>
    </method>
    <method name="allowsSelfLoops" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting
 to add a self-loop to a graph that does not allow them will throw an {@link
 IllegalArgumentException}.]]>
      </doc>
    </method>
    <method name="nodeOrder" return="com.google.common.graph.ElementOrder&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the order of iteration for the elements of {@link #nodes()}.]]>
      </doc>
    </method>
    <method name="incidentEdgeOrder" return="com.google.common.graph.ElementOrder&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link ElementOrder} that specifies the order of iteration for the elements of
 {@link #edges()}, {@link #adjacentNodes(Object)}, {@link #predecessors(Object)}, {@link
 #successors(Object)} and {@link #incidentEdges(Object)}.

 @since 29.0]]>
      </doc>
    </method>
    <method name="adjacentNodes" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of the nodes which have an incident edge in common with {@code node} in
 this graph.

 <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="predecessors" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by
 traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.

 <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="successors" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by
 traversing {@code node}'s outgoing edges in the direction (if any) of the edge.

 <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.

 <p>This is <i>not</i> the same as "all nodes reachable from {@code node} by following outgoing
 edges". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="incidentEdges" return="java.util.Set&lt;com.google.common.graph.EndpointPair&lt;N&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of the edges in this graph whose endpoints include {@code node}.

 <p>This is equal to the union of incoming and outgoing edges.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph
 @since 24.0]]>
      </doc>
    </method>
    <method name="degree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,
 the number of times an edge touches {@code node}).

 <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.

 <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of
 self-loops incident to {@code node}).

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="inDegree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})
 in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="outDegree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})
 in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is
 equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.

 <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.

 @since 23.0]]>
      </doc>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns true if there is an edge that directly connects {@code endpoints} (in the order, if
 any, specified by {@code endpoints}). This is equivalent to {@code
 edges().contains(endpoints)}.

 <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the
 endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for
 consistency with the behavior of {@link Collection#contains(Object)} (which does not generally
 throw if the object cannot be present in the collection), and the desire to have this method's
 behavior be compatible with {@code edges().contains(endpoints)}.

 @since 27.1]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} iff {@code object} is a {@link Graph} that has the same elements and the
 same structural relationships as those in this graph.

 <p>Thus, two graphs A and B are equal if <b>all</b> of the following are true:

 <ul>
   <li>A and B have equal {@link #isDirected() directedness}.
   <li>A and B have equal {@link #nodes() node sets}.
   <li>A and B have equal {@link #edges() edge sets}.
 </ul>

 <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.
 For example, two graphs may be considered equal even if one allows self-loops and the other
 doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order
 in which they are iterated over, are irrelevant.

 <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this graph. The hash code of a graph is defined as the hash code of
 the set returned by {@link #edges()}.

 <p>A reference implementation of this is provided by {@link AbstractGraph#hashCode()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface for <a
 href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>-structured data,
 whose edges are anonymous entities with no identity or information of their own.

 <p>A graph is composed of a set of nodes and a set of edges connecting pairs of nodes.

 <p>There are three primary interfaces provided to represent graphs. In order of increasing
 complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally
 prefer the simplest interface that satisfies your use case. See the <a
 href="https://github.com/google/guava/wiki/GraphsExplained#choosing-the-right-graph-type">
 "Choosing the right graph type"</a> section of the Guava User Guide for more details.

 <h3>Capabilities</h3>

 <p>{@code Graph} supports the following use cases (<a
 href="https://github.com/google/guava/wiki/GraphsExplained#definitions">definitions of
 terms</a>):

 <ul>
   <li>directed graphs
   <li>undirected graphs
   <li>graphs that do/don't allow self-loops
   <li>graphs whose nodes/edges are insertion-ordered, sorted, or unordered
 </ul>

 <p>{@code Graph} explicitly does not support parallel edges, and forbids implementations or
 extensions with parallel edges. If you need parallel edges, use {@link Network}.

 <h3>Building a {@code Graph}</h3>

 <p>The implementation classes that {@code common.graph} provides are not public, by design. To
 create an instance of one of the built-in implementations of {@code Graph}, use the {@link
 GraphBuilder} class:

 {@snippet :
 MutableGraph<Integer> graph = GraphBuilder.undirected().build();
 }

 <p>{@link GraphBuilder#build()} returns an instance of {@link MutableGraph}, which is a subtype
 of {@code Graph} that provides methods for adding and removing nodes and edges. If you do not
 need to mutate a graph (e.g. if you write a method than runs a read-only algorithm on the graph),
 you should use the non-mutating {@link Graph} interface, or an {@link ImmutableGraph}.

 <p>You can create an immutable copy of an existing {@code Graph} using {@link
 ImmutableGraph#copyOf(Graph)}:

 {@snippet :
 ImmutableGraph<Integer> immutableGraph = ImmutableGraph.copyOf(graph);
 }

 <p>Instances of {@link ImmutableGraph} do not implement {@link MutableGraph} (obviously!) and are
 contractually guaranteed to be unmodifiable and thread-safe.

 <p>The Guava User Guide has <a
 href="https://github.com/google/guava/wiki/GraphsExplained#building-graph-instances">more
 information on (and examples of) building graphs</a>.

 <h3>Additional documentation</h3>

 <p>See the Guava User Guide for the {@code common.graph} package (<a
 href="https://github.com/google/guava/wiki/GraphsExplained">"Graphs Explained"</a>) for
 additional documentation, including:

 <ul>
   <li><a
       href="https://github.com/google/guava/wiki/GraphsExplained#equals-hashcode-and-graph-equivalence">
       {@code equals()}, {@code hashCode()}, and graph equivalence</a>
   <li><a href="https://github.com/google/guava/wiki/GraphsExplained#synchronization">
       Synchronization policy</a>
   <li><a href="https://github.com/google/guava/wiki/GraphsExplained#notes-for-implementors">Notes
       for implementors</a>
 </ul>

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> Node parameter type
 @since 20.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.Graph -->
  <!-- start class com.google.common.graph.GraphBuilder -->
  <class name="GraphBuilder" extends="com.google.common.graph.AbstractGraphBuilder&lt;N&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="directed" return="com.google.common.graph.GraphBuilder&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link GraphBuilder} for building directed graphs.]]>
      </doc>
    </method>
    <method name="undirected" return="com.google.common.graph.GraphBuilder&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link GraphBuilder} for building undirected graphs.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.graph.GraphBuilder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns a {@link GraphBuilder} initialized with all properties queryable from {@code graph}.

 <p>The "queryable" properties are those that are exposed through the {@link Graph} interface,
 such as {@link Graph#isDirected()}. Other properties, such as {@link #expectedNodeCount(int)},
 are not set in the new builder.]]>
      </doc>
    </method>
    <method name="immutable" return="com.google.common.graph.ImmutableGraph.Builder&lt;N1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link ImmutableGraph.Builder} with the properties of this {@link GraphBuilder}.

 <p>The returned builder can be used for populating an {@link ImmutableGraph}.

 <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link
 ElementOrder#stable()}, regardless of the value that was set in this builder.

 @since 28.0]]>
      </doc>
    </method>
    <method name="allowsSelfLoops" return="com.google.common.graph.GraphBuilder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allowsSelfLoops" type="boolean"/>
      <doc>
      <![CDATA[Specifies whether the graph will allow self-loops (edges that connect a node to itself).
 Attempting to add a self-loop to a graph that does not allow them will throw an {@link
 UnsupportedOperationException}.

 <p>The default value is {@code false}.]]>
      </doc>
    </method>
    <method name="expectedNodeCount" return="com.google.common.graph.GraphBuilder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedNodeCount" type="int"/>
      <doc>
      <![CDATA[Specifies the expected number of nodes in the graph.

 @throws IllegalArgumentException if {@code expectedNodeCount} is negative]]>
      </doc>
    </method>
    <method name="nodeOrder" return="com.google.common.graph.GraphBuilder&lt;N1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeOrder" type="com.google.common.graph.ElementOrder&lt;N1&gt;"/>
      <doc>
      <![CDATA[Specifies the order of iteration for the elements of {@link Graph#nodes()}.

 <p>The default value is {@link ElementOrder#insertion() insertion order}.]]>
      </doc>
    </method>
    <method name="incidentEdgeOrder" return="com.google.common.graph.GraphBuilder&lt;N1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="incidentEdgeOrder" type="com.google.common.graph.ElementOrder&lt;N1&gt;"/>
      <doc>
      <![CDATA[Specifies the order of iteration for the elements of {@link Graph#edges()}, {@link
 Graph#adjacentNodes(Object)}, {@link Graph#predecessors(Object)}, {@link
 Graph#successors(Object)} and {@link Graph#incidentEdges(Object)}.

 <p>The default value is {@link ElementOrder#unordered() unordered} for mutable graphs. For
 immutable graphs, this value is ignored; they always have a {@link ElementOrder#stable()
 stable} order.

 @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code
     ElementOrder.unordered()} or {@code ElementOrder.stable()}.
 @since 29.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.graph.MutableGraph&lt;N1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty {@link MutableGraph} with the properties of this {@link GraphBuilder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for constructing instances of {@link MutableGraph} or {@link ImmutableGraph} with
 user-defined properties.

 <p>A {@code Graph} built by this class has the following default properties:

 <ul>
   <li>does not allow self-loops
   <li>orders {@link Graph#nodes()} in the order in which the elements were added (insertion
       order)
 </ul>

 <p>{@code Graph}s built by this class also guarantee that each collection-returning accessor
 returns a <b>(live) unmodifiable view</b>; see <a
 href="https://github.com/google/guava/wiki/GraphsExplained#accessor-behavior">the external
 documentation</a> for details.

 <p>Examples of use:

 {@snippet :
 // Building a mutable graph
 MutableGraph<String> graph = GraphBuilder.undirected().allowsSelfLoops(true).build();
 graph.putEdge("bread", "bread");
 graph.putEdge("chocolate", "peanut butter");
 graph.putEdge("peanut butter", "jelly");

 // Building an immutable graph
 ImmutableGraph<String> immutableGraph =
     GraphBuilder.undirected()
         .allowsSelfLoops(true)
         .<String>immutable()
         .putEdge("bread", "bread")
         .putEdge("chocolate", "peanut butter")
         .putEdge("peanut butter", "jelly")
         .build();
 }

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> The most general node type this builder will support. This is normally {@code Object}
     unless it is constrained by using a method like {@link #nodeOrder}, or the builder is
     constructed based on an existing {@code Graph} using {@link #from(Graph)}.
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.GraphBuilder -->
  <!-- start class com.google.common.graph.Graphs -->
  <class name="Graphs" extends="com.google.common.graph.GraphsBridgeMethods"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hasCycle" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns true if {@code graph} has at least one cycle. A cycle is defined as a non-empty subset
 of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) starting
 and ending with the same node.

 <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1).]]>
      </doc>
    </method>
    <method name="hasCycle" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="network" type="com.google.common.graph.Network&lt;?, ?&gt;"/>
      <doc>
      <![CDATA[Returns true if {@code network} has at least one cycle. A cycle is defined as a non-empty
 subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)
 starting and ending with the same node.

 <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1).]]>
      </doc>
    </method>
    <method name="transitiveClosure" return="com.google.common.graph.ImmutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns the transitive closure of {@code graph}. The transitive closure of a graph is another
 graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,
 Object) reachable} from node A.

 <p>This is a "snapshot" based on the current topology of {@code graph}, rather than a live view
 of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not
 be updated after modifications to {@code graph}.

 @since 33.1.0 (present with return type {@code Graph} since 20.0)]]>
      </doc>
    </method>
    <method name="reachableNodes" return="com.google.common.collect.ImmutableSet&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the set of nodes that are reachable from {@code node}. Specifically, it returns all
 nodes {@code v} such that there exists a path (a sequence of adjacent outgoing edges) starting
 at {@code node} and ending at {@code v}. This implementation includes {@code node} as the first
 element in the result.

 <p>If needed, the {@link Traverser} class provides more flexible and lighter-weight ways to
 list the nodes reachable from a given node or nodes. See the <a
 href="https://github.com/google/guava/wiki/GraphsExplained#Graph-traversal">"Graph traversal"
 section of the Guava User's Guide</a> for more information.

 <p>The {@link Set} returned is a "snapshot" based on the current topology of {@code graph},
 rather than a live view. In other words, modifications to {@code graph} made after this method
 returns will not be reflected in the set.

 @throws IllegalArgumentException if {@code node} is not present in {@code graph}
 @since 33.1.0 (present with return type {@code Set} since 20.0)]]>
      </doc>
    </method>
    <method name="transpose" return="com.google.common.graph.Graph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other
 properties remain intact, and further updates to {@code graph} will be reflected in the view.]]>
      </doc>
    </method>
    <method name="transpose" return="com.google.common.graph.ValueGraph&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.ValueGraph&lt;N, V&gt;"/>
      <doc>
      <![CDATA[Returns a view of {@code graph} with the direction (if any) of every edge reversed. All other
 properties remain intact, and further updates to {@code graph} will be reflected in the view.]]>
      </doc>
    </method>
    <method name="transpose" return="com.google.common.graph.Network&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="network" type="com.google.common.graph.Network&lt;N, E&gt;"/>
      <doc>
      <![CDATA[Returns a view of {@code network} with the direction (if any) of every edge reversed. All other
 properties remain intact, and further updates to {@code network} will be reflected in the view.]]>
      </doc>
    </method>
    <method name="inducedSubgraph" return="com.google.common.graph.MutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <param name="nodes" type="java.lang.Iterable&lt;? extends N&gt;"/>
      <doc>
      <![CDATA[Returns the subgraph of {@code graph} induced by {@code nodes}. This subgraph is a new graph
 that contains all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges}
 from {@code graph} for which both nodes are contained by {@code nodes}.

 @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph]]>
      </doc>
    </method>
    <method name="inducedSubgraph" return="com.google.common.graph.MutableValueGraph&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.ValueGraph&lt;N, V&gt;"/>
      <param name="nodes" type="java.lang.Iterable&lt;? extends N&gt;"/>
      <doc>
      <![CDATA[Returns the subgraph of {@code graph} induced by {@code nodes}. This subgraph is a new graph
 that contains all of the nodes in {@code nodes}, and all of the {@link Graph#edges() edges}
 (and associated edge values) from {@code graph} for which both nodes are contained by {@code
 nodes}.

 @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph]]>
      </doc>
    </method>
    <method name="inducedSubgraph" return="com.google.common.graph.MutableNetwork&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="network" type="com.google.common.graph.Network&lt;N, E&gt;"/>
      <param name="nodes" type="java.lang.Iterable&lt;? extends N&gt;"/>
      <doc>
      <![CDATA[Returns the subgraph of {@code network} induced by {@code nodes}. This subgraph is a new graph
 that contains all of the nodes in {@code nodes}, and all of the {@link Network#edges() edges}
 from {@code network} for which the {@link Network#incidentNodes(Object) incident nodes} are
 both contained by {@code nodes}.

 @throws IllegalArgumentException if any element in {@code nodes} is not a node in the graph]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.graph.MutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <doc>
      <![CDATA[Creates a mutable copy of {@code graph} with the same nodes and edges.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.graph.MutableValueGraph&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.ValueGraph&lt;N, V&gt;"/>
      <doc>
      <![CDATA[Creates a mutable copy of {@code graph} with the same nodes, edges, and edge values.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.graph.MutableNetwork&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="network" type="com.google.common.graph.Network&lt;N, E&gt;"/>
      <doc>
      <![CDATA[Creates a mutable copy of {@code network} with the same nodes and edges.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods for {@link Graph}, {@link ValueGraph}, and {@link Network} instances.

 @author James Sexton
 @author Joshua O'Madadhain
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.Graphs -->
  <!-- start class com.google.common.graph.ImmutableGraph -->
  <class name="ImmutableGraph" extends="com.google.common.graph.ForwardingGraph&lt;N&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="copyOf" return="com.google.common.graph.ImmutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.Graph&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns an immutable copy of {@code graph}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.graph.ImmutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="graph" type="com.google.common.graph.ImmutableGraph&lt;N&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this]]>
      </doc>
    </method>
    <method name="incidentEdgeOrder" return="com.google.common.graph.ElementOrder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link Graph} whose elements and structural relationships will never change. Instances of this
 class may be obtained with {@link #copyOf(Graph)}.

 <p>See the Guava User's Guide's <a
 href="https://github.com/google/guava/wiki/GraphsExplained#immutable-implementations">discussion
 of the {@code Immutable*} types</a> for more information on the properties and guarantees
 provided by this class.

 @author James Sexton
 @author Joshua O'Madadhain
 @author Omar Darwish
 @author Jens Nyman
 @param <N> Node parameter type
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ImmutableGraph -->
  <!-- start class com.google.common.graph.ImmutableGraph.Builder -->
  <class name="ImmutableGraph.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addNode" return="com.google.common.graph.ImmutableGraph.Builder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Adds {@code node} if it is not already present.

 <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.

 @return this {@code Builder} object]]>
      </doc>
    </method>
    <method name="putEdge" return="com.google.common.graph.ImmutableGraph.Builder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present.

 <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be
 undirected.

 <p>If {@code nodeU} and {@code nodeV} are not already present in this graph, this method will
 silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the graph.

 @return this {@code Builder} object
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}]]>
      </doc>
    </method>
    <method name="putEdge" return="com.google.common.graph.ImmutableGraph.Builder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code endpoints} (in the order, if any, specified by {@code
 endpoints}) if one is not already present.

 <p>If this graph is directed, {@code endpoints} must be ordered and the added edge will be
 directed; if it is undirected, the added edge will be undirected.

 <p>If this graph is directed, {@code endpoints} must be ordered.

 <p>If either or both endpoints are not already present in this graph, this method will
 silently {@link #addNode(Object) add} each missing endpoint to the graph.

 @return this {@code Builder} object
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}
 @throws IllegalArgumentException if the endpoints are unordered and the graph is directed]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.graph.ImmutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableGraph} based on the contents of this {@code Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating {@link ImmutableGraph} instances, especially {@code static final}
 graphs. Example:

 {@snippet :
 static final ImmutableGraph<Country> COUNTRY_ADJACENCY_GRAPH =
     GraphBuilder.undirected()
         .<Country>immutable()
         .putEdge(FRANCE, GERMANY)
         .putEdge(FRANCE, BELGIUM)
         .putEdge(GERMANY, BELGIUM)
         .addNode(ICELAND)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple graphs in series. Each new graph contains all the elements of the ones created before
 it.

 @since 28.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ImmutableGraph.Builder -->
  <!-- start class com.google.common.graph.ImmutableNetwork -->
  <class name="ImmutableNetwork" extends="com.google.common.graph.StandardNetwork&lt;N, E&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="copyOf" return="com.google.common.graph.ImmutableNetwork&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="network" type="com.google.common.graph.Network&lt;N, E&gt;"/>
      <doc>
      <![CDATA[Returns an immutable copy of {@code network}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.graph.ImmutableNetwork&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="network" type="com.google.common.graph.ImmutableNetwork&lt;N, E&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this]]>
      </doc>
    </method>
    <method name="asGraph" return="com.google.common.graph.ImmutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link Network} whose elements and structural relationships will never change. Instances of
 this class may be obtained with {@link #copyOf(Network)}.

 <p>See the Guava User's Guide's <a
 href="https://github.com/google/guava/wiki/GraphsExplained#immutable-implementations">discussion
 of the {@code Immutable*} types</a> for more information on the properties and guarantees
 provided by this class.

 @author James Sexton
 @author Joshua O'Madadhain
 @author Omar Darwish
 @author Jens Nyman
 @param <N> Node parameter type
 @param <E> Edge parameter type
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ImmutableNetwork -->
  <!-- start class com.google.common.graph.ImmutableNetwork.Builder -->
  <class name="ImmutableNetwork.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addNode" return="com.google.common.graph.ImmutableNetwork.Builder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Adds {@code node} if it is not already present.

 <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.

 @return this {@code Builder} object]]>
      </doc>
    </method>
    <method name="addEdge" return="com.google.common.graph.ImmutableNetwork.Builder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Adds {@code edge} connecting {@code nodeU} to {@code nodeV}.

 <p>If the network is directed, {@code edge} will be directed in this network; otherwise, it
 will be undirected.

 <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It
 must also be non-null.

 <p>If {@code nodeU} and {@code nodeV} are not already present in this network, this method
 will silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the network.

 <p>If {@code edge} already connects {@code nodeU} to {@code nodeV} (in the specified order if
 this network {@link #isDirected()}, else in any order), then this method will have no effect.

 @return this {@code Builder} object
 @throws IllegalArgumentException if {@code edge} already exists in the network and does not
     connect {@code nodeU} to {@code nodeV}
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsParallelEdges()} or {@link #allowsSelfLoops()}]]>
      </doc>
    </method>
    <method name="addEdge" return="com.google.common.graph.ImmutableNetwork.Builder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will
 also connect {@code nodeV} to {@code nodeU}.

 <p>If this network is directed, {@code edge} will be directed in this network; if it is
 undirected, {@code edge} will be undirected in this network.

 <p>If this network is directed, {@code endpoints} must be ordered.

 <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It
 must also be non-null.

 <p>If either or both endpoints are not already present in this network, this method will
 silently {@link #addNode(Object) add} each missing endpoint to the network.

 <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this
 method will have no effect.

 @return this {@code Builder} object
 @throws IllegalArgumentException if {@code edge} already exists in the network and connects
     some other endpoint pair that is not equal to {@code endpoints}
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
 @throws IllegalArgumentException if the endpoints are unordered and the network is directed]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.graph.ImmutableNetwork&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableNetwork} based on the contents of this {@code
 Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating {@link ImmutableNetwork} instances, especially {@code static final}
 networks. Example:

 {@snippet :
 static final ImmutableNetwork<City, Train> TRAIN_NETWORK =
     NetworkBuilder.undirected()
         .allowsParallelEdges(true)
         .<City, Train>immutable()
         .addEdge(PARIS, BRUSSELS, Thalys.trainNumber("1111"))
         .addEdge(PARIS, BRUSSELS, RegionalTrain.trainNumber("2222"))
         .addEdge(LONDON, PARIS, Eurostar.trainNumber("3333"))
         .addEdge(LONDON, BRUSSELS, Eurostar.trainNumber("4444"))
         .addNode(REYKJAVIK)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple networks in series. Each new network contains all the elements of the ones created
 before it.

 @since 28.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ImmutableNetwork.Builder -->
  <!-- start class com.google.common.graph.ImmutableValueGraph -->
  <class name="ImmutableValueGraph" extends="com.google.common.graph.StandardValueGraph&lt;N, V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="copyOf" return="com.google.common.graph.ImmutableValueGraph&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.ValueGraph&lt;N, V&gt;"/>
      <doc>
      <![CDATA[Returns an immutable copy of {@code graph}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.graph.ImmutableValueGraph&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="graph" type="com.google.common.graph.ImmutableValueGraph&lt;N, V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this]]>
      </doc>
    </method>
    <method name="incidentEdgeOrder" return="com.google.common.graph.ElementOrder&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asGraph" return="com.google.common.graph.ImmutableGraph&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link ValueGraph} whose elements and structural relationships will never change. Instances of
 this class may be obtained with {@link #copyOf(ValueGraph)}.

 <p>See the Guava User's Guide's <a
 href="https://github.com/google/guava/wiki/GraphsExplained#immutable-implementations">discussion
 of the {@code Immutable*} types</a> for more information on the properties and guarantees
 provided by this class.

 @author James Sexton
 @author Jens Nyman
 @param <N> Node parameter type
 @param <V> Value parameter type
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ImmutableValueGraph -->
  <!-- start class com.google.common.graph.ImmutableValueGraph.Builder -->
  <class name="ImmutableValueGraph.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addNode" return="com.google.common.graph.ImmutableValueGraph.Builder&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Adds {@code node} if it is not already present.

 <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.

 @return this {@code Builder} object]]>
      </doc>
    </method>
    <method name="putEdgeValue" return="com.google.common.graph.ImmutableValueGraph.Builder&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present, and
 sets a value for that edge to {@code value} (overwriting the existing value, if any).

 <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be
 undirected.

 <p>Values do not have to be unique. However, values must be non-null.

 <p>If {@code nodeU} and {@code nodeV} are not already present in this graph, this method will
 silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the graph.

 @return this {@code Builder} object
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}]]>
      </doc>
    </method>
    <method name="putEdgeValue" return="com.google.common.graph.ImmutableValueGraph.Builder&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code endpoints} if one is not already present, and sets a value for
 that edge to {@code value} (overwriting the existing value, if any).

 <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be
 undirected.

 <p>If this graph is directed, {@code endpoints} must be ordered.

 <p>Values do not have to be unique. However, values must be non-null.

 <p>If either or both endpoints are not already present in this graph, this method will
 silently {@link #addNode(Object) add} each missing endpoint to the graph.

 @return this {@code Builder} object
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}
 @throws IllegalArgumentException if the endpoints are unordered and the graph is directed]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.graph.ImmutableValueGraph&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a newly-created {@code ImmutableValueGraph} based on the contents of this {@code
 Builder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating {@link ImmutableValueGraph} instances, especially {@code static final}
 graphs. Example:

 {@snippet :
 static final ImmutableValueGraph<City, Distance> CITY_ROAD_DISTANCE_GRAPH =
     ValueGraphBuilder.undirected()
         .<City, Distance>immutable()
         .putEdgeValue(PARIS, BERLIN, kilometers(1060))
         .putEdgeValue(PARIS, BRUSSELS, kilometers(317))
         .putEdgeValue(BERLIN, BRUSSELS, kilometers(764))
         .addNode(REYKJAVIK)
         .build();
 }

 <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
 multiple graphs in series. Each new graph contains all the elements of the ones created before
 it.

 @since 28.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ImmutableValueGraph.Builder -->
  <!-- start interface com.google.common.graph.MutableGraph -->
  <interface name="MutableGraph"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.Graph&lt;N&gt;"/>
    <method name="addNode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Adds {@code node} if it is not already present.

 <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.

 @return {@code true} if the graph was modified as a result of this call]]>
      </doc>
    </method>
    <method name="putEdge" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present.

 <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be
 undirected.

 <p>If {@code nodeU} and {@code nodeV} are not already present in this graph, this method will
 silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the graph.

 @return {@code true} if the graph was modified as a result of this call
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}]]>
      </doc>
    </method>
    <method name="putEdge" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code endpoints} (in the order, if any, specified by {@code
 endpoints}) if one is not already present.

 <p>If this graph is directed, {@code endpoints} must be ordered and the added edge will be
 directed; if it is undirected, the added edge will be undirected.

 <p>If this graph is directed, {@code endpoints} must be ordered.

 <p>If either or both endpoints are not already present in this graph, this method will silently
 {@link #addNode(Object) add} each missing endpoint to the graph.

 @return {@code true} if the graph was modified as a result of this call
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}
 @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
 @since 27.1]]>
      </doc>
    </method>
    <method name="removeNode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Removes {@code node} if it is present; all edges incident to {@code node} will also be removed.

 @return {@code true} if the graph was modified as a result of this call]]>
      </doc>
    </method>
    <method name="removeEdge" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Removes the edge connecting {@code nodeU} to {@code nodeV}, if it is present.

 @return {@code true} if the graph was modified as a result of this call]]>
      </doc>
    </method>
    <method name="removeEdge" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Removes the edge connecting {@code endpoints}, if it is present.

 <p>If this graph is directed, {@code endpoints} must be ordered.

 @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
 @return {@code true} if the graph was modified as a result of this call
 @since 27.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A subinterface of {@link Graph} which adds mutation methods. When mutation is not required, users
 should prefer the {@link Graph} interface.

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> Node parameter type
 @since 20.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.MutableGraph -->
  <!-- start interface com.google.common.graph.MutableNetwork -->
  <interface name="MutableNetwork"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.Network&lt;N, E&gt;"/>
    <method name="addNode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Adds {@code node} if it is not already present.

 <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.

 @return {@code true} if the network was modified as a result of this call]]>
      </doc>
    </method>
    <method name="addEdge" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Adds {@code edge} connecting {@code nodeU} to {@code nodeV}.

 <p>If the graph is directed, {@code edge} will be directed in this graph; otherwise, it will be
 undirected.

 <p><b>{@code edge} must be unique to this graph</b>, just as a {@code Map} key must be. It must
 also be non-null.

 <p>If {@code nodeU} and {@code nodeV} are not already present in this graph, this method will
 silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the graph.

 <p>If {@code edge} already connects {@code nodeU} to {@code nodeV} (in the specified order if
 this network {@link #isDirected()}, else in any order), then this method will have no effect.

 @return {@code true} if the network was modified as a result of this call
 @throws IllegalArgumentException if {@code edge} already exists in the graph and does not
     connect {@code nodeU} to {@code nodeV}
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsParallelEdges()} or {@link #allowsSelfLoops()}]]>
      </doc>
    </method>
    <method name="addEdge" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will
 also connect {@code nodeV} to {@code nodeU}.

 <p>If this graph is directed, {@code edge} will be directed in this graph; if it is undirected,
 {@code edge} will be undirected in this graph.

 <p>If this graph is directed, {@code endpoints} must be ordered.

 <p><b>{@code edge} must be unique to this graph</b>, just as a {@code Map} key must be. It must
 also be non-null.

 <p>If either or both endpoints are not already present in this graph, this method will silently
 {@link #addNode(Object) add} each missing endpoint to the graph.

 <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this
 method will have no effect.

 @return {@code true} if the network was modified as a result of this call
 @throws IllegalArgumentException if {@code edge} already exists in the graph and connects some
     other endpoint pair that is not equal to {@code endpoints}
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
 @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
 @since 27.1]]>
      </doc>
    </method>
    <method name="removeNode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Removes {@code node} if it is present; all edges incident to {@code node} will also be removed.

 @return {@code true} if the network was modified as a result of this call]]>
      </doc>
    </method>
    <method name="removeEdge" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Removes {@code edge} from this network, if it is present.

 @return {@code true} if the network was modified as a result of this call]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A subinterface of {@link Network} which adds mutation methods. When mutation is not required,
 users should prefer the {@link Network} interface.

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> Node parameter type
 @param <E> Edge parameter type
 @since 20.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.MutableNetwork -->
  <!-- start interface com.google.common.graph.MutableValueGraph -->
  <interface name="MutableValueGraph"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.ValueGraph&lt;N, V&gt;"/>
    <method name="addNode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Adds {@code node} if it is not already present.

 <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.

 @return {@code true} if the graph was modified as a result of this call]]>
      </doc>
    </method>
    <method name="putEdgeValue" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code nodeU} to {@code nodeV} if one is not already present, and sets
 a value for that edge to {@code value} (overwriting the existing value, if any).

 <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be
 undirected.

 <p>Values do not have to be unique. However, values must be non-null.

 <p>If {@code nodeU} and {@code nodeV} are not already present in this graph, this method will
 silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the graph.

 @return the value previously associated with the edge connecting {@code nodeU} to {@code
     nodeV}, or null if there was no such edge.
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}]]>
      </doc>
    </method>
    <method name="putEdgeValue" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds an edge connecting {@code endpoints} if one is not already present, and sets a value for
 that edge to {@code value} (overwriting the existing value, if any).

 <p>If the graph is directed, the resultant edge will be directed; otherwise, it will be
 undirected.

 <p>If this graph is directed, {@code endpoints} must be ordered.

 <p>Values do not have to be unique. However, values must be non-null.

 <p>If either or both endpoints are not already present in this graph, this method will silently
 {@link #addNode(Object) add} each missing endpoint to the graph.

 @return the value previously associated with the edge connecting {@code nodeU} to {@code
     nodeV}, or null if there was no such edge.
 @throws IllegalArgumentException if the introduction of the edge would violate {@link
     #allowsSelfLoops()}
 @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
 @since 27.1]]>
      </doc>
    </method>
    <method name="removeNode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Removes {@code node} if it is present; all edges incident to {@code node} will also be removed.

 @return {@code true} if the graph was modified as a result of this call]]>
      </doc>
    </method>
    <method name="removeEdge" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Removes the edge connecting {@code nodeU} to {@code nodeV}, if it is present.

 @return the value previously associated with the edge connecting {@code nodeU} to {@code
     nodeV}, or null if there was no such edge.]]>
      </doc>
    </method>
    <method name="removeEdge" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Removes the edge connecting {@code endpoints}, if it is present.

 <p>If this graph is directed, {@code endpoints} must be ordered.

 @return the value previously associated with the edge connecting {@code endpoints}, or null if
     there was no such edge.
 @since 27.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A subinterface of {@link ValueGraph} which adds mutation methods. When mutation is not required,
 users should prefer the {@link ValueGraph} interface.

 @author James Sexton
 @param <N> Node parameter type
 @param <V> Value parameter type
 @since 20.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.MutableValueGraph -->
  <!-- start interface com.google.common.graph.Network -->
  <interface name="Network"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.SuccessorsFunction&lt;N&gt;"/>
    <implements name="com.google.common.graph.PredecessorsFunction&lt;N&gt;"/>
    <method name="nodes" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all nodes in this network, in the order specified by {@link #nodeOrder()}.]]>
      </doc>
    </method>
    <method name="edges" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all edges in this network, in the order specified by {@link #edgeOrder()}.]]>
      </doc>
    </method>
    <method name="asGraph" return="com.google.common.graph.Graph&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a live view of this network as a {@link Graph}. The resulting {@link Graph} will have
 an edge connecting node A to node B if this {@link Network} has an edge connecting A to B.

 <p>If this network {@link #allowsParallelEdges() allows parallel edges}, parallel edges will be
 treated as if collapsed into a single edge. For example, the {@link #degree(Object)} of a node
 in the {@link Graph} view may be less than the degree of the same node in this {@link Network}.]]>
      </doc>
    </method>
    <method name="isDirected" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the edges in this network are directed. Directed edges connect a {@link
 EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while
 undirected edges connect a pair of nodes to each other.]]>
      </doc>
    </method>
    <method name="allowsParallelEdges" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this network allows parallel edges. Attempting to add a parallel edge to a
 network that does not allow them will throw an {@link IllegalArgumentException}.]]>
      </doc>
    </method>
    <method name="allowsSelfLoops" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this network allows self-loops (edges that connect a node to itself).
 Attempting to add a self-loop to a network that does not allow them will throw an {@link
 IllegalArgumentException}.]]>
      </doc>
    </method>
    <method name="nodeOrder" return="com.google.common.graph.ElementOrder&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the order of iteration for the elements of {@link #nodes()}.]]>
      </doc>
    </method>
    <method name="edgeOrder" return="com.google.common.graph.ElementOrder&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the order of iteration for the elements of {@link #edges()}.]]>
      </doc>
    </method>
    <method name="adjacentNodes" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of the nodes which have an incident edge in common with {@code node} in
 this network.

 <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.

 <p>If {@code node} is removed from the network after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="predecessors" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all nodes in this network adjacent to {@code node} which can be reached
 by traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.

 <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.

 <p>If {@code node} is removed from the network after this method is called, the {@code Set}
 returned by this method will be invalidated, and will throw {@code IllegalStateException} if it
 is accessed in any way.

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="successors" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all nodes in this network adjacent to {@code node} which can be reached
 by traversing {@code node}'s outgoing edges in the direction (if any) of the edge.

 <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.

 <p>This is <i>not</i> the same as "all nodes reachable from {@code node} by following outgoing
 edges". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.

 <p>If {@code node} is removed from the network after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="incidentEdges" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of the edges whose {@link #incidentNodes(Object) incident nodes} in this
 network include {@code node}.

 <p>This is equal to the union of {@link #inEdges(Object)} and {@link #outEdges(Object)}.

 <p>If {@code node} is removed from the network after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this network
 @since 24.0]]>
      </doc>
    </method>
    <method name="inEdges" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all edges in this network which can be traversed in the direction (if
 any) of the edge to end at {@code node}.

 <p>In a directed network, an incoming edge's {@link EndpointPair#target()} equals {@code node}.

 <p>In an undirected network, this is equivalent to {@link #incidentEdges(Object)}.

 <p>If {@code node} is removed from the network after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="outEdges" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all edges in this network which can be traversed in the direction (if
 any) of the edge starting from {@code node}.

 <p>In a directed network, an outgoing edge's {@link EndpointPair#source()} equals {@code node}.

 <p>In an undirected network, this is equivalent to {@link #incidentEdges(Object)}.

 <p>If {@code node} is removed from the network after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="degree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s {@link #incidentEdges(Object) incident edges}, counting
 self-loops twice (equivalently, the number of times an edge touches {@code node}).

 <p>For directed networks, this is equal to {@code inDegree(node) + outDegree(node)}.

 <p>For undirected networks, this is equal to {@code incidentEdges(node).size()} + (number of
 self-loops incident to {@code node}).

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="inDegree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s {@link #inEdges(Object) incoming edges} in a directed
 network. In an undirected network, returns the {@link #degree(Object)}.

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="outDegree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s {@link #outEdges(Object) outgoing edges} in a directed
 network. In an undirected network, returns the {@link #degree(Object)}.

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this network]]>
      </doc>
    </method>
    <method name="incidentNodes" return="com.google.common.graph.EndpointPair&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Returns the nodes which are the endpoints of {@code edge} in this network.

 @throws IllegalArgumentException if {@code edge} is not an element of this network]]>
      </doc>
    </method>
    <method name="adjacentEdges" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="E"/>
      <doc>
      <![CDATA[Returns a live view of the edges which have an {@link #incidentNodes(Object) incident node} in
 common with {@code edge}. An edge is not considered adjacent to itself.

 <p>If {@code edge} is removed from the network after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code edge} is re-added to the network after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code edge} is not an element of this network]]>
      </doc>
    </method>
    <method name="edgesConnecting" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Returns a live view of the set of edges that each directly connect {@code nodeU} to {@code
 nodeV}.

 <p>In an undirected network, this is equal to {@code edgesConnecting(nodeV, nodeU)}.

 <p>The resulting set of edges will be parallel (i.e. have equal {@link
 #incidentNodes(Object)}). If this network does not {@link #allowsParallelEdges() allow parallel
 edges}, the resulting set will contain at most one edge (equivalent to {@code
 edgeConnecting(nodeU, nodeV).asSet()}).

 <p>If either {@code nodeU} or {@code nodeV} are removed from the network after this method is
 called, the {@code Set} {@code view} returned by this method will be invalidated, and will
 throw {@code IllegalStateException} if it is accessed in any way, with the following
 exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code nodeU} or {@code nodeV} are re-added to the network after having been removed,
       {@code view}'s behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not an element of this
     network]]>
      </doc>
    </method>
    <method name="edgesConnecting" return="java.util.Set&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns a live view of the set of edges that each directly connect {@code endpoints} (in the
 order, if any, specified by {@code endpoints}).

 <p>The resulting set of edges will be parallel (i.e. have equal {@link
 #incidentNodes(Object)}). If this network does not {@link #allowsParallelEdges() allow parallel
 edges}, the resulting set will contain at most one edge (equivalent to {@code
 edgeConnecting(endpoints).asSet()}).

 <p>If this network is directed, {@code endpoints} must be ordered.

 <p>If either element of {@code endpoints} is removed from the network after this method is
 called, the {@code Set} {@code view} returned by this method will be invalidated, and will
 throw {@code IllegalStateException} if it is accessed in any way, with the following
 exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if either endpoint is re-added to the network after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if either endpoint is not an element of this network
 @throws IllegalArgumentException if the endpoints are unordered and the network is directed
 @since 27.1]]>
      </doc>
    </method>
    <method name="edgeConnectingOrNull" return="E"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Returns the single edge that directly connects {@code nodeU} to {@code nodeV}, if one is
 present, or {@code null} if no such edge exists.

 <p>In an undirected network, this is equal to {@code edgeConnectingOrNull(nodeV, nodeU)}.

 @throws IllegalArgumentException if there are multiple parallel edges connecting {@code nodeU}
     to {@code nodeV}
 @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not an element of this
     network
 @since 23.0]]>
      </doc>
    </method>
    <method name="edgeConnectingOrNull" return="E"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns the single edge that directly connects {@code endpoints} (in the order, if any,
 specified by {@code endpoints}), if one is present, or {@code null} if no such edge exists.

 <p>If this network is directed, the endpoints must be ordered.

 @throws IllegalArgumentException if there are multiple parallel edges connecting {@code nodeU}
     to {@code nodeV}
 @throws IllegalArgumentException if either endpoint is not an element of this network
 @throws IllegalArgumentException if the endpoints are unordered and the network is directed
 @since 27.1]]>
      </doc>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is
 equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}, and to
 {@code edgeConnectingOrNull(nodeU, nodeV) != null}.

 <p>In an undirected network, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.

 @since 23.0]]>
      </doc>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns true if there is an edge that directly connects {@code endpoints} (in the order, if
 any, specified by {@code endpoints}).

 <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the
 endpoints are unordered and the network is directed; it simply returns {@code false}. This is
 for consistency with {@link Graph#hasEdgeConnecting(EndpointPair)} and {@link
 ValueGraph#hasEdgeConnecting(EndpointPair)}.

 @since 27.1]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} iff {@code object} is a {@link Network} that has the same elements and the
 same structural relationships as those in this network.

 <p>Thus, two networks A and B are equal if <b>all</b> of the following are true:

 <ul>
   <li>A and B have equal {@link #isDirected() directedness}.
   <li>A and B have equal {@link #nodes() node sets}.
   <li>A and B have equal {@link #edges() edge sets}.
   <li>Every edge in A and B connects the same nodes in the same direction (if any).
 </ul>

 <p>Network properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.
 For example, two networks may be considered equal even if one allows parallel edges and the
 other doesn't. Additionally, the order in which nodes or edges are added to the network, and
 the order in which they are iterated over, are irrelevant.

 <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this network. The hash code of a network is defined as the hash code
 of a map from each of its {@link #edges() edges} to their {@link #incidentNodes(Object)
 incident nodes}.

 <p>A reference implementation of this is provided by {@link AbstractNetwork#hashCode()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface for <a
 href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>-structured data,
 whose edges are <a
 href="https://github.com/google/guava/wiki/GraphsExplained#uniqueness">unique</a> objects.

 <p>A graph is composed of a set of nodes and a set of edges connecting pairs of nodes.

 <p>There are three primary interfaces provided to represent graphs. In order of increasing
 complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally
 prefer the simplest interface that satisfies your use case. See the <a
 href="https://github.com/google/guava/wiki/GraphsExplained#choosing-the-right-graph-type">
 "Choosing the right graph type"</a> section of the Guava User Guide for more details.

 <h3>Capabilities</h3>

 <p>{@code Network} supports the following use cases (<a
 href="https://github.com/google/guava/wiki/GraphsExplained#definitions">definitions of
 terms</a>):

 <ul>
   <li>directed graphs
   <li>undirected graphs
   <li>graphs that do/don't allow parallel edges
   <li>graphs that do/don't allow self-loops
   <li>graphs whose nodes/edges are insertion-ordered, sorted, or unordered
   <li>graphs whose edges are <a
       href="https://github.com/google/guava/wiki/GraphsExplained#uniqueness">unique</a> objects
 </ul>

 <h3>Building a {@code Network}</h3>

 <p>The implementation classes that {@code common.graph} provides are not public, by design. To
 create an instance of one of the built-in implementations of {@code Network}, use the {@link
 NetworkBuilder} class:

 {@snippet :
 MutableNetwork<Integer, MyEdge> network = NetworkBuilder.directed().build();
 }

 <p>{@link NetworkBuilder#build()} returns an instance of {@link MutableNetwork}, which is a
 subtype of {@code Network} that provides methods for adding and removing nodes and edges. If you
 do not need to mutate a network (e.g. if you write a method than runs a read-only algorithm on
 the network), you should use the non-mutating {@link Network} interface, or an {@link
 ImmutableNetwork}.

 <p>You can create an immutable copy of an existing {@code Network} using {@link
 ImmutableNetwork#copyOf(Network)}:

 {@snippet :
 ImmutableNetwork<Integer, MyEdge> immutableGraph = ImmutableNetwork.copyOf(network);
 }

 <p>Instances of {@link ImmutableNetwork} do not implement {@link MutableNetwork} (obviously!) and
 are contractually guaranteed to be unmodifiable and thread-safe.

 <p>The Guava User Guide has <a
 href="https://github.com/google/guava/wiki/GraphsExplained#building-graph-instances">more
 information on (and examples of) building graphs</a>.

 <h3>Additional documentation</h3>

 <p>See the Guava User Guide for the {@code common.graph} package (<a
 href="https://github.com/google/guava/wiki/GraphsExplained">"Graphs Explained"</a>) for
 additional documentation, including:

 <ul>
   <li><a
       href="https://github.com/google/guava/wiki/GraphsExplained#equals-hashcode-and-graph-equivalence">
       {@code equals()}, {@code hashCode()}, and graph equivalence</a>
   <li><a href="https://github.com/google/guava/wiki/GraphsExplained#synchronization">
       Synchronization policy</a>
   <li><a href="https://github.com/google/guava/wiki/GraphsExplained#notes-for-implementors">Notes
       for implementors</a>
 </ul>

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> Node parameter type
 @param <E> Edge parameter type
 @since 20.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.Network -->
  <!-- start class com.google.common.graph.NetworkBuilder -->
  <class name="NetworkBuilder" extends="com.google.common.graph.AbstractGraphBuilder&lt;N&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="directed" return="com.google.common.graph.NetworkBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link NetworkBuilder} for building directed networks.]]>
      </doc>
    </method>
    <method name="undirected" return="com.google.common.graph.NetworkBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link NetworkBuilder} for building undirected networks.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.graph.NetworkBuilder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="network" type="com.google.common.graph.Network&lt;N, E&gt;"/>
      <doc>
      <![CDATA[Returns a {@link NetworkBuilder} initialized with all properties queryable from {@code
 network}.

 <p>The "queryable" properties are those that are exposed through the {@link Network} interface,
 such as {@link Network#isDirected()}. Other properties, such as {@link
 #expectedNodeCount(int)}, are not set in the new builder.]]>
      </doc>
    </method>
    <method name="immutable" return="com.google.common.graph.ImmutableNetwork.Builder&lt;N1, E1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link ImmutableNetwork.Builder} with the properties of this {@link NetworkBuilder}.

 <p>The returned builder can be used for populating an {@link ImmutableNetwork}.

 @since 28.0]]>
      </doc>
    </method>
    <method name="allowsParallelEdges" return="com.google.common.graph.NetworkBuilder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allowsParallelEdges" type="boolean"/>
      <doc>
      <![CDATA[Specifies whether the network will allow parallel edges. Attempting to add a parallel edge to a
 network that does not allow them will throw an {@link UnsupportedOperationException}.

 <p>The default value is {@code false}.]]>
      </doc>
    </method>
    <method name="allowsSelfLoops" return="com.google.common.graph.NetworkBuilder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allowsSelfLoops" type="boolean"/>
      <doc>
      <![CDATA[Specifies whether the network will allow self-loops (edges that connect a node to itself).
 Attempting to add a self-loop to a network that does not allow them will throw an {@link
 UnsupportedOperationException}.

 <p>The default value is {@code false}.]]>
      </doc>
    </method>
    <method name="expectedNodeCount" return="com.google.common.graph.NetworkBuilder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedNodeCount" type="int"/>
      <doc>
      <![CDATA[Specifies the expected number of nodes in the network.

 @throws IllegalArgumentException if {@code expectedNodeCount} is negative]]>
      </doc>
    </method>
    <method name="expectedEdgeCount" return="com.google.common.graph.NetworkBuilder&lt;N, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedEdgeCount" type="int"/>
      <doc>
      <![CDATA[Specifies the expected number of edges in the network.

 @throws IllegalArgumentException if {@code expectedEdgeCount} is negative]]>
      </doc>
    </method>
    <method name="nodeOrder" return="com.google.common.graph.NetworkBuilder&lt;N1, E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeOrder" type="com.google.common.graph.ElementOrder&lt;N1&gt;"/>
      <doc>
      <![CDATA[Specifies the order of iteration for the elements of {@link Network#nodes()}.

 <p>The default value is {@link ElementOrder#insertion() insertion order}.]]>
      </doc>
    </method>
    <method name="edgeOrder" return="com.google.common.graph.NetworkBuilder&lt;N, E1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edgeOrder" type="com.google.common.graph.ElementOrder&lt;E1&gt;"/>
      <doc>
      <![CDATA[Specifies the order of iteration for the elements of {@link Network#edges()}.

 <p>The default value is {@link ElementOrder#insertion() insertion order}.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.graph.MutableNetwork&lt;N1, E1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty {@link MutableNetwork} with the properties of this {@link NetworkBuilder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for constructing instances of {@link MutableNetwork} or {@link ImmutableNetwork} with
 user-defined properties.

 <p>A {@code Network} built by this class has the following default properties:

 <ul>
   <li>does not allow parallel edges
   <li>does not allow self-loops
   <li>orders {@link Network#nodes()} and {@link Network#edges()} in the order in which the
       elements were added (insertion order)
 </ul>

 <p>{@code Network}s built by this class also guarantee that each collection-returning accessor
 returns a <b>(live) unmodifiable view</b>; see <a
 href="https://github.com/google/guava/wiki/GraphsExplained#accessor-behavior">the external
 documentation</a> for details.

 <p>Examples of use:

 {@snippet :
 // Building a mutable network
 MutableNetwork<String, Integer> network =
     NetworkBuilder.directed().allowsParallelEdges(true).build();
 flightNetwork.addEdge("LAX", "ATL", 3025);
 flightNetwork.addEdge("LAX", "ATL", 1598);
 flightNetwork.addEdge("ATL", "LAX", 2450);

 // Building a immutable network
 ImmutableNetwork<String, Integer> immutableNetwork =
     NetworkBuilder.directed()
         .allowsParallelEdges(true)
         .<String, Integer>immutable()
         .addEdge("LAX", "ATL", 3025)
         .addEdge("LAX", "ATL", 1598)
         .addEdge("ATL", "LAX", 2450)
         .build();
 }

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> The most general node type this builder will support. This is normally {@code Object}
     unless it is constrained by using a method like {@link #nodeOrder}, or the builder is
     constructed based on an existing {@code Network} using {@link #from(Network)}.
 @param <E> The most general edge type this builder will support. This is normally {@code Object}
     unless it is constrained by using a method like {@link #edgeOrder}, or the builder is
     constructed based on an existing {@code Network} using {@link #from(Network)}.
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.NetworkBuilder -->
  <!-- start interface com.google.common.graph.PredecessorsFunction -->
  <interface name="PredecessorsFunction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="predecessors" return="java.lang.Iterable&lt;? extends N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing
 {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.

 <p>Some algorithms that operate on a {@code PredecessorsFunction} may produce undesired results
 if the returned {@link Iterable} contains duplicate elements. Implementations of such
 algorithms should document their behavior in the presence of duplicates.

 <p>The elements of the returned {@code Iterable} must each be:

 <ul>
   <li>Non-null
   <li>Usable as {@code Map} keys (see the Guava User Guide's section on <a
       href="https://github.com/google/guava/wiki/GraphsExplained#graph-elements-nodes-and-edges">
       graph elements</a> for details)
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A functional interface for <a
 href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>-structured data.

 <p>This interface is meant to be used as the type of a parameter to graph algorithms (such as
 topological sort) that only need a way of accessing the predecessors of a node in a graph.

 <h3>Usage</h3>

 Given an algorithm, for example:

 {@snippet :
 public <N> someGraphAlgorithm(N startNode, PredecessorsFunction<N> predecessorsFunction);
 }

 you will invoke it depending on the graph representation you're using.

 <p>If you have an instance of one of the primary {@code common.graph} types ({@link Graph},
 {@link ValueGraph}, and {@link Network}):

 {@snippet :
 someGraphAlgorithm(startNode, graph);
 }

 This works because those types each implement {@code PredecessorsFunction}. It will also work
 with any other implementation of this interface.

 <p>If you have your own graph implementation based around a custom node type {@code MyNode},
 which has a method {@code getParents()} that retrieves its predecessors in a graph:

 {@snippet :
 someGraphAlgorithm(startNode, MyNode::getParents);
 }

 <p>If you have some other mechanism for returning the predecessors of a node, or one that doesn't
 return a {@code Iterable<? extends N>}, then you can use a lambda to perform a more general
 transformation:

 {@snippet :
 someGraphAlgorithm(startNode, node -> ImmutableList.of(node.mother(), node.father()));
 }

 <p>Graph algorithms that need additional capabilities (accessing both predecessors and
 successors, iterating over the edges, etc.) should declare their input to be of a type that
 provides those capabilities, such as {@link Graph}, {@link ValueGraph}, or {@link Network}.

 <h3>Additional documentation</h3>

 <p>See the Guava User Guide for the {@code common.graph} package (<a
 href="https://github.com/google/guava/wiki/GraphsExplained">"Graphs Explained"</a>) for
 additional documentation, including <a
 href="https://github.com/google/guava/wiki/GraphsExplained#notes-for-implementors">notes for
 implementors</a>

 @author Joshua O'Madadhain
 @author Jens Nyman
 @param <N> Node parameter type
 @since 23.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.PredecessorsFunction -->
  <!-- start interface com.google.common.graph.SuccessorsFunction -->
  <interface name="SuccessorsFunction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="successors" return="java.lang.Iterable&lt;? extends N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns all nodes in this graph adjacent to {@code node} which can be reached by traversing
 {@code node}'s outgoing edges in the direction (if any) of the edge.

 <p>This is <i>not</i> the same as "all nodes reachable from {@code node} by following outgoing
 edges". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.

 <p>Some algorithms that operate on a {@code SuccessorsFunction} may produce undesired results
 if the returned {@link Iterable} contains duplicate elements. Implementations of such
 algorithms should document their behavior in the presence of duplicates.

 <p>The elements of the returned {@code Iterable} must each be:

 <ul>
   <li>Non-null
   <li>Usable as {@code Map} keys (see the Guava User Guide's section on <a
       href="https://github.com/google/guava/wiki/GraphsExplained#graph-elements-nodes-and-edges">
       graph elements</a> for details)
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A functional interface for <a
 href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>-structured data.

 <p>This interface is meant to be used as the type of a parameter to graph algorithms (such as
 breadth first traversal) that only need a way of accessing the successors of a node in a graph.

 <h3>Usage</h3>

 Given an algorithm, for example:

 {@snippet :
 public <N> someGraphAlgorithm(N startNode, SuccessorsFunction<N> successorsFunction);
 }

 you will invoke it depending on the graph representation you're using.

 <p>If you have an instance of one of the primary {@code common.graph} types ({@link Graph},
 {@link ValueGraph}, and {@link Network}):

 {@snippet :
 someGraphAlgorithm(startNode, graph);
 }

 This works because those types each implement {@code SuccessorsFunction}. It will also work with
 any other implementation of this interface.

 <p>If you have your own graph implementation based around a custom node type {@code MyNode},
 which has a method {@code getChildren()} that retrieves its successors in a graph:

 {@snippet :
 someGraphAlgorithm(startNode, MyNode::getChildren);
 }

 <p>If you have some other mechanism for returning the successors of a node, or one that doesn't
 return an {@code Iterable<? extends N>}, then you can use a lambda to perform a more general
 transformation:

 {@snippet :
 someGraphAlgorithm(startNode, node -> ImmutableList.of(node.leftChild(), node.rightChild()));
 }

 <p>Graph algorithms that need additional capabilities (accessing both predecessors and
 successors, iterating over the edges, etc.) should declare their input to be of a type that
 provides those capabilities, such as {@link Graph}, {@link ValueGraph}, or {@link Network}.

 <h3>Additional documentation</h3>

 <p>See the Guava User Guide for the {@code common.graph} package (<a
 href="https://github.com/google/guava/wiki/GraphsExplained">"Graphs Explained"</a>) for
 additional documentation, including <a
 href="https://github.com/google/guava/wiki/GraphsExplained#notes-for-implementors">notes for
 implementors</a>

 @author Joshua O'Madadhain
 @author Jens Nyman
 @param <N> Node parameter type
 @since 23.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.SuccessorsFunction -->
  <!-- start class com.google.common.graph.Traverser -->
  <class name="Traverser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="forGraph" return="com.google.common.graph.Traverser&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.SuccessorsFunction&lt;N&gt;"/>
      <doc>
      <![CDATA[Creates a new traverser for the given general {@code graph}.

 <p>Traversers created using this method are guaranteed to visit each node reachable from the
 start node(s) at most once.

 <p>If you know that no node in {@code graph} is reachable by more than one path from the start
 node(s), consider using {@link #forTree(SuccessorsFunction)} instead.

 <p><b>Performance notes</b>

 <ul>
   <li>Traversals require <i>O(n)</i> time (where <i>n</i> is the number of nodes reachable from
       the start node), assuming that the node objects have <i>O(1)</i> {@code equals()} and
       {@code hashCode()} implementations. (See the <a
       href="https://github.com/google/guava/wiki/GraphsExplained#elements-must-be-useable-as-map-keys">
       notes on element objects</a> for more information.)
   <li>While traversing, the traverser will use <i>O(n)</i> space (where <i>n</i> is the number
       of nodes that have thus far been visited), plus <i>O(H)</i> space (where <i>H</i> is the
       number of nodes that have been seen but not yet visited, that is, the "horizon").
 </ul>

 @param graph {@link SuccessorsFunction} representing a general graph that may have cycles.]]>
      </doc>
    </method>
    <method name="forTree" return="com.google.common.graph.Traverser&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tree" type="com.google.common.graph.SuccessorsFunction&lt;N&gt;"/>
      <doc>
      <![CDATA[Creates a new traverser for a directed acyclic graph that has at most one path from the start
 node(s) to any node reachable from the start node(s), and has no paths from any start node to
 any other start node, such as a tree or forest.

 <p>{@code forTree()} is especially useful (versus {@code forGraph()}) in cases where the data
 structure being traversed is, in addition to being a tree/forest, also defined <a
 href="https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness">recursively</a>.
 This is because the {@code forTree()}-based implementations don't keep track of visited nodes,
 and therefore don't need to call {@code equals()} or {@code hashCode()} on the node objects;
 this saves both time and space versus traversing the same graph using {@code forGraph()}.

 <p>Providing a graph to be traversed for which there is more than one path from the start
 node(s) to any node may lead to:

 <ul>
   <li>Traversal not terminating (if the graph has cycles)
   <li>Nodes being visited multiple times (if multiple paths exist from any start node to any
       node reachable from any start node)
 </ul>

 <p><b>Performance notes</b>

 <ul>
   <li>Traversals require <i>O(n)</i> time (where <i>n</i> is the number of nodes reachable from
       the start node).
   <li>While traversing, the traverser will use <i>O(H)</i> space (where <i>H</i> is the number
       of nodes that have been seen but not yet visited, that is, the "horizon").
 </ul>

 <p><b>Examples</b> (all edges are directed facing downwards)

 <p>The graph below would be valid input with start nodes of {@code a, f, c}. However, if {@code
 b} were <i>also</i> a start node, then there would be multiple paths to reach {@code e} and
 {@code h}.

 {@snippet :
    a     b      c
   / \   / \     |
  /   \ /   \    |
 d     e     f   g
       |
       |
       h
 }

 <p>.

 <p>The graph below would be a valid input with start nodes of {@code a, f}. However, if {@code
 b} were a start node, there would be multiple paths to {@code f}.

 {@snippet :
    a     b
   / \   / \
  /   \ /   \
 c     d     e
        \   /
         \ /
          f
 }

 <p><b>Note on binary trees</b>

 <p>This method can be used to traverse over a binary tree. Given methods {@code
 leftChild(node)} and {@code rightChild(node)}, this method can be called as

 {@snippet :
 Traverser.forTree(node -> ImmutableList.of(leftChild(node), rightChild(node)));
 }

 @param tree {@link SuccessorsFunction} representing a directed acyclic graph that has at most
     one path between any two nodes]]>
      </doc>
    </method>
    <method name="breadthFirst" return="java.lang.Iterable&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="startNode" type="N"/>
      <doc>
      <![CDATA[Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
 the order of a breadth-first traversal. That is, all the nodes of depth 0 are returned, then
 depth 1, then 2, and so on.

 <p><b>Example:</b> The following graph with {@code startNode} {@code a} would return nodes in
 the order {@code abcdef} (assuming successors are returned in alphabetical order).

 {@snippet :
 b ---- a ---- d
 |      |
 |      |
 e ---- c ---- f
 }

 <p>The behavior of this method is undefined if the nodes, or the topology of the graph, change
 while iteration is in progress.

 <p>The returned {@code Iterable} can be iterated over multiple times. Every iterator will
 compute its next element on the fly. It is thus possible to limit the traversal to a certain
 number of nodes as follows:

 {@snippet :
 Iterables.limit(Traverser.forGraph(graph).breadthFirst(node), maxNumberOfNodes);
 }

 <p>See <a href="https://en.wikipedia.org/wiki/Breadth-first_search">Wikipedia</a> for more
 info.

 @throws IllegalArgumentException if {@code startNode} is not an element of the graph]]>
      </doc>
    </method>
    <method name="breadthFirst" return="java.lang.Iterable&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="startNodes" type="java.lang.Iterable&lt;? extends N&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
 startNodes}, in the order of a breadth-first traversal. This is equivalent to a breadth-first
 traversal of a graph with an additional root node whose successors are the listed {@code
 startNodes}.

 @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph
 @see #breadthFirst(Object)
 @since 24.1]]>
      </doc>
    </method>
    <method name="depthFirstPreOrder" return="java.lang.Iterable&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="startNode" type="N"/>
      <doc>
      <![CDATA[Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
 the order of a depth-first pre-order traversal. "Pre-order" implies that nodes appear in the
 {@code Iterable} in the order in which they are first visited.

 <p><b>Example:</b> The following graph with {@code startNode} {@code a} would return nodes in
 the order {@code abecfd} (assuming successors are returned in alphabetical order).

 {@snippet :
 b ---- a ---- d
 |      |
 |      |
 e ---- c ---- f
 }

 <p>The behavior of this method is undefined if the nodes, or the topology of the graph, change
 while iteration is in progress.

 <p>The returned {@code Iterable} can be iterated over multiple times. Every iterator will
 compute its next element on the fly. It is thus possible to limit the traversal to a certain
 number of nodes as follows:

 {@snippet :
 Iterables.limit(
     Traverser.forGraph(graph).depthFirstPreOrder(node), maxNumberOfNodes);
 }

 <p>See <a href="https://en.wikipedia.org/wiki/Depth-first_search">Wikipedia</a> for more info.

 @throws IllegalArgumentException if {@code startNode} is not an element of the graph]]>
      </doc>
    </method>
    <method name="depthFirstPreOrder" return="java.lang.Iterable&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="startNodes" type="java.lang.Iterable&lt;? extends N&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
 startNodes}, in the order of a depth-first pre-order traversal. This is equivalent to a
 depth-first pre-order traversal of a graph with an additional root node whose successors are
 the listed {@code startNodes}.

 @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph
 @see #depthFirstPreOrder(Object)
 @since 24.1]]>
      </doc>
    </method>
    <method name="depthFirstPostOrder" return="java.lang.Iterable&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="startNode" type="N"/>
      <doc>
      <![CDATA[Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
 the order of a depth-first post-order traversal. "Post-order" implies that nodes appear in the
 {@code Iterable} in the order in which they are visited for the last time.

 <p><b>Example:</b> The following graph with {@code startNode} {@code a} would return nodes in
 the order {@code fcebda} (assuming successors are returned in alphabetical order).

 {@snippet :
 b ---- a ---- d
 |      |
 |      |
 e ---- c ---- f
 }

 <p>The behavior of this method is undefined if the nodes, or the topology of the graph, change
 while iteration is in progress.

 <p>The returned {@code Iterable} can be iterated over multiple times. Every iterator will
 compute its next element on the fly. It is thus possible to limit the traversal to a certain
 number of nodes as follows:

 {@snippet :
 Iterables.limit(
     Traverser.forGraph(graph).depthFirstPostOrder(node), maxNumberOfNodes);
 }

 <p>See <a href="https://en.wikipedia.org/wiki/Depth-first_search">Wikipedia</a> for more info.

 @throws IllegalArgumentException if {@code startNode} is not an element of the graph]]>
      </doc>
    </method>
    <method name="depthFirstPostOrder" return="java.lang.Iterable&lt;N&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="startNodes" type="java.lang.Iterable&lt;? extends N&gt;"/>
      <doc>
      <![CDATA[Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
 startNodes}, in the order of a depth-first post-order traversal. This is equivalent to a
 depth-first post-order traversal of a graph with an additional root node whose successors are
 the listed {@code startNodes}.

 @throws IllegalArgumentException if any of {@code startNodes} is not an element of the graph
 @see #depthFirstPostOrder(Object)
 @since 24.1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that can traverse the nodes that are reachable from a specified (set of) start node(s)
 using a specified {@link SuccessorsFunction}.

 <p>There are two entry points for creating a {@code Traverser}: {@link
 #forTree(SuccessorsFunction)} and {@link #forGraph(SuccessorsFunction)}. You should choose one
 based on your answers to the following questions:

 <ol>
   <li>Is there only one path to any node that's reachable from any start node? (If so, the graph
       to be traversed is a tree or forest even if it is a subgraph of a graph which is neither.)
   <li>Are the node objects' implementations of {@code equals()}/{@code hashCode()} <a
       href="https://github.com/google/guava/wiki/GraphsExplained#non-recursiveness">recursive</a>?
 </ol>

 <p>If your answers are:

 <ul>
   <li>(1) "no" and (2) "no", use {@link #forGraph(SuccessorsFunction)}.
   <li>(1) "yes" and (2) "yes", use {@link #forTree(SuccessorsFunction)}.
   <li>(1) "yes" and (2) "no", you can use either, but {@code forTree()} will be more efficient.
   <li>(1) "no" and (2) "yes", <b><i>neither will work</i></b>, but if you transform your node
       objects into a non-recursive form, you can use {@code forGraph()}.
 </ul>

 @author Jens Nyman
 @param <N> Node parameter type
 @since 23.1]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.Traverser -->
  <!-- start interface com.google.common.graph.ValueGraph -->
  <interface name="ValueGraph"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.graph.BaseGraph&lt;N&gt;"/>
    <method name="nodes" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}.]]>
      </doc>
    </method>
    <method name="edges" return="java.util.Set&lt;com.google.common.graph.EndpointPair&lt;N&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all edges in this graph.]]>
      </doc>
    </method>
    <method name="asGraph" return="com.google.common.graph.Graph&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a live view of this graph as a {@link Graph}. The resulting {@link Graph} will have an
 edge connecting node A to node B if this {@link ValueGraph} has an edge connecting A to B.]]>
      </doc>
    </method>
    <method name="isDirected" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the edges in this graph are directed. Directed edges connect a {@link
 EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while
 undirected edges connect a pair of nodes to each other.]]>
      </doc>
    </method>
    <method name="allowsSelfLoops" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting
 to add a self-loop to a graph that does not allow them will throw an {@link
 IllegalArgumentException}.]]>
      </doc>
    </method>
    <method name="nodeOrder" return="com.google.common.graph.ElementOrder&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the order of iteration for the elements of {@link #nodes()}.]]>
      </doc>
    </method>
    <method name="incidentEdgeOrder" return="com.google.common.graph.ElementOrder&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link ElementOrder} that specifies the order of iteration for the elements of
 {@link #edges()}, {@link #adjacentNodes(Object)}, {@link #predecessors(Object)}, {@link
 #successors(Object)} and {@link #incidentEdges(Object)}.

 @since 29.0]]>
      </doc>
    </method>
    <method name="adjacentNodes" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of the nodes which have an incident edge in common with {@code node} in
 this graph.

 <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="predecessors" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by
 traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.

 <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 returned by this method will be invalidated, and will throw {@code IllegalStateException} if it
 is accessed in any way.

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="successors" return="java.util.Set&lt;N&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by
 traversing {@code node}'s outgoing edges in the direction (if any) of the edge.

 <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.

 <p>This is <i>not</i> the same as "all nodes reachable from {@code node} by following outgoing
 edges". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="incidentEdges" return="java.util.Set&lt;com.google.common.graph.EndpointPair&lt;N&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns a live view of the edges in this graph whose endpoints include {@code node}.

 <p>This is equal to the union of incoming and outgoing edges.

 <p>If {@code node} is removed from the graph after this method is called, the {@code Set}
 {@code view} returned by this method will be invalidated, and will throw {@code
 IllegalStateException} if it is accessed in any way, with the following exceptions:

 <ul>
   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}
       expression involving {@code view} will throw)
   <li>{@code hashCode()} does not throw
   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s
       behavior is undefined
 </ul>

 @throws IllegalArgumentException if {@code node} is not an element of this graph
 @since 24.0]]>
      </doc>
    </method>
    <method name="degree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,
 the number of times an edge touches {@code node}).

 <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.

 <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of
 self-loops incident to {@code node}).

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="inDegree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})
 in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="outDegree" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="N"/>
      <doc>
      <![CDATA[Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})
 in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.

 <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.

 @throws IllegalArgumentException if {@code node} is not an element of this graph]]>
      </doc>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <doc>
      <![CDATA[Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is
 equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.

 <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.

 @since 23.0]]>
      </doc>
    </method>
    <method name="hasEdgeConnecting" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <doc>
      <![CDATA[Returns true if there is an edge that directly connects {@code endpoints} (in the order, if
 any, specified by {@code endpoints}). This is equivalent to {@code
 edges().contains(endpoints)}.

 <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the
 endpoints are unordered and the graph is directed; it simply returns {@code false}. This is for
 consistency with the behavior of {@link Collection#contains(Object)} (which does not generally
 throw if the object cannot be present in the collection), and the desire to have this method's
 behavior be compatible with {@code edges().contains(endpoints)}.

 @since 27.1]]>
      </doc>
    </method>
    <method name="edgeValueOrDefault" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeU" type="N"/>
      <param name="nodeV" type="N"/>
      <param name="defaultValue" type="V"/>
      <doc>
      <![CDATA[Returns the value of the edge that connects {@code nodeU} to {@code nodeV}, if one is present;
 otherwise, returns {@code defaultValue}.

 <p>In an undirected graph, this is equal to {@code edgeValueOrDefault(nodeV, nodeU,
 defaultValue)}.

 @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not an element of this
     graph]]>
      </doc>
    </method>
    <method name="edgeValueOrDefault" return="V"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endpoints" type="com.google.common.graph.EndpointPair&lt;N&gt;"/>
      <param name="defaultValue" type="V"/>
      <doc>
      <![CDATA[Returns the value of the edge that connects {@code endpoints} (in the order, if any, specified
 by {@code endpoints}), if one is present; otherwise, returns {@code defaultValue}.

 <p>If this graph is directed, the endpoints must be ordered.

 @throws IllegalArgumentException if either endpoint is not an element of this graph
 @throws IllegalArgumentException if the endpoints are unordered and the graph is directed
 @since 27.1]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} iff {@code object} is a {@link ValueGraph} that has the same elements and
 the same structural relationships as those in this graph.

 <p>Thus, two value graphs A and B are equal if <b>all</b> of the following are true:

 <ul>
   <li>A and B have equal {@link #isDirected() directedness}.
   <li>A and B have equal {@link #nodes() node sets}.
   <li>A and B have equal {@link #edges() edge sets}.
   <li>The {@link #edgeValueOrDefault(N, N, V) value} of a given edge is the same in both A and
       B.
 </ul>

 <p>Graph properties besides {@link #isDirected() directedness} do <b>not</b> affect equality.
 For example, two graphs may be considered equal even if one allows self-loops and the other
 doesn't. Additionally, the order in which nodes or edges are added to the graph, and the order
 in which they are iterated over, are irrelevant.

 <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the hash code for this graph. The hash code of a graph is defined as the hash code of a
 map from each of its {@link #edges() edges} to the associated {@link #edgeValueOrDefault(N, N,
 V) edge value}.

 <p>A reference implementation of this is provided by {@link AbstractValueGraph#hashCode()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface for <a
 href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a>-structured data,
 whose edges have associated non-unique values.

 <p>A graph is composed of a set of nodes and a set of edges connecting pairs of nodes.

 <p>There are three primary interfaces provided to represent graphs. In order of increasing
 complexity they are: {@link Graph}, {@link ValueGraph}, and {@link Network}. You should generally
 prefer the simplest interface that satisfies your use case. See the <a
 href="https://github.com/google/guava/wiki/GraphsExplained#choosing-the-right-graph-type">
 "Choosing the right graph type"</a> section of the Guava User Guide for more details.

 <h3>Capabilities</h3>

 <p>{@code ValueGraph} supports the following use cases (<a
 href="https://github.com/google/guava/wiki/GraphsExplained#definitions">definitions of
 terms</a>):

 <ul>
   <li>directed graphs
   <li>undirected graphs
   <li>graphs that do/don't allow self-loops
   <li>graphs whose nodes/edges are insertion-ordered, sorted, or unordered
   <li>graphs whose edges have associated values
 </ul>

 <p>{@code ValueGraph}, as a subtype of {@code Graph}, explicitly does not support parallel edges,
 and forbids implementations or extensions with parallel edges. If you need parallel edges, use
 {@link Network}. (You can use a positive {@code Integer} edge value as a loose representation of
 edge multiplicity, but the {@code *degree()} and mutation methods will not reflect your
 interpretation of the edge value as its multiplicity.)

 <h3>Building a {@code ValueGraph}</h3>

 <p>The implementation classes that {@code common.graph} provides are not public, by design. To
 create an instance of one of the built-in implementations of {@code ValueGraph}, use the {@link
 ValueGraphBuilder} class:

 {@snippet :
 MutableValueGraph<Integer, Double> graph = ValueGraphBuilder.directed().build();
 }

 <p>{@link ValueGraphBuilder#build()} returns an instance of {@link MutableValueGraph}, which is a
 subtype of {@code ValueGraph} that provides methods for adding and removing nodes and edges. If
 you do not need to mutate a graph (e.g. if you write a method than runs a read-only algorithm on
 the graph), you should use the non-mutating {@link ValueGraph} interface, or an {@link
 ImmutableValueGraph}.

 <p>You can create an immutable copy of an existing {@code ValueGraph} using {@link
 ImmutableValueGraph#copyOf(ValueGraph)}:

 {@snippet :
 ImmutableValueGraph<Integer, Double> immutableGraph = ImmutableValueGraph.copyOf(graph);
 }

 <p>Instances of {@link ImmutableValueGraph} do not implement {@link MutableValueGraph}
 (obviously!) and are contractually guaranteed to be unmodifiable and thread-safe.

 <p>The Guava User Guide has <a
 href="https://github.com/google/guava/wiki/GraphsExplained#building-graph-instances">more
 information on (and examples of) building graphs</a>.

 <h3>Additional documentation</h3>

 <p>See the Guava User Guide for the {@code common.graph} package (<a
 href="https://github.com/google/guava/wiki/GraphsExplained">"Graphs Explained"</a>) for
 additional documentation, including:

 <ul>
   <li><a
       href="https://github.com/google/guava/wiki/GraphsExplained#equals-hashcode-and-graph-equivalence">
       {@code equals()}, {@code hashCode()}, and graph equivalence</a>
   <li><a href="https://github.com/google/guava/wiki/GraphsExplained#synchronization">
       Synchronization policy</a>
   <li><a href="https://github.com/google/guava/wiki/GraphsExplained#notes-for-implementors">Notes
       for implementors</a>
 </ul>

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> Node parameter type
 @param <V> Value parameter type
 @since 20.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.graph.ValueGraph -->
  <!-- start class com.google.common.graph.ValueGraphBuilder -->
  <class name="ValueGraphBuilder" extends="com.google.common.graph.AbstractGraphBuilder&lt;N&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="directed" return="com.google.common.graph.ValueGraphBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link ValueGraphBuilder} for building directed graphs.]]>
      </doc>
    </method>
    <method name="undirected" return="com.google.common.graph.ValueGraphBuilder&lt;java.lang.Object, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link ValueGraphBuilder} for building undirected graphs.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.graph.ValueGraphBuilder&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.ValueGraph&lt;N, V&gt;"/>
      <doc>
      <![CDATA[Returns a {@link ValueGraphBuilder} initialized with all properties queryable from {@code
 graph}.

 <p>The "queryable" properties are those that are exposed through the {@link ValueGraph}
 interface, such as {@link ValueGraph#isDirected()}. Other properties, such as {@link
 #expectedNodeCount(int)}, are not set in the new builder.]]>
      </doc>
    </method>
    <method name="immutable" return="com.google.common.graph.ImmutableValueGraph.Builder&lt;N1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link ImmutableValueGraph.Builder} with the properties of this {@link
 ValueGraphBuilder}.

 <p>The returned builder can be used for populating an {@link ImmutableValueGraph}.

 <p>Note that the returned builder will always have {@link #incidentEdgeOrder} set to {@link
 ElementOrder#stable()}, regardless of the value that was set in this builder.

 @since 28.0]]>
      </doc>
    </method>
    <method name="allowsSelfLoops" return="com.google.common.graph.ValueGraphBuilder&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allowsSelfLoops" type="boolean"/>
      <doc>
      <![CDATA[Specifies whether the graph will allow self-loops (edges that connect a node to itself).
 Attempting to add a self-loop to a graph that does not allow them will throw an {@link
 UnsupportedOperationException}.

 <p>The default value is {@code false}.]]>
      </doc>
    </method>
    <method name="expectedNodeCount" return="com.google.common.graph.ValueGraphBuilder&lt;N, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedNodeCount" type="int"/>
      <doc>
      <![CDATA[Specifies the expected number of nodes in the graph.

 @throws IllegalArgumentException if {@code expectedNodeCount} is negative]]>
      </doc>
    </method>
    <method name="nodeOrder" return="com.google.common.graph.ValueGraphBuilder&lt;N1, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeOrder" type="com.google.common.graph.ElementOrder&lt;N1&gt;"/>
      <doc>
      <![CDATA[Specifies the order of iteration for the elements of {@link Graph#nodes()}.

 <p>The default value is {@link ElementOrder#insertion() insertion order}.]]>
      </doc>
    </method>
    <method name="incidentEdgeOrder" return="com.google.common.graph.ValueGraphBuilder&lt;N1, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="incidentEdgeOrder" type="com.google.common.graph.ElementOrder&lt;N1&gt;"/>
      <doc>
      <![CDATA[Specifies the order of iteration for the elements of {@link ValueGraph#edges()}, {@link
 ValueGraph#adjacentNodes(Object)}, {@link ValueGraph#predecessors(Object)}, {@link
 ValueGraph#successors(Object)} and {@link ValueGraph#incidentEdges(Object)}.

 <p>The default value is {@link ElementOrder#unordered() unordered} for mutable graphs. For
 immutable graphs, this value is ignored; they always have a {@link ElementOrder#stable()
 stable} order.

 @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code
     ElementOrder.unordered()} or {@code ElementOrder.stable()}.
 @since 29.0]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.graph.MutableValueGraph&lt;N1, V1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty {@link MutableValueGraph} with the properties of this {@link
 ValueGraphBuilder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for constructing instances of {@link MutableValueGraph} or {@link ImmutableValueGraph}
 with user-defined properties.

 <p>A {@code ValueGraph} built by this class has the following default properties:

 <ul>
   <li>does not allow self-loops
   <li>orders {@link ValueGraph#nodes()} in the order in which the elements were added (insertion
       order)
 </ul>

 <p>{@code ValueGraph}s built by this class also guarantee that each collection-returning accessor
 returns a <b>(live) unmodifiable view</b>; see <a
 href="https://github.com/google/guava/wiki/GraphsExplained#accessor-behavior">the external
 documentation</a> for details.

 <p>Examples of use:

 {@snippet :
 // Building a mutable value graph
 MutableValueGraph<String, Double> graph =
     ValueGraphBuilder.undirected().allowsSelfLoops(true).build();
 graph.putEdgeValue("San Francisco", "San Francisco", 0.0);
 graph.putEdgeValue("San Jose", "San Jose", 0.0);
 graph.putEdgeValue("San Francisco", "San Jose", 48.4);

 // Building an immutable value graph
 ImmutableValueGraph<String, Double> immutableGraph =
     ValueGraphBuilder.undirected()
         .allowsSelfLoops(true)
         .<String, Double>immutable()
         .putEdgeValue("San Francisco", "San Francisco", 0.0)
         .putEdgeValue("San Jose", "San Jose", 0.0)
         .putEdgeValue("San Francisco", "San Jose", 48.4)
         .build();
 }

 @author James Sexton
 @author Joshua O'Madadhain
 @param <N> The most general node type this builder will support. This is normally {@code Object}
     unless it is constrained by using a method like {@link #nodeOrder}, or the builder is
     constructed based on an existing {@code ValueGraph} using {@link #from(ValueGraph)}.
 @param <V> The most general value type this builder will support. This is normally {@code Object}
     unless the builder is constructed based on an existing {@code Graph} using {@link
     #from(ValueGraph)}.
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.graph.ValueGraphBuilder -->
</package>
<package name="com.google.common.hash">
  <!-- start class com.google.common.hash.BloomFilter -->
  <class name="BloomFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.base.Predicate&lt;T&gt;"/>
    <implements name="java.io.Serializable"/>
    <method name="copy" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code BloomFilter} that's a copy of this instance. The new instance is equal to
 this instance but shares no mutable state.

 @since 12.0]]>
      </doc>
    </method>
    <method name="mightContain" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Returns {@code true} if the element <i>might</i> have been put in this Bloom filter, {@code
 false} if this is <i>definitely</i> not the case.]]>
      </doc>
    </method>
    <method name="apply" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Provided only to satisfy the {@link Predicate} interface; use {@link #mightContain}
     instead.">
      <param name="input" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[@deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #mightContain}
     instead.]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Puts an element into this {@code BloomFilter}. Ensures that subsequent invocations of {@link
 #mightContain(Object)} with the same element will always return {@code true}.

 @return true if the Bloom filter's bits changed as a result of this operation. If the bits
     changed, this is <i>definitely</i> the first time {@code object} has been added to the
     filter. If the bits haven't changed, this <i>might</i> be the first time {@code object} has
     been added to the filter. Note that {@code put(t)} always returns the <i>opposite</i>
     result to what {@code mightContain(t)} would have returned at the time it is called.
 @since 12.0 (present in 11.0 with {@code void} return type})]]>
      </doc>
    </method>
    <method name="expectedFpp" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the probability that {@linkplain #mightContain(Object)} will erroneously return {@code
 true} for an object that has not actually been put in the {@code BloomFilter}.

 <p>Ideally, this number should be close to the {@code fpp} parameter passed in {@linkplain
 #create(Funnel, int, double)}, or smaller. If it is significantly higher, it is usually the
 case that too many elements (more than expected) have been put in the {@code BloomFilter},
 degenerating it.

 @since 14.0 (since 11.0 as expectedFalsePositiveProbability())]]>
      </doc>
    </method>
    <method name="approximateElementCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an estimate for the total number of distinct elements that have been added to this
 Bloom filter. This approximation is reasonably accurate if it does not exceed the value of
 {@code expectedInsertions} that was used when constructing the filter.

 @since 22.0]]>
      </doc>
    </method>
    <method name="isCompatible" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="com.google.common.hash.BloomFilter&lt;T&gt;"/>
      <doc>
      <![CDATA[Determines whether a given Bloom filter is compatible with this Bloom filter. For two Bloom
 filters to be compatible, they must:

 <ul>
   <li>not be the same instance
   <li>have the same number of hash functions
   <li>have the same bit size
   <li>have the same strategy
   <li>have equal funnels
 </ul>

 @param that The Bloom filter to check for compatibility.
 @since 15.0]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="com.google.common.hash.BloomFilter&lt;T&gt;"/>
      <doc>
      <![CDATA[Combines this Bloom filter with another Bloom filter by performing a bitwise OR of the
 underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the Bloom
 filters are appropriately sized to avoid saturating them.

 @param that The Bloom filter to combine this Bloom filter with. It is not mutated.
 @throws IllegalArgumentException if {@code isCompatible(that) == false}
 @since 15.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toBloomFilter" return="java.util.stream.Collector&lt;T, ?, com.google.common.hash.BloomFilter&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <param name="expectedInsertions" type="long"/>
      <doc>
      <![CDATA[Returns a {@code Collector} expecting the specified number of insertions, and yielding a {@link
 BloomFilter} with false positive probability 3%.

 <p>Note that if the {@code Collector} receives significantly more elements than specified, the
 resulting {@code BloomFilter} will suffer a sharp deterioration of its false positive
 probability.

 <p>The constructed {@code BloomFilter} will be serializable if the provided {@code Funnel<T>}
 is.

 <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of
 ensuring proper serialization and deserialization, which is important since {@link #equals}
 also relies on object identity of funnels.

 @param funnel the funnel of T's that the constructed {@code BloomFilter} will use
 @param expectedInsertions the number of expected insertions to the constructed {@code
     BloomFilter}; must be positive
 @return a {@code Collector} generating a {@code BloomFilter} of the received elements
 @since 33.4.0 (but since 23.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toBloomFilter" return="java.util.stream.Collector&lt;T, ?, com.google.common.hash.BloomFilter&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <param name="expectedInsertions" type="long"/>
      <param name="fpp" type="double"/>
      <doc>
      <![CDATA[Returns a {@code Collector} expecting the specified number of insertions, and yielding a {@link
 BloomFilter} with the specified expected false positive probability.

 <p>Note that if the {@code Collector} receives significantly more elements than specified, the
 resulting {@code BloomFilter} will suffer a sharp deterioration of its false positive
 probability.

 <p>The constructed {@code BloomFilter} will be serializable if the provided {@code Funnel<T>}
 is.

 <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of
 ensuring proper serialization and deserialization, which is important since {@link #equals}
 also relies on object identity of funnels.

 @param funnel the funnel of T's that the constructed {@code BloomFilter} will use
 @param expectedInsertions the number of expected insertions to the constructed {@code
     BloomFilter}; must be positive
 @param fpp the desired false positive probability (must be positive and less than 1.0)
 @return a {@code Collector} generating a {@code BloomFilter} of the received elements
 @since 33.4.0 (but since 23.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <param name="expectedInsertions" type="int"/>
      <param name="fpp" type="double"/>
      <doc>
      <![CDATA[Creates a {@link BloomFilter} with the expected number of insertions and expected false
 positive probability.

 <p>Note that overflowing a {@code BloomFilter} with significantly more elements than specified,
 will result in its saturation, and a sharp deterioration of its false positive probability.

 <p>The constructed {@code BloomFilter} will be serializable if the provided {@code Funnel<T>}
 is.

 <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of
 ensuring proper serialization and deserialization, which is important since {@link #equals}
 also relies on object identity of funnels.

 @param funnel the funnel of T's that the constructed {@code BloomFilter} will use
 @param expectedInsertions the number of expected insertions to the constructed {@code
     BloomFilter}; must be positive
 @param fpp the desired false positive probability (must be positive and less than 1.0)
 @return a {@code BloomFilter}]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <param name="expectedInsertions" type="long"/>
      <param name="fpp" type="double"/>
      <doc>
      <![CDATA[Creates a {@link BloomFilter} with the expected number of insertions and expected false
 positive probability.

 <p>Note that overflowing a {@code BloomFilter} with significantly more elements than specified,
 will result in its saturation, and a sharp deterioration of its false positive probability.

 <p>The constructed {@code BloomFilter} will be serializable if the provided {@code Funnel<T>}
 is.

 <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of
 ensuring proper serialization and deserialization, which is important since {@link #equals}
 also relies on object identity of funnels.

 @param funnel the funnel of T's that the constructed {@code BloomFilter} will use
 @param expectedInsertions the number of expected insertions to the constructed {@code
     BloomFilter}; must be positive
 @param fpp the desired false positive probability (must be positive and less than 1.0)
 @return a {@code BloomFilter}
 @since 19.0]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <param name="expectedInsertions" type="int"/>
      <doc>
      <![CDATA[Creates a {@link BloomFilter} with the expected number of insertions and a default expected
 false positive probability of 3%.

 <p>Note that overflowing a {@code BloomFilter} with significantly more elements than specified,
 will result in its saturation, and a sharp deterioration of its false positive probability.

 <p>The constructed {@code BloomFilter} will be serializable if the provided {@code Funnel<T>}
 is.

 <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of
 ensuring proper serialization and deserialization, which is important since {@link #equals}
 also relies on object identity of funnels.

 @param funnel the funnel of T's that the constructed {@code BloomFilter} will use
 @param expectedInsertions the number of expected insertions to the constructed {@code
     BloomFilter}; must be positive
 @return a {@code BloomFilter}]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <param name="expectedInsertions" type="long"/>
      <doc>
      <![CDATA[Creates a {@link BloomFilter} with the expected number of insertions and a default expected
 false positive probability of 3%.

 <p>Note that overflowing a {@code BloomFilter} with significantly more elements than specified,
 will result in its saturation, and a sharp deterioration of its false positive probability.

 <p>The constructed {@code BloomFilter} will be serializable if the provided {@code Funnel<T>}
 is.

 <p>It is recommended that the funnel be implemented as a Java enum. This has the benefit of
 ensuring proper serialization and deserialization, which is important since {@link #equals}
 also relies on object identity of funnels.

 @param funnel the funnel of T's that the constructed {@code BloomFilter} will use
 @param expectedInsertions the number of expected insertions to the constructed {@code
     BloomFilter}; must be positive
 @return a {@code BloomFilter}
 @since 19.0]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes this {@code BloomFilter} to an output stream, with a custom format (not Java
 serialization). This has been measured to save at least 400 bytes compared to regular
 serialization.

 <p>Use {@linkplain #readFrom(InputStream, Funnel)} to reconstruct the written BloomFilter.]]>
      </doc>
    </method>
    <method name="readFrom" return="com.google.common.hash.BloomFilter&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a byte stream, which was written by {@linkplain #writeTo(OutputStream)}, into a {@code
 BloomFilter}.

 <p>The {@code Funnel} to be used is not encoded in the stream, so it must be provided here.
 <b>Warning:</b> the funnel provided <b>must</b> behave identically to the one used to populate
 the original Bloom filter!

 @throws IOException if the InputStream throws an {@code IOException}, or if its data does not
     appear to be a BloomFilter serialized using the {@linkplain #writeTo(OutputStream)} method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Bloom filter for instances of {@code T}. A Bloom filter offers an approximate containment test
 with one-sided error: if it claims that an element is contained in it, this might be in error,
 but if it claims that an element is <i>not</i> contained in it, then this is definitely true.

 <p>If you are unfamiliar with Bloom filters, this nice <a
 href="http://llimllib.github.io/bloomfilter-tutorial/">tutorial</a> may help you understand how
 they work.

 <p>The false positive probability ({@code FPP}) of a Bloom filter is defined as the probability
 that {@linkplain #mightContain(Object)} will erroneously return {@code true} for an object that
 has not actually been put in the {@code BloomFilter}.

 <p>Bloom filters are serializable. They also support a more compact serial representation via the
 {@link #writeTo} and {@link #readFrom} methods. Both serialized forms will continue to be
 supported by future versions of this library. However, serial forms generated by newer versions
 of the code may not be readable by older versions of the code (e.g., a serialized Bloom filter
 generated today may <i>not</i> be readable by a binary that was compiled 6 months ago).

 <p>As of Guava 23.0, this class is thread-safe and lock-free. It internally uses atomics and
 compare-and-swap to ensure correctness when multiple threads are used to access it.

 @param <T> the type of instances that the {@code BloomFilter} accepts
 @author Dimitris Andreou
 @author Kevin Bourrillion
 @since 11.0 (thread-safe since 23.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.BloomFilter -->
  <!-- start interface com.google.common.hash.Funnel -->
  <interface name="Funnel"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="funnel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="T extends java.lang.Object"/>
      <param name="into" type="com.google.common.hash.PrimitiveSink"/>
      <doc>
      <![CDATA[Sends a stream of data from the {@code from} object into the sink {@code into}. There is no
 requirement that this data be complete enough to fully reconstitute the object later.

 @since 12.0 (in Guava 11.0, {@code PrimitiveSink} was named {@code Sink})]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object which can send data from an object of type {@code T} into a {@code PrimitiveSink}.
 Implementations for common types can be found in {@link Funnels}.

 <p>Note that serialization of {@linkplain BloomFilter bloom filters} requires the proper
 serialization of funnels. When possible, it is recommended that funnels be implemented as a
 single-element enum to maintain serialization guarantees. See Effective Java (2nd Edition), Item
 3: "Enforce the singleton property with a private constructor or an enum type". For example:

 {@snippet :
 public enum PersonFunnel implements Funnel<Person> {
   INSTANCE;
   public void funnel(Person person, PrimitiveSink into) {
     into.putUnencodedChars(person.getFirstName())
         .putUnencodedChars(person.getLastName())
         .putInt(person.getAge());
   }
 }
 }

 @author Dimitris Andreou
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.Funnel -->
  <!-- start class com.google.common.hash.Funnels -->
  <class name="Funnels" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="byteArrayFunnel" return="com.google.common.hash.Funnel&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel that extracts the bytes from a {@code byte} array.]]>
      </doc>
    </method>
    <method name="unencodedCharsFunnel" return="com.google.common.hash.Funnel&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel that extracts the characters from a {@code CharSequence}, a character at a
 time, without performing any encoding. If you need to use a specific encoding, use {@link
 Funnels#stringFunnel(Charset)} instead.

 @since 15.0 (since 11.0 as {@code Funnels.stringFunnel()}.]]>
      </doc>
    </method>
    <method name="stringFunnel" return="com.google.common.hash.Funnel&lt;java.lang.CharSequence&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a funnel that encodes the characters of a {@code CharSequence} with the specified
 {@code Charset}.

 @since 15.0]]>
      </doc>
    </method>
    <method name="integerFunnel" return="com.google.common.hash.Funnel&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel for integers.

 @since 13.0]]>
      </doc>
    </method>
    <method name="sequentialFunnel" return="com.google.common.hash.Funnel&lt;java.lang.Iterable&lt;? extends E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementFunnel" type="com.google.common.hash.Funnel&lt;E&gt;"/>
      <doc>
      <![CDATA[Returns a funnel that processes an {@code Iterable} by funneling its elements in iteration
 order with the specified funnel. No separators are added between the elements.

 @since 15.0]]>
      </doc>
    </method>
    <method name="longFunnel" return="com.google.common.hash.Funnel&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a funnel for longs.

 @since 13.0]]>
      </doc>
    </method>
    <method name="asOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sink" type="com.google.common.hash.PrimitiveSink"/>
      <doc>
      <![CDATA[Wraps a {@code PrimitiveSink} as an {@link OutputStream}, so it is easy to {@link Funnel#funnel
 funnel} an object to a {@code PrimitiveSink} if there is already a way to write the contents of
 the object to an {@code OutputStream}.

 <p>The {@code close} and {@code flush} methods of the returned {@code OutputStream} do nothing,
 and no method throws {@code IOException}.

 @since 13.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Funnels for common types. All implementations are serializable.

 @author Dimitris Andreou
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.Funnels -->
  <!-- start class com.google.common.hash.HashCode -->
  <class name="HashCode" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="bits" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bits in this hash code; a positive multiple of 8.]]>
      </doc>
    </method>
    <method name="asInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the first four bytes of {@linkplain #asBytes() this hashcode's bytes}, converted to an
 {@code int} value in little-endian order.

 @throws IllegalStateException if {@code bits() < 32}]]>
      </doc>
    </method>
    <method name="asLong" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the first eight bytes of {@linkplain #asBytes() this hashcode's bytes}, converted to a
 {@code long} value in little-endian order.

 @throws IllegalStateException if {@code bits() < 64}]]>
      </doc>
    </method>
    <method name="padToLong" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If this hashcode has enough bits, returns {@code asLong()}, otherwise returns a {@code long}
 value with {@code asBytes()} as the least-significant bytes and {@code 0x00} as the remaining
 most-significant bytes.

 @since 14.0 (since 11.0 as {@code Hashing.padToLong(HashCode)})]]>
      </doc>
    </method>
    <method name="asBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this hash code as a byte array. The caller may modify the byte array;
 changes to it will <i>not</i> be reflected in this {@code HashCode} object or any other arrays
 returned by this method.]]>
      </doc>
    </method>
    <method name="writeBytesTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dest" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="maxLength" type="int"/>
      <doc>
      <![CDATA[Copies bytes from this hash code into {@code dest}.

 @param dest the byte array into which the hash code will be written
 @param offset the start offset in the data
 @param maxLength the maximum number of bytes to write
 @return the number of bytes written to {@code dest}
 @throws IndexOutOfBoundsException if there is not enough room in {@code dest}]]>
      </doc>
    </method>
    <method name="fromInt" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hash" type="int"/>
      <doc>
      <![CDATA[Creates a 32-bit {@code HashCode} representation of the given int value. The underlying bytes
 are interpreted in little endian order.

 @since 15.0 (since 12.0 in HashCodes)]]>
      </doc>
    </method>
    <method name="fromLong" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hash" type="long"/>
      <doc>
      <![CDATA[Creates a 64-bit {@code HashCode} representation of the given long value. The underlying bytes
 are interpreted in little endian order.

 @since 15.0 (since 12.0 in HashCodes)]]>
      </doc>
    </method>
    <method name="fromBytes" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Creates a {@code HashCode} from a byte array. The array is defensively copied to preserve the
 immutability contract of {@code HashCode}. The array cannot be empty.

 @since 15.0 (since 12.0 in HashCodes)]]>
      </doc>
    </method>
    <method name="fromString" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a {@code HashCode} from a hexadecimal ({@code base 16}) encoded string. The string must
 be at least 2 characters long, and contain only valid, lower-cased hexadecimal characters.

 <p>This method accepts the exact format generated by {@link #toString}. If you require more
 lenient {@code base 16} decoding, please use {@link com.google.common.io.BaseEncoding#decode}
 (and pass the result to {@link #fromBytes}).

 @since 15.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is a {@link HashCode} instance with the identical byte
 representation to this hash code.

 <p><b>Security note:</b> this method uses a constant-time (not short-circuiting) implementation
 to protect against <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a "Java hash code" for this {@code HashCode} instance; this is well-defined (so, for
 example, you can safely put {@code HashCode} instances into a {@code HashSet}) but is otherwise
 probably not what you want to use.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string containing each byte of {@link #asBytes}, in order, as a two-digit unsigned
 hexadecimal number in lower case.

 <p>Note that if the output is considered to be a single hexadecimal number, whether this string
 is big-endian or little-endian depends on the byte order of {@link #asBytes}. This may be
 surprising for implementations of {@code HashCode} that represent the number in big-endian
 since everything else in the hashing API uniformly treats multibyte values as little-endian.

 <p>To create a {@code HashCode} from its string representation, see {@link #fromString}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable hash code of arbitrary bit length.

 @author Dimitris Andreou
 @author Kurt Alfred Kluever
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.HashCode -->
  <!-- start interface com.google.common.hash.Hasher -->
  <interface name="Hasher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.hash.PrimitiveSink"/>
    <method name="putByte" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
    </method>
    <method name="putBytes" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
    </method>
    <method name="putBytes" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="putBytes" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="java.nio.ByteBuffer"/>
    </method>
    <method name="putShort" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="short"/>
    </method>
    <method name="putInt" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="putLong" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
    </method>
    <method name="putFloat" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <doc>
      <![CDATA[Equivalent to {@code putInt(Float.floatToRawIntBits(f))}.]]>
      </doc>
    </method>
    <method name="putDouble" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <doc>
      <![CDATA[Equivalent to {@code putLong(Double.doubleToRawLongBits(d))}.]]>
      </doc>
    </method>
    <method name="putBoolean" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Equivalent to {@code putByte(b ? (byte) 1 : (byte) 0)}.]]>
      </doc>
    </method>
    <method name="putChar" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
    </method>
    <method name="putUnencodedChars" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Equivalent to processing each {@code char} value in the {@code CharSequence}, in order. In
 other words, no character encoding is performed; the low byte and high byte of each {@code
 char} are hashed directly (in that order). The input must not be updated while this method is
 in progress.

 <p><b>Warning:</b> This method will produce different output than most other languages do when
 running the same hash function on the equivalent input. For cross-language compatibility, use
 {@link #putString}, usually with a charset of UTF-8. For other use cases, use {@code
 putUnencodedChars}.

 @since 15.0 (since 11.0 as putString(CharSequence)).]]>
      </doc>
    </method>
    <method name="putString" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Equivalent to {@code putBytes(charSequence.toString().getBytes(charset))}.

 <p><b>Warning:</b> This method, which reencodes the input before hashing it, is useful only for
 cross-language compatibility. For other use cases, prefer {@link #putUnencodedChars}, which is
 faster, produces the same output across Java releases, and hashes every {@code char} in the
 input, even if some are invalid.]]>
      </doc>
    </method>
    <method name="putObject" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T extends java.lang.Object"/>
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <doc>
      <![CDATA[A simple convenience for {@code funnel.funnel(object, this)}.]]>
      </doc>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a hash code based on the data that have been provided to this hasher. The result is
 unspecified if this method is called more than once on the same instance.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This returns {@link Object#hashCode()}; you almost certainly mean to call {@code
     hash().asInt()}.">
      <doc>
      <![CDATA[{@inheritDoc}

 @deprecated This returns {@link Object#hashCode()}; you almost certainly mean to call {@code
     hash().asInt()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link PrimitiveSink} that can compute a hash code after reading the input. Each hasher should
 translate all multibyte values ({@link #putInt(int)}, {@link #putLong(long)}, etc) to bytes in
 little-endian order.

 <p><b>Warning:</b> The result of calling any methods after calling {@link #hash} is undefined.

 <p><b>Warning:</b> Using a specific character encoding when hashing a {@link CharSequence} with
 {@link #putString(CharSequence, Charset)} is generally only useful for cross-language
 compatibility (otherwise prefer {@link #putUnencodedChars}). However, the character encodings
 must be identical across languages. Also beware that {@link Charset} definitions may occasionally
 change between Java releases.

 <p><b>Warning:</b> Chunks of data that are put into the {@link Hasher} are not delimited. The
 resulting {@link HashCode} is dependent only on the bytes inserted, and the order in which they
 were inserted, not how those bytes were chunked into discrete put() operations. For example, the
 following three expressions all generate colliding hash codes:

 {@snippet :
 newHasher().putByte(b1).putByte(b2).putByte(b3).hash()
 newHasher().putByte(b1).putBytes(new byte[] { b2, b3 }).hash()
 newHasher().putBytes(new byte[] { b1, b2, b3 }).hash()
 }

 <p>If you wish to avoid this, you should either prepend or append the size of each chunk. Keep in
 mind that when dealing with char sequences, the encoded form of two concatenated char sequences
 is not equivalent to the concatenation of their encoded form. Therefore, {@link
 #putString(CharSequence, Charset)} should only be used consistently with <i>complete</i>
 sequences and not broken into chunks.

 @author Kevin Bourrillion
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.Hasher -->
  <!-- start interface com.google.common.hash.HashFunction -->
  <interface name="HashFunction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newHasher" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Begins a new hash code computation by returning an initialized, stateful {@code Hasher}
 instance that is ready to receive data. Example:

 {@snippet :
 HashFunction hf = Hashing.md5();
 HashCode hc = hf.newHasher()
     .putLong(id)
     .putBoolean(isActive)
     .hash();
 }]]>
      </doc>
    </method>
    <method name="newHasher" return="com.google.common.hash.Hasher"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedInputSize" type="int"/>
      <doc>
      <![CDATA[Begins a new hash code computation as {@link #newHasher()}, but provides a hint of the expected
 size of the input (in bytes). This is only important for non-streaming hash functions (hash
 functions that need to buffer their whole input before processing any of it).]]>
      </doc>
    </method>
    <method name="hashInt" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="int"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putInt(input).hash()}; returns the hash code for the given
 {@code int} value, interpreted in little-endian byte order. The implementation <i>might</i>
 perform better than its longhand equivalent, but should not perform worse.

 @since 12.0]]>
      </doc>
    </method>
    <method name="hashLong" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="long"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putLong(input).hash()}; returns the hash code for the given
 {@code long} value, interpreted in little-endian byte order. The implementation <i>might</i>
 perform better than its longhand equivalent, but should not perform worse.]]>
      </doc>
    </method>
    <method name="hashBytes" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putBytes(input).hash()}. The implementation <i>might</i>
 perform better than its longhand equivalent, but should not perform worse.]]>
      </doc>
    </method>
    <method name="hashBytes" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putBytes(input, off, len).hash()}. The implementation
 <i>might</i> perform better than its longhand equivalent, but should not perform worse.

 @throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length} or
     {@code len < 0}]]>
      </doc>
    </method>
    <method name="hashBytes" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putBytes(input).hash()}. The implementation <i>might</i>
 perform better than its longhand equivalent, but should not perform worse.

 @since 23.0]]>
      </doc>
    </method>
    <method name="hashUnencodedChars" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putUnencodedChars(input).hash()}. The implementation
 <i>might</i> perform better than its longhand equivalent, but should not perform worse. Note
 that no character encoding is performed; the low byte and high byte of each {@code char} are
 hashed directly (in that order).

 <p><b>Warning:</b> This method will produce different output than most other languages do when
 running the same hash function on the equivalent input. For cross-language compatibility, use
 {@link #hashString}, usually with a charset of UTF-8. For other use cases, use {@code
 hashUnencodedChars}.

 @since 15.0 (since 11.0 as hashString(CharSequence)).]]>
      </doc>
    </method>
    <method name="hashString" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putString(input, charset).hash()}. Characters are encoded using
 the given {@link Charset}. The implementation <i>might</i> perform better than its longhand
 equivalent, but should not perform worse.

 <p><b>Warning:</b> This method, which reencodes the input before hashing it, is useful only for
 cross-language compatibility. For other use cases, prefer {@link #hashUnencodedChars}, which is
 faster, produces the same output across Java releases, and hashes every {@code char} in the
 input, even if some are invalid.]]>
      </doc>
    </method>
    <method name="hashObject" return="com.google.common.hash.HashCode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T extends java.lang.Object"/>
      <param name="funnel" type="com.google.common.hash.Funnel&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Shortcut for {@code newHasher().putObject(instance, funnel).hash()}. The implementation
 <i>might</i> perform better than its longhand equivalent, but should not perform worse.

 @since 14.0]]>
      </doc>
    </method>
    <method name="bits" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bits (a multiple of 32) that each hash code produced by this hash
 function has.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A hash function is a collision-averse pure function that maps an arbitrary block of data to a
 number called a <i>hash code</i>.

 <h3>Definition</h3>

 <p>Unpacking this definition:

 <ul>
   <li><b>block of data:</b> the input for a hash function is always, in concept, an ordered byte
       array. This hashing API accepts an arbitrary sequence of byte and multibyte values (via
       {@link Hasher}), but this is merely a convenience; these are always translated into raw
       byte sequences under the covers.
   <li><b>hash code:</b> each hash function always yields hash codes of the same fixed bit length
       (given by {@link #bits}). For example, {@link Hashing#sha1} produces a 160-bit number,
       while {@link Hashing#murmur3_32()} yields only 32 bits. Because a {@code long} value is
       clearly insufficient to hold all hash code values, this API represents a hash code as an
       instance of {@link HashCode}.
   <li><b>pure function:</b> the value produced must depend only on the input bytes, in the order
       they appear. Input data is never modified. {@link HashFunction} instances should always be
       stateless, and therefore thread-safe.
   <li><b>collision-averse:</b> while it can't be helped that a hash function will sometimes
       produce the same hash code for distinct inputs (a "collision"), every hash function strives
       to <i>some</i> degree to make this unlikely. (Without this condition, a function that
       always returns zero could be called a hash function. It is not.)
 </ul>

 <p>Summarizing the last two points: "equal yield equal <i>always</i>; unequal yield unequal
 <i>often</i>." This is the most important characteristic of all hash functions.

 <h3>Desirable properties</h3>

 <p>A high-quality hash function strives for some subset of the following virtues:

 <ul>
   <li><b>collision-resistant:</b> while the definition above requires making at least <i>some</i>
       token attempt, one measure of the quality of a hash function is <i>how well</i> it succeeds
       at this goal. Important note: it may be easy to achieve the theoretical minimum collision
       rate when using completely <i>random</i> sample input. The true test of a hash function is
       how it performs on representative real-world data, which tends to contain many hidden
       patterns and clumps. The goal of a good hash function is to stamp these patterns out as
       thoroughly as possible.
   <li><b>bit-dispersing:</b> masking out any <i>single bit</i> from a hash code should yield only
       the expected <i>twofold</i> increase to all collision rates. Informally, the "information"
       in the hash code should be as evenly "spread out" through the hash code's bits as possible.
       The result is that, for example, when choosing a bucket in a hash table of size 2^8,
       <i>any</i> eight bits could be consistently used.
   <li><b>cryptographic:</b> certain hash functions such as {@link Hashing#sha512} are designed to
       make it as infeasible as possible to reverse-engineer the input that produced a given hash
       code, or even to discover <i>any</i> two distinct inputs that yield the same result. These
       are called <i>cryptographic hash functions</i>. But, whenever it is learned that either of
       these feats has become computationally feasible, the function is deemed "broken" and should
       no longer be used for secure purposes. (This is the likely eventual fate of <i>all</i>
       cryptographic hashes.)
   <li><b>fast:</b> perhaps self-explanatory, but often the most important consideration.
 </ul>

 <h3>Providing input to a hash function</h3>

 <p>The primary way to provide the data that your hash function should act on is via a {@link
 Hasher}. Obtain a new hasher from the hash function using {@link #newHasher}, "push" the relevant
 data into it using methods like {@link Hasher#putBytes(byte[])}, and finally ask for the {@code
 HashCode} when finished using {@link Hasher#hash}. (See an {@linkplain #newHasher example} of
 this.)

 <p>If all you want to hash is a single byte array, string or {@code long} value, there are
 convenient shortcut methods defined directly on {@link HashFunction} to make this easier.

 <p>Hasher accepts primitive data types, but can also accept any Object of type {@code T} provided
 that you implement a {@link Funnel}{@code <T>} to specify how to "feed" data from that object
 into the function. (See {@linkplain Hasher#putObject an example} of this.)

 <p><b>Compatibility note:</b> Throughout this API, multibyte values are always interpreted in
 <i>little-endian</i> order. That is, hashing the byte array {@code {0x01, 0x02, 0x03, 0x04}} is
 equivalent to hashing the {@code int} value {@code 0x04030201}. If this isn't what you need,
 methods such as {@link Integer#reverseBytes} and {@link Ints#toByteArray} will help.

 <h3>Relationship to {@link Object#hashCode}</h3>

 <p>Java's baked-in concept of hash codes is constrained to 32 bits, and provides no separation
 between hash algorithms and the data they act on, so alternate hash algorithms can't be easily
 substituted. Also, implementations of {@code hashCode} tend to be poor-quality, in part because
 they end up depending on <i>other</i> existing poor-quality {@code hashCode} implementations,
 including those in many JDK classes.

 <p>{@code Object.hashCode} implementations tend to be very fast, but have weak collision
 prevention and <i>no</i> expectation of bit dispersion. This leaves them perfectly suitable for
 use in hash tables, because extra collisions cause only a slight performance hit, while poor bit
 dispersion is easily corrected using a secondary hash function (which all reasonable hash table
 implementations in Java use). For the many uses of hash functions beyond data structures,
 however, {@code Object.hashCode} almost always falls short -- hence this library.

 @author Kevin Bourrillion
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.HashFunction -->
  <!-- start class com.google.common.hash.Hashing -->
  <class name="Hashing" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="goodFastHash" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="minimumBits" type="int"/>
      <doc>
      <![CDATA[Returns a general-purpose, <b>temporary-use</b>, non-cryptographic hash function. The algorithm
 the returned function implements is unspecified and subject to change without notice.

 <p><b>Warning:</b> a new random seed for these functions is chosen each time the {@code
 Hashing} class is loaded. <b>Do not use this method</b> if hash codes may escape the current
 process in any way, for example being sent over RPC, or saved to disk. For a general-purpose,
 non-cryptographic hash function that will never change behavior, we suggest {@link
 #murmur3_128}.

 <p>Repeated calls to this method on the same loaded {@code Hashing} class, using the same value
 for {@code minimumBits}, will return identically-behaving {@link HashFunction} instances.

 @param minimumBits a positive integer. This can be arbitrarily large. The returned {@link
     HashFunction} instance may use memory proportional to this integer.
 @return a hash function, described above, that produces hash codes of length {@code
     minimumBits} or greater]]>
      </doc>
    </method>
    <method name="murmur3_32" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This implementation produces incorrect hash values from the {@link
     HashFunction#hashString} method if the string contains non-BMP characters. Use {@link
     #murmur3_32_fixed(int)} instead.">
      <param name="seed" type="int"/>
      <doc>
      <![CDATA[Returns a hash function implementing the <a
 href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">32-bit murmur3
 algorithm, x86 variant</a> (little-endian variant), using the given seed value, <b>with a known
 bug</b> as described in the deprecation text.

 <p>The C++ equivalent is the MurmurHash3_x86_32 function (Murmur3A), which however does not
 have the bug.

 @deprecated This implementation produces incorrect hash values from the {@link
     HashFunction#hashString} method if the string contains non-BMP characters. Use {@link
     #murmur3_32_fixed(int)} instead.]]>
      </doc>
    </method>
    <method name="murmur3_32" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This implementation produces incorrect hash values from the {@link
     HashFunction#hashString} method if the string contains non-BMP characters. Use {@link
     #murmur3_32_fixed()} instead.">
      <doc>
      <![CDATA[Returns a hash function implementing the <a
 href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">32-bit murmur3
 algorithm, x86 variant</a> (little-endian variant), using the given seed value, <b>with a known
 bug</b> as described in the deprecation text.

 <p>The C++ equivalent is the MurmurHash3_x86_32 function (Murmur3A), which however does not
 have the bug.

 @deprecated This implementation produces incorrect hash values from the {@link
     HashFunction#hashString} method if the string contains non-BMP characters. Use {@link
     #murmur3_32_fixed()} instead.]]>
      </doc>
    </method>
    <method name="murmur3_32_fixed" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="int"/>
      <doc>
      <![CDATA[Returns a hash function implementing the <a
 href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">32-bit murmur3
 algorithm, x86 variant</a> (little-endian variant), using the given seed value.

 <p>The exact C++ equivalent is the MurmurHash3_x86_32 function (Murmur3A).

 <p>This method is called {@code murmur3_32_fixed} because it fixes a bug in the {@code
 HashFunction} returned by the original {@code murmur3_32} method.

 @since 31.0]]>
      </doc>
    </method>
    <method name="murmur3_32_fixed" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the <a
 href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">32-bit murmur3
 algorithm, x86 variant</a> (little-endian variant), using a seed value of zero.

 <p>The exact C++ equivalent is the MurmurHash3_x86_32 function (Murmur3A).

 <p>This method is called {@code murmur3_32_fixed} because it fixes a bug in the {@code
 HashFunction} returned by the original {@code murmur3_32} method.

 @since 31.0]]>
      </doc>
    </method>
    <method name="murmur3_128" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="int"/>
      <doc>
      <![CDATA[Returns a hash function implementing the <a
 href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">128-bit murmur3
 algorithm, x64 variant</a> (little-endian variant), using the given seed value.

 <p>The exact C++ equivalent is the MurmurHash3_x64_128 function (Murmur3F).]]>
      </doc>
    </method>
    <method name="murmur3_128" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the <a
 href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">128-bit murmur3
 algorithm, x64 variant</a> (little-endian variant), using a seed value of zero.

 <p>The exact C++ equivalent is the MurmurHash3_x64_128 function (Murmur3F).]]>
      </doc>
    </method>
    <method name="sipHash24" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the <a href="https://131002.net/siphash/">64-bit
 SipHash-2-4 algorithm</a> using a seed value of {@code k = 00 01 02 ...}.

 @since 15.0]]>
      </doc>
    </method>
    <method name="sipHash24" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k0" type="long"/>
      <param name="k1" type="long"/>
      <doc>
      <![CDATA[Returns a hash function implementing the <a href="https://131002.net/siphash/">64-bit
 SipHash-2-4 algorithm</a> using the given seed.

 @since 15.0]]>
      </doc>
    </method>
    <method name="md5" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="If you must interoperate with a system that requires MD5, then use this method,
     despite its deprecation. But if you can choose your hash function, avoid MD5, which is
     neither fast nor secure. As of January 2017, we suggest:
     lEsS_tHaNul>
       lEsS_tHaNli>For security:
           {@link Hashing#sha256} or a higher-level API.
       lEsS_tHaNli>For speed: {@link Hashing#goodFastHash}, though see its docs for caveats.
     lEsS_tHaN/ul>">
      <doc>
      <![CDATA[Returns a hash function implementing the MD5 hash algorithm (128 hash bits).

 @deprecated If you must interoperate with a system that requires MD5, then use this method,
     despite its deprecation. But if you can choose your hash function, avoid MD5, which is
     neither fast nor secure. As of January 2017, we suggest:
     <ul>
       <li>For security:
           {@link Hashing#sha256} or a higher-level API.
       <li>For speed: {@link Hashing#goodFastHash}, though see its docs for caveats.
     </ul>]]>
      </doc>
    </method>
    <method name="sha1" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="If you must interoperate with a system that requires SHA-1, then use this method,
     despite its deprecation. But if you can choose your hash function, avoid SHA-1, which is
     neither fast nor secure. As of January 2017, we suggest:
     lEsS_tHaNul>
       lEsS_tHaNli>For security:
           {@link Hashing#sha256} or a higher-level API.
       lEsS_tHaNli>For speed: {@link Hashing#goodFastHash}, though see its docs for caveats.
     lEsS_tHaN/ul>">
      <doc>
      <![CDATA[Returns a hash function implementing the SHA-1 algorithm (160 hash bits).

 @deprecated If you must interoperate with a system that requires SHA-1, then use this method,
     despite its deprecation. But if you can choose your hash function, avoid SHA-1, which is
     neither fast nor secure. As of January 2017, we suggest:
     <ul>
       <li>For security:
           {@link Hashing#sha256} or a higher-level API.
       <li>For speed: {@link Hashing#goodFastHash}, though see its docs for caveats.
     </ul>]]>
      </doc>
    </method>
    <method name="sha256" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the SHA-256 algorithm (256 hash bits).]]>
      </doc>
    </method>
    <method name="sha384" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the SHA-384 algorithm (384 hash bits).

 @since 19.0]]>
      </doc>
    </method>
    <method name="sha512" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the SHA-512 algorithm (512 hash bits).]]>
      </doc>
    </method>
    <method name="hmacMd5" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.security.Key"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 MD5 (128 hash bits) hash function and the given secret key.

 <p>If you are designing a new system that needs HMAC, prefer {@link #hmacSha256} or other
 future-proof algorithms <a
 href="https://datatracker.ietf.org/doc/html/rfc6151#section-2.3">over {@code hmacMd5}</a>.

 @param key the secret key
 @throws IllegalArgumentException if the given key is inappropriate for initializing this MAC
 @since 20.0]]>
      </doc>
    </method>
    <method name="hmacMd5" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 MD5 (128 hash bits) hash function and a {@link SecretKeySpec} created from the given byte array
 and the MD5 algorithm.

 <p>If you are designing a new system that needs HMAC, prefer {@link #hmacSha256} or other
 future-proof algorithms <a
 href="https://datatracker.ietf.org/doc/html/rfc6151#section-2.3">over {@code hmacMd5}</a>.

 @param key the key material of the secret key
 @since 20.0]]>
      </doc>
    </method>
    <method name="hmacSha1" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.security.Key"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 SHA-1 (160 hash bits) hash function and the given secret key.

 @param key the secret key
 @throws IllegalArgumentException if the given key is inappropriate for initializing this MAC
 @since 20.0]]>
      </doc>
    </method>
    <method name="hmacSha1" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 SHA-1 (160 hash bits) hash function and a {@link SecretKeySpec} created from the given byte
 array and the SHA-1 algorithm.

 @param key the key material of the secret key
 @since 20.0]]>
      </doc>
    </method>
    <method name="hmacSha256" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.security.Key"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 SHA-256 (256 hash bits) hash function and the given secret key.

 @param key the secret key
 @throws IllegalArgumentException if the given key is inappropriate for initializing this MAC
 @since 20.0]]>
      </doc>
    </method>
    <method name="hmacSha256" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 SHA-256 (256 hash bits) hash function and a {@link SecretKeySpec} created from the given byte
 array and the SHA-256 algorithm.

 @param key the key material of the secret key
 @since 20.0]]>
      </doc>
    </method>
    <method name="hmacSha512" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.security.Key"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 SHA-512 (512 hash bits) hash function and the given secret key.

 @param key the secret key
 @throws IllegalArgumentException if the given key is inappropriate for initializing this MAC
 @since 20.0]]>
      </doc>
    </method>
    <method name="hmacSha512" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <doc>
      <![CDATA[Returns a hash function implementing the Message Authentication Code (MAC) algorithm, using the
 SHA-512 (512 hash bits) hash function and a {@link SecretKeySpec} created from the given byte
 array and the SHA-512 algorithm.

 @param key the key material of the secret key
 @since 20.0]]>
      </doc>
    </method>
    <method name="crc32c" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the CRC32C checksum algorithm (32 hash bits) as described
 by RFC 3720, Section 12.1.

 <p>This function is best understood as a <a
 href="https://en.wikipedia.org/wiki/Checksum">checksum</a> rather than a true <a
 href="https://en.wikipedia.org/wiki/Hash_function">hash function</a>.

 @since 18.0]]>
      </doc>
    </method>
    <method name="crc32" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the CRC-32 checksum algorithm (32 hash bits).

 <p>To get the {@code long} value equivalent to {@link Checksum#getValue()} for a {@code
 HashCode} produced by this function, use {@link HashCode#padToLong()}.

 <p>This function is best understood as a <a
 href="https://en.wikipedia.org/wiki/Checksum">checksum</a> rather than a true <a
 href="https://en.wikipedia.org/wiki/Hash_function">hash function</a>.

 @since 14.0]]>
      </doc>
    </method>
    <method name="adler32" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the Adler-32 checksum algorithm (32 hash bits).

 <p>To get the {@code long} value equivalent to {@link Checksum#getValue()} for a {@code
 HashCode} produced by this function, use {@link HashCode#padToLong()}.

 <p>This function is best understood as a <a
 href="https://en.wikipedia.org/wiki/Checksum">checksum</a> rather than a true <a
 href="https://en.wikipedia.org/wiki/Hash_function">hash function</a>.

 @since 14.0]]>
      </doc>
    </method>
    <method name="farmHashFingerprint64" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing FarmHash's Fingerprint64, an open-source algorithm.

 <p>This is designed for generating persistent fingerprints of strings. It isn't
 cryptographically secure, but it produces a high-quality hash with fewer collisions than some
 alternatives we've used in the past.

 <p>FarmHash fingerprints are encoded by {@link HashCode#asBytes} in little-endian order. This
 means {@link HashCode#asLong} is guaranteed to return the same value that
 farmhash::Fingerprint64() would for the same input (when compared using {@link
 com.google.common.primitives.UnsignedLongs}'s encoding of 64-bit unsigned numbers).

 <p>This function is best understood as a <a
 href="https://en.wikipedia.org/wiki/Fingerprint_(computing)">fingerprint</a> rather than a true
 <a href="https://en.wikipedia.org/wiki/Hash_function">hash function</a>.

 @since 20.0]]>
      </doc>
    </method>
    <method name="fingerprint2011" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash function implementing the Fingerprint2011 hashing function (64 hash bits).

 <p>This is designed for generating persistent fingerprints of strings. It isn't
 cryptographically secure, but it produces a high-quality hash with few collisions. Fingerprints
 generated using this are byte-wise identical to those created using the C++ version, but note
 that this uses unsigned integers (see {@link com.google.common.primitives.UnsignedInts}).
 Comparisons between the two should take this into account.

 <p>Fingerprint2011() is a form of Murmur2 on strings up to 32 bytes and a form of CityHash for
 longer strings. It could have been one or the other throughout. The main advantage of the
 combination is that CityHash has a bunch of special cases for short strings that don't need to
 be replicated here. The result will never be 0 or 1.

 <p>This function is best understood as a <a
 href="https://en.wikipedia.org/wiki/Fingerprint_(computing)">fingerprint</a> rather than a true
 <a href="https://en.wikipedia.org/wiki/Hash_function">hash function</a>.

 @since 31.1]]>
      </doc>
    </method>
    <method name="consistentHash" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashCode" type="com.google.common.hash.HashCode"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Assigns to {@code hashCode} a "bucket" in the range {@code [0, buckets)}, in a uniform manner
 that minimizes the need for remapping as {@code buckets} grows. That is, {@code
 consistentHash(h, n)} equals:

 <ul>
   <li>{@code n - 1}, with approximate probability {@code 1/n}
   <li>{@code consistentHash(h, n - 1)}, otherwise (probability {@code 1 - 1/n})
 </ul>

 <p>This method is suitable for the common use case of dividing work among buckets that meet the
 following conditions:

 <ul>
   <li>You want to assign the same fraction of inputs to each bucket.
   <li>When you reduce the number of buckets, you can accept that the most recently added
       buckets will be removed first. More concretely, if you are dividing traffic among tasks,
       you can decrease the number of tasks from 15 and 10, killing off the final 5 tasks, and
       {@code consistentHash} will handle it. If, however, you are dividing traffic among
       servers {@code alpha}, {@code bravo}, and {@code charlie} and you occasionally need to
       take each of the servers offline, {@code consistentHash} will be a poor fit: It provides
       no way for you to specify which of the three buckets is disappearing. Thus, if your
       buckets change from {@code [alpha, bravo, charlie]} to {@code [bravo, charlie]}, it will
       assign all the old {@code alpha} traffic to {@code bravo} and all the old {@code bravo}
       traffic to {@code charlie}, rather than letting {@code bravo} keep its traffic.
 </ul>

 <p>See the <a href="http://en.wikipedia.org/wiki/Consistent_hashing">Wikipedia article on
 consistent hashing</a> for more information.]]>
      </doc>
    </method>
    <method name="consistentHash" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="long"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Assigns to {@code input} a "bucket" in the range {@code [0, buckets)}, in a uniform manner that
 minimizes the need for remapping as {@code buckets} grows. That is, {@code consistentHash(h,
 n)} equals:

 <ul>
   <li>{@code n - 1}, with approximate probability {@code 1/n}
   <li>{@code consistentHash(h, n - 1)}, otherwise (probability {@code 1 - 1/n})
 </ul>

 <p>This method is suitable for the common use case of dividing work among buckets that meet the
 following conditions:

 <ul>
   <li>You want to assign the same fraction of inputs to each bucket.
   <li>When you reduce the number of buckets, you can accept that the most recently added
       buckets will be removed first. More concretely, if you are dividing traffic among tasks,
       you can decrease the number of tasks from 15 and 10, killing off the final 5 tasks, and
       {@code consistentHash} will handle it. If, however, you are dividing traffic among
       servers {@code alpha}, {@code bravo}, and {@code charlie} and you occasionally need to
       take each of the servers offline, {@code consistentHash} will be a poor fit: It provides
       no way for you to specify which of the three buckets is disappearing. Thus, if your
       buckets change from {@code [alpha, bravo, charlie]} to {@code [bravo, charlie]}, it will
       assign all the old {@code alpha} traffic to {@code bravo} and all the old {@code bravo}
       traffic to {@code charlie}, rather than letting {@code bravo} keep its traffic.
 </ul>

 <p>See the <a href="http://en.wikipedia.org/wiki/Consistent_hashing">Wikipedia article on
 consistent hashing</a> for more information.]]>
      </doc>
    </method>
    <method name="combineOrdered" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashCodes" type="java.lang.Iterable&lt;com.google.common.hash.HashCode&gt;"/>
      <doc>
      <![CDATA[Returns a hash code, having the same bit length as each of the input hash codes, that combines
 the information of these hash codes in an ordered fashion. That is, whenever two equal hash
 codes are produced by two calls to this method, it is <i>as likely as possible</i> that each
 was computed from the <i>same</i> input hash codes in the <i>same</i> order.

 @throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes do not all
     have the same bit length]]>
      </doc>
    </method>
    <method name="combineUnordered" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashCodes" type="java.lang.Iterable&lt;com.google.common.hash.HashCode&gt;"/>
      <doc>
      <![CDATA[Returns a hash code, having the same bit length as each of the input hash codes, that combines
 the information of these hash codes in an unordered fashion. That is, whenever two equal hash
 codes are produced by two calls to this method, it is <i>as likely as possible</i> that each
 was computed from the <i>same</i> input hash codes in <i>some</i> order.

 @throws IllegalArgumentException if {@code hashCodes} is empty, or the hash codes do not all
     have the same bit length]]>
      </doc>
    </method>
    <method name="concatenating" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="com.google.common.hash.HashFunction"/>
      <param name="second" type="com.google.common.hash.HashFunction"/>
      <param name="rest" type="com.google.common.hash.HashFunction[]"/>
      <doc>
      <![CDATA[Returns a hash function which computes its hash code by concatenating the hash codes of the
 underlying hash functions together. This can be useful if you need to generate hash codes of a
 specific length.

 <p>For example, if you need 1024-bit hash codes, you could join two {@link Hashing#sha512} hash
 functions together: {@code Hashing.concatenating(Hashing.sha512(), Hashing.sha512())}.

 @since 19.0]]>
      </doc>
    </method>
    <method name="concatenating" return="com.google.common.hash.HashFunction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashFunctions" type="java.lang.Iterable&lt;com.google.common.hash.HashFunction&gt;"/>
      <doc>
      <![CDATA[Returns a hash function which computes its hash code by concatenating the hash codes of the
 underlying hash functions together. This can be useful if you need to generate hash codes of a
 specific length.

 <p>For example, if you need 1024-bit hash codes, you could join two {@link Hashing#sha512} hash
 functions together: {@code Hashing.concatenating(Hashing.sha512(), Hashing.sha512())}.

 @since 19.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static methods to obtain {@link HashFunction} instances, and other static hashing-related
 utilities.

 <p>A comparison of the various hash functions can be found <a
 href="https://docs.google.com/spreadsheets/d/1_q2EVcxA2HjcrlVMbaqXwMj31h9M5-Bqj_m8vITOwwk/">here</a>.

 @author Kevin Bourrillion
 @author Dimitris Andreou
 @author Kurt Alfred Kluever
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.Hashing -->
  <!-- start class com.google.common.hash.HashingInputStream -->
  <class name="HashingInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HashingInputStream" type="com.google.common.hash.HashFunction, java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an input stream that hashes using the given {@link HashFunction} and delegates all data
 read from it to the underlying {@link InputStream}.

 <p>The {@link InputStream} should not be read from before or after the hand-off.]]>
      </doc>
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the next byte of data from the underlying input stream and updates the hasher with the
 byte read.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the specified bytes of data from the underlying input stream and updates the hasher with
 the bytes read.]]>
      </doc>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[mark() is not supported for HashingInputStream

 @return {@code false} always]]>
      </doc>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
      <doc>
      <![CDATA[mark() is not supported for HashingInputStream]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[reset() is not supported for HashingInputStream.

 @throws IOException this operation is not supported]]>
      </doc>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link HashCode} based on the data read from this stream. The result is unspecified
 if this method is called more than once on the same instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that maintains a hash of the data read from it.

 @author Qian Huang
 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.HashingInputStream -->
  <!-- start class com.google.common.hash.HashingOutputStream -->
  <class name="HashingOutputStream" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HashingOutputStream" type="com.google.common.hash.HashFunction, java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an output stream that hashes using the given {@link HashFunction}, and forwards all
 data written to it to the underlying {@link OutputStream}.

 <p>The {@link OutputStream} should not be written to before or after the hand-off.]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link HashCode} based on the data written to this stream. The result is
 unspecified if this method is called more than once on the same instance.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link OutputStream} that maintains a hash of the data written to it.

 @author Zoe Piepmeier
 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.hash.HashingOutputStream -->
  <!-- start interface com.google.common.hash.PrimitiveSink -->
  <interface name="PrimitiveSink"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="putByte" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Puts a byte into this sink.

 @param b a byte
 @return this instance]]>
      </doc>
    </method>
    <method name="putBytes" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Puts an array of bytes into this sink.

 @param bytes a byte array
 @return this instance]]>
      </doc>
    </method>
    <method name="putBytes" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Puts a chunk of an array of bytes into this sink. {@code bytes[off]} is the first byte written,
 {@code bytes[off + len - 1]} is the last.

 @param bytes a byte array
 @param off the start offset in the array
 @param len the number of bytes to write
 @return this instance
 @throws IndexOutOfBoundsException if {@code off < 0} or {@code off + len > bytes.length} or
     {@code len < 0}]]>
      </doc>
    </method>
    <method name="putBytes" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[Puts the remaining bytes of a byte buffer into this sink. {@code bytes.position()} is the first
 byte written, {@code bytes.limit() - 1} is the last. The position of the buffer will be equal
 to the limit when this method returns.

 @param bytes a byte buffer
 @return this instance
 @since 23.0]]>
      </doc>
    </method>
    <method name="putShort" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="short"/>
      <doc>
      <![CDATA[Puts a short into this sink.]]>
      </doc>
    </method>
    <method name="putInt" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Puts an int into this sink.]]>
      </doc>
    </method>
    <method name="putLong" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <doc>
      <![CDATA[Puts a long into this sink.]]>
      </doc>
    </method>
    <method name="putFloat" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <doc>
      <![CDATA[Puts a float into this sink.]]>
      </doc>
    </method>
    <method name="putDouble" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <doc>
      <![CDATA[Puts a double into this sink.]]>
      </doc>
    </method>
    <method name="putBoolean" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Puts a boolean into this sink.]]>
      </doc>
    </method>
    <method name="putChar" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <doc>
      <![CDATA[Puts a character into this sink.]]>
      </doc>
    </method>
    <method name="putUnencodedChars" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Puts each 16-bit code unit from the {@link CharSequence} into this sink.

 <p><b>Warning:</b> This method will produce different output than most other languages do when
 running on the equivalent input. For cross-language compatibility, use {@link #putString},
 usually with a charset of UTF-8. For other use cases, use {@code putUnencodedChars}.

 @since 15.0 (since 11.0 as putString(CharSequence))]]>
      </doc>
    </method>
    <method name="putString" return="com.google.common.hash.PrimitiveSink"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Puts a string into this sink using the given charset.

 <p><b>Warning:</b> This method, which reencodes the input before processing it, is useful only
 for cross-language compatibility. For other use cases, prefer {@link #putUnencodedChars}, which
 is faster, produces the same output across Java releases, and processes every {@code char} in
 the input, even if some are invalid.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object which can receive a stream of primitive values.

 @author Kevin Bourrillion
 @since 12.0 (in 11.0 as {@code Sink})]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.hash.PrimitiveSink -->
</package>
<package name="com.google.common.html">
  <!-- start class com.google.common.html.HtmlEscapers -->
  <class name="HtmlEscapers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="htmlEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Escaper} instance that escapes HTML metacharacters as specified by <a
 href="http://www.w3.org/TR/html4/">HTML 4.01</a>. The resulting strings can be used both in
 attribute values and in <em>most</em> elements' text contents, provided that the HTML
 document's character encoding can encode any non-ASCII code points in the input (as UTF-8 and
 other Unicode encodings can).

 <p><b>Note:</b> This escaper only performs minimal escaping to make content structurally
 compatible with HTML. Specifically, it does not perform entity replacement (symbolic or
 numeric), so it does not replace non-ASCII code points with character references. This escaper
 escapes only the following five ASCII characters: {@code '"&<>}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[{@code Escaper} instances suitable for strings to be included in HTML attribute values and
 <em>most</em> elements' text contents. When possible, avoid manual escaping by using templating
 systems and high-level APIs that provide autoescaping.
 One Google-authored templating system available for external use is <a
 href="https://developers.google.com/closure/templates/">Closure Templates</a>.

 <p>HTML escaping is particularly tricky: For example, <a
 href="https://www.w3.org/TR/html4/types.html#h-6.2">some elements' text contents must not be HTML
 escaped</a>. As a result, it is impossible to escape an HTML document correctly without
 domain-specific knowledge beyond what {@code HtmlEscapers} provides. We strongly encourage the
 use of HTML templating systems.

 @author Sven Mawson
 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.html.HtmlEscapers -->
</package>
<package name="com.google.common.io">
  <!-- start class com.google.common.io.BaseEncoding -->
  <class name="BaseEncoding" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="encode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Encodes the specified byte array, and returns the encoded {@code String}.]]>
      </doc>
    </method>
    <method name="encode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Encodes the specified range of the specified byte array, and returns the encoded {@code
 String}.]]>
      </doc>
    </method>
    <method name="encodingStream" return="java.io.OutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <doc>
      <![CDATA[Returns an {@code OutputStream} that encodes bytes using this encoding into the specified
 {@code Writer}. When the returned {@code OutputStream} is closed, so is the backing {@code
 Writer}.]]>
      </doc>
    </method>
    <method name="encodingSink" return="com.google.common.io.ByteSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="encodedSink" type="com.google.common.io.CharSink"/>
      <doc>
      <![CDATA[Returns a {@code ByteSink} that writes base-encoded bytes to the specified {@code CharSink}.]]>
      </doc>
    </method>
    <method name="canDecode" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Determines whether the specified character sequence is a valid encoded string according to this
 encoding.

 @since 20.0]]>
      </doc>
    </method>
    <method name="decode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the
 inverse operation to {@link #encode(byte[])}.

 @throws IllegalArgumentException if the input is not a valid encoded string according to this
     encoding.]]>
      </doc>
    </method>
    <method name="decodingStream" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <doc>
      <![CDATA[Returns an {@code InputStream} that decodes base-encoded input from the specified {@code
 Reader}. The returned stream throws a {@link DecodingException} upon decoding-specific errors.]]>
      </doc>
    </method>
    <method name="decodingSource" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="encodedSource" type="com.google.common.io.CharSource"/>
      <doc>
      <![CDATA[Returns a {@code ByteSource} that reads base-encoded bytes from the specified {@code
 CharSource}.]]>
      </doc>
    </method>
    <method name="omitPadding" return="com.google.common.io.BaseEncoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an encoding that behaves equivalently to this encoding, but omits any padding
 characters as specified by <a href="http://tools.ietf.org/html/rfc4648#section-3.2">RFC 4648
 section 3.2</a>, Padding of Encoded Data.]]>
      </doc>
    </method>
    <method name="withPadChar" return="com.google.common.io.BaseEncoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="padChar" type="char"/>
      <doc>
      <![CDATA[Returns an encoding that behaves equivalently to this encoding, but uses an alternate character
 for padding.

 @throws IllegalArgumentException if this padding character is already used in the alphabet or a
     separator]]>
      </doc>
    </method>
    <method name="withSeparator" return="com.google.common.io.BaseEncoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns an encoding that behaves equivalently to this encoding, but adds a separator string
 after every {@code n} characters. Any occurrences of any characters that occur in the separator
 are skipped over in decoding.

 @throws IllegalArgumentException if any alphabet or padding characters appear in the separator
     string, or if {@code n <= 0}
 @throws UnsupportedOperationException if this encoding already uses a separator]]>
      </doc>
    </method>
    <method name="upperCase" return="com.google.common.io.BaseEncoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an encoding that behaves equivalently to this encoding, but encodes and decodes with
 uppercase letters. Padding and separator characters remain in their original case.

 @throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and
     lower-case characters]]>
      </doc>
    </method>
    <method name="lowerCase" return="com.google.common.io.BaseEncoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an encoding that behaves equivalently to this encoding, but encodes and decodes with
 lowercase letters. Padding and separator characters remain in their original case.

 @throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and
     lower-case characters]]>
      </doc>
    </method>
    <method name="ignoreCase" return="com.google.common.io.BaseEncoding"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an encoding that behaves equivalently to this encoding, but decodes letters without
 regard to case.

 @throws IllegalStateException if the alphabet used by this encoding contains mixed upper- and
     lower-case characters
 @since 32.0.0]]>
      </doc>
    </method>
    <method name="base64" return="com.google.common.io.BaseEncoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "base64" base encoding specified by <a
 href="http://tools.ietf.org/html/rfc4648#section-4">RFC 4648 section 4</a>, Base 64 Encoding.
 (This is the same as the base 64 encoding from <a
 href="http://tools.ietf.org/html/rfc3548#section-3">RFC 3548</a>.)

 <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()
 omitted} or {@linkplain #withPadChar(char) replaced}.

 <p>No line feeds are added by default, as per <a
 href="http://tools.ietf.org/html/rfc4648#section-3.1">RFC 4648 section 3.1</a>, Line Feeds in
 Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.]]>
      </doc>
    </method>
    <method name="base64Url" return="com.google.common.io.BaseEncoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "base64url" encoding specified by <a
 href="http://tools.ietf.org/html/rfc4648#section-5">RFC 4648 section 5</a>, Base 64 Encoding
 with URL and Filename Safe Alphabet, also sometimes referred to as the "web safe Base64." (This
 is the same as the base 64 encoding with URL and filename safe alphabet from <a
 href="http://tools.ietf.org/html/rfc3548#section-4">RFC 3548</a>.)

 <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()
 omitted} or {@linkplain #withPadChar(char) replaced}.

 <p>No line feeds are added by default, as per <a
 href="http://tools.ietf.org/html/rfc4648#section-3.1">RFC 4648 section 3.1</a>, Line Feeds in
 Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.]]>
      </doc>
    </method>
    <method name="base32" return="com.google.common.io.BaseEncoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "base32" encoding specified by <a href="http://tools.ietf.org/html/rfc4648#section-6">RFC
 4648 section 6</a>, Base 32 Encoding. (This is the same as the base 32 encoding from <a
 href="http://tools.ietf.org/html/rfc3548#section-5">RFC 3548</a>.)

 <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()
 omitted} or {@linkplain #withPadChar(char) replaced}.

 <p>No line feeds are added by default, as per <a
 href="http://tools.ietf.org/html/rfc4648#section-3.1">RFC 4648 section 3.1</a>, Line Feeds in
 Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.]]>
      </doc>
    </method>
    <method name="base32Hex" return="com.google.common.io.BaseEncoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "base32hex" encoding specified by <a
 href="http://tools.ietf.org/html/rfc4648#section-7">RFC 4648 section 7</a>, Base 32 Encoding
 with Extended Hex Alphabet. There is no corresponding encoding in RFC 3548.

 <p>The character {@code '='} is used for padding, but can be {@linkplain #omitPadding()
 omitted} or {@linkplain #withPadChar(char) replaced}.

 <p>No line feeds are added by default, as per <a
 href="http://tools.ietf.org/html/rfc4648#section-3.1">RFC 4648 section 3.1</a>, Line Feeds in
 Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.]]>
      </doc>
    </method>
    <method name="base16" return="com.google.common.io.BaseEncoding"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The "base16" encoding specified by <a href="http://tools.ietf.org/html/rfc4648#section-8">RFC
 4648 section 8</a>, Base 16 Encoding. (This is the same as the base 16 encoding from <a
 href="http://tools.ietf.org/html/rfc3548#section-6">RFC 3548</a>.) This is commonly known as
 "hexadecimal" format.

 <p>No padding is necessary in base 16, so {@link #withPadChar(char)} and {@link #omitPadding()}
 have no effect.

 <p>No line feeds are added by default, as per <a
 href="http://tools.ietf.org/html/rfc4648#section-3.1">RFC 4648 section 3.1</a>, Line Feeds in
 Encoded Data. Line feeds may be added using {@link #withSeparator(String, int)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binary encoding scheme for reversibly translating between byte sequences and printable ASCII
 strings. This class includes several constants for encoding schemes specified by <a
 href="http://tools.ietf.org/html/rfc4648">RFC 4648</a>. For example, the expression:

 {@snippet :
 BaseEncoding.base32().encode("foo".getBytes(US_ASCII))
 }

 <p>returns the string {@code "MZXW6==="}, and

 {@snippet :
 byte[] decoded = BaseEncoding.base32().decode("MZXW6===");
 }

 <p>...returns the ASCII bytes of the string {@code "foo"}.

 <p>By default, {@code BaseEncoding}'s behavior is relatively strict and in accordance with RFC
 4648. Decoding rejects characters in the wrong case, though padding is optional. To modify
 encoding and decoding behavior, use configuration methods to obtain a new encoding with modified
 behavior:

 {@snippet :
 BaseEncoding.base16().lowerCase().decode("deadbeef");
 }

 <p>Warning: BaseEncoding instances are immutable. Invoking a configuration method has no effect
 on the receiving instance; you must store and use the new encoding instance it returns, instead.

 {@snippet :
 // Do NOT do this
 BaseEncoding hex = BaseEncoding.base16();
 hex.lowerCase(); // does nothing!
 return hex.decode("deadbeef"); // throws an IllegalArgumentException
 }

 <p>It is guaranteed that {@code encoding.decode(encoding.encode(x))} is always equal to {@code
 x}, but the reverse does not necessarily hold.

 <table>
 <caption>Encodings</caption>
 <tr>
 <th>Encoding
 <th>Alphabet
 <th>{@code char:byte} ratio
 <th>Default padding
 <th>Comments
 <tr>
 <td>{@link #base16()}
 <td>0-9 A-F
 <td>2.00
 <td>N/A
 <td>Traditional hexadecimal. Defaults to upper case.
 <tr>
 <td>{@link #base32()}
 <td>A-Z 2-7
 <td>1.60
 <td>=
 <td>Human-readable; no possibility of mixing up 0/O or 1/I. Defaults to upper case.
 <tr>
 <td>{@link #base32Hex()}
 <td>0-9 A-V
 <td>1.60
 <td>=
 <td>"Numerical" base 32; extended from the traditional hex alphabet. Defaults to upper case.
 <tr>
 <td>{@link #base64()}
 <td>A-Z a-z 0-9 + /
 <td>1.33
 <td>=
 <td>
 <tr>
 <td>{@link #base64Url()}
 <td>A-Z a-z 0-9 - _
 <td>1.33
 <td>=
 <td>Safe to use as filenames, or to pass in URLs without escaping
 </table>

 <p>All instances of this class are immutable, so they may be stored safely as static constants.

 @author Louis Wasserman
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.BaseEncoding -->
  <!-- start class com.google.common.io.BaseEncoding.DecodingException -->
  <class name="BaseEncoding.DecodingException" extends="java.io.IOException"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Exception indicating invalid base-encoded input encountered while decoding.

 @author Louis Wasserman
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.BaseEncoding.DecodingException -->
  <!-- start interface com.google.common.io.ByteArrayDataInput -->
  <interface name="ByteArrayDataInput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataInput"/>
    <method name="readFully"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="readFully"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="skipBytes" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readByte" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedByte" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readShort" return="short"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readChar" return="char"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLong" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFloat" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readDouble" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readLine" return="String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readUTF" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An extension of {@code DataInput} for reading from in-memory byte arrays; its methods offer
 identical functionality but do not throw {@link IOException}.

 <p><b>Warning:</b> The caller is responsible for not attempting to read past the end of the
 array. If any method encounters the end of the array prematurely, it throws {@link
 IllegalStateException} to signify <i>programmer error</i>. This behavior is a technical violation
 of the supertype's contract, which specifies a checked exception.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataInput -->
  <!-- start interface com.google.common.io.ByteArrayDataOutput -->
  <interface name="ByteArrayDataOutput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataOutput"/>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="writeBoolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="boolean"/>
    </method>
    <method name="writeByte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeShort"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeChar"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeInt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
    </method>
    <method name="writeLong"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
    </method>
    <method name="writeFloat"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
    </method>
    <method name="writeDouble"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
    </method>
    <method name="writeChars"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeUTF"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="writeBytes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="This method is dangerous as it discards the high byte of every character. For
     UTF-8, use {@code write(s.getBytes(StandardCharsets.UTF_8))}.">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated This method is dangerous as it discards the high byte of every character. For
     UTF-8, use {@code write(s.getBytes(StandardCharsets.UTF_8))}.]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the contents that have been written to this instance, as a byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An extension of {@code DataOutput} for writing to in-memory byte arrays; its methods offer
 identical functionality but do not throw {@link IOException}.

 @author Jayaprabhakar Kadarkarai
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteArrayDataOutput -->
  <!-- start interface com.google.common.io.ByteProcessor -->
  <interface name="ByteProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processBytes" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called for each chunk of bytes in an input stream. The implementation
 should process the bytes from {@code buf[off]} through {@code buf[off + len - 1]} (inclusive).

 @param buf the byte array containing the data to process
 @param off the initial offset into the array
 @param len the length of data to be processed
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the bytes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback interface to process bytes from a stream.

 <p>{@link #processBytes} will be called for each chunk of data that is read, and should return
 {@code false} when you want to stop processing.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.ByteProcessor -->
  <!-- start class com.google.common.io.ByteSink -->
  <class name="ByteSink" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteSink"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="asCharSink" return="com.google.common.io.CharSink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a {@link CharSink} view of this {@code ByteSink} that writes characters to this sink as
 bytes encoded with the given {@link Charset charset}.]]>
      </doc>
    </method>
    <method name="openStream" return="java.io.OutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new {@link OutputStream} for writing to this sink. This method returns a new,
 independent stream each time it is called.

 <p>The caller is responsible for ensuring that the returned stream is closed.

 @throws IOException if an I/O error occurs while opening the stream]]>
      </doc>
    </method>
    <method name="openBufferedStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new buffered {@link OutputStream} for writing to this sink. The returned stream is not
 required to be a {@link BufferedOutputStream} in order to allow implementations to simply
 delegate to {@link #openStream()} when the stream returned by that method does not benefit from
 additional buffering (for example, a {@code ByteArrayOutputStream}). This method returns a new,
 independent stream each time it is called.

 <p>The caller is responsible for ensuring that the returned stream is closed.

 @throws IOException if an I/O error occurs while opening the stream
 @since 15.0 (in 14.0 with return type {@link BufferedOutputStream})]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes all the given bytes to this sink.

 @throws IOException if an I/O occurs while writing to this sink]]>
      </doc>
    </method>
    <method name="writeFrom" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes all the bytes from the given {@code InputStream} to this sink. Does not close {@code
 input}.

 @return the number of bytes written
 @throws IOException if an I/O occurs while reading from {@code input} or writing to this sink]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A destination to which bytes can be written, such as a file. Unlike an {@link OutputStream}, a
 {@code ByteSink} is not an open, stateful stream that can be written to and closed. Instead, it
 is an immutable <i>supplier</i> of {@code OutputStream} instances.

 <p>{@code ByteSink} provides two kinds of methods:

 <ul>
   <li><b>Methods that return a stream:</b> These methods should return a <i>new</i>, independent
       instance each time they are called. The caller is responsible for ensuring that the
       returned stream is closed.
   <li><b>Convenience methods:</b> These are implementations of common operations that are
       typically implemented by opening a stream using one of the methods in the first category,
       doing something and finally closing the stream or channel that was opened.
 </ul>

 @since 14.0
 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.ByteSink -->
  <!-- start class com.google.common.io.ByteSource -->
  <class name="ByteSource" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteSource"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="asCharSource" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a {@link CharSource} view of this byte source that decodes bytes read from this source
 as characters using the given {@link Charset}.

 <p>If {@link CharSource#asByteSource} is called on the returned source with the same charset,
 the default implementation of this method will ensure that the original {@code ByteSource} is
 returned, rather than round-trip encoding. Subclasses that override this method should behave
 the same way.]]>
      </doc>
    </method>
    <method name="openStream" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new {@link InputStream} for reading from this source. This method returns a new,
 independent stream each time it is called.

 <p>The caller is responsible for ensuring that the returned stream is closed.

 @throws IOException if an I/O error occurs while opening the stream]]>
      </doc>
    </method>
    <method name="openBufferedStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new buffered {@link InputStream} for reading from this source. The returned stream is
 not required to be a {@link BufferedInputStream} in order to allow implementations to simply
 delegate to {@link #openStream()} when the stream returned by that method does not benefit from
 additional buffering (for example, a {@code ByteArrayInputStream}). This method returns a new,
 independent stream each time it is called.

 <p>The caller is responsible for ensuring that the returned stream is closed.

 @throws IOException if an I/O error occurs while opening the stream
 @since 15.0 (in 14.0 with return type {@link BufferedInputStream})]]>
      </doc>
    </method>
    <method name="slice" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Returns a view of a slice of this byte source that is at most {@code length} bytes long
 starting at the given {@code offset}. If {@code offset} is greater than the size of this
 source, the returned source will be empty. If {@code offset + length} is greater than the size
 of this source, the returned source will contain the slice starting at {@code offset} and
 ending at the end of this source.

 @throws IllegalArgumentException if {@code offset} or {@code length} is negative]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns whether the source has zero bytes. The default implementation first checks {@link
 #sizeIfKnown}, returning true if it's known to be zero and false if it's known to be non-zero.
 If the size is not known, it falls back to opening a stream and checking for EOF.

 <p>Note that, in cases where {@code sizeIfKnown} returns zero, it is <i>possible</i> that bytes
 are actually available for reading. (For example, some special files may return a size of 0
 despite actually having content when read.) This means that a source may return {@code true}
 from {@code isEmpty()} despite having readable content.

 @throws IOException if an I/O error occurs
 @since 15.0]]>
      </doc>
    </method>
    <method name="sizeIfKnown" return="com.google.common.base.Optional&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the size of this source in bytes, if the size can be easily determined without actually
 opening the data stream.

 <p>The default implementation returns {@link Optional#absent}. Some sources, such as a file,
 may return a non-absent value. Note that in such cases, it is <i>possible</i> that this method
 will return a different number of bytes than would be returned by reading all of the bytes (for
 example, some special files may return a size of 0 despite actually having content when read).

 <p>Additionally, for mutable sources such as files, a subsequent read may return a different
 number of bytes if the contents are changed.

 @since 19.0]]>
      </doc>
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the size of this source in bytes, even if doing so requires opening and traversing an
 entire stream. To avoid a potentially expensive operation, see {@link #sizeIfKnown}.

 <p>The default implementation calls {@link #sizeIfKnown} and returns the value if present. If
 absent, it will fall back to a heavyweight operation that will open a stream, read (or {@link
 InputStream#skip(long) skip}, if possible) to the end of the stream and return the total number
 of bytes that were read.

 <p>Note that for some sources that implement {@link #sizeIfKnown} to provide a more efficient
 implementation, it is <i>possible</i> that this method will return a different number of bytes
 than would be returned by reading all of the bytes (for example, some special files may return
 a size of 0 despite actually having content when read).

 <p>In either case, for mutable sources such as files, a subsequent read may return a different
 number of bytes if the contents are changed.

 @throws IOException if an I/O error occurs while reading the size of this source]]>
      </doc>
    </method>
    <method name="copyTo" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="output" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies the contents of this byte source to the given {@code OutputStream}. Does not close
 {@code output}.

 @return the number of bytes copied
 @throws IOException if an I/O error occurs while reading from this source or writing to {@code
     output}]]>
      </doc>
    </method>
    <method name="copyTo" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sink" type="com.google.common.io.ByteSink"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies the contents of this byte source to the given {@code ByteSink}.

 @return the number of bytes copied
 @throws IOException if an I/O error occurs while reading from this source or writing to {@code
     sink}]]>
      </doc>
    </method>
    <method name="read" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the full contents of this byte source as a byte array.

 @throws IOException if an I/O error occurs while reading from this source]]>
      </doc>
    </method>
    <method name="read" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the contents of this byte source using the given {@code processor} to process bytes as
 they are read. Stops when all bytes have been read or the consumer returns {@code false}.
 Returns the result produced by the processor.

 @throws IOException if an I/O error occurs while reading from this source or if {@code
     processor} throws an {@code IOException}
 @since 16.0]]>
      </doc>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hashFunction" type="com.google.common.hash.HashFunction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Hashes the contents of this byte source using the given hash function.

 @throws IOException if an I/O error occurs while reading from this source]]>
      </doc>
    </method>
    <method name="contentEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.io.ByteSource"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Checks that the contents of this byte source are equal to the contents of the given byte
 source.

 @throws IOException if an I/O error occurs while reading from this source or {@code other}]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sources" type="java.lang.Iterable&lt;? extends com.google.common.io.ByteSource&gt;"/>
      <doc>
      <![CDATA[Concatenates multiple {@link ByteSource} instances into a single source. Streams returned from
 the source will contain the concatenated data from the streams of the underlying sources.

 <p>Only one underlying stream will be open at a time. Closing the concatenated stream will
 close the open underlying stream.

 @param sources the sources to concatenate
 @return a {@code ByteSource} containing the concatenated data
 @since 15.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sources" type="java.util.Iterator&lt;? extends com.google.common.io.ByteSource&gt;"/>
      <doc>
      <![CDATA[Concatenates multiple {@link ByteSource} instances into a single source. Streams returned from
 the source will contain the concatenated data from the streams of the underlying sources.

 <p>Only one underlying stream will be open at a time. Closing the concatenated stream will
 close the open underlying stream.

 <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method
 is called. This will fail if the iterator is infinite and may cause problems if the iterator
 eagerly fetches data for each source when iterated (rather than producing sources that only
 load data through their streams). Prefer using the {@link #concat(Iterable)} overload if
 possible.

 @param sources the sources to concatenate
 @return a {@code ByteSource} containing the concatenated data
 @throws NullPointerException if any of {@code sources} is {@code null}
 @since 15.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sources" type="com.google.common.io.ByteSource[]"/>
      <doc>
      <![CDATA[Concatenates multiple {@link ByteSource} instances into a single source. Streams returned from
 the source will contain the concatenated data from the streams of the underlying sources.

 <p>Only one underlying stream will be open at a time. Closing the concatenated stream will
 close the open underlying stream.

 @param sources the sources to concatenate
 @return a {@code ByteSource} containing the concatenated data
 @throws NullPointerException if any of {@code sources} is {@code null}
 @since 15.0]]>
      </doc>
    </method>
    <method name="wrap" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <doc>
      <![CDATA[Returns a view of the given byte array as a {@link ByteSource}. To view only a specific range
 in the array, use {@code ByteSource.wrap(b).slice(offset, length)}.

 <p>Note that the given byte array may be passed directly to methods on, for example, {@code
 OutputStream} (when {@code copyTo(OutputStream)} is called on the resulting {@code
 ByteSource}). This could allow a malicious {@code OutputStream} implementation to modify the
 contents of the array, but provides better performance in the normal case.

 @since 15.0 (since 14.0 as {@code ByteStreams.asByteSource(byte[])}).]]>
      </doc>
    </method>
    <method name="empty" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable {@link ByteSource} that contains no bytes.

 @since 15.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A readable source of bytes, such as a file. Unlike an {@link InputStream}, a {@code ByteSource}
 is not an open, stateful stream for input that can be read and closed. Instead, it is an
 immutable <i>supplier</i> of {@code InputStream} instances.

 <p>{@code ByteSource} provides two kinds of methods:

 <ul>
   <li><b>Methods that return a stream:</b> These methods should return a <i>new</i>, independent
       instance each time they are called. The caller is responsible for ensuring that the
       returned stream is closed.
   <li><b>Convenience methods:</b> These are implementations of common operations that are
       typically implemented by opening a stream using one of the methods in the first category,
       doing something and finally closing the stream that was opened.
 </ul>

 <p><b>Note:</b> In general, {@code ByteSource} is intended to be used for "file-like" sources
 that provide streams that are:

 <ul>
   <li><b>Finite:</b> Many operations, such as {@link #size()} and {@link #read()}, will either
       block indefinitely or fail if the source creates an infinite stream.
   <li><b>Non-destructive:</b> A <i>destructive</i> stream will consume or otherwise alter the
       bytes of the source as they are read from it. A source that provides such streams will not
       be reusable, and operations that read from the stream (including {@link #size()}, in some
       implementations) will prevent further operations from completing as expected.
 </ul>

 @since 14.0
 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.ByteSource -->
  <!-- start class com.google.common.io.ByteStreams -->
  <class name="ByteStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.InputStream"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the input stream to the output stream. Does not close or flush either
 stream.

 <p><b>Java 9 users and later:</b> this method should be treated as deprecated; use the
 equivalent {@link InputStream#transferTo} method instead.

 @param from the input stream to read from
 @param to the output stream to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.nio.channels.ReadableByteChannel"/>
      <param name="to" type="java.nio.channels.WritableByteChannel"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from the readable channel to the writable channel. Does not close or flush
 either channel.

 @param from the readable channel to read from
 @param to the writable channel to write to
 @return the number of bytes copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from an input stream into a byte array. Does not close the stream.

 <p><b>Java 9+ users:</b> use {@code in#readAllBytes()} instead.

 @param in the input stream to read from
 @return a byte array containing all the bytes from the stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="exhaust" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads and discards data from the given {@code InputStream} until the end of the stream is
 reached. Returns the total number of bytes read. Does not close the stream.

 @since 20.0]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array from the
 beginning.]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the {@code bytes} array,
 starting at the given position.

 @throws IndexOutOfBoundsException if {@code start} is negative or greater than the length of
     the array]]>
      </doc>
    </method>
    <method name="newDataInput" return="com.google.common.io.ByteArrayDataInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="byteArrayInputStream" type="java.io.ByteArrayInputStream"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataInput} instance to read from the given {@code
 ByteArrayInputStream}. The given input stream is not reset before being read from by the
 returned {@code ByteArrayDataInput}.

 @since 17.0]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance with a default size.]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance sized to hold {@code size} bytes before
 resizing.

 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="newDataOutput" return="com.google.common.io.ByteArrayDataOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="byteArrayOutputStream" type="java.io.ByteArrayOutputStream"/>
      <doc>
      <![CDATA[Returns a new {@link ByteArrayDataOutput} instance which writes to the given {@code
 ByteArrayOutputStream}. The given output stream is not reset before being written to by the
 returned {@code ByteArrayDataOutput} and new data will be appended to any existing content.

 <p>Note that if the given output stream was not empty or is modified after the {@code
 ByteArrayDataOutput} is created, the contract for {@link ByteArrayDataOutput#toByteArray} will
 not be honored (the bytes returned in the byte array may not be exactly what was written via
 calls to {@code ByteArrayDataOutput}).

 @since 17.0]]>
      </doc>
    </method>
    <method name="nullOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link OutputStream} that simply discards written bytes.

 <p><b>Java 11+ users:</b> use {@link OutputStream#nullOutputStream()} instead. Note that the
 {@link ByteStreams} method returns a singleton stream whose {@code close} method has no effect,
 while the {@link OutputStream} method returns a new instance whose {@code write} methods throw
 if called on a closed stream.

 @since 14.0 (since 1.0 as com.google.common.io.NullOutputStream)]]>
      </doc>
    </method>
    <method name="limit" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="limit" type="long"/>
      <doc>
      <![CDATA[Wraps a {@link InputStream}, limiting the number of bytes which can be read.

 @param in the input stream to be wrapped
 @param limit the maximum number of bytes to be read
 @return a length-limited {@link InputStream}
 @since 14.0 (since 1.0 as com.google.common.io.LimitInputStream)]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read enough bytes from the stream to fill the given byte array, with the same
 behavior as {@link DataInput#readFully(byte[])}. Does not close the stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @throws EOFException if this stream reaches the end before reading all the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Attempts to read {@code len} bytes from the stream into the given array starting at {@code
 off}, with the same behavior as {@link DataInput#readFully(byte[], int, int)}. Does not close
 the stream.

 @param in the input stream to read from.
 @param b the buffer into which the data is read.
 @param off an int specifying the offset into the data.
 @param len an int specifying the number of bytes to read.
 @throws EOFException if this stream reaches the end before reading all the bytes.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} bytes of data from the input stream. This method will block until the full
 amount has been skipped. Does not close the stream.

 @param in the input stream to read from
 @param n the number of bytes to skip
 @throws EOFException if this stream reaches the end before skipping all the bytes
 @throws IOException if an I/O error occurs, or the stream does not support skipping]]>
      </doc>
    </method>
    <method name="readBytes" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.io.InputStream"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of the given input stream using the given processor.

 @param input the input stream to process
 @param processor the object to which to pass the bytes of the stream
 @return the result of the byte processor
 @throws IOException if an I/O error occurs
 @since 14.0]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads some bytes from an input stream and stores them into the buffer array {@code b}. This
 method blocks until {@code len} bytes of input data have been read into the array, or end of
 file is detected. The number of bytes read is returned, possibly zero. Does not close the
 stream.

 <p>A caller can detect EOF if the number of bytes read is less than {@code len}. All subsequent
 calls on the same stream will return zero.

 <p>If {@code b} is null, a {@code NullPointerException} is thrown. If {@code off} is negative,
 or {@code len} is negative, or {@code off+len} is greater than the length of the array {@code
 b}, then an {@code IndexOutOfBoundsException} is thrown. If {@code len} is zero, then no bytes
 are read. Otherwise, the first byte read is stored into element {@code b[off]}, the next one
 into {@code b[off+1]}, and so on. The number of bytes read is, at most, equal to {@code len}.

 @param in the input stream to read from
 @param b the buffer into which the data is read
 @param off an int specifying the offset into the data
 @param len an int specifying the number of bytes to read
 @return the number of bytes read
 @throws IOException if an I/O error occurs
 @throws IndexOutOfBoundsException if {@code off} is negative, if {@code len} is negative, or if
     {@code off + len} is greater than {@code b.length}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with byte arrays and I/O streams.

 @author Chris Nokleberg
 @author Colin Decker
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.ByteStreams -->
  <!-- start class com.google.common.io.CharSink -->
  <class name="CharSink" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharSink"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="openStream" return="java.io.Writer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new {@link Writer} for writing to this sink. This method returns a new, independent
 writer each time it is called.

 <p>The caller is responsible for ensuring that the returned writer is closed.

 @throws IOException if an I/O error occurs while opening the writer]]>
      </doc>
    </method>
    <method name="openBufferedStream" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new buffered {@link Writer} for writing to this sink. The returned stream is not
 required to be a {@link BufferedWriter} in order to allow implementations to simply delegate to
 {@link #openStream()} when the stream returned by that method does not benefit from additional
 buffering. This method returns a new, independent writer each time it is called.

 <p>The caller is responsible for ensuring that the returned writer is closed.

 @throws IOException if an I/O error occurs while opening the writer
 @since 15.0 (in 14.0 with return type {@link BufferedWriter})]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the given character sequence to this sink.

 @throws IOException if an I/O error while writing to this sink]]>
      </doc>
    </method>
    <method name="writeLines"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lines" type="java.lang.Iterable&lt;? extends java.lang.CharSequence&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the given lines of text to this sink with each line (including the last) terminated with
 the operating system's default line separator. This method is equivalent to {@code
 writeLines(lines, System.getProperty("line.separator"))}.

 @throws IOException if an I/O error occurs while writing to this sink]]>
      </doc>
    </method>
    <method name="writeLines"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lines" type="java.lang.Iterable&lt;? extends java.lang.CharSequence&gt;"/>
      <param name="lineSeparator" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the given lines of text to this sink with each line (including the last) terminated with
 the given line separator.

 @throws IOException if an I/O error occurs while writing to this sink]]>
      </doc>
    </method>
    <method name="writeLines"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lines" type="java.util.stream.Stream&lt;? extends java.lang.CharSequence&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the given lines of text to this sink with each line (including the last) terminated with
 the operating system's default line separator. This method is equivalent to {@code
 writeLines(lines, System.getProperty("line.separator"))}.

 @throws IOException if an I/O error occurs while writing to this sink
 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="writeLines"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lines" type="java.util.stream.Stream&lt;? extends java.lang.CharSequence&gt;"/>
      <param name="lineSeparator" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the given lines of text to this sink with each line (including the last) terminated with
 the given line separator.

 @throws IOException if an I/O error occurs while writing to this sink
 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="writeFrom" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readable" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes all the text from the given {@link Readable} (such as a {@link Reader}) to this sink.
 Does not close {@code readable} if it is {@code Closeable}.

 @return the number of characters written
 @throws IOException if an I/O error occurs while reading from {@code readable} or writing to
     this sink]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A destination to which characters can be written, such as a text file. Unlike a {@link Writer}, a
 {@code CharSink} is not an open, stateful stream that can be written to and closed. Instead, it
 is an immutable <i>supplier</i> of {@code Writer} instances.

 <p>{@code CharSink} provides two kinds of methods:

 <ul>
   <li><b>Methods that return a writer:</b> These methods should return a <i>new</i>, independent
       instance each time they are called. The caller is responsible for ensuring that the
       returned writer is closed.
   <li><b>Convenience methods:</b> These are implementations of common operations that are
       typically implemented by opening a writer using one of the methods in the first category,
       doing something and finally closing the writer that was opened.
 </ul>

 <p>Any {@link ByteSink} may be viewed as a {@code CharSink} with a specific {@linkplain Charset
 character encoding} using {@link ByteSink#asCharSink(Charset)}. Characters written to the
 resulting {@code CharSink} will written to the {@code ByteSink} as encoded bytes.

 @since 14.0
 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CharSink -->
  <!-- start class com.google.common.io.CharSource -->
  <class name="CharSource" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharSource"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="asByteSource" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a {@link ByteSource} view of this char source that encodes chars read from this source
 as bytes using the given {@link Charset}.

 <p>If {@link ByteSource#asCharSource} is called on the returned source with the same charset,
 the default implementation of this method will ensure that the original {@code CharSource} is
 returned, rather than round-trip encoding. Subclasses that override this method should behave
 the same way.

 @since 20.0]]>
      </doc>
    </method>
    <method name="openStream" return="java.io.Reader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new {@link Reader} for reading from this source. This method returns a new, independent
 reader each time it is called.

 <p>The caller is responsible for ensuring that the returned reader is closed.

 @throws IOException if an I/O error occurs while opening the reader]]>
      </doc>
    </method>
    <method name="openBufferedStream" return="java.io.BufferedReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new {@link BufferedReader} for reading from this source. This method returns a new,
 independent reader each time it is called.

 <p>The caller is responsible for ensuring that the returned reader is closed.

 @throws IOException if an I/O error occurs while of opening the reader]]>
      </doc>
    </method>
    <method name="lines" return="java.util.stream.Stream&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens a new {@link Stream} for reading text one line at a time from this source. This method
 returns a new, independent stream each time it is called.

 <p>The returned stream is lazy and only reads from the source in the terminal operation. If an
 I/O error occurs while the stream is reading from the source or when the stream is closed, an
 {@link UncheckedIOException} is thrown.

 <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
 text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
 \n}. If the source's content does not end in a line termination sequence, it is treated as if
 it does.

 <p>The caller is responsible for ensuring that the returned stream is closed. For example:

 {@snippet :
 try (Stream<String> lines = source.lines()) {
   lines.map(...)
      .filter(...)
      .forEach(...);
 }
 }

 @throws IOException if an I/O error occurs while opening the stream
 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="lengthIfKnown" return="com.google.common.base.Optional&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the size of this source in chars, if the size can be easily determined without actually
 opening the data stream.

 <p>The default implementation returns {@link Optional#absent}. Some sources, such as a {@code
 CharSequence}, may return a non-absent value. Note that in such cases, it is <i>possible</i>
 that this method will return a different number of chars than would be returned by reading all
 of the chars.

 <p>Additionally, for mutable sources such as {@code StringBuilder}s, a subsequent read may
 return a different number of chars if the contents are changed.

 @since 19.0]]>
      </doc>
    </method>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the length of this source in chars, even if doing so requires opening and traversing an
 entire stream. To avoid a potentially expensive operation, see {@link #lengthIfKnown}.

 <p>The default implementation calls {@link #lengthIfKnown} and returns the value if present. If
 absent, it will fall back to a heavyweight operation that will open a stream, {@link
 Reader#skip(long) skip} to the end of the stream, and return the total number of chars that
 were skipped.

 <p>Note that for sources that implement {@link #lengthIfKnown} to provide a more efficient
 implementation, it is <i>possible</i> that this method will return a different number of chars
 than would be returned by reading all of the chars.

 <p>In either case, for mutable sources such as files, a subsequent read may return a different
 number of chars if the contents are changed.

 @throws IOException if an I/O error occurs while reading the length of this source
 @since 19.0]]>
      </doc>
    </method>
    <method name="copyTo" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends the contents of this source to the given {@link Appendable} (such as a {@link Writer}).
 Does not close {@code appendable} if it is {@code Closeable}.

 @return the number of characters copied
 @throws IOException if an I/O error occurs while reading from this source or writing to {@code
     appendable}]]>
      </doc>
    </method>
    <method name="copyTo" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sink" type="com.google.common.io.CharSink"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies the contents of this source to the given sink.

 @return the number of characters copied
 @throws IOException if an I/O error occurs while reading from this source or writing to {@code
     sink}]]>
      </doc>
    </method>
    <method name="read" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the contents of this source as a string.

 @throws IOException if an I/O error occurs while reading from this source]]>
      </doc>
    </method>
    <method name="readFirstLine" return="String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line of this source as a string. Returns {@code null} if this source is empty.

 <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
 text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
 \n}. If the source's content does not end in a line termination sequence, it is treated as if
 it does.

 @throws IOException if an I/O error occurs while reading from this source]]>
      </doc>
    </method>
    <method name="readLines" return="com.google.common.collect.ImmutableList&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all the lines of this source as a list of strings. The returned list will be empty if
 this source is empty.

 <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
 text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
 \n}. If the source's content does not end in a line termination sequence, it is treated as if
 it does.

 @throws IOException if an I/O error occurs while reading from this source]]>
      </doc>
    </method>
    <method name="readLines" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="processor" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads lines of text from this source, processing each line as it is read using the given {@link
 LineProcessor processor}. Stops when all lines have been processed or the processor returns
 {@code false} and returns the result produced by the processor.

 <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
 text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
 \n}. If the source's content does not end in a line termination sequence, it is treated as if
 it does.

 @throws IOException if an I/O error occurs while reading from this source or if {@code
     processor} throws an {@code IOException}
 @since 16.0]]>
      </doc>
    </method>
    <method name="forEachLine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.function.Consumer&lt;? super java.lang.String&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all lines of text from this source, running the given {@code action} for each line as it
 is read.

 <p>Like {@link BufferedReader#readLine()}, this method considers a line to be a sequence of
 text that is terminated by (but does not include) one of {@code \r\n}, {@code \r} or {@code
 \n}. If the source's content does not end in a line termination sequence, it is treated as if
 it does.

 @throws IOException if an I/O error occurs while reading from this source or if {@code action}
     throws an {@code UncheckedIOException}
 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns whether the source has zero chars. The default implementation first checks {@link
 #lengthIfKnown}, returning true if it's known to be zero and false if it's known to be
 non-zero. If the length is not known, it falls back to opening a stream and checking for EOF.

 <p>Note that, in cases where {@code lengthIfKnown} returns zero, it is <i>possible</i> that
 chars are actually available for reading. This means that a source may return {@code true} from
 {@code isEmpty()} despite having readable content.

 @throws IOException if an I/O error occurs
 @since 15.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sources" type="java.lang.Iterable&lt;? extends com.google.common.io.CharSource&gt;"/>
      <doc>
      <![CDATA[Concatenates multiple {@link CharSource} instances into a single source. Streams returned from
 the source will contain the concatenated data from the streams of the underlying sources.

 <p>Only one underlying stream will be open at a time. Closing the concatenated stream will
 close the open underlying stream.

 @param sources the sources to concatenate
 @return a {@code CharSource} containing the concatenated data
 @since 15.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sources" type="java.util.Iterator&lt;? extends com.google.common.io.CharSource&gt;"/>
      <doc>
      <![CDATA[Concatenates multiple {@link CharSource} instances into a single source. Streams returned from
 the source will contain the concatenated data from the streams of the underlying sources.

 <p>Only one underlying stream will be open at a time. Closing the concatenated stream will
 close the open underlying stream.

 <p>Note: The input {@code Iterator} will be copied to an {@code ImmutableList} when this method
 is called. This will fail if the iterator is infinite and may cause problems if the iterator
 eagerly fetches data for each source when iterated (rather than producing sources that only
 load data through their streams). Prefer using the {@link #concat(Iterable)} overload if
 possible.

 @param sources the sources to concatenate
 @return a {@code CharSource} containing the concatenated data
 @throws NullPointerException if any of {@code sources} is {@code null}
 @since 15.0]]>
      </doc>
    </method>
    <method name="concat" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sources" type="com.google.common.io.CharSource[]"/>
      <doc>
      <![CDATA[Concatenates multiple {@link CharSource} instances into a single source. Streams returned from
 the source will contain the concatenated data from the streams of the underlying sources.

 <p>Only one underlying stream will be open at a time. Closing the concatenated stream will
 close the open underlying stream.

 @param sources the sources to concatenate
 @return a {@code CharSource} containing the concatenated data
 @throws NullPointerException if any of {@code sources} is {@code null}
 @since 15.0]]>
      </doc>
    </method>
    <method name="wrap" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charSequence" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Returns a view of the given character sequence as a {@link CharSource}. The behavior of the
 returned {@code CharSource} and any {@code Reader} instances created by it is unspecified if
 the {@code charSequence} is mutated while it is being read, so don't do that.

 @since 15.0 (since 14.0 as {@code CharStreams.asCharSource(String)})]]>
      </doc>
    </method>
    <method name="empty" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable {@link CharSource} that contains no characters.

 @since 15.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code
 CharSource} is not an open, stateful stream of characters that can be read and closed. Instead,
 it is an immutable <i>supplier</i> of {@code Reader} instances.

 <p>{@code CharSource} provides two kinds of methods:

 <ul>
   <li><b>Methods that return a reader:</b> These methods should return a <i>new</i>, independent
       instance each time they are called. The caller is responsible for ensuring that the
       returned reader is closed.
   <li><b>Convenience methods:</b> These are implementations of common operations that are
       typically implemented by opening a reader using one of the methods in the first category,
       doing something and finally closing the reader that was opened.
 </ul>

 <p>Several methods in this class, such as {@link #readLines()}, break the contents of the source
 into lines. Like {@link BufferedReader}, these methods break lines on any of {@code \n}, {@code
 \r} or {@code \r\n}, do not include the line separator in each line and do not consider there to
 be an empty line at the end if the contents are terminated with a line separator.

 <p>Any {@link ByteSource} containing text encoded with a specific {@linkplain Charset character
 encoding} may be viewed as a {@code CharSource} using {@link ByteSource#asCharSource(Charset)}.

 <p><b>Note:</b> In general, {@code CharSource} is intended to be used for "file-like" sources
 that provide readers that are:

 <ul>
   <li><b>Finite:</b> Many operations, such as {@link #length()} and {@link #read()}, will either
       block indefinitely or fail if the source creates an infinite reader.
   <li><b>Non-destructive:</b> A <i>destructive</i> reader will consume or otherwise alter the
       source as they are read from it. A source that provides such readers will not be reusable,
       and operations that read from the stream (including {@link #length()}, in some
       implementations) will prevent further operations from completing as expected.
 </ul>

 @since 14.0
 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CharSource -->
  <!-- start class com.google.common.io.CharStreams -->
  <class name="CharStreams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.Readable"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters between the {@link Readable} and {@link Appendable} objects. Does not
 close or flush either object.

 @param from the object to read from
 @param to the object to write to
 @return the number of characters copied
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a {@link Readable} object into a {@link String}. Does not close the
 {@code Readable}.

 @param r the object to read from
 @return a string containing all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a {@link Readable} object. The lines do not include
 line-termination characters, but do include other leading and trailing whitespace.

 <p>Does not close the {@code Readable}. If reading files or resources you should use the {@link
 Files#readLines} and {@link Resources#readLines} methods.

 @param r the object to read from
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readable" type="java.lang.Readable"/>
      <param name="processor" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link Readable} object, stopping when the processor returns {@code false}
 or all lines have been read and returning the result produced by the processor. Does not close
 {@code readable}. Note that this method may not fully consume the contents of {@code readable}
 if the processor stops processing early.

 @throws IOException if an I/O error occurs
 @since 14.0]]>
      </doc>
    </method>
    <method name="exhaust" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readable" type="java.lang.Readable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads and discards data from the given {@code Readable} until the end of the stream is reached.
 Returns the total number of chars read. Does not close the stream.

 @since 20.0]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Discards {@code n} characters of data from the reader. This method will block until the full
 amount has been skipped. Does not close the reader.

 @param reader the reader to read from
 @param n the number of characters to skip
 @throws EOFException if this stream reaches the end before skipping all the characters
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="nullWriter" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Writer} that simply discards written chars.

 <p><b>Java 11+ users:</b> use {@link Writer#nullWriter()} instead. Note that the {@link
 CharStreams} method returns a singleton writer whose {@code close} method has no effect, while
 the {@link Writer#nullWriter()} method returns a new instance whose methods throw after the
 instance is {@link Writer#close() closed}.

 @since 15.0]]>
      </doc>
    </method>
    <method name="asWriter" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.Appendable"/>
      <doc>
      <![CDATA[Returns a Writer that sends all output to the given {@link Appendable} target. Closing the
 writer will close the target if it is {@link Closeable}, and flushing the writer will flush the
 target if it is {@link java.io.Flushable}.

 @param target the object to which output will be sent
 @return a new Writer object, unless target is a Writer, in which case the target is returned]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with character streams.

 @author Chris Nokleberg
 @author Bin Zhu
 @author Colin Decker
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CharStreams -->
  <!-- start class com.google.common.io.Closeables -->
  <class name="Closeables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="Closeable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes a {@link Closeable}, with control over whether an {@code IOException} may be thrown.
 This is primarily useful in a finally block, where a thrown exception needs to be logged but
 not propagated (otherwise the original exception will be lost).

 <p>If {@code swallowIOException} is true then we never throw {@code IOException} but merely log
 it.

 <p>Example:

 {@snippet :
 public void useStreamNicely() throws IOException {
   SomeStream stream = new SomeStream("foo");
   boolean threw = true;
   try {
     // ... code which does something with the stream ...
     threw = false;
   } finally {
     // If an exception occurs, rethrow it only if threw==false:
     Closeables.close(stream, threw);
   }
 }
 }

 @param closeable the {@code Closeable} object to be closed, or null, in which case this method
     does nothing
 @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code close}
     methods
 @throws IOException if {@code swallowIOException} is false and {@code close} throws an {@code
     IOException}.]]>
      </doc>
    </method>
    <method name="closeQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputStream" type="InputStream"/>
      <doc>
      <![CDATA[Closes the given {@link InputStream}, logging any {@code IOException} that's thrown rather than
 propagating it.

 <p>While it's not safe in the general case to ignore exceptions that are thrown when closing an
 I/O resource, it should generally be safe in the case of a resource that's being used only for
 reading, such as an {@code InputStream}. Unlike with writable resources, there's no chance that
 a failure that occurs when closing the stream indicates a meaningful problem such as a failure
 to flush all bytes to the underlying resource.

 @param inputStream the input stream to be closed, or {@code null} in which case this method
     does nothing
 @since 17.0]]>
      </doc>
    </method>
    <method name="closeQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="Reader"/>
      <doc>
      <![CDATA[Closes the given {@link Reader}, logging any {@code IOException} that's thrown rather than
 propagating it.

 <p>While it's not safe in the general case to ignore exceptions that are thrown when closing an
 I/O resource, it should generally be safe in the case of a resource that's being used only for
 reading, such as a {@code Reader}. Unlike with writable resources, there's no chance that a
 failure that occurs when closing the reader indicates a meaningful problem such as a failure to
 flush all bytes to the underlying resource.

 @param reader the reader to be closed, or {@code null} in which case this method does nothing
 @since 17.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Closeable} objects.

 @author Michael Lancaster
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Closeables -->
  <!-- start class com.google.common.io.Closer -->
  <class name="Closer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="create" return="com.google.common.io.Closer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link Closer}.]]>
      </doc>
    </method>
    <method name="register" return="C extends java.io.Closeable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="C extends java.io.Closeable"/>
      <doc>
      <![CDATA[Registers the given {@code closeable} to be closed when this {@code Closer} is {@linkplain
 #close closed}.

 @return the given {@code closeable}]]>
      </doc>
    </method>
    <method name="rethrow" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores the given throwable and rethrows it. It will be rethrown as is if it is an {@code
 IOException}, {@code RuntimeException} or {@code Error}. Otherwise, it will be rethrown wrapped
 in a {@code RuntimeException}. <b>Note:</b> Be sure to declare all of the checked exception
 types your try block can throw when calling an overload of this method so as to avoid losing
 the original exception type.

 <p>This method always throws, and as such should be called as {@code throw closer.rethrow(e);}
 to ensure the compiler knows that it will throw.

 @return this method does not return; it always throws
 @throws IOException when the given throwable is an IOException]]>
      </doc>
    </method>
    <method name="rethrow" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <param name="declaredType" type="java.lang.Class&lt;X&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stores the given throwable and rethrows it. It will be rethrown as is if it is an {@code
 IOException}, {@code RuntimeException}, {@code Error} or a checked exception of the given type.
 Otherwise, it will be rethrown wrapped in a {@code RuntimeException}. <b>Note:</b> Be sure to
 declare all of the checked exception types your try block can throw when calling an overload of
 this method so as to avoid losing the original exception type.

 <p>This method always throws, and as such should be called as {@code throw closer.rethrow(e,
 ...);} to ensure the compiler knows that it will throw.

 @return this method does not return; it always throws
 @throws IOException when the given throwable is an IOException
 @throws X when the given throwable is of the declared type X]]>
      </doc>
    </method>
    <method name="rethrow" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <param name="declaredType1" type="java.lang.Class&lt;X1&gt;"/>
      <param name="declaredType2" type="java.lang.Class&lt;X2&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stores the given throwable and rethrows it. It will be rethrown as is if it is an {@code
 IOException}, {@code RuntimeException}, {@code Error} or a checked exception of either of the
 given types. Otherwise, it will be rethrown wrapped in a {@code RuntimeException}. <b>Note:</b>
 Be sure to declare all of the checked exception types your try block can throw when calling an
 overload of this method so as to avoid losing the original exception type.

 <p>This method always throws, and as such should be called as {@code throw closer.rethrow(e,
 ...);} to ensure the compiler knows that it will throw.

 @return this method does not return; it always throws
 @throws IOException when the given throwable is an IOException
 @throws X1 when the given throwable is of the declared type X1
 @throws X2 when the given throwable is of the declared type X2]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes all {@code Closeable} instances that have been added to this {@code Closer}. If an
 exception was thrown in the try block and passed to one of the {@code exceptionThrown} methods,
 any exceptions thrown when attempting to close a closeable will be suppressed. Otherwise, the
 <i>first</i> exception to be thrown from an attempt to close a closeable will be thrown and any
 additional exceptions that are thrown after that will be suppressed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Closeable} that collects {@code Closeable} resources and closes them all when it is
 {@linkplain #close closed}. This was intended to approximately emulate the behavior of Java 7's
 <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html"
 >try-with-resources</a> statement in JDK6-compatible code. Code using this should be
 approximately equivalent in behavior to the same code written with try-with-resources.

 <p>This class is intended to be used in the following pattern:

 {@snippet :
 Closer closer = Closer.create();
 try {
   InputStream in = closer.register(openInputStream());
   OutputStream out = closer.register(openOutputStream());
   // do stuff
 } catch (Throwable e) {
   // ensure that any checked exception types other than IOException that could be thrown are
   // provided here, e.g. throw closer.rethrow(e, CheckedException.class);
   throw closer.rethrow(e);
 } finally {
   closer.close();
 }
 }

 <p>Note that this try-catch-finally block is not equivalent to a try-catch-finally block using
 try-with-resources. To get the equivalent of that, you must wrap the above code in <i>another</i>
 try block in order to catch any exception that may be thrown (including from the call to {@code
 close()}).

 <p>This pattern ensures the following:

 <ul>
   <li>Each {@code Closeable} resource that is successfully registered will be closed later.
   <li>If a {@code Throwable} is thrown in the try block, no exceptions that occur when attempting
       to close resources will be thrown from the finally block. The throwable from the try block
       will be thrown.
   <li>If no exceptions or errors were thrown in the try block, the <i>first</i> exception thrown
       by an attempt to close a resource will be thrown.
   <li>Any exception caught when attempting to close a resource that is <i>not</i> thrown (because
       another exception is already being thrown) is <i>suppressed</i>.
 </ul>

 <p>An exception that is suppressed is added to the exception that <i>will</i> be thrown using
 {@code Throwable.addSuppressed(Throwable)}.

 @author Colin Decker
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Closer -->
  <!-- start class com.google.common.io.CountingInputStream -->
  <class name="CountingInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another input stream, counting the number of bytes read.

 @param in the input stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes read.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that counts the number of bytes read.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingInputStream -->
  <!-- start class com.google.common.io.CountingOutputStream -->
  <class name="CountingOutputStream" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wraps another output stream, counting the number of bytes written.

 @param out the output stream to be wrapped]]>
      </doc>
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes written.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An OutputStream that counts the number of bytes written.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.CountingOutputStream -->
  <!-- start class com.google.common.io.FileBackedOutputStream -->
  <class name="FileBackedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileBackedOutputStream" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold, and does not reset the data when the
 {@link ByteSource} returned by {@link #asByteSource} is finalized.

 @param fileThreshold the number of bytes before the stream should switch to buffering to a file
 @throws IllegalArgumentException if {@code fileThreshold} is negative]]>
      </doc>
    </constructor>
    <constructor name="FileBackedOutputStream" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that uses the given file threshold, and optionally resets the data when
 the {@link ByteSource} returned by {@link #asByteSource} is finalized.

 @param fileThreshold the number of bytes before the stream should switch to buffering to a file
 @param resetOnFinalize if true, the {@link #reset} method will be called when the {@link
     ByteSource} returned by {@link #asByteSource} is finalized.
 @throws IllegalArgumentException if {@code fileThreshold} is negative]]>
      </doc>
    </constructor>
    <method name="asByteSource" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a readable {@link ByteSource} view of the data that has been written to this stream.

 @since 15.0]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calls {@link #close} if not already closed, and then resets this object back to its initial
 state, for reuse. If data was buffered to a file, it will be deleted.

 @throws IOException if an I/O error occurred while deleting the file buffer]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An {@link OutputStream} that starts buffering to a byte array, but switches to file buffering
 once the data reaches a configurable size.

 <p>When this stream creates a temporary file, it restricts the file's permissions to the current
 user or, in the case of Android, the current app. If that is not possible (as is the case under
 the very old Android Ice Cream Sandwich release), then this stream throws an exception instead of
 creating a file that would be more accessible. (This behavior is new in Guava 32.0.0. Previous
 versions would create a file that is more accessible, as discussed in <a
 href="https://github.com/google/guava/issues/2575">Guava issue 2575</a>. TODO: b/283778848 - Fill
 in CVE number once it's available.)

 <p>Temporary files created by this stream may live in the local filesystem until either:

 <ul>
   <li>{@link #reset} is called (removing the data in this stream and deleting the file), or...
   <li>this stream (or, more precisely, its {@link #asByteSource} view) is finalized during
       garbage collection, <strong>AND</strong> this stream was not constructed with {@linkplain
       #FileBackedOutputStream(int) the 1-arg constructor} or the {@linkplain
       #FileBackedOutputStream(int, boolean) 2-arg constructor} passing {@code false} in the
       second parameter.
 </ul>

 <p>This class is thread-safe.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.FileBackedOutputStream -->
  <!-- start class com.google.common.io.Files -->
  <class name="Files" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReader" return="java.io.BufferedReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered reader that reads from a file using the given character set.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link
 java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @return the buffered reader]]>
      </doc>
    </method>
    <method name="newWriter" return="java.io.BufferedWriter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Returns a buffered writer that writes to a file using the given character set.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link
 java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,
 java.nio.file.OpenOption...)}.

 @param file the file to write to
 @param charset the charset used to encode the output stream; see {@link StandardCharsets} for
     helpful predefined constants
 @return the buffered writer]]>
      </doc>
    </method>
    <method name="asByteSource" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a new {@link ByteSource} for reading bytes from the given file.

 @since 14.0]]>
      </doc>
    </method>
    <method name="asByteSink" return="com.google.common.io.ByteSink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="modes" type="com.google.common.io.FileWriteMode[]"/>
      <doc>
      <![CDATA[Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}
 control how the file is opened for writing. When no mode is provided, the file will be
 truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes
 will append to the end of the file without truncating it.

 @since 14.0]]>
      </doc>
    </method>
    <method name="asCharSource" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a new {@link CharSource} for reading character data from the given file using the given
 character set.

 @since 14.0]]>
      </doc>
    </method>
    <method name="asCharSink" return="com.google.common.io.CharSink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="modes" type="com.google.common.io.FileWriteMode[]"/>
      <doc>
      <![CDATA[Returns a new {@link CharSink} for writing character data to the given file using the given
 character set. The given {@code modes} control how the file is opened for writing. When no mode
 is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND
 APPEND} mode is provided, writes will append to the end of the file without truncating it.

 @since 14.0]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a file into a byte array.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.

 @param file the file to read from
 @return a byte array containing all the bytes from file
 @throws IllegalArgumentException if the file is bigger than the largest possible byte array
     (2^31 - 1)
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asCharSource(file, charset).read()}.">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a file into a {@link String}, using the given character set.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @return a string containing all the characters from the file
 @throws IOException if an I/O error occurs
 @deprecated Prefer {@code asCharSource(file, charset).read()}.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="byte[]"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Overwrites a file with the contents of a byte array.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link
 java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.

 @param from the bytes to write
 @param to the destination file
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asCharSink(to, charset).write(from)}.">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a character sequence (such as a string) to a file using the given character set.

 @param from the character sequence to write
 @param to the destination file
 @param charset the charset used to encode the output stream; see {@link StandardCharsets} for
     helpful predefined constants
 @throws IOException if an I/O error occurs
 @deprecated Prefer {@code asCharSink(to, charset).write(from)}.]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a file to an output stream.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link
 java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.

 @param from the source file
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all the bytes from one file to another.

 <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process
 termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you
 need to guard against those conditions, you should employ other file-level synchronization.

 <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten
 with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>
 file, the contents of that file will be deleted.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link
 java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.

 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs
 @throws IllegalArgumentException if {@code from.equals(to)}]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asCharSource(from, charset).copyTo(to)}.">
      <param name="from" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="to" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all characters from a file to an appendable object, using the given character set.

 @param from the source file
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @param to the appendable object
 @throws IOException if an I/O error occurs
 @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This
     method is scheduled to be removed in October 2019.">
      <param name="from" type="java.lang.CharSequence"/>
      <param name="to" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Appends a character sequence (such as a string) to a file using the given character set.

 @param from the character sequence to append
 @param to the destination file
 @param charset the charset used to encode the output stream; see {@link StandardCharsets} for
     helpful predefined constants
 @throws IOException if an I/O error occurs
 @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This
     method is scheduled to be removed in October 2019.]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file1" type="java.io.File"/>
      <param name="file2" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the given files exist, are not directories, and contain the same bytes.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="createTempDir" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="For Android users, see the lEsS_tHaNa
     href=quote_cHaRhttps://developer.android.com/training/data-storagequote_cHaR target=quote_cHaR_blankquote_cHaR>Data and File
     Storage overviewlEsS_tHaN/a> to select an appropriate temporary directory (perhaps {@code
     context.getCacheDir()}), and create your own directory under that. (For example, you might
     use {@code new File(context.getCacheDir(), quote_cHaRdirectorynamequote_cHaR).mkdir()}, or, if you need an
     arbitrary number of temporary directories, you might have to generate multiple directory
     names in a loop until {@code mkdir()} returns {@code true}.) For JRE users, prefer {@link
     java.nio.file.Files#createTempDirectory}, transforming it to a {@link File} using {@link
     java.nio.file.Path#toFile() toFile()} if needed. To restrict permissions as this method
     does, pass {@code
     PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(quote_cHaRrwx------quote_cHaR))} to your
     call to {@code createTempDirectory}.">
      <doc>
      <![CDATA[Atomically creates a new directory somewhere beneath the system's temporary directory (as
 defined by the {@code java.io.tmpdir} system property), and returns its name.

 <p>The temporary directory is created with permissions restricted to the current user or, in
 the case of Android, the current app. If that is not possible (as is the case under the very
 old Android Ice Cream Sandwich release), then this method throws an exception instead of
 creating a directory that would be more accessible. (This behavior is new in Guava 32.0.0.
 Previous versions would create a directory that is more accessible, as discussed in <a
 href="https://github.com/google/guava/issues/4011">CVE-2020-8908</a>.)

 <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to
 create a directory, not a regular file. A common pitfall is to call {@code createTempFile},
 delete the file and create a directory in its place, but this leads a race condition which can
 be exploited to create security vulnerabilities, especially when executable files are to be
 written into the directory.

 <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,
 and that it will not be called thousands of times per second.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link
 java.nio.file.Files#createTempDirectory}.

 @return the newly-created directory
 @throws IllegalStateException if the directory could not be created, such as if the system does
     not support creating temporary directories securely
 @deprecated For Android users, see the <a
     href="https://developer.android.com/training/data-storage" target="_blank">Data and File
     Storage overview</a> to select an appropriate temporary directory (perhaps {@code
     context.getCacheDir()}), and create your own directory under that. (For example, you might
     use {@code new File(context.getCacheDir(), "directoryname").mkdir()}, or, if you need an
     arbitrary number of temporary directories, you might have to generate multiple directory
     names in a loop until {@code mkdir()} returns {@code true}.) For JRE users, prefer {@link
     java.nio.file.Files#createTempDirectory}, transforming it to a {@link File} using {@link
     java.nio.file.Path#toFile() toFile()} if needed. To restrict permissions as this method
     does, pass {@code
     PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString("rwx------"))} to your
     call to {@code createTempDirectory}.]]>
      </doc>
    </method>
    <method name="touch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates an empty file or updates the last updated timestamp on the same as the unix command of
 the same name.

 @param file the file to create or update
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="createParentDirs"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates any necessary but nonexistent parent directories of the specified file. Note that if
 this operation fails it may have succeeded in creating some (but not all) of the necessary
 parent directories.

 @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent
     directories of the specified file could not be created.
 @since 4.0]]>
      </doc>
    </method>
    <method name="move"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.io.File"/>
      <param name="to" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Moves a file from one path to another. This method can rename a file and/or move it to a
 different directory. In either case {@code to} must be the target path for the file itself; not
 just the new name for the file or the path to the new parent directory.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.

 @param from the source file
 @param to the destination file
 @throws IOException if an I/O error occurs
 @throws IllegalArgumentException if {@code from.equals(to)}]]>
      </doc>
    </method>
    <method name="readFirstLine" return="String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asCharSource(file, charset).readFirstLine()}.">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the first line from a file. The line does not include line-termination characters, but
 does include other leading and trailing whitespace.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @return the first line, or null if the file is empty
 @throws IOException if an I/O error occurs
 @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}.]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a file. The lines do not include line-termination characters, but
 do include other leading and trailing whitespace.

 <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code
 Files.asCharSource(file, charset).readLines()}.

 <p><b>{@link java.nio.file.Path} equivalent:</b> {@link
 java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asCharSource(file, charset).readLines(callback)}.">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a {@link File}, stopping when our callback returns false, or we have read
 all of the lines.

 @param file the file to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @param callback the {@link LineProcessor} to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs
 @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}.]]>
      </doc>
    </method>
    <method name="readBytes" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asByteSource(file).read(processor)}.">
      <param name="file" type="java.io.File"/>
      <param name="processor" type="com.google.common.io.ByteProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Process the bytes of a file.

 <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)

 @param file the file to read
 @param processor the object to which the bytes of the file are passed.
 @return the result of the byte processor
 @throws IOException if an I/O error occurs
 @deprecated Prefer {@code asByteSource(file).read(processor)}.]]>
      </doc>
    </method>
    <method name="hash" return="com.google.common.hash.HashCode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Prefer {@code asByteSource(file).hash(hashFunction)}.">
      <param name="file" type="java.io.File"/>
      <param name="hashFunction" type="com.google.common.hash.HashFunction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Computes the hash code of the {@code file} using {@code hashFunction}.

 @param file the file to read
 @param hashFunction the hash function to use to hash the data
 @return the {@link HashCode} of all of the bytes in the file
 @throws IOException if an I/O error occurs
 @since 12.0
 @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}.]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully maps a file read-only in to memory as per {@link
 FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.

 <p>Files are mapped from offset 0 to its length.

 <p>This only works for files # {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @return a read-only buffer reflecting {@code file}
 @throws FileNotFoundException if the {@code file} does not exist
 @throws IOException if an I/O error occurs
 @see FileChannel#map(MapMode, long, long)
 @since 2.0]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="mode" type="java.nio.channels.FileChannel.MapMode"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully maps a file in to memory as per {@link
 FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link
 MapMode}.

 <p>Files are mapped from offset 0 to its length.

 <p>This only works for files # {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @param mode the mode to use when mapping {@code file}
 @return a buffer reflecting {@code file}
 @throws FileNotFoundException if the {@code file} does not exist
 @throws IOException if an I/O error occurs
 @see FileChannel#map(MapMode, long, long)
 @since 2.0]]>
      </doc>
    </method>
    <method name="map" return="java.nio.MappedByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="mode" type="java.nio.channels.FileChannel.MapMode"/>
      <param name="size" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,
 long, long)} using the requested {@link MapMode}.

 <p>Files are mapped from offset 0 to {@code size}.

 <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created
 with the requested {@code size}. Thus this method is useful for creating memory mapped files
 which do not yet exist.

 <p>This only works for files # {@link Integer#MAX_VALUE} bytes.

 @param file the file to map
 @param mode the mode to use when mapping {@code file}
 @return a buffer reflecting {@code file}
 @throws IOException if an I/O error occurs
 @see FileChannel#map(MapMode, long, long)
 @since 2.0]]>
      </doc>
    </method>
    <method name="simplifyPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathname" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent
 to the original. The following heuristics are used:

 <ul>
   <li>empty string becomes .
   <li>. stays as .
   <li>fold out ./
   <li>fold out ../ when possible
   <li>collapse multiple slashes
   <li>delete trailing slashes (unless the path is just "/")
 </ul>

 <p>These heuristics do not always match the behavior of the filesystem. In particular, consider
 the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a
 symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the
 sibling of {@code a} referred to by {@code b}.

 @since 11.0]]>
      </doc>
    </method>
    <method name="getFileExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fullName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> for
 the given file name, or the empty string if the file has no extension. The result does not
 include the '{@code .}'.

 <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's
 name as determined by {@link File#getName}. It does not account for any filesystem-specific
 behavior that the {@link File} API does not already account for. For example, on NTFS it will
 report {@code "txt"} as the extension for the filename {@code "foo.exe:.txt"} even though NTFS
 will drop the {@code ":.txt"} part of the name when the file is actually created on the
 filesystem due to NTFS's <a
 href="https://learn.microsoft.com/en-us/archive/blogs/askcore/alternate-data-streams-in-ntfs">Alternate
 Data Streams</a>.

 @since 11.0]]>
      </doc>
    </method>
    <method name="getNameWithoutExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the file name without its <a
 href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> or path. This is
 similar to the {@code basename} unix command. The result does not include the '{@code .}'.

 @param file The name of the file to trim the extension from. This can be either a fully
     qualified file name (including a path) or just a file name.
 @return The file name without its path or extension.
 @since 14.0]]>
      </doc>
    </method>
    <method name="fileTraverser" return="com.google.common.graph.Traverser&lt;java.io.File&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Traverser} instance for the file and directory tree. The returned traverser
 starts from a {@link File} and will return all files and directories it encounters.

 <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no
 way to ensure that a symbolic link to a directory is not followed when traversing the tree. In
 this case, iterables created by this traverser could contain files that are outside of the
 given directory or even be infinite if there is a symbolic link loop.

 <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same
 except that it doesn't follow symbolic links and returns {@code Path} instances.

 <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not
 a directory, no exception will be thrown and the returned {@link Iterable} will contain a
 single element: that file.

 <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File("/"))} may return files
 with the following paths: {@code ["/", "/etc", "/etc/config.txt", "/etc/fonts", "/home",
 "/home/alice", ...]}

 @since 23.5]]>
      </doc>
    </method>
    <method name="isDirectory" return="com.google.common.base.Predicate&lt;java.io.File&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that returns the result of {@link File#isDirectory} on input files.

 @since 15.0]]>
      </doc>
    </method>
    <method name="isFile" return="com.google.common.base.Predicate&lt;java.io.File&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a predicate that returns the result of {@link File#isFile} on input files.

 @since 15.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with {@linkplain File files}.

 <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the
 JDK's {@link java.nio.file.Files} class.

 @author Chris Nokleberg
 @author Colin Decker
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Files -->
  <!-- start class com.google.common.io.FileWriteMode -->
  <class name="FileWriteMode" extends="java.lang.Enum&lt;com.google.common.io.FileWriteMode&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.io.FileWriteMode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.io.FileWriteMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Modes for opening a file for writing. The default when mode when none is specified is to truncate
 the file before writing.

 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.FileWriteMode -->
  <!-- start class com.google.common.io.Flushables -->
  <class name="Flushables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <param name="swallowIOException" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush a {@link Flushable}, with control over whether an {@code IOException} may be thrown.

 <p>If {@code swallowIOException} is true, then we don't rethrow {@code IOException}, but merely
 log it.

 @param flushable the {@code Flushable} object to be flushed.
 @param swallowIOException if true, don't propagate IO exceptions thrown by the {@code flush}
     method
 @throws IOException if {@code swallowIOException} is false and {@link Flushable#flush} throws
     an {@code IOException}.
 @see Closeables#close]]>
      </doc>
    </method>
    <method name="flushQuietly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flushable" type="java.io.Flushable"/>
      <doc>
      <![CDATA[Equivalent to calling {@code flush(flushable, true)}, but with no {@code IOException} in the
 signature.

 @param flushable the {@code Flushable} object to be flushed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for working with {@link Flushable} objects.

 @author Michael Lancaster
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Flushables -->
  <!-- start class com.google.common.io.InsecureRecursiveDeleteException -->
  <class name="InsecureRecursiveDeleteException" extends="java.nio.file.FileSystemException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InsecureRecursiveDeleteException" type="String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception indicating that a recursive delete can't be performed because the file system does not
 have the support necessary to guarantee that it is not vulnerable to race conditions that would
 allow it to delete files and directories outside of the directory being deleted (i.e., {@link
 SecureDirectoryStream} is not supported).

 <p>{@link RecursiveDeleteOption#ALLOW_INSECURE} can be used to force the recursive delete method
 to proceed anyway.

 @since 33.4.0 (but since 21.0 in the JRE flavor)
 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.InsecureRecursiveDeleteException -->
  <!-- start interface com.google.common.io.LineProcessor -->
  <interface name="LineProcessor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="processLine" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="line" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method will be called once for each line.

 @param line the line read from the input, without delimiter
 @return true to continue processing, false to stop]]>
      </doc>
    </method>
    <method name="getResult" return="T extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the result of processing all the lines.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback to be used with the streaming {@code readLines} methods.

 <p>{@link #processLine} will be called for each line that is read, and should return {@code
 false} when you want to stop processing.

 @author Miles Barr
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.io.LineProcessor -->
  <!-- start class com.google.common.io.LineReader -->
  <class name="LineReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LineReader" type="java.lang.Readable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance that will read lines from the given {@code Readable} object.]]>
      </doc>
    </constructor>
    <method name="readLine" return="String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a line of text. A line is considered to be terminated by any one of a line feed ({@code
 '\n'}), a carriage return ({@code '\r'}), or a carriage return followed immediately by a
 linefeed ({@code "\r\n"}).

 @return a {@code String} containing the contents of the line, not including any
     line-termination characters, or {@code null} if the end of the stream has been reached.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for reading lines of text. Provides the same functionality as {@link
 java.io.BufferedReader#readLine()} but for all {@link Readable} objects, not just instances of
 {@link Reader}.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LineReader -->
  <!-- start class com.google.common.io.LittleEndianDataInputStream -->
  <class name="LittleEndianDataInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataInput"/>
    <constructor name="LittleEndianDataInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code LittleEndianDataInputStream} that wraps the given stream.

 @param in the stream to delegate to]]>
      </doc>
    </constructor>
    <method name="readLine" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method will throw an {@link UnsupportedOperationException}.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readUnsignedByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads an unsigned {@code short} as specified by {@link DataInputStream#readUnsignedShort()},
 except using little-endian byte order.

 @return the next two bytes of the input stream, interpreted as an unsigned 16-bit integer in
     little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads an integer as specified by {@link DataInputStream#readInt()}, except using little-endian
 byte order.

 @return the next four bytes of the input stream, interpreted as an {@code int} in little-endian
     byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code long} as specified by {@link DataInputStream#readLong()}, except using
 little-endian byte order.

 @return the next eight bytes of the input stream, interpreted as a {@code long} in
     little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code float} as specified by {@link DataInputStream#readFloat()}, except using
 little-endian byte order.

 @return the next four bytes of the input stream, interpreted as a {@code float} in
     little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code double} as specified by {@link DataInputStream#readDouble()}, except using
 little-endian byte order.

 @return the next eight bytes of the input stream, interpreted as a {@code double} in
     little-endian byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readUTF" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a {@code short} as specified by {@link DataInputStream#readShort()}, except using
 little-endian byte order.

 @return the next two bytes of the input stream, interpreted as a {@code short} in little-endian
     byte order.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a char as specified by {@link DataInputStream#readChar()}, except using little-endian
 byte order.

 @return the next two bytes of the input stream, interpreted as a {@code char} in little-endian
     byte order
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An implementation of {@link DataInput} that uses little-endian byte ordering for reading {@code
 short}, {@code int}, {@code float}, {@code double}, and {@code long} values.

 <p><b>Note:</b> This class intentionally violates the specification of its supertype {@code
 DataInput}, which explicitly requires big-endian byte order.

 @author Chris Nokleberg
 @author Keith Bottner
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LittleEndianDataInputStream -->
  <!-- start class com.google.common.io.LittleEndianDataOutputStream -->
  <class name="LittleEndianDataOutputStream" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.DataOutput"/>
    <constructor name="LittleEndianDataOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code LittleEndianDataOutputStream} that wraps the given stream.

 @param out the stream to delegate to]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="The semantics of {@code writeBytes(String s)} are considered dangerous. Please use
     {@link #writeUTF(String s)}, {@link #writeChars(String s)} or another write method instead.">
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated The semantics of {@code writeBytes(String s)} are considered dangerous. Please use
     {@link #writeUTF(String s)}, {@link #writeChars(String s)} or another write method instead.]]>
      </doc>
    </method>
    <method name="writeChar"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a char as specified by {@link DataOutputStream#writeChar(int)}, except using
 little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeChars"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code String} as specified by {@link DataOutputStream#writeChars(String)}, except
 each character is written using little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="double"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code double} as specified by {@link DataOutputStream#writeDouble(double)}, except
 using little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="float"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code float} as specified by {@link DataOutputStream#writeFloat(float)}, except using
 little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes an {@code int} as specified by {@link DataOutputStream#writeInt(int)}, except using
 little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code long} as specified by {@link DataOutputStream#writeLong(long)}, except using
 little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeShort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes a {@code short} as specified by {@link DataOutputStream#writeShort(int)}, except using
 little-endian byte order.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="writeUTF"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An implementation of {@link DataOutput} that uses little-endian byte ordering for writing {@code
 char}, {@code short}, {@code int}, {@code float}, {@code double}, and {@code long} values.

 <p><b>Note:</b> This class intentionally violates the specification of its supertype {@code
 DataOutput}, which explicitly requires big-endian byte order.

 @author Chris Nokleberg
 @author Keith Bottner
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.LittleEndianDataOutputStream -->
  <!-- start class com.google.common.io.MoreFiles -->
  <class name="MoreFiles" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="asByteSource" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="options" type="java.nio.file.OpenOption[]"/>
      <doc>
      <![CDATA[Returns a view of the given {@code path} as a {@link ByteSource}.

 <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file
 and may affect the behavior of the returned source and the streams it provides. See {@link
 StandardOpenOption} for the standard options that may be provided. Providing no options is
 equivalent to providing the {@link StandardOpenOption#READ READ} option.]]>
      </doc>
    </method>
    <method name="asByteSink" return="com.google.common.io.ByteSink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="options" type="java.nio.file.OpenOption[]"/>
      <doc>
      <![CDATA[Returns a view of the given {@code path} as a {@link ByteSink}.

 <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file
 and may affect the behavior of the returned sink and the streams it provides. See {@link
 StandardOpenOption} for the standard options that may be provided. Providing no options is
 equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link
 StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE
 WRITE} options.]]>
      </doc>
    </method>
    <method name="asCharSource" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="options" type="java.nio.file.OpenOption[]"/>
      <doc>
      <![CDATA[Returns a view of the given {@code path} as a {@link CharSource} using the given {@code
 charset}.

 <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file
 and may affect the behavior of the returned source and the streams it provides. See {@link
 StandardOpenOption} for the standard options that may be provided. Providing no options is
 equivalent to providing the {@link StandardOpenOption#READ READ} option.]]>
      </doc>
    </method>
    <method name="asCharSink" return="com.google.common.io.CharSink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="options" type="java.nio.file.OpenOption[]"/>
      <doc>
      <![CDATA[Returns a view of the given {@code path} as a {@link CharSink} using the given {@code charset}.

 <p>Any {@linkplain OpenOption open options} provided are used when opening streams to the file
 and may affect the behavior of the returned sink and the streams it provides. See {@link
 StandardOpenOption} for the standard options that may be provided. Providing no options is
 equivalent to providing the {@link StandardOpenOption#CREATE CREATE}, {@link
 StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} and {@link StandardOpenOption#WRITE
 WRITE} options.]]>
      </doc>
    </method>
    <method name="listFiles" return="com.google.common.collect.ImmutableList&lt;java.nio.file.Path&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns an immutable list of paths to the files contained in the given directory.

 @throws NoSuchFileException if the file does not exist <i>(optional specific exception)</i>
 @throws NotDirectoryException if the file could not be opened because it is not a directory
     <i>(optional specific exception)</i>
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="fileTraverser" return="com.google.common.graph.Traverser&lt;java.nio.file.Path&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Traverser} instance for the file and directory tree. The returned traverser
 starts from a {@link Path} and will return all files and directories it encounters.

 <p>The returned traverser attempts to avoid following symbolic links to directories. However,
 the traverser cannot guarantee that it will not follow symbolic links to directories as it is
 possible for a directory to be replaced with a symbolic link between checking if the file is a
 directory and actually reading the contents of that directory.

 <p>If the {@link Path} passed to one of the traversal methods does not exist or is not a
 directory, no exception will be thrown and the returned {@link Iterable} will contain a single
 element: that path.

 <p>{@link DirectoryIteratorException} may be thrown when iterating {@link Iterable} instances
 created by this traverser if an {@link IOException} is thrown by a call to {@link
 #listFiles(Path)}.

 <p>Example: {@code MoreFiles.fileTraverser().depthFirstPreOrder(Paths.get("/"))} may return the
 following paths: {@code ["/", "/etc", "/etc/config.txt", "/etc/fonts", "/home", "/home/alice",
 ...]}

 @since 23.5]]>
      </doc>
    </method>
    <method name="isDirectory" return="com.google.common.base.Predicate&lt;java.nio.file.Path&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="options" type="java.nio.file.LinkOption[]"/>
      <doc>
      <![CDATA[Returns a predicate that returns the result of {@link java.nio.file.Files#isDirectory(Path,
 LinkOption...)} on input paths with the given link options.]]>
      </doc>
    </method>
    <method name="isRegularFile" return="com.google.common.base.Predicate&lt;java.nio.file.Path&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="options" type="java.nio.file.LinkOption[]"/>
      <doc>
      <![CDATA[Returns a predicate that returns the result of {@link java.nio.file.Files#isRegularFile(Path,
 LinkOption...)} on input paths with the given link options.]]>
      </doc>
    </method>
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path1" type="java.nio.file.Path"/>
      <param name="path2" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns true if the files located by the given paths exist, are not directories, and contain
 the same bytes.

 @throws IOException if an I/O error occurs
 @since 22.0]]>
      </doc>
    </method>
    <method name="touch"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Like the unix command of the same name, creates an empty file or updates the last modified
 timestamp of the existing file at the given path to the current system time.]]>
      </doc>
    </method>
    <method name="createParentDirectories"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.FileAttribute[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates any necessary but nonexistent parent directories of the specified path. Note that if
 this operation fails, it may have succeeded in creating some (but not all) of the necessary
 parent directories. The parent directory is created with the given {@code attrs}.

 @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent
     directories of the specified file could not be created.]]>
      </doc>
    </method>
    <method name="getFileExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> for
 the file at the given path, or the empty string if the file has no extension. The result does
 not include the '{@code .}'.

 <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's
 name as determined by {@link Path#getFileName}. It does not account for any filesystem-specific
 behavior that the {@link Path} API does not already account for. For example, on NTFS it will
 report {@code "txt"} as the extension for the filename {@code "foo.exe:.txt"} even though NTFS
 will drop the {@code ":.txt"} part of the name when the file is actually created on the
 filesystem due to NTFS's <a
 href="https://learn.microsoft.com/en-us/archive/blogs/askcore/alternate-data-streams-in-ntfs">Alternate
 Data Streams</a>.]]>
      </doc>
    </method>
    <method name="getNameWithoutExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <doc>
      <![CDATA[Returns the file name without its <a
 href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> or path. This is
 similar to the {@code basename} unix command. The result does not include the '{@code .}'.]]>
      </doc>
    </method>
    <method name="deleteRecursively"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="options" type="com.google.common.io.RecursiveDeleteOption[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes the file or directory at the given {@code path} recursively. Deletes symbolic links,
 not their targets (subject to the caveat below).

 <p>If an I/O exception occurs attempting to read, open or delete any file under the given
 directory, this method skips that file and continues. All such exceptions are collected and,
 after attempting to delete all files, an {@code IOException} is thrown containing those
 exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.

 <h2>Warning: Security of recursive deletes</h2>

 <p>On a file system that supports symbolic links and does <i>not</i> support {@link
 SecureDirectoryStream}, it is possible for a recursive delete to delete files and directories
 that are <i>outside</i> the directory being deleted. This can happen if, after checking that a
 file is a directory (and not a symbolic link), that directory is replaced by a symbolic link to
 an outside directory before the call that opens the directory to read its entries.

 <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't
 guarantee the security of recursive deletes. If you wish to allow the recursive deletes anyway,
 pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that behavior.

 @throws NoSuchFileException if {@code path} does not exist <i>(optional specific exception)</i>
 @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be
     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not
     specified
 @throws IOException if {@code path} or any file in the subtree rooted at it can't be deleted
     for any reason]]>
      </doc>
    </method>
    <method name="deleteDirectoryContents"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="options" type="com.google.common.io.RecursiveDeleteOption[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes all files within the directory at the given {@code path} {@linkplain #deleteRecursively
 recursively}. Does not delete the directory itself. Deletes symbolic links, not their targets
 (subject to the caveat below). If {@code path} itself is a symbolic link to a directory, that
 link is followed and the contents of the directory it targets are deleted.

 <p>If an I/O exception occurs attempting to read, open or delete any file under the given
 directory, this method skips that file and continues. All such exceptions are collected and,
 after attempting to delete all files, an {@code IOException} is thrown containing those
 exceptions as {@linkplain Throwable#getSuppressed() suppressed exceptions}.

 <h2>Warning: Security of recursive deletes</h2>

 <p>On a file system that supports symbolic links and does <i>not</i> support {@link
 SecureDirectoryStream}, it is possible for a recursive delete to delete files and directories
 that are <i>outside</i> the directory being deleted. This can happen if, after checking that a
 file is a directory (and not a symbolic link), that directory is replaced by a symbolic link to
 an outside directory before the call that opens the directory to read its entries.

 <p>By default, this method throws {@link InsecureRecursiveDeleteException} if it can't
 guarantee the security of recursive deletes. If you wish to allow the recursive deletes anyway,
 pass {@link RecursiveDeleteOption#ALLOW_INSECURE} to this method to override that behavior.

 @throws NoSuchFileException if {@code path} does not exist <i>(optional specific exception)</i>
 @throws NotDirectoryException if the file at {@code path} is not a directory <i>(optional
     specific exception)</i>
 @throws InsecureRecursiveDeleteException if the security of recursive deletes can't be
     guaranteed for the file system and {@link RecursiveDeleteOption#ALLOW_INSECURE} was not
     specified
 @throws IOException if one or more files can't be deleted for any reason]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utilities for use with {@link Path} instances, intended to complement {@link Files}.

 <p>Many methods provided by Guava's {@code Files} class for {@link java.io.File} instances are
 now available via the JDK's {@link java.nio.file.Files} class for {@code Path} - check the JDK's
 class if a sibling method from {@code Files} appears to be missing from this class.

 @since 33.4.0 (but since 21.0 in the JRE flavor)
 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.MoreFiles -->
  <!-- start class com.google.common.io.PatternFilenameFilter -->
  <class name="PatternFilenameFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.FilenameFilter"/>
    <constructor name="PatternFilenameFilter" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.

 @param patternStr the pattern string on which to filter file names
 @throws PatternSyntaxException if pattern compilation fails (runtime)]]>
      </doc>
    </constructor>
    <constructor name="PatternFilenameFilter" type="java.util.regex.Pattern"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a pattern file name filter object.

 @param pattern the pattern on which to filter file names]]>
      </doc>
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="fileName" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[File name filter that only accepts files matching a regular expression. This class is thread-safe
 and immutable.

 @author Apple Chow
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.PatternFilenameFilter -->
  <!-- start class com.google.common.io.RecursiveDeleteOption -->
  <class name="RecursiveDeleteOption" extends="java.lang.Enum&lt;com.google.common.io.RecursiveDeleteOption&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.io.RecursiveDeleteOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.io.RecursiveDeleteOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Options for use with recursive delete methods ({@link MoreFiles#deleteRecursively} and {@link
 MoreFiles#deleteDirectoryContents}).

 @since 33.4.0 (but since 21.0 in the JRE flavor)
 @author Colin Decker]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.RecursiveDeleteOption -->
  <!-- start class com.google.common.io.Resources -->
  <class name="Resources" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="asByteSource" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Returns a {@link ByteSource} that reads from the given URL.

 @since 14.0]]>
      </doc>
    </method>
    <method name="asCharSource" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a {@link CharSource} that reads from the given URL using the given character set.

 @since 14.0]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all bytes from a URL into a byte array.

 @param url the URL to read from
 @return a byte array containing all the bytes from the URL
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all characters from a URL into a {@link String}, using the given character set.

 @param url the URL to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @return a string containing all the characters from the URL
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="readLines" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="callback" type="com.google.common.io.LineProcessor&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Streams lines from a URL, stopping when our callback returns false, or we have read all of the
 lines.

 @param url the URL to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @param callback the LineProcessor to use to handle the lines
 @return the output of processing the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="readLines" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads all of the lines from a URL. The lines do not include line-termination characters, but do
 include other leading and trailing whitespace.

 <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code
 Resources.asCharSource(url, charset).readLines()}.

 @param url the URL to read from
 @param charset the charset used to decode the input stream; see {@link StandardCharsets} for
     helpful predefined constants
 @return a mutable {@link List} containing all the lines
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.net.URL"/>
      <param name="to" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies all bytes from a URL to an output stream.

 @param from the URL to read from
 @param to the output stream
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code URL} pointing to {@code resourceName} if the resource is found using the
 {@linkplain Thread#getContextClassLoader() context class loader}. In simple environments, the
 context class loader will find resources from the class path. In environments where different
 threads can have different class loaders, for example app servers, the context class loader
 will typically have been set to an appropriate loader for the current thread.

 <p>In the unusual case where the context class loader is null, the class loader that loaded
 this class ({@code Resources}) will be used instead.

 @throws IllegalArgumentException if the resource is not found]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="resourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Given a {@code resourceName} that is relative to {@code contextClass}, returns a {@code URL}
 pointing to the named resource.

 @throws IllegalArgumentException if the resource is not found]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides utility methods for working with resources in the classpath. Note that even though these
 methods use {@link URL} parameters, they are usually not appropriate for HTTP or other
 non-classpath resources.

 @author Chris Nokleberg
 @author Ben Yu
 @author Colin Decker
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.io.Resources -->
</package>
<package name="com.google.common.math">
  <!-- start class com.google.common.math.BigDecimalMath -->
  <class name="BigDecimalMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="roundToDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigDecimal"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}
 is precisely representable as a {@code double}, its {@code double} value will be returned;
 otherwise, the rounding will choose between the two nearest representable values with {@code
 mode}.

 <p>For the case of {@link RoundingMode#HALF_DOWN}, {@code HALF_UP}, and {@code HALF_EVEN},
 infinite {@code double} values are considered infinitely far away. For example, 2^2000 is not
 representable as a double, but {@code roundToDouble(BigDecimal.valueOf(2).pow(2000), HALF_UP)}
 will return {@code Double.MAX_VALUE}, not {@code Double.POSITIVE_INFINITY}.

 <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754
 default rounding mode: if the two nearest representable values are equally near, the one with
 the least significant bit zero is chosen. (In such cases, both of the nearest representable
 values are even integers; this method returns the one that is a multiple of a greater power of
 two.)

 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not precisely representable as a {@code double}
 @since 30.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on {@link BigDecimal} that is not covered by its built-in methods.

 @author Louis Wasserman
 @since 30.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.BigDecimalMath -->
  <!-- start class com.google.common.math.BigIntegerMath -->
  <class name="BigIntegerMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="ceilingPowerOfTwo" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to
 {@code BigInteger.valueOf(2).pow(log2(x, CEILING))}.

 @throws IllegalArgumentException if {@code x <= 0}
 @since 20.0]]>
      </doc>
    </method>
    <method name="floorPowerOfTwo" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code
 BigInteger.valueOf(2).pow(log2(x, FLOOR))}.

 @throws IllegalArgumentException if {@code x <= 0}
 @since 20.0]]>
      </doc>
    </method>
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a power of two.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not a power of two]]>
      </doc>
    </method>
    <method name="log10" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not a power of ten]]>
      </doc>
    </method>
    <method name="sqrt" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the square root of {@code x}, rounded with the specified rounding mode.

 @throws IllegalArgumentException if {@code x < 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code
     sqrt(x)} is not an integer]]>
      </doc>
    </method>
    <method name="roundToDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}
 is precisely representable as a {@code double}, its {@code double} value will be returned;
 otherwise, the rounding will choose between the two nearest representable values with {@code
 mode}.

 <p>For the case of {@link RoundingMode#HALF_DOWN}, {@code HALF_UP}, and {@code HALF_EVEN},
 infinite {@code double} values are considered infinitely far away. For example, 2^2000 is not
 representable as a double, but {@code roundToDouble(BigInteger.valueOf(2).pow(2000), HALF_UP)}
 will return {@code Double.MAX_VALUE}, not {@code Double.POSITIVE_INFINITY}.

 <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754
 default rounding mode: if the two nearest representable values are equally near, the one with
 the least significant bit zero is chosen. (In such cases, both of the nearest representable
 values are even integers; this method returns the one that is a multiple of a greater power of
 two.)

 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not precisely representable as a {@code double}
 @since 30.0]]>
      </doc>
    </method>
    <method name="divide" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.math.BigInteger"/>
      <param name="q" type="java.math.BigInteger"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code
 RoundingMode}.

 @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
     is not an integer multiple of {@code b}]]>
      </doc>
    </method>
    <method name="factorial" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive integers, or {@code 1}
 if {@code n == 0}.

 <p><b>Warning:</b> the result takes <i>O(n log n)</i> space, so use cautiously.

 <p>This uses an efficient binary recursive algorithm to compute the factorial with balanced
 multiplies. It also removes all the 2s from the intermediate products (shifting them back in at
 the end).

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="binomial" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and
 {@code k}, that is, {@code n! / (k! (n - k)!)}.

 <p><b>Warning:</b> the result can take as much as <i>O(k log n)</i> space.

 @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on values of type {@code BigInteger}.

 <p>The implementations of many methods in this class are based on material from Henry S. Warren,
 Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).

 <p>Similar functionality for {@code int} and for {@code long} can be found in {@link IntMath} and
 {@link LongMath} respectively.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.BigIntegerMath -->
  <!-- start class com.google.common.math.DoubleMath -->
  <class name="DoubleMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="roundToInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the {@code int} value that is equal to {@code x} rounded with the specified rounding
 mode, if possible.

 @throws ArithmeticException if
     <ul>
       <li>{@code x} is infinite or NaN
       <li>{@code x}, after being rounded to a mathematical integer using the specified rounding
           mode, is either less than {@code Integer.MIN_VALUE} or greater than {@code
           Integer.MAX_VALUE}
       <li>{@code x} is not a mathematical integer and {@code mode} is {@link
           RoundingMode#UNNECESSARY}
     </ul>]]>
      </doc>
    </method>
    <method name="roundToLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the {@code long} value that is equal to {@code x} rounded with the specified rounding
 mode, if possible.

 @throws ArithmeticException if
     <ul>
       <li>{@code x} is infinite or NaN
       <li>{@code x}, after being rounded to a mathematical integer using the specified rounding
           mode, is either less than {@code Long.MIN_VALUE} or greater than {@code
           Long.MAX_VALUE}
       <li>{@code x} is not a mathematical integer and {@code mode} is {@link
           RoundingMode#UNNECESSARY}
     </ul>]]>
      </doc>
    </method>
    <method name="roundToBigInteger" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the {@code BigInteger} value that is equal to {@code x} rounded with the specified
 rounding mode, if possible.

 @throws ArithmeticException if
     <ul>
       <li>{@code x} is infinite or NaN
       <li>{@code x} is not a mathematical integer and {@code mode} is {@link
           RoundingMode#UNNECESSARY}
     </ul>]]>
      </doc>
    </method>
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} is exactly equal to {@code 2^k} for some finite integer
 {@code k}.]]>
      </doc>
    </method>
    <method name="log2" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Returns the base 2 logarithm of a double value.

 <p>Special cases:

 <ul>
   <li>If {@code x} is NaN or less than zero, the result is NaN.
   <li>If {@code x} is positive infinity, the result is positive infinity.
   <li>If {@code x} is positive or negative zero, the result is negative infinity.
 </ul>

 <p>The computed result is within 1 ulp of the exact result.

 <p>If the result of this method will be immediately rounded to an {@code int}, {@link
 #log2(double, RoundingMode)} is faster.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base 2 logarithm of a double value, rounded with the specified rounding mode to an
 {@code int}.

 <p>Regardless of the rounding mode, this is faster than {@code (int) log2(x)}.

 @throws IllegalArgumentException if {@code x <= 0.0}, {@code x} is NaN, or {@code x} is
     infinite]]>
      </doc>
    </method>
    <method name="isMathematicalInteger" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a mathematical integer.

 <p>This is equivalent to, but not necessarily implemented as, the expression {@code
 !Double.isNaN(x) && !Double.isInfinite(x) && x == Math.rint(x)}.]]>
      </doc>
    </method>
    <method name="factorial" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if
 {@code n == 0}, or {@code n!}, or {@link Double#POSITIVE_INFINITY} if {@code n! >
 Double.MAX_VALUE}.

 <p>The result is within 1 ulp of the true value.

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="fuzzyEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <param name="tolerance" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code a} and {@code b} are within {@code tolerance} of each other.

 <p>Technically speaking, this is equivalent to {@code Math.abs(a - b) <= tolerance ||
 Double.valueOf(a).equals(Double.valueOf(b))}.

 <p>Notable special cases include:

 <ul>
   <li>All NaNs are fuzzily equal.
   <li>If {@code a == b}, then {@code a} and {@code b} are always fuzzily equal.
   <li>Positive and negative zero are always fuzzily equal.
   <li>If {@code tolerance} is zero, and neither {@code a} nor {@code b} is NaN, then {@code a}
       and {@code b} are fuzzily equal if and only if {@code a == b}.
   <li>With {@link Double#POSITIVE_INFINITY} tolerance, all non-NaN values are fuzzily equal.
   <li>With finite tolerance, {@code Double.POSITIVE_INFINITY} and {@code
       Double.NEGATIVE_INFINITY} are fuzzily equal only to themselves.
 </ul>

 <p>This is reflexive and symmetric, but <em>not</em> transitive, so it is <em>not</em> an
 equivalence relation and <em>not</em> suitable for use in {@link Object#equals}
 implementations.

 @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN
 @since 13.0]]>
      </doc>
    </method>
    <method name="fuzzyCompare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <param name="tolerance" type="double"/>
      <doc>
      <![CDATA[Compares {@code a} and {@code b} "fuzzily," with a tolerance for nearly-equal values.

 <p>This method is equivalent to {@code fuzzyEquals(a, b, tolerance) ? 0 : Double.compare(a,
 b)}. In particular, like {@link Double#compare(double, double)}, it treats all NaN values as
 equal and greater than all other values (including {@link Double#POSITIVE_INFINITY}).

 <p>This is <em>not</em> a total ordering and is <em>not</em> suitable for use in {@link
 Comparable#compareTo} implementations. In particular, it is not transitive.

 @throws IllegalArgumentException if {@code tolerance} is {@code < 0} or NaN
 @since 13.0]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.">
      <param name="values" type="double[]"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of
 {@code values}.

 <p>If these values are a sample drawn from a population, this is also an unbiased estimator of
 the arithmetic mean of the population.

 @param values a nonempty series of values
 @throws IllegalArgumentException if {@code values} is empty or contains any non-finite value
 @deprecated Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.">
      <param name="values" type="int[]"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of
 {@code values}.

 <p>If these values are a sample drawn from a population, this is also an unbiased estimator of
 the arithmetic mean of the population.

 @param values a nonempty series of values
 @throws IllegalArgumentException if {@code values} is empty
 @deprecated Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.">
      <param name="values" type="long[]"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of
 {@code values}.

 <p>If these values are a sample drawn from a population, this is also an unbiased estimator of
 the arithmetic mean of the population.

 @param values a nonempty series of values, which will be converted to {@code double} values
     (this may cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))
 @throws IllegalArgumentException if {@code values} is empty
 @deprecated Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.">
      <param name="values" type="java.lang.Iterable&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of
 {@code values}.

 <p>If these values are a sample drawn from a population, this is also an unbiased estimator of
 the arithmetic mean of the population.

 @param values a nonempty series of values, which will be converted to {@code double} values
     (this may cause loss of precision)
 @throws IllegalArgumentException if {@code values} is empty or contains any non-finite value
 @deprecated Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.">
      <param name="values" type="java.util.Iterator&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of
 {@code values}.

 <p>If these values are a sample drawn from a population, this is also an unbiased estimator of
 the arithmetic mean of the population.

 @param values a nonempty series of values, which will be converted to {@code double} values
     (this may cause loss of precision)
 @throws IllegalArgumentException if {@code values} is empty or contains any non-finite value
 @deprecated Use {@link Stats#meanOf} instead, noting the less strict handling of non-finite
     values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on doubles that is not covered by {@link java.lang.Math}.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.DoubleMath -->
  <!-- start class com.google.common.math.IntMath -->
  <class name="IntMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="ceilingPowerOfTwo" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to
 {@code checkedPow(2, log2(x, CEILING))}.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException of the next-higher power of two is not representable as an {@code
     int}, i.e. when {@code x > 2^30}
 @since 20.0]]>
      </doc>
    </method>
    <method name="floorPowerOfTwo" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code
 checkedPow(2, log2(x, FLOOR))}.

 @throws IllegalArgumentException if {@code x <= 0}
 @since 20.0]]>
      </doc>
    </method>
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a power of two.

 <p>This differs from {@code Integer.bitCount(x) == 1}, because {@code
 Integer.bitCount(Integer.MIN_VALUE) == 1}, but {@link Integer#MIN_VALUE} is not a power of two.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not a power of two]]>
      </doc>
    </method>
    <method name="log10" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not a power of ten]]>
      </doc>
    </method>
    <method name="pow" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to
 {@code BigInteger.valueOf(b).pow(k).intValue()}. This implementation runs in {@code O(log k)}
 time.

 <p>Compare {@link #checkedPow}, which throws an {@link ArithmeticException} upon overflow.

 @throws IllegalArgumentException if {@code k < 0}]]>
      </doc>
    </method>
    <method name="sqrt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the square root of {@code x}, rounded with the specified rounding mode.

 @throws IllegalArgumentException if {@code x < 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code
     sqrt(x)} is not an integer]]>
      </doc>
    </method>
    <method name="divide" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="int"/>
      <param name="q" type="int"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code
 RoundingMode}. If the {@code RoundingMode} is {@link RoundingMode#DOWN}, then this method is
 equivalent to regular Java division, {@code p / q}; and if it is {@link RoundingMode#FLOOR},
 then this method is equivalent to {@link Math#floorDiv(int,int) Math.floorDiv}{@code (p, q)}.

 @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
     is not an integer multiple of {@code b}]]>
      </doc>
    </method>
    <method name="mod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="m" type="int"/>
      <doc>
      <![CDATA[Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %
 m}, which might be negative. This method is equivalent to {@code Math.floorMod(x, m)} except
 that that method also allows negative {@code m}. {@code Math.floorMod} should be preferred when
 {@code m} is known to be positive.

 <p>For example:

 {@snippet :
 mod(7, 4) == 3
 mod(-7, 4) == 1
 mod(-1, 4) == 3
 mod(-8, 4) == 0
 mod(8, 4) == 0
 }

 @throws ArithmeticException if {@code m <= 0}
 @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3">
     Remainder Operator</a>]]>
      </doc>
    </method>
    <method name="gcd" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if {@code a == 0 && b ==
 0}.

 @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}]]>
      </doc>
    </method>
    <method name="checkedAdd" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the sum of {@code a} and {@code b}, provided it does not overflow.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 Math#addExact(int, int)} instead.

 @throws ArithmeticException if {@code a + b} overflows in signed {@code int} arithmetic]]>
      </doc>
    </method>
    <method name="checkedSubtract" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the difference of {@code a} and {@code b}, provided it does not overflow.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 Math#subtractExact(int, int)} instead.

 @throws ArithmeticException if {@code a - b} overflows in signed {@code int} arithmetic]]>
      </doc>
    </method>
    <method name="checkedMultiply" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the product of {@code a} and {@code b}, provided it does not overflow.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 Math#multiplyExact(int, int)} instead.

 @throws ArithmeticException if {@code a * b} overflows in signed {@code int} arithmetic]]>
      </doc>
    </method>
    <method name="checkedPow" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code b} to the {@code k}th power, provided it does not overflow.

 <p>{@link #pow} may be faster, but does not check for overflow.

 @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed {@code
     int} arithmetic]]>
      </doc>
    </method>
    <method name="saturatedAdd" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the sum of {@code a} and {@code b} unless it would overflow or underflow in which case
 {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="saturatedSubtract" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the difference of {@code a} and {@code b} unless it would overflow or underflow in
 which case {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="saturatedMultiply" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Returns the product of {@code a} and {@code b} unless it would overflow or underflow in which
 case {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="saturatedPow" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code b} to the {@code k}th power, unless it would overflow or underflow in which
 case {@code Integer.MAX_VALUE} or {@code Integer.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="factorial" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if
 {@code n == 0}, or {@link Integer#MAX_VALUE} if the result does not fit in a {@code int}.

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="binomial" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and
 {@code k}, or {@link Integer#MAX_VALUE} if the result does not fit in an {@code int}.

 @throws IllegalArgumentException if {@code n < 0}, {@code k < 0} or {@code k > n}]]>
      </doc>
    </method>
    <method name="mean" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <doc>
      <![CDATA[Returns the arithmetic mean of {@code x} and {@code y}, rounded towards negative infinity. This
 method is overflow resilient.

 @since 14.0]]>
      </doc>
    </method>
    <method name="isPrime" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code n} is a <a
 href="http://mathworld.wolfram.com/PrimeNumber.html">prime number</a>: an integer <i>greater
 than one</i> that cannot be factored into a product of <i>smaller</i> positive integers.
 Returns {@code false} if {@code n} is zero, one, or a composite number (one which <i>can</i> be
 factored into smaller positive integers).

 <p>To test larger numbers, use {@link LongMath#isPrime} or {@link BigInteger#isProbablePrime}.

 @throws IllegalArgumentException if {@code n} is negative
 @since 20.0]]>
      </doc>
    </method>
    <method name="saturatedAbs" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Returns the closest representable {@code int} to the absolute value of {@code x}.

 <p>This is the same thing as the true absolute value of {@code x} except in the case when
 {@code x} is {@link Integer#MIN_VALUE}, in which case this returns {@link Integer#MAX_VALUE}.
 (Note that {@code Integer.MAX_VALUE} is mathematically equal to {@code -Integer.MIN_VALUE -
 1}.)

 <p>There are three common APIs for determining the absolute value of an integer, all of which
 behave identically except when passed {@code Integer.MIN_VALUE}. Those methods are:

 <ul>
   <li>{@link Math#abs(int)}, which returns {@code Integer.MIN_VALUE} when passed {@code
       Integer.MIN_VALUE}
   <li>{@link Math#absExact(int)}, which throws {@link ArithmeticException} when passed {@code
       Integer.MIN_VALUE}
   <li>this method, {@code IntMath.saturatedAbs(int)}, which returns {@code Integer.MAX_VALUE}
       when passed {@code Integer.MIN_VALUE}
 </ul>

 <p>Note that if your only goal is to turn a well-distributed `int` (such as a random number or
 hash code) into a well-distributed nonnegative number, the most even distribution is achieved
 not by this method or other absolute value methods, but by {@code x & Integer.MAX_VALUE}.

 @since NEXT]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on values of type {@code int}. Where possible, methods are defined and
 named analogously to their {@code BigInteger} counterparts.

 <p>The implementations of many methods in this class are based on material from Henry S. Warren,
 Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).

 <p>Similar functionality for {@code long} and for {@link BigInteger} can be found in {@link
 LongMath} and {@link BigIntegerMath} respectively. For other common operations on {@code int}
 values, see {@link com.google.common.primitives.Ints}.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.IntMath -->
  <!-- start class com.google.common.math.LinearTransformation -->
  <class name="LinearTransformation" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LinearTransformation"
      static="false" final="false" visibility="public"
      deprecated="Create instances by using the static factory methods of the class.">
      <doc>
      <![CDATA[Constructor for use by subclasses inside Guava.

 @deprecated Create instances by using the static factory methods of the class.]]>
      </doc>
    </constructor>
    <method name="mapping" return="com.google.common.math.LinearTransformation.LinearTransformationBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x1" type="double"/>
      <param name="y1" type="double"/>
      <doc>
      <![CDATA[Start building an instance which maps {@code x = x1} to {@code y = y1}. Both arguments must be
 finite. Call either {@link LinearTransformationBuilder#and} or {@link
 LinearTransformationBuilder#withSlope} on the returned object to finish building the instance.]]>
      </doc>
    </method>
    <method name="vertical" return="com.google.common.math.LinearTransformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Builds an instance representing a vertical transformation with a constant value of {@code x}.
 (The inverse of this will be a horizontal transformation.)]]>
      </doc>
    </method>
    <method name="horizontal" return="com.google.common.math.LinearTransformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="y" type="double"/>
      <doc>
      <![CDATA[Builds an instance representing a horizontal transformation with a constant value of {@code y}.
 (The inverse of this will be a vertical transformation.)]]>
      </doc>
    </method>
    <method name="forNaN" return="com.google.common.math.LinearTransformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds an instance for datasets which contains {@link Double#NaN}. The {@link #isHorizontal}
 and {@link #isVertical} methods return {@code false} and the {@link #slope}, and {@link
 #transform} methods all return {@link Double#NaN}. The {@link #inverse} method returns the same
 instance.]]>
      </doc>
    </method>
    <method name="isVertical" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this is a vertical transformation.]]>
      </doc>
    </method>
    <method name="isHorizontal" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this is a horizontal transformation.]]>
      </doc>
    </method>
    <method name="slope" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the slope of the transformation, i.e. the rate of change of {@code y} with respect to
 {@code x}. This must not be called on a vertical transformation (i.e. when {@link
 #isVertical()} is true).]]>
      </doc>
    </method>
    <method name="transform" return="double"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <doc>
      <![CDATA[Returns the {@code y} corresponding to the given {@code x}. This must not be called on a
 vertical transformation (i.e. when {@link #isVertical()} is true).]]>
      </doc>
    </method>
    <method name="inverse" return="com.google.common.math.LinearTransformation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the inverse linear transformation. The inverse of a horizontal transformation is a
 vertical transformation, and vice versa. The inverse of the {@link #forNaN} transformation is
 itself. In all other cases, the inverse is a transformation such that applying both the
 original transformation and its inverse to a value gives you the original value give-or-take
 numerical errors. Calling this method multiple times on the same instance will always return
 the same instance. Calling this method on the result of calling this method on an instance will
 always return that original instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The representation of a linear transformation between real numbers {@code x} and {@code y}.
 Graphically, this is the specification of a straight line on a plane. The transformation can be
 expressed as {@code y = m * x + c} for finite {@code m} and {@code c}, unless it is a vertical
 transformation in which case {@code x} has a constant value for all {@code y}. In the
 non-vertical case, {@code m} is the slope of the transformation (and a horizontal transformation
 has zero slope).

 @author Pete Gillin
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.LinearTransformation -->
  <!-- start class com.google.common.math.LinearTransformation.LinearTransformationBuilder -->
  <class name="LinearTransformation.LinearTransformationBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="and" return="com.google.common.math.LinearTransformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x2" type="double"/>
      <param name="y2" type="double"/>
      <doc>
      <![CDATA[Finish building an instance which also maps {@code x = x2} to {@code y = y2}. These values
 must not both be identical to the values given in the first mapping. If only the {@code x}
 values are identical, the transformation is vertical. If only the {@code y} values are
 identical, the transformation is horizontal (i.e. the slope is zero).]]>
      </doc>
    </method>
    <method name="withSlope" return="com.google.common.math.LinearTransformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="slope" type="double"/>
      <doc>
      <![CDATA[Finish building an instance with the given slope, i.e. the rate of change of {@code y} with
 respect to {@code x}. The slope must not be {@code NaN}. It may be infinite, in which case
 the transformation is vertical. (If it is zero, the transformation is horizontal.)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is an intermediate stage in the construction process. It is returned by {@link
 LinearTransformation#mapping}. You almost certainly don't want to keep instances around, but
 instead use method chaining. This represents a single point mapping, i.e. a mapping between one
 {@code x} and {@code y} value pair.

 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.LinearTransformation.LinearTransformationBuilder -->
  <!-- start class com.google.common.math.LongMath -->
  <class name="LongMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="ceilingPowerOfTwo" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <doc>
      <![CDATA[Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to
 {@code checkedPow(2, log2(x, CEILING))}.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException of the next-higher power of two is not representable as a {@code
     long}, i.e. when {@code x > 2^62}
 @since 20.0]]>
      </doc>
    </method>
    <method name="floorPowerOfTwo" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <doc>
      <![CDATA[Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code
 checkedPow(2, log2(x, FLOOR))}.

 @throws IllegalArgumentException if {@code x <= 0}
 @since 20.0]]>
      </doc>
    </method>
    <method name="isPowerOfTwo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code x} represents a power of two.

 <p>This differs from {@code Long.bitCount(x) == 1}, because {@code
 Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.]]>
      </doc>
    </method>
    <method name="log2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not a power of two]]>
      </doc>
    </method>
    <method name="log10" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.

 @throws IllegalArgumentException if {@code x <= 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not a power of ten]]>
      </doc>
    </method>
    <method name="pow" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="long"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code b} to the {@code k}th power. Even if the result overflows, it will be equal to
 {@code BigInteger.valueOf(b).pow(k).longValue()}. This implementation runs in {@code O(log k)}
 time.

 @throws IllegalArgumentException if {@code k < 0}]]>
      </doc>
    </method>
    <method name="sqrt" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the square root of {@code x}, rounded with the specified rounding mode.

 @throws IllegalArgumentException if {@code x < 0}
 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code
     sqrt(x)} is not an integer]]>
      </doc>
    </method>
    <method name="divide" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="long"/>
      <param name="q" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code
 RoundingMode}. If the {@code RoundingMode} is {@link RoundingMode#DOWN}, then this method is
 equivalent to regular Java division, {@code p / q}; and if it is {@link RoundingMode#FLOOR},
 then this method is equivalent to {@link Math#floorDiv(long,long) Math.floorDiv}{@code (p, q)}.

 @throws ArithmeticException if {@code q == 0}, or if {@code mode == UNNECESSARY} and {@code a}
     is not an integer multiple of {@code b}]]>
      </doc>
    </method>
    <method name="mod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="m" type="int"/>
      <doc>
      <![CDATA[Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %
 m}, which might be negative.

 <p>For example:

 {@snippet :
 mod(7, 4) == 3
 mod(-7, 4) == 1
 mod(-1, 4) == 3
 mod(-8, 4) == 0
 mod(8, 4) == 0
 }

 @throws ArithmeticException if {@code m <= 0}
 @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3">
     Remainder Operator</a>]]>
      </doc>
    </method>
    <method name="mod" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="m" type="long"/>
      <doc>
      <![CDATA[Returns {@code x mod m}, a non-negative value less than {@code m}. This differs from {@code x %
 m}, which might be negative.

 <p>For example:

 {@snippet :
 mod(7, 4) == 3
 mod(-7, 4) == 1
 mod(-1, 4) == 3
 mod(-8, 4) == 0
 mod(8, 4) == 0
 }

 @throws ArithmeticException if {@code m <= 0}
 @see <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.17.3">
     Remainder Operator</a>]]>
      </doc>
    </method>
    <method name="gcd" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the greatest common divisor of {@code a, b}. Returns {@code 0} if {@code a == 0 && b ==
 0}.

 @throws IllegalArgumentException if {@code a < 0} or {@code b < 0}]]>
      </doc>
    </method>
    <method name="checkedAdd" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the sum of {@code a} and {@code b}, provided it does not overflow.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 Math#addExact(long, long)} instead. Note that if both arguments are {@code int} values, writing
 {@code Math.addExact(a, b)} will call the {@link Math#addExact(int, int)} overload, not {@link
 Math#addExact(long, long)}. Also note that adding two {@code int} values can <b>never</b>
 overflow a {@code long}, so you can just write {@code (long) a + b}.

 @throws ArithmeticException if {@code a + b} overflows in signed {@code long} arithmetic]]>
      </doc>
    </method>
    <method name="checkedSubtract" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the difference of {@code a} and {@code b}, provided it does not overflow.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 Math#subtractExact(long, long)} instead. Note that if both arguments are {@code int} values,
 writing {@code Math.subtractExact(a, b)} will call the {@link Math#subtractExact(int, int)}
 overload, not {@link Math#subtractExact(long, long)}. Also note that subtracting two {@code
 int} values can <b>never</b> overflow a {@code long}, so you can just write {@code (long) a -
 b}.

 @throws ArithmeticException if {@code a - b} overflows in signed {@code long} arithmetic]]>
      </doc>
    </method>
    <method name="checkedMultiply" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the product of {@code a} and {@code b}, provided it does not overflow.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use {@link
 Math#multiplyExact(long, long)} instead. Note that if both arguments are {@code int} values,
 writing {@code Math.multiplyExact(a, b)} will call the {@link Math#multiplyExact(int, int)}
 overload, not {@link Math#multiplyExact(long, long)}. Also note that multiplying two {@code
 int} values can <b>never</b> overflow a {@code long}, so you can just write {@code (long) a *
 b}.

 @throws ArithmeticException if {@code a * b} overflows in signed {@code long} arithmetic]]>
      </doc>
    </method>
    <method name="checkedPow" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="long"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code b} to the {@code k}th power, provided it does not overflow.

 @throws ArithmeticException if {@code b} to the {@code k}th power overflows in signed {@code
     long} arithmetic]]>
      </doc>
    </method>
    <method name="saturatedAdd" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the sum of {@code a} and {@code b} unless it would overflow or underflow in which case
 {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="saturatedSubtract" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the difference of {@code a} and {@code b} unless it would overflow or underflow in
 which case {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="saturatedMultiply" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Returns the product of {@code a} and {@code b} unless it would overflow or underflow in which
 case {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="saturatedPow" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="long"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns the {@code b} to the {@code k}th power, unless it would overflow or underflow in which
 case {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.

 @since 20.0]]>
      </doc>
    </method>
    <method name="factorial" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Returns {@code n!}, that is, the product of the first {@code n} positive integers, {@code 1} if
 {@code n == 0}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.

 @throws IllegalArgumentException if {@code n < 0}]]>
      </doc>
    </method>
    <method name="binomial" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <param name="k" type="int"/>
      <doc>
      <![CDATA[Returns {@code n} choose {@code k}, also known as the binomial coefficient of {@code n} and
 {@code k}, or {@link Long#MAX_VALUE} if the result does not fit in a {@code long}.

 @throws IllegalArgumentException if {@code n < 0}, {@code k < 0}, or {@code k > n}]]>
      </doc>
    </method>
    <method name="mean" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="y" type="long"/>
      <doc>
      <![CDATA[Returns the arithmetic mean of {@code x} and {@code y}, rounded toward negative infinity. This
 method is resilient to overflow.

 @since 14.0]]>
      </doc>
    </method>
    <method name="isPrime" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code n} is a <a
 href="http://mathworld.wolfram.com/PrimeNumber.html">prime number</a>: an integer <i>greater
 than one</i> that cannot be factored into a product of <i>smaller</i> positive integers.
 Returns {@code false} if {@code n} is zero, one, or a composite number (one which <i>can</i> be
 factored into smaller positive integers).

 <p>To test larger numbers, use {@link BigInteger#isProbablePrime}.

 @throws IllegalArgumentException if {@code n} is negative
 @since 20.0]]>
      </doc>
    </method>
    <method name="roundToDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="mode" type="java.math.RoundingMode"/>
      <doc>
      <![CDATA[Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}
 is precisely representable as a {@code double}, its {@code double} value will be returned;
 otherwise, the rounding will choose between the two nearest representable values with {@code
 mode}.

 <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754
 default rounding mode: if the two nearest representable values are equally near, the one with
 the least significant bit zero is chosen. (In such cases, both of the nearest representable
 values are even integers; this method returns the one that is a multiple of a greater power of
 two.)

 @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
     is not precisely representable as a {@code double}
 @since 30.0]]>
      </doc>
    </method>
    <method name="saturatedAbs" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <doc>
      <![CDATA[Returns the closest representable {@code long} to the absolute value of {@code x}.

 <p>This is the same thing as the true absolute value of {@code x} except in the case when
 {@code x} is {@link Long#MIN_VALUE}, in which case this returns {@link Long#MAX_VALUE}. (Note
 that {@code Long.MAX_VALUE} is mathematically equal to {@code -Long.MIN_VALUE - 1}.)

 <p>There are three common APIs for determining the absolute value of a long, all of which
 behave identically except when passed {@code Long.MIN_VALUE}. Those methods are:

 <ul>
   <li>{@link Math#abs(long)}, which returns {@code Long.MIN_VALUE} when passed {@code
       Long.MIN_VALUE}
   <li>{@link Math#absExact(long)}, which throws {@link ArithmeticException} when passed {@code
       Long.MIN_VALUE}
   <li>this method, {@code LongMath.saturatedAbs(long)}, which returns {@code Long.MAX_VALUE}
       when passed {@code Long.MIN_VALUE}
 </ul>

 <p>Note that if your only goal is to turn a well-distributed `long` (such as a random number)
 into a well-distributed nonnegative number, the most even distribution is achieved not by this
 method or other absolute value methods, but by {@code x & Long.MAX_VALUE}.

 @since NEXT]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class for arithmetic on values of type {@code long}. Where possible, methods are defined and
 named analogously to their {@code BigInteger} counterparts.

 <p>The implementations of many methods in this class are based on material from Henry S. Warren,
 Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).

 <p>Similar functionality for {@code int} and for {@link BigInteger} can be found in {@link
 IntMath} and {@link BigIntegerMath} respectively. For other common operations on {@code long}
 values, see {@link com.google.common.primitives.Longs}.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.LongMath -->
  <!-- start class com.google.common.math.PairedStats -->
  <class name="PairedStats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="count" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of pairs in the dataset.]]>
      </doc>
    </method>
    <method name="xStats" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the statistics on the {@code x} values alone.]]>
      </doc>
    </method>
    <method name="yStats" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the statistics on the {@code y} values alone.]]>
      </doc>
    </method>
    <method name="populationCovariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the population covariance of the values. The count must be non-zero.

 <p>This is guaranteed to return zero if the dataset contains a single pair of finite values. It
 is not guaranteed to return zero when the dataset consists of the same pair of values multiple
 times, due to numerical errors.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="sampleCovariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sample covariance of the values. The count must be greater than one.

 <p>This is not guaranteed to return zero when the dataset consists of the same pair of values
 multiple times, due to numerical errors.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single pair of values]]>
      </doc>
    </method>
    <method name="pearsonsCorrelationCoefficient" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://mathworld.wolfram.com/CorrelationCoefficient.html">Pearson's or
 product-moment correlation coefficient</a> of the values. The count must greater than one, and
 the {@code x} and {@code y} values must both have non-zero population variance (i.e. {@code
 xStats().populationVariance() > 0.0 && yStats().populationVariance() > 0.0}). The result is not
 guaranteed to be exactly +/-1 even when the data are perfectly (anti-)correlated, due to
 numerical errors. However, it is guaranteed to be in the inclusive range [-1, +1].

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single pair of values, or
     either the {@code x} and {@code y} dataset has zero population variance]]>
      </doc>
    </method>
    <method name="leastSquaresFit" return="com.google.common.math.LinearTransformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a linear transformation giving the best fit to the data according to <a
 href="http://mathworld.wolfram.com/LeastSquaresFitting.html">Ordinary Least Squares linear
 regression</a> of {@code y} as a function of {@code x}. The count must be greater than one, and
 either the {@code x} or {@code y} data must have a non-zero population variance (i.e. {@code
 xStats().populationVariance() > 0.0 || yStats().populationVariance() > 0.0}). The result is
 guaranteed to be horizontal if there is variance in the {@code x} data but not the {@code y}
 data, and vertical if there is variance in the {@code y} data but not the {@code x} data.

 <p>This fit minimizes the root-mean-square error in {@code y} as a function of {@code x}. This
 error is defined as the square root of the mean of the squares of the differences between the
 actual {@code y} values of the data and the values predicted by the fit for the {@code x}
 values (i.e. it is the square root of the mean of the squares of the vertical distances between
 the data points and the best fit line). For this fit, this error is a fraction {@code sqrt(1 -
 R*R)} of the population standard deviation of {@code y}, where {@code R} is the Pearson's
 correlation coefficient (as given by {@link #pearsonsCorrelationCoefficient()}).

 <p>The corresponding root-mean-square error in {@code x} as a function of {@code y} is a
 fraction {@code sqrt(1/(R*R) - 1)} of the population standard deviation of {@code x}. This fit
 does not normally minimize that error: to do that, you should swap the roles of {@code x} and
 {@code y}.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link
 LinearTransformation#forNaN()}.

 @throws IllegalStateException if the dataset is empty or contains a single pair of values, or
     both the {@code x} and {@code y} dataset must have zero population variance]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This tests exact equality of the calculated statistics, including the floating
 point values. Two instances are guaranteed to be considered equal if one is copied from the
 other using {@code second = new PairedStatsAccumulator().addAll(first).snapshot()}, if both
 were obtained by calling {@code snapshot()} on the same {@link PairedStatsAccumulator} without
 adding any values in between the two calls, or if one is obtained from the other after
 round-tripping through java serialization. However, floating point rounding errors mean that it
 may be false for some instances where the statistics are mathematically equal, including
 instances constructed from the same values in a different order... or (in the general case)
 even in the same order. (It is guaranteed to return true for instances constructed from the
 same values in the same order if {@code strictfp} is in effect, or if the system architecture
 guarantees {@code strictfp}-like semantics.)]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This hash code is consistent with exact equality of the calculated statistics,
 including the floating point values. See the note on {@link #equals} for details.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a byte array representation of this instance.

 <p><b>Note:</b> No guarantees are made regarding stability of the representation between
 versions.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="com.google.common.math.PairedStats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="byteArray" type="byte[]"/>
      <doc>
      <![CDATA[Creates a {@link PairedStats} instance from the given byte representation which was obtained by
 {@link #toByteArray}.

 <p><b>Note:</b> No guarantees are made regarding stability of the representation between
 versions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable value object capturing some basic statistics about a collection of paired double
 values (e.g. points on a plane). Build instances with {@link PairedStatsAccumulator#snapshot}.

 @author Pete Gillin
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.PairedStats -->
  <!-- start class com.google.common.math.PairedStatsAccumulator -->
  <class name="PairedStatsAccumulator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PairedStatsAccumulator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new accumulator.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="double"/>
      <param name="y" type="double"/>
      <doc>
      <![CDATA[Adds the given pair of values to the dataset.]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="com.google.common.math.PairedStats"/>
      <doc>
      <![CDATA[Adds the given statistics to the dataset, as if the individual values used to compute the
 statistics had been added directly.]]>
      </doc>
    </method>
    <method name="snapshot" return="com.google.common.math.PairedStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable snapshot of the current statistics.]]>
      </doc>
    </method>
    <method name="count" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of pairs in the dataset.]]>
      </doc>
    </method>
    <method name="xStats" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable snapshot of the statistics on the {@code x} values alone.]]>
      </doc>
    </method>
    <method name="yStats" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable snapshot of the statistics on the {@code y} values alone.]]>
      </doc>
    </method>
    <method name="populationCovariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the population covariance of the values. The count must be non-zero.

 <p>This is guaranteed to return zero if the dataset contains a single pair of finite values. It
 is not guaranteed to return zero when the dataset consists of the same pair of values multiple
 times, due to numerical errors.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="sampleCovariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sample covariance of the values. The count must be greater than one.

 <p>This is not guaranteed to return zero when the dataset consists of the same pair of values
 multiple times, due to numerical errors.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single pair of values]]>
      </doc>
    </method>
    <method name="pearsonsCorrelationCoefficient" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://mathworld.wolfram.com/CorrelationCoefficient.html">Pearson's or
 product-moment correlation coefficient</a> of the values. The count must greater than one, and
 the {@code x} and {@code y} values must both have non-zero population variance (i.e. {@code
 xStats().populationVariance() > 0.0 && yStats().populationVariance() > 0.0}). The result is not
 guaranteed to be exactly +/-1 even when the data are perfectly (anti-)correlated, due to
 numerical errors. However, it is guaranteed to be in the inclusive range [-1, +1].

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single pair of values, or
     either the {@code x} and {@code y} dataset has zero population variance]]>
      </doc>
    </method>
    <method name="leastSquaresFit" return="com.google.common.math.LinearTransformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a linear transformation giving the best fit to the data according to <a
 href="http://mathworld.wolfram.com/LeastSquaresFitting.html">Ordinary Least Squares linear
 regression</a> of {@code y} as a function of {@code x}. The count must be greater than one, and
 either the {@code x} or {@code y} data must have a non-zero population variance (i.e. {@code
 xStats().populationVariance() > 0.0 || yStats().populationVariance() > 0.0}). The result is
 guaranteed to be horizontal if there is variance in the {@code x} data but not the {@code y}
 data, and vertical if there is variance in the {@code y} data but not the {@code x} data.

 <p>This fit minimizes the root-mean-square error in {@code y} as a function of {@code x}. This
 error is defined as the square root of the mean of the squares of the differences between the
 actual {@code y} values of the data and the values predicted by the fit for the {@code x}
 values (i.e. it is the square root of the mean of the squares of the vertical distances between
 the data points and the best fit line). For this fit, this error is a fraction {@code sqrt(1 -
 R*R)} of the population standard deviation of {@code y}, where {@code R} is the Pearson's
 correlation coefficient (as given by {@link #pearsonsCorrelationCoefficient()}).

 <p>The corresponding root-mean-square error in {@code x} as a function of {@code y} is a
 fraction {@code sqrt(1/(R*R) - 1)} of the population standard deviation of {@code x}. This fit
 does not normally minimize that error: to do that, you should swap the roles of {@code x} and
 {@code y}.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link
 LinearTransformation#forNaN()}.

 @throws IllegalStateException if the dataset is empty or contains a single pair of values, or
     both the {@code x} and {@code y} dataset have zero population variance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mutable object which accumulates paired double values (e.g. points on a plane) and tracks some
 basic statistics over all the values added so far. This class is not thread safe.

 @author Pete Gillin
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.PairedStatsAccumulator -->
  <!-- start class com.google.common.math.Quantiles -->
  <class name="Quantiles" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Quantiles"
      static="false" final="false" visibility="public"
      deprecated="Use the static factory methods of the class. There is no reason to create an
     instance of {@link Quantiles}.">
      <doc>
      <![CDATA[Constructor for a type that is not meant to be instantiated.

 @deprecated Use the static factory methods of the class. There is no reason to create an
     instance of {@link Quantiles}.]]>
      </doc>
    </constructor>
    <method name="median" return="com.google.common.math.Quantiles.ScaleAndIndex"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies the computation of a median (i.e. the 1st 2-quantile).]]>
      </doc>
    </method>
    <method name="quartiles" return="com.google.common.math.Quantiles.Scale"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies the computation of quartiles (i.e. 4-quantiles).]]>
      </doc>
    </method>
    <method name="percentiles" return="com.google.common.math.Quantiles.Scale"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies the computation of percentiles (i.e. 100-quantiles).]]>
      </doc>
    </method>
    <method name="scale" return="com.google.common.math.Quantiles.Scale"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scale" type="int"/>
      <doc>
      <![CDATA[Specifies the computation of q-quantiles.

 @param scale the scale for the quantiles to be calculated, i.e. the q of the q-quantiles, which
     must be positive]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a fluent API for calculating <a
 href="http://en.wikipedia.org/wiki/Quantile">quantiles</a>.

 <h3>Examples</h3>

 <p>To compute the median:

 {@snippet :
 double myMedian = median().compute(myDataset);
 }

 where {@link #median()} has been statically imported.

 <p>To compute the 99th percentile:

 {@snippet :
 double myPercentile99 = percentiles().index(99).compute(myDataset);
 }

 where {@link #percentiles()} has been statically imported.

 <p>To compute median and the 90th and 99th percentiles:

 {@snippet :
 Map<Integer, Double> myPercentiles =
     percentiles().indexes(50, 90, 99).compute(myDataset);
 }

 where {@link #percentiles()} has been statically imported: {@code myPercentiles} maps the keys
 50, 90, and 99, to their corresponding quantile values.

 <p>To compute quartiles, use {@link #quartiles()} instead of {@link #percentiles()}. To compute
 arbitrary q-quantiles, use {@link #scale scale(q)}.

 <p>These examples all take a copy of your dataset. If you have a double array, you are okay with
 it being arbitrarily reordered, and you want to avoid that copy, you can use {@code
 computeInPlace} instead of {@code compute}.

 <h3>Definition and notes on interpolation</h3>

 <p>The definition of the kth q-quantile of N values is as follows: define x = k * (N - 1) / q; if
 x is an integer, the result is the value which would appear at index x in the sorted dataset
 (unless there are {@link Double#NaN NaN} values, see below); otherwise, the result is the average
 of the values which would appear at the indexes floor(x) and ceil(x) weighted by (1-frac(x)) and
 frac(x) respectively. This is the same definition as used by Excel and by S, it is the Type 7
 definition in <a
 href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html">R</a>, and it is
 described by <a
 href="http://en.wikipedia.org/wiki/Quantile#Estimating_the_quantiles_of_a_population">
 wikipedia</a> as providing "Linear interpolation of the modes for the order statistics for the
 uniform distribution on [0,1]."

 <h3>Handling of non-finite values</h3>

 <p>If any values in the input are {@link Double#NaN NaN} then all values returned are {@link
 Double#NaN NaN}. (This is the one occasion when the behaviour is not the same as you'd get from
 sorting with {@link java.util.Arrays#sort(double[]) Arrays.sort(double[])} or {@link
 java.util.Collections#sort(java.util.List) Collections.sort(List&lt;Double&gt;)} and selecting
 the required value(s). Those methods would sort {@link Double#NaN NaN} as if it is greater than
 any other value and place them at the end of the dataset, even after {@link
 Double#POSITIVE_INFINITY POSITIVE_INFINITY}.)

 <p>Otherwise, {@link Double#NEGATIVE_INFINITY NEGATIVE_INFINITY} and {@link
 Double#POSITIVE_INFINITY POSITIVE_INFINITY} sort to the beginning and the end of the dataset, as
 you would expect.

 <p>If required to do a weighted average between an infinity and a finite value, or between an
 infinite value and itself, the infinite value is returned. If required to do a weighted average
 between {@link Double#NEGATIVE_INFINITY NEGATIVE_INFINITY} and {@link Double#POSITIVE_INFINITY
 POSITIVE_INFINITY}, {@link Double#NaN NaN} is returned (note that this will only happen if the
 dataset contains no finite values).

 <h3>Performance</h3>

 <p>The average time complexity of the computation is O(N) in the size of the dataset. There is a
 worst case time complexity of O(N^2). You are extremely unlikely to hit this quadratic case on
 randomly ordered data (the probability decreases faster than exponentially in N), but if you are
 passing in unsanitized user data then a malicious user could force it. A light shuffle of the
 data using an unpredictable seed should normally be enough to thwart this attack.

 <p>The time taken to compute multiple quantiles on the same dataset using {@link Scale#indexes
 indexes} is generally less than the total time taken to compute each of them separately, and
 sometimes much less. For example, on a large enough dataset, computing the 90th and 99th
 percentiles together takes about 55% as long as computing them separately.

 <p>When calling {@link ScaleAndIndex#compute} (in {@linkplain ScaleAndIndexes#compute either
 form}), the memory requirement is 8*N bytes for the copy of the dataset plus an overhead which is
 independent of N (but depends on the quantiles being computed). When calling {@link
 ScaleAndIndex#computeInPlace computeInPlace} (in {@linkplain ScaleAndIndexes#computeInPlace
 either form}), only the overhead is required. The number of object allocations is independent of
 N in both cases.

 @author Pete Gillin
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.Quantiles -->
  <!-- start class com.google.common.math.Quantiles.Scale -->
  <class name="Quantiles.Scale" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="index" return="com.google.common.math.Quantiles.ScaleAndIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Specifies a single quantile index to be calculated, i.e. the k in the kth q-quantile.

 @param index the quantile index, which must be in the inclusive range [0, q] for q-quantiles]]>
      </doc>
    </method>
    <method name="indexes" return="com.google.common.math.Quantiles.ScaleAndIndexes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="indexes" type="int[]"/>
      <doc>
      <![CDATA[Specifies multiple quantile indexes to be calculated, each index being the k in the kth
 q-quantile.

 @param indexes the quantile indexes, each of which must be in the inclusive range [0, q] for
     q-quantiles; the order of the indexes is unimportant, duplicates will be ignored, and the
     set will be snapshotted when this method is called
 @throws IllegalArgumentException if {@code indexes} is empty]]>
      </doc>
    </method>
    <method name="indexes" return="com.google.common.math.Quantiles.ScaleAndIndexes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="indexes" type="java.util.Collection&lt;java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Specifies multiple quantile indexes to be calculated, each index being the k in the kth
 q-quantile.

 @param indexes the quantile indexes, each of which must be in the inclusive range [0, q] for
     q-quantiles; the order of the indexes is unimportant, duplicates will be ignored, and the
     set will be snapshotted when this method is called
 @throws IllegalArgumentException if {@code indexes} is empty]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Describes the point in a fluent API chain where only the scale (i.e. the q in q-quantiles) has
 been specified.

 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.Quantiles.Scale -->
  <!-- start class com.google.common.math.Quantiles.ScaleAndIndex -->
  <class name="Quantiles.ScaleAndIndex" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compute" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Computes the quantile value of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will be
     cast to doubles (with any associated lost of precision), and which will not be mutated by
     this call (it is copied instead)
 @return the quantile value]]>
      </doc>
    </method>
    <method name="compute" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="double[]"/>
      <doc>
      <![CDATA[Computes the quantile value of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will not
     be mutated by this call (it is copied instead)
 @return the quantile value]]>
      </doc>
    </method>
    <method name="compute" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="long[]"/>
      <doc>
      <![CDATA[Computes the quantile value of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will be
     cast to doubles (with any associated lost of precision), and which will not be mutated by
     this call (it is copied instead)
 @return the quantile value]]>
      </doc>
    </method>
    <method name="compute" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="int[]"/>
      <doc>
      <![CDATA[Computes the quantile value of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will be
     cast to doubles, and which will not be mutated by this call (it is copied instead)
 @return the quantile value]]>
      </doc>
    </method>
    <method name="computeInPlace" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="double[]"/>
      <doc>
      <![CDATA[Computes the quantile value of the given dataset, performing the computation in-place.

 @param dataset the dataset to do the calculation on, which must be non-empty, and which will
     be arbitrarily reordered by this method call
 @return the quantile value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Describes the point in a fluent API chain where the scale and a single quantile index (i.e. the
 q and the k in the kth q-quantile) have been specified.

 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.Quantiles.ScaleAndIndex -->
  <!-- start class com.google.common.math.Quantiles.ScaleAndIndexes -->
  <class name="Quantiles.ScaleAndIndexes" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compute" return="java.util.Map&lt;java.lang.Integer, java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Computes the quantile values of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will be
     cast to doubles (with any associated lost of precision), and which will not be mutated by
     this call (it is copied instead)
 @return an unmodifiable, ordered map of results: the keys will be the specified quantile
     indexes, and the values the corresponding quantile values. When iterating, entries in the
     map are ordered by quantile index in the same order they were passed to the {@code
     indexes} method.]]>
      </doc>
    </method>
    <method name="compute" return="java.util.Map&lt;java.lang.Integer, java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="double[]"/>
      <doc>
      <![CDATA[Computes the quantile values of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will not
     be mutated by this call (it is copied instead)
 @return an unmodifiable, ordered map of results: the keys will be the specified quantile
     indexes, and the values the corresponding quantile values. When iterating, entries in the
     map are ordered by quantile index in the same order they were passed to the {@code
     indexes} method.]]>
      </doc>
    </method>
    <method name="compute" return="java.util.Map&lt;java.lang.Integer, java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="long[]"/>
      <doc>
      <![CDATA[Computes the quantile values of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will be
     cast to doubles (with any associated lost of precision), and which will not be mutated by
     this call (it is copied instead)
 @return an unmodifiable, ordered map of results: the keys will be the specified quantile
     indexes, and the values the corresponding quantile values. When iterating, entries in the
     map are ordered by quantile index in the same order they were passed to the {@code
     indexes} method.]]>
      </doc>
    </method>
    <method name="compute" return="java.util.Map&lt;java.lang.Integer, java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="int[]"/>
      <doc>
      <![CDATA[Computes the quantile values of the given dataset.

 @param dataset the dataset to do the calculation on, which must be non-empty, which will be
     cast to doubles, and which will not be mutated by this call (it is copied instead)
 @return an unmodifiable, ordered map of results: the keys will be the specified quantile
     indexes, and the values the corresponding quantile values. When iterating, entries in the
     map are ordered by quantile index in the same order they were passed to the {@code
     indexes} method.]]>
      </doc>
    </method>
    <method name="computeInPlace" return="java.util.Map&lt;java.lang.Integer, java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="double[]"/>
      <doc>
      <![CDATA[Computes the quantile values of the given dataset, performing the computation in-place.

 @param dataset the dataset to do the calculation on, which must be non-empty, and which will
     be arbitrarily reordered by this method call
 @return an unmodifiable, ordered map of results: the keys will be the specified quantile
     indexes, and the values the corresponding quantile values. When iterating, entries in the
     map are ordered by quantile index in the same order that the indexes were passed to the
     {@code indexes} method.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Describes the point in a fluent API chain where the scale and a multiple quantile indexes (i.e.
 the q and a set of values for the k in the kth q-quantile) have been specified.

 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.Quantiles.ScaleAndIndexes -->
  <!-- start class com.google.common.math.Stats -->
  <class name="Stats" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Iterator&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values. The iterator will be completely
 consumed by this method.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="double[]"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values.

 @param values a series of values]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="int[]"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values.

 @param values a series of values]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="long[]"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.stream.DoubleStream"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values. The stream will be completely
 consumed by this method.

 <p>If you have a {@code Stream<Double>} rather than a {@code DoubleStream}, you should collect
 the values using {@link #toStats()} instead.

 @param values a series of values
 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.stream.IntStream"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values. The stream will be completely
 consumed by this method.

 <p>If you have a {@code Stream<Integer>} rather than an {@code IntStream}, you should collect
 the values using {@link #toStats()} instead.

 @param values a series of values
 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.stream.LongStream"/>
      <doc>
      <![CDATA[Returns statistics over a dataset containing the given values. The stream will be completely
 consumed by this method.

 <p>If you have a {@code Stream<Long>} rather than a {@code LongStream}, you should collect the
 values using {@link #toStats()} instead.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))
 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toStats" return="java.util.stream.Collector&lt;java.lang.Number, com.google.common.math.StatsAccumulator, com.google.common.math.Stats&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Collector} which accumulates statistics from a {@link java.util.stream.Stream}
 of any type of boxed {@link Number} into a {@link Stats}. Use by calling {@code
 boxedNumericStream.collect(toStats())}. The numbers will be converted to {@code double} values
 (which may cause loss of precision).

 <p>If you have any of the primitive streams {@code DoubleStream}, {@code IntStream}, or {@code
 LongStream}, you should use the factory method {@link #of} instead.

 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="count" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of values.]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
 values. The count must be non-zero.

 <p>If these values are a sample drawn from a population, this is also an unbiased estimator of
 the arithmetic mean of the population.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the
 result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values
 only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.
 If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link
 Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.

 <p>If you only want to calculate the mean, use {@link #meanOf} instead of creating a {@link
 Stats} instance.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="sum" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sum of the values.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the
 result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values
 only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.
 If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link
 Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.]]>
      </doc>
    </method>
    <method name="populationVariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Variance#Population_variance">population
 variance</a> of the values. The count must be non-zero.

 <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It
 is not guaranteed to return zero when the dataset consists of the same value multiple times,
 due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="populationStandardDeviation" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a
 href="http://en.wikipedia.org/wiki/Standard_deviation#Definition_of_population_values">
 population standard deviation</a> of the values. The count must be non-zero.

 <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It
 is not guaranteed to return zero when the dataset consists of the same value multiple times,
 due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="sampleVariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Variance#Sample_variance">unbiased sample
 variance</a> of the values. If this dataset is a sample drawn from a population, this is an
 unbiased estimator of the population variance of the population. The count must be greater than
 one.

 <p>This is not guaranteed to return zero when the dataset consists of the same value multiple
 times, due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single value]]>
      </doc>
    </method>
    <method name="sampleStandardDeviation" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a
 href="http://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation">
 corrected sample standard deviation</a> of the values. If this dataset is a sample drawn from a
 population, this is an estimator of the population standard deviation of the population which
 is less biased than {@link #populationStandardDeviation()} (the unbiased estimator depends on
 the distribution). The count must be greater than one.

 <p>This is not guaranteed to return zero when the dataset consists of the same value multiple
 times, due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single value]]>
      </doc>
    </method>
    <method name="min" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lowest value in the dataset. The count must be non-zero.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains {@link Double#NEGATIVE_INFINITY} and not {@link Double#NaN} then the result is {@link
 Double#NEGATIVE_INFINITY}. If it contains {@link Double#POSITIVE_INFINITY} and finite values
 only then the result is the lowest finite value. If it contains {@link
 Double#POSITIVE_INFINITY} only then the result is {@link Double#POSITIVE_INFINITY}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="max" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the highest value in the dataset. The count must be non-zero.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains {@link Double#POSITIVE_INFINITY} and not {@link Double#NaN} then the result is {@link
 Double#POSITIVE_INFINITY}. If it contains {@link Double#NEGATIVE_INFINITY} and finite values
 only then the result is the highest finite value. If it contains {@link
 Double#NEGATIVE_INFINITY} only then the result is {@link Double#NEGATIVE_INFINITY}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This tests exact equality of the calculated statistics, including the floating
 point values. Two instances are guaranteed to be considered equal if one is copied from the
 other using {@code second = new StatsAccumulator().addAll(first).snapshot()}, if both were
 obtained by calling {@code snapshot()} on the same {@link StatsAccumulator} without adding any
 values in between the two calls, or if one is obtained from the other after round-tripping
 through java serialization. However, floating point rounding errors mean that it may be false
 for some instances where the statistics are mathematically equal, including instances
 constructed from the same values in a different order... or (in the general case) even in the
 same order. (It is guaranteed to return true for instances constructed from the same values in
 the same order if {@code strictfp} is in effect, or if the system architecture guarantees
 {@code strictfp}-like semantics.)]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 <p><b>Note:</b> This hash code is consistent with exact equality of the calculated statistics,
 including the floating point values. See the note on {@link #equals} for details.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="meanOf" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
 values. The count must be non-zero.

 <p>The definition of the mean is the same as {@link Stats#mean}.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision)
 @throws IllegalArgumentException if the dataset is empty]]>
      </doc>
    </method>
    <method name="meanOf" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Iterator&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
 values. The count must be non-zero.

 <p>The definition of the mean is the same as {@link Stats#mean}.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision)
 @throws IllegalArgumentException if the dataset is empty]]>
      </doc>
    </method>
    <method name="meanOf" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="double[]"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
 values. The count must be non-zero.

 <p>The definition of the mean is the same as {@link Stats#mean}.

 @param values a series of values
 @throws IllegalArgumentException if the dataset is empty]]>
      </doc>
    </method>
    <method name="meanOf" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="int[]"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
 values. The count must be non-zero.

 <p>The definition of the mean is the same as {@link Stats#mean}.

 @param values a series of values
 @throws IllegalArgumentException if the dataset is empty]]>
      </doc>
    </method>
    <method name="meanOf" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="long[]"/>
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
 values. The count must be non-zero.

 <p>The definition of the mean is the same as {@link Stats#mean}.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))
 @throws IllegalArgumentException if the dataset is empty]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a byte array representation of this instance.

 <p><b>Note:</b> No guarantees are made regarding stability of the representation between
 versions.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="byteArray" type="byte[]"/>
      <doc>
      <![CDATA[Creates a Stats instance from the given byte representation which was obtained by {@link
 #toByteArray}.

 <p><b>Note:</b> No guarantees are made regarding stability of the representation between
 versions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A bundle of statistical summary values -- sum, count, mean/average, min and max, and several
 forms of variance -- that were computed from a single set of zero or more floating-point values.

 <p>There are two ways to obtain a {@code Stats} instance:

 <ul>
   <li>If all the values you want to summarize are already known, use the appropriate {@code
       Stats.of} factory method below. Primitive arrays, iterables and iterators of any kind of
       {@code Number}, and primitive varargs are supported.
   <li>Or, to avoid storing up all the data first, create a {@link StatsAccumulator} instance,
       feed values to it as you get them, then call {@link StatsAccumulator#snapshot}.
 </ul>

 <p>Static convenience methods called {@code meanOf} are also provided for users who wish to
 calculate <i>only</i> the mean.

 <p><b>Java 8+ users:</b> If you are not using any of the variance statistics, you may wish to use
 built-in JDK libraries instead of this class.

 @author Pete Gillin
 @author Kevin Bourrillion
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.Stats -->
  <!-- start class com.google.common.math.StatsAccumulator -->
  <class name="StatsAccumulator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="StatsAccumulator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new accumulator.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Adds the given value to the dataset.]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Adds the given values to the dataset.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision)]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Iterator&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Adds the given values to the dataset.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision)]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="double[]"/>
      <doc>
      <![CDATA[Adds the given values to the dataset.

 @param values a series of values]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="int[]"/>
      <doc>
      <![CDATA[Adds the given values to the dataset.

 @param values a series of values]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="long[]"/>
      <doc>
      <![CDATA[Adds the given values to the dataset.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.stream.DoubleStream"/>
      <doc>
      <![CDATA[Adds the given values to the dataset. The stream will be completely consumed by this method.

 @param values a series of values
 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.stream.IntStream"/>
      <doc>
      <![CDATA[Adds the given values to the dataset. The stream will be completely consumed by this method.

 @param values a series of values
 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.stream.LongStream"/>
      <doc>
      <![CDATA[Adds the given values to the dataset. The stream will be completely consumed by this method.

 @param values a series of values, which will be converted to {@code double} values (this may
     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))
 @since 33.4.0 (but since 28.2 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="com.google.common.math.Stats"/>
      <doc>
      <![CDATA[Adds the given statistics to the dataset, as if the individual values used to compute the
 statistics had been added directly.]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="com.google.common.math.StatsAccumulator"/>
      <doc>
      <![CDATA[Adds the given statistics to the dataset, as if the individual values used to compute the
 statistics had been added directly.

 @since 28.2]]>
      </doc>
    </method>
    <method name="snapshot" return="com.google.common.math.Stats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable snapshot of the current statistics.]]>
      </doc>
    </method>
    <method name="count" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of values.]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean</a> of the
 values. The count must be non-zero.

 <p>If these values are a sample drawn from a population, this is also an unbiased estimator of
 the arithmetic mean of the population.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the
 result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values
 only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.
 If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link
 Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="sum" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sum of the values.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains both {@link Double#POSITIVE_INFINITY} and {@link Double#NEGATIVE_INFINITY} then the
 result is {@link Double#NaN}. If it contains {@link Double#POSITIVE_INFINITY} and finite values
 only or {@link Double#POSITIVE_INFINITY} only, the result is {@link Double#POSITIVE_INFINITY}.
 If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link
 Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.]]>
      </doc>
    </method>
    <method name="populationVariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Variance#Population_variance">population
 variance</a> of the values. The count must be non-zero.

 <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It
 is not guaranteed to return zero when the dataset consists of the same value multiple times,
 due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="populationStandardDeviation" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a
 href="http://en.wikipedia.org/wiki/Standard_deviation#Definition_of_population_values">
 population standard deviation</a> of the values. The count must be non-zero.

 <p>This is guaranteed to return zero if the dataset contains only exactly one finite value. It
 is not guaranteed to return zero when the dataset consists of the same value multiple times,
 due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="sampleVariance" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a href="http://en.wikipedia.org/wiki/Variance#Sample_variance">unbiased sample
 variance</a> of the values. If this dataset is a sample drawn from a population, this is an
 unbiased estimator of the population variance of the population. The count must be greater than
 one.

 <p>This is not guaranteed to return zero when the dataset consists of the same value multiple
 times, due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single value]]>
      </doc>
    </method>
    <method name="sampleStandardDeviation" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the <a
 href="http://en.wikipedia.org/wiki/Standard_deviation#Corrected_sample_standard_deviation">
 corrected sample standard deviation</a> of the values. If this dataset is a sample drawn from a
 population, this is an estimator of the population standard deviation of the population which
 is less biased than {@link #populationStandardDeviation()} (the unbiased estimator depends on
 the distribution). The count must be greater than one.

 <p>This is not guaranteed to return zero when the dataset consists of the same value multiple
 times, due to numerical errors. However, it is guaranteed never to return a negative result.

 <h3>Non-finite values</h3>

 <p>If the dataset contains any non-finite values ({@link Double#POSITIVE_INFINITY}, {@link
 Double#NEGATIVE_INFINITY}, or {@link Double#NaN}) then the result is {@link Double#NaN}.

 @throws IllegalStateException if the dataset is empty or contains a single value]]>
      </doc>
    </method>
    <method name="min" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lowest value in the dataset. The count must be non-zero.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains {@link Double#NEGATIVE_INFINITY} and not {@link Double#NaN} then the result is {@link
 Double#NEGATIVE_INFINITY}. If it contains {@link Double#POSITIVE_INFINITY} and finite values
 only then the result is the lowest finite value. If it contains {@link
 Double#POSITIVE_INFINITY} only then the result is {@link Double#POSITIVE_INFINITY}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <method name="max" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the highest value in the dataset. The count must be non-zero.

 <h3>Non-finite values</h3>

 <p>If the dataset contains {@link Double#NaN} then the result is {@link Double#NaN}. If it
 contains {@link Double#POSITIVE_INFINITY} and not {@link Double#NaN} then the result is {@link
 Double#POSITIVE_INFINITY}. If it contains {@link Double#NEGATIVE_INFINITY} and finite values
 only then the result is the highest finite value. If it contains {@link
 Double#NEGATIVE_INFINITY} only then the result is {@link Double#NEGATIVE_INFINITY}.

 @throws IllegalStateException if the dataset is empty]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mutable object which accumulates double values and tracks some basic statistics over all the
 values added so far. The values may be added singly or in groups. This class is not thread safe.

 @author Pete Gillin
 @author Kevin Bourrillion
 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.math.StatsAccumulator -->
</package>
<package name="com.google.common.net">
  <!-- start class com.google.common.net.HostAndPort -->
  <class name="HostAndPort" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="getHost" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the portion of this {@code HostAndPort} instance that should represent the hostname or
 IPv4/IPv6 literal.

 <p>A successful parse does not imply any degree of sanity in this field. For additional
 validation, see the {@link HostSpecifier} class.

 @since 20.0 (since 10.0 as {@code getHostText})]]>
      </doc>
    </method>
    <method name="hasPort" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if this instance has a defined port.]]>
      </doc>
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current port number, failing if no port is defined.

 @return a validated port number, in the range [0..65535]
 @throws IllegalStateException if no port is defined. You can use {@link #withDefaultPort(int)}
     to prevent this from occurring.]]>
      </doc>
    </method>
    <method name="getPortOrDefault" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Returns the current port number, with a default if no port is defined.]]>
      </doc>
    </method>
    <method name="fromParts" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <doc>
      <![CDATA[Build a HostAndPort instance from separate host and port values.

 <p>Note: Non-bracketed IPv6 literals are allowed. Use {@link #requireBracketsForIPv6()} to
 prohibit these.

 @param host the host string to parse. Must not contain a port number.
 @param port a port number from [0..65535]
 @return if parsing was successful, a populated HostAndPort object.
 @throws IllegalArgumentException if {@code host} contains a port number, or {@code port} is out
     of range.]]>
      </doc>
    </method>
    <method name="fromHost" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <doc>
      <![CDATA[Build a HostAndPort instance from a host only.

 <p>Note: Non-bracketed IPv6 literals are allowed. Use {@link #requireBracketsForIPv6()} to
 prohibit these.

 @param host the host-only string to parse. Must not contain a port number.
 @return if parsing was successful, a populated HostAndPort object.
 @throws IllegalArgumentException if {@code host} contains a port number.
 @since 17.0]]>
      </doc>
    </method>
    <method name="fromString" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostPortString" type="java.lang.String"/>
      <doc>
      <![CDATA[Split a freeform string into a host and port, without strict validation.

 <p>Note that the host-only formats will leave the port field undefined. You can use {@link
 #withDefaultPort(int)} to patch in a default value.

 @param hostPortString the input string to parse.
 @return if parsing was successful, a populated HostAndPort object.
 @throws IllegalArgumentException if nothing meaningful could be parsed.]]>
      </doc>
    </method>
    <method name="withDefaultPort" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Provide a default port if the parsed string contained only a host.

 <p>You can chain this after {@link #fromString(String)} to include a port in case the port was
 omitted from the input string. If a port was already provided, then this method is a no-op.

 @param defaultPort a port number, from [0..65535]
 @return a HostAndPort instance, guaranteed to have a defined port.]]>
      </doc>
    </method>
    <method name="requireBracketsForIPv6" return="com.google.common.net.HostAndPort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate an error if the host might be a non-bracketed IPv6 literal.

 <p>URI formatting requires that IPv6 literals be surrounded by brackets, like "[2001:db8::1]".
 Chain this call after {@link #fromString(String)} to increase the strictness of the parser, and
 disallow IPv6 literals that don't contain these brackets.

 <p>Note that this parser identifies IPv6 literals solely based on the presence of a colon. To
 perform actual validation of IP addresses, see the {@link InetAddresses#forString(String)}
 method.

 @return {@code this}, to enable chaining of calls.
 @throws IllegalArgumentException if bracketless IPv6 is detected.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Rebuild the host:port string, including brackets if necessary.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable representation of a host and port.

 <p>Example usage:

 <pre>
 HostAndPort hp = HostAndPort.fromString("[2001:db8::1]")
     .withDefaultPort(80)
     .requireBracketsForIPv6();
 hp.getHost();   // returns "2001:db8::1"
 hp.getPort();   // returns 80
 hp.toString();  // returns "[2001:db8::1]:80"
 </pre>

 <p>Here are some examples of recognized formats:

 <ul>
   <li>example.com
   <li>example.com:80
   <li>192.0.2.1
   <li>192.0.2.1:80
   <li>[2001:db8::1] - {@link #getHost()} omits brackets
   <li>[2001:db8::1]:80 - {@link #getHost()} omits brackets
   <li>2001:db8::1 - Use {@link #requireBracketsForIPv6()} to prohibit this
 </ul>

 <p>Note that this is not an exhaustive list, because these methods are only concerned with
 brackets, colons, and port numbers. Full validation of the host field (if desired) is the
 caller's responsibility.

 @author Paul Marks
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HostAndPort -->
  <!-- start class com.google.common.net.HostSpecifier -->
  <class name="HostSpecifier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="fromValid" return="com.google.common.net.HostSpecifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a {@code HostSpecifier} built from the provided {@code specifier}, which is already
 known to be valid. If the {@code specifier} might be invalid, use {@link #from(String)}
 instead.

 <p>The specifier must be in one of these formats:

 <ul>
   <li>A domain name, like {@code google.com}
   <li>A IPv4 address string, like {@code 127.0.0.1}
   <li>An IPv6 address string with or without brackets, like {@code [2001:db8::1]} or {@code
       2001:db8::1}
 </ul>

 @throws IllegalArgumentException if the specifier is not valid.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.net.HostSpecifier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <exception name="ParseException" type="java.text.ParseException"/>
      <doc>
      <![CDATA[Attempts to return a {@code HostSpecifier} for the given string, throwing an exception if
 parsing fails. Always use this method in preference to {@link #fromValid(String)} for a
 specifier that is not already known to be valid.

 @throws ParseException if the specifier is not valid.]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Determines whether {@code specifier} represents a valid {@link HostSpecifier} as described in
 the documentation for {@link #fromValid(String)}.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the host specifier suitable for inclusion in a URI. If the
 host specifier is a domain name, the string will be normalized to all lower case. If the
 specifier was an IPv6 address without brackets, brackets are added so that the result will be
 usable in the host part of a URI.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A syntactically valid host specifier, suitable for use in a URI. This may be either a numeric IP
 address in IPv4 or IPv6 notation, or a domain name.

 <p>Because this class is intended to represent host specifiers which can reasonably be used in a
 URI, the domain name case is further restricted to include only those domain names which end in a
 recognized public suffix; see {@link InternetDomainName#isPublicSuffix()} for details.

 <p>Note that no network lookups are performed by any {@code HostSpecifier} methods. No attempt is
 made to verify that a provided specifier corresponds to a real or accessible host. Only syntactic
 and pattern-based checks are performed.

 <p>If you know that a given string represents a numeric IP address, use {@link InetAddresses} to
 obtain and manipulate a {@link java.net.InetAddress} instance from it rather than using this
 class. Similarly, if you know that a given string represents a domain name, use {@link
 InternetDomainName} rather than this class.

 @author Craig Berry
 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HostSpecifier -->
  <!-- start class com.google.common.net.HttpHeaders -->
  <class name="HttpHeaders" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="CACHE_CONTROL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Cache-Control} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_LENGTH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-Length} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-Type} header field name.]]>
      </doc>
    </field>
    <field name="DATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Date} header field name.]]>
      </doc>
    </field>
    <field name="PRAGMA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Pragma} header field name.]]>
      </doc>
    </field>
    <field name="VIA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Via} header field name.]]>
      </doc>
    </field>
    <field name="WARNING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Warning} header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Accept} header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_CHARSET" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Accept-Charset} header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_ENCODING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Accept-Encoding} header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_LANGUAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Accept-Language} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_REQUEST_HEADERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Request-Headers} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_REQUEST_METHOD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Request-Method} header field name.]]>
      </doc>
    </field>
    <field name="AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Authorization} header field name.]]>
      </doc>
    </field>
    <field name="CONNECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Connection} header field name.]]>
      </doc>
    </field>
    <field name="COOKIE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Cookie} header field name.]]>
      </doc>
    </field>
    <field name="CROSS_ORIGIN_RESOURCE_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header">{@code
 Cross-Origin-Resource-Policy}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="EARLY_DATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc8470">{@code Early-Data}</a> header
 field name.

 @since 27.0]]>
      </doc>
    </field>
    <field name="EXPECT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Expect} header field name.]]>
      </doc>
    </field>
    <field name="FROM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code From} header field name.]]>
      </doc>
    </field>
    <field name="FORWARDED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7239">{@code Forwarded}</a> header
 field name.

 @since 20.0]]>
      </doc>
    </field>
    <field name="FOLLOW_ONLY_WHEN_PRERENDER_SHOWN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Follow-Only-When-Prerender-Shown} header field name.

 @since 17.0]]>
      </doc>
    </field>
    <field name="HOST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Host} header field name.]]>
      </doc>
    </field>
    <field name="HTTP2_SETTINGS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7540#section-3.2.1">{@code
 HTTP2-Settings} </a> header field name.

 @since 24.0]]>
      </doc>
    </field>
    <field name="IF_MATCH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code If-Match} header field name.]]>
      </doc>
    </field>
    <field name="IF_MODIFIED_SINCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code If-Modified-Since} header field name.]]>
      </doc>
    </field>
    <field name="IF_NONE_MATCH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code If-None-Match} header field name.]]>
      </doc>
    </field>
    <field name="IF_RANGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code If-Range} header field name.]]>
      </doc>
    </field>
    <field name="IF_UNMODIFIED_SINCE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code If-Unmodified-Since} header field name.]]>
      </doc>
    </field>
    <field name="LAST_EVENT_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Last-Event-ID} header field name.]]>
      </doc>
    </field>
    <field name="MAX_FORWARDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Max-Forwards} header field name.]]>
      </doc>
    </field>
    <field name="ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Origin} header field name.]]>
      </doc>
    </field>
    <field name="ORIGIN_ISOLATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://github.com/WICG/origin-isolation">{@code Origin-Isolation}</a> header
 field name.

 @since 30.1]]>
      </doc>
    </field>
    <field name="PROXY_AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Proxy-Authorization} header field name.]]>
      </doc>
    </field>
    <field name="RANGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Range} header field name.]]>
      </doc>
    </field>
    <field name="REFERER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Referer} header field name.]]>
      </doc>
    </field>
    <field name="REFERRER_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://www.w3.org/TR/referrer-policy/">{@code Referrer-Policy}</a> header
 field name.

 @since 23.4]]>
      </doc>
    </field>
    <field name="SERVICE_WORKER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://www.w3.org/TR/service-workers/#update-algorithm">{@code
 Service-Worker}</a> header field name.

 @since 20.0]]>
      </doc>
    </field>
    <field name="TE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code TE} header field name.]]>
      </doc>
    </field>
    <field name="UPGRADE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Upgrade} header field name.]]>
      </doc>
    </field>
    <field name="UPGRADE_INSECURE_REQUESTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://w3c.github.io/webappsec-upgrade-insecure-requests/#preference">{@code
 Upgrade-Insecure-Requests}</a> header field name.

 @since 28.1]]>
      </doc>
    </field>
    <field name="USER_AGENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code User-Agent} header field name.]]>
      </doc>
    </field>
    <field name="ACCEPT_RANGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Accept-Ranges} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_HEADERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Allow-Headers} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_METHODS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Allow-Methods} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Allow-Origin} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_PRIVATE_NETWORK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/private-network-access/#headers">{@code
 Access-Control-Allow-Private-Network}</a> header field name.

 @since 31.1]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_ALLOW_CREDENTIALS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Allow-Credentials} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_EXPOSE_HEADERS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Expose-Headers} header field name.]]>
      </doc>
    </field>
    <field name="ACCESS_CONTROL_MAX_AGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Access-Control-Max-Age} header field name.]]>
      </doc>
    </field>
    <field name="AGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Age} header field name.]]>
      </doc>
    </field>
    <field name="ALLOW" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Allow} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_DISPOSITION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-Disposition} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_ENCODING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-Encoding} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_LANGUAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-Language} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_LOCATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-Location} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_MD5" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-MD5} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_RANGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Content-Range} header field name.]]>
      </doc>
    </field>
    <field name="CONTENT_SECURITY_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://w3.org/TR/CSP/#content-security-policy-header-field">{@code
 Content-Security-Policy}</a> header field name.

 @since 15.0]]>
      </doc>
    </field>
    <field name="CONTENT_SECURITY_POLICY_REPORT_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://w3.org/TR/CSP/#content-security-policy-report-only-header-field">
 {@code Content-Security-Policy-Report-Only}</a> header field name.

 @since 15.0]]>
      </doc>
    </field>
    <field name="X_CONTENT_SECURITY_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP nonstandard {@code X-Content-Security-Policy} header field name. It was introduced in
 <a href="https://www.w3.org/TR/2011/WD-CSP-20111129/">CSP v.1</a> and used by the Firefox until
 version 23 and the Internet Explorer version 10. Please, use {@link #CONTENT_SECURITY_POLICY}
 to pass the CSP.

 @since 20.0]]>
      </doc>
    </field>
    <field name="X_CONTENT_SECURITY_POLICY_REPORT_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP nonstandard {@code X-Content-Security-Policy-Report-Only} header field name. It was
 introduced in <a href="https://www.w3.org/TR/2011/WD-CSP-20111129/">CSP v.1</a> and used by the
 Firefox until version 23 and the Internet Explorer version 10. Please, use {@link
 #CONTENT_SECURITY_POLICY_REPORT_ONLY} to pass the CSP.

 @since 20.0]]>
      </doc>
    </field>
    <field name="X_WEBKIT_CSP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP nonstandard {@code X-WebKit-CSP} header field name. It was introduced in <a
 href="https://www.w3.org/TR/2011/WD-CSP-20111129/">CSP v.1</a> and used by the Chrome until
 version 25. Please, use {@link #CONTENT_SECURITY_POLICY} to pass the CSP.

 @since 20.0]]>
      </doc>
    </field>
    <field name="X_WEBKIT_CSP_REPORT_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP nonstandard {@code X-WebKit-CSP-Report-Only} header field name. It was introduced in
 <a href="https://www.w3.org/TR/2011/WD-CSP-20111129/">CSP v.1</a> and used by the Chrome until
 version 25. Please, use {@link #CONTENT_SECURITY_POLICY_REPORT_ONLY} to pass the CSP.

 @since 20.0]]>
      </doc>
    </field>
    <field name="CROSS_ORIGIN_EMBEDDER_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/cross-origin-embedder-policy/#COEP">{@code
 Cross-Origin-Embedder-Policy}</a> header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="CROSS_ORIGIN_EMBEDDER_POLICY_REPORT_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/cross-origin-embedder-policy/#COEP-RO">{@code
 Cross-Origin-Embedder-Policy-Report-Only}</a> header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="CROSS_ORIGIN_OPENER_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP Cross-Origin-Opener-Policy header field name.

 @since 28.2]]>
      </doc>
    </field>
    <field name="ETAG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code ETag} header field name.]]>
      </doc>
    </field>
    <field name="EXPIRES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Expires} header field name.]]>
      </doc>
    </field>
    <field name="LAST_MODIFIED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Last-Modified} header field name.]]>
      </doc>
    </field>
    <field name="LINK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Link} header field name.]]>
      </doc>
    </field>
    <field name="LOCATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Location} header field name.]]>
      </doc>
    </field>
    <field name="KEEP_ALIVE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Keep-Alive} header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="NO_VARY_SEARCH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://github.com/WICG/nav-speculation/blob/main/no-vary-search.md">{@code
 No-Vary-Seearch}</a> header field name.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="ORIGIN_TRIAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://googlechrome.github.io/OriginTrials/#header">{@code Origin-Trial}</a>
 header field name.

 @since 27.1]]>
      </doc>
    </field>
    <field name="P3P" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code P3P} header field name. Limited browser support.]]>
      </doc>
    </field>
    <field name="PROXY_AUTHENTICATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Proxy-Authenticate} header field name.]]>
      </doc>
    </field>
    <field name="REFRESH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Refresh} header field name. Non-standard header supported by most browsers.]]>
      </doc>
    </field>
    <field name="REPORT_TO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://www.w3.org/TR/reporting/">{@code Report-To}</a> header field name.

 @since 27.1]]>
      </doc>
    </field>
    <field name="RETRY_AFTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Retry-After} header field name.]]>
      </doc>
    </field>
    <field name="SERVER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Server} header field name.]]>
      </doc>
    </field>
    <field name="SERVER_TIMING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://www.w3.org/TR/server-timing/">{@code Server-Timing}</a> header field
 name.

 @since 23.6]]>
      </doc>
    </field>
    <field name="SERVICE_WORKER_ALLOWED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://www.w3.org/TR/service-workers/#update-algorithm">{@code
 Service-Worker-Allowed}</a> header field name.

 @since 20.0]]>
      </doc>
    </field>
    <field name="SET_COOKIE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Set-Cookie} header field name.]]>
      </doc>
    </field>
    <field name="SET_COOKIE2" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Set-Cookie2} header field name.]]>
      </doc>
    </field>
    <field name="SOURCE_MAP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/SourceMap">{@code
 SourceMap}</a> header field name.

 @since 27.1]]>
      </doc>
    </field>
    <field name="SUPPORTS_LOADING_MODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://github.com/WICG/nav-speculation/blob/main/opt-in.md">{@code
 Supports-Loading-Mode}</a> header field name. This can be used to specify, for example, <a
 href="https://developer.chrome.com/docs/privacy-sandbox/fenced-frame/#server-opt-in">fenced
 frames</a>.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="STRICT_TRANSPORT_SECURITY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://tools.ietf.org/html/rfc6797#section-6.1">{@code
 Strict-Transport-Security}</a> header field name.

 @since 15.0]]>
      </doc>
    </field>
    <field name="TIMING_ALLOW_ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://www.w3.org/TR/resource-timing/#cross-origin-resources">{@code
 Timing-Allow-Origin}</a> header field name.

 @since 15.0]]>
      </doc>
    </field>
    <field name="TRAILER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Trailer} header field name.]]>
      </doc>
    </field>
    <field name="TRANSFER_ENCODING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Transfer-Encoding} header field name.]]>
      </doc>
    </field>
    <field name="VARY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code Vary} header field name.]]>
      </doc>
    </field>
    <field name="WWW_AUTHENTICATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code WWW-Authenticate} header field name.]]>
      </doc>
    </field>
    <field name="DNT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code DNT} header field name.]]>
      </doc>
    </field>
    <field name="X_CONTENT_TYPE_OPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Content-Type-Options} header field name.]]>
      </doc>
    </field>
    <field name="X_DEVICE_IP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://iabtechlab.com/wp-content/uploads/2019/06/VAST_4.2_final_june26.pdf">{@code
 X-Device-IP}</a> header field name. Header used for VAST requests to provide the IP address of
 the device on whose behalf the request is being made.

 @since 31.0]]>
      </doc>
    </field>
    <field name="X_DEVICE_REFERER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://iabtechlab.com/wp-content/uploads/2019/06/VAST_4.2_final_june26.pdf">{@code
 X-Device-Referer}</a> header field name. Header used for VAST requests to provide the {@link
 #REFERER} header value that the on-behalf-of client would have used when making a request
 itself.

 @since 31.0]]>
      </doc>
    </field>
    <field name="X_DEVICE_ACCEPT_LANGUAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://iabtechlab.com/wp-content/uploads/2019/06/VAST_4.2_final_june26.pdf">{@code
 X-Device-Accept-Language}</a> header field name. Header used for VAST requests to provide the
 {@link #ACCEPT_LANGUAGE} header value that the on-behalf-of client would have used when making
 a request itself.

 @since 31.0]]>
      </doc>
    </field>
    <field name="X_DEVICE_REQUESTED_WITH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://iabtechlab.com/wp-content/uploads/2019/06/VAST_4.2_final_june26.pdf">{@code
 X-Device-Requested-With}</a> header field name. Header used for VAST requests to provide the
 {@link #X_REQUESTED_WITH} header value that the on-behalf-of client would have used when making
 a request itself.

 @since 31.0]]>
      </doc>
    </field>
    <field name="X_DO_NOT_TRACK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Do-Not-Track} header field name.]]>
      </doc>
    </field>
    <field name="X_FORWARDED_FOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Forwarded-For} header field name (superseded by {@code Forwarded}).]]>
      </doc>
    </field>
    <field name="X_FORWARDED_PROTO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Forwarded-Proto} header field name.]]>
      </doc>
    </field>
    <field name="X_FORWARDED_HOST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host">{@code
 X-Forwarded-Host}</a> header field name.

 @since 20.0]]>
      </doc>
    </field>
    <field name="X_FORWARDED_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/x-forwarded-headers.html#x-forwarded-port">{@code
 X-Forwarded-Port}</a> header field name.

 @since 20.0]]>
      </doc>
    </field>
    <field name="X_FRAME_OPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Frame-Options} header field name.]]>
      </doc>
    </field>
    <field name="X_POWERED_BY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Powered-By} header field name.]]>
      </doc>
    </field>
    <field name="PUBLIC_KEY_PINS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://tools.ietf.org/html/draft-evans-palmer-key-pinning">{@code
 Public-Key-Pins}</a> header field name.

 @since 15.0]]>
      </doc>
    </field>
    <field name="PUBLIC_KEY_PINS_REPORT_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://tools.ietf.org/html/draft-evans-palmer-key-pinning">{@code
 Public-Key-Pins-Report-Only}</a> header field name.

 @since 15.0]]>
      </doc>
    </field>
    <field name="X_REQUEST_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Request-ID} header field name.

 @since 30.1]]>
      </doc>
    </field>
    <field name="X_REQUESTED_WITH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-Requested-With} header field name.]]>
      </doc>
    </field>
    <field name="X_USER_IP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-User-IP} header field name.]]>
      </doc>
    </field>
    <field name="X_DOWNLOAD_OPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://learn.microsoft.com/en-us/archive/blogs/ieinternals/internet-explorer-and-custom-http-headers#:~:text=X%2DDownload%2DOptions">{@code
 X-Download-Options}</a> header field name.

 <p>When the new X-Download-Options header is present with the value {@code noopen}, the user is
 prevented from opening a file download directly; instead, they must first save the file
 locally.

 @since 24.1]]>
      </doc>
    </field>
    <field name="X_XSS_PROTECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP {@code X-XSS-Protection} header field name.]]>
      </doc>
    </field>
    <field name="X_DNS_PREFETCH_CONTROL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control">{@code
 X-DNS-Prefetch-Control}</a> header controls DNS prefetch behavior. Value can be "on" or "off".
 By default, DNS prefetching is "on" for HTTP pages and "off" for HTTPS pages.]]>
      </doc>
    </field>
    <field name="PING_FROM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://html.spec.whatwg.org/multipage/semantics.html#hyperlink-auditing">
 {@code Ping-From}</a> header field name.

 @since 19.0]]>
      </doc>
    </field>
    <field name="PING_TO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="http://html.spec.whatwg.org/multipage/semantics.html#hyperlink-auditing">
 {@code Ping-To}</a> header field name.

 @since 19.0]]>
      </doc>
    </field>
    <field name="PURPOSE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ#As_a_server_admin.2C_can_I_distinguish_prefetch_requests_from_normal_requests.3F">{@code
 Purpose}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="X_PURPOSE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ#As_a_server_admin.2C_can_I_distinguish_prefetch_requests_from_normal_requests.3F">{@code
 X-Purpose}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="X_MOZ" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ#As_a_server_admin.2C_can_I_distinguish_prefetch_requests_from_normal_requests.3F">{@code
 X-Moz}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="DEVICE_MEMORY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Device-Memory">{@code
 Device-Memory}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="DOWNLINK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Downlink">{@code
 Downlink}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="ECT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ECT">{@code
 ECT}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="RTT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/RTT">{@code
 RTT}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="SAVE_DATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data">{@code
 Save-Data}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="VIEWPORT_WIDTH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Viewport-Width">{@code
 Viewport-Width}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="WIDTH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Width">{@code
 Width}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="PERMISSIONS_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://www.w3.org/TR/permissions-policy-1/">{@code Permissions-Policy}</a>
 header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="PERMISSIONS_POLICY_REPORT_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://w3c.github.io/webappsec-permissions-policy/#permissions-policy-report-only-http-header-field">{@code
 Permissions-Policy-Report-Only}</a> header field name.

 @since 33.2.0]]>
      </doc>
    </field>
    <field name="SEC_CH_PREFERS_COLOR_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://wicg.github.io/user-preference-media-features-headers/#sec-ch-prefers-color-scheme">{@code
 Sec-CH-Prefers-Color-Scheme}</a> header field name.

 <p>This header is experimental.

 @since 31.0]]>
      </doc>
    </field>
    <field name="ACCEPT_CH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://www.rfc-editor.org/rfc/rfc8942#name-the-accept-ch-response-head">{@code
 Accept-CH}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="CRITICAL_CH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://datatracker.ietf.org/doc/html/draft-davidben-http-client-hint-reliability-03.txt#section-3">{@code
 Critical-CH}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua">{@code Sec-CH-UA}</a>
 header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_ARCH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-arch">{@code
 Sec-CH-UA-Arch}</a> header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_MODEL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-model">{@code
 Sec-CH-UA-Model}</a> header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_PLATFORM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-platform">{@code
 Sec-CH-UA-Platform}</a> header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_PLATFORM_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-platform-version">{@code
 Sec-CH-UA-Platform-Version}</a> header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_FULL_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Prefer {@link SEC_CH_UA_FULL_VERSION_LIST}.">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-full-version">{@code
 Sec-CH-UA-Full-Version}</a> header field name.

 @deprecated Prefer {@link SEC_CH_UA_FULL_VERSION_LIST}.
 @since 30.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_FULL_VERSION_LIST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-full-version-list">{@code
 Sec-CH-UA-Full-Version}</a> header field name.

 @since 31.1]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_MOBILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-mobile">{@code
 Sec-CH-UA-Mobile}</a> header field name.

 @since 30.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_WOW64" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-wow64">{@code
 Sec-CH-UA-WoW64}</a> header field name.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_BITNESS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-bitness">{@code
 Sec-CH-UA-Bitness}</a> header field name.

 @since 31.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_FORM_FACTOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Prefer {@link SEC_CH_UA_FORM_FACTORS}.">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-form-factor">{@code
 Sec-CH-UA-Form-Factor}</a> header field name.

 @deprecated Prefer {@link SEC_CH_UA_FORM_FACTORS}.
 @since 32.0.0]]>
      </doc>
    </field>
    <field name="SEC_CH_UA_FORM_FACTORS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/ua-client-hints/#sec-ch-ua-form-factors">{@code
 Sec-CH-UA-Form-Factors}</a> header field name.

 @since 33.3.0]]>
      </doc>
    </field>
    <field name="SEC_CH_VIEWPORT_WIDTH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://wicg.github.io/responsive-image-client-hints/#sec-ch-viewport-width">{@code
 Sec-CH-Viewport-Width}</a> header field name.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="SEC_CH_VIEWPORT_HEIGHT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://wicg.github.io/responsive-image-client-hints/#sec-ch-viewport-height">{@code
 Sec-CH-Viewport-Height}</a> header field name.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="SEC_CH_DPR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/responsive-image-client-hints/#sec-ch-dpr">{@code
 Sec-CH-DPR}</a> header field name.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="SEC_FETCH_DEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://w3c.github.io/webappsec-fetch-metadata/">{@code Sec-Fetch-Dest}</a>
 header field name.

 @since 27.1]]>
      </doc>
    </field>
    <field name="SEC_FETCH_MODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://w3c.github.io/webappsec-fetch-metadata/">{@code Sec-Fetch-Mode}</a>
 header field name.

 @since 27.1]]>
      </doc>
    </field>
    <field name="SEC_FETCH_SITE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://w3c.github.io/webappsec-fetch-metadata/">{@code Sec-Fetch-Site}</a>
 header field name.

 @since 27.1]]>
      </doc>
    </field>
    <field name="SEC_FETCH_USER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://w3c.github.io/webappsec-fetch-metadata/">{@code Sec-Fetch-User}</a>
 header field name.

 @since 27.1]]>
      </doc>
    </field>
    <field name="SEC_METADATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://w3c.github.io/webappsec-fetch-metadata/">{@code Sec-Metadata}</a>
 header field name.

 @since 26.0]]>
      </doc>
    </field>
    <field name="SEC_TOKEN_BINDING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/draft-ietf-tokbind-https">{@code
 Sec-Token-Binding}</a> header field name.

 @since 25.1]]>
      </doc>
    </field>
    <field name="SEC_PROVIDED_TOKEN_BINDING_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/draft-ietf-tokbind-ttrp">{@code
 Sec-Provided-Token-Binding-ID}</a> header field name.

 @since 25.1]]>
      </doc>
    </field>
    <field name="SEC_REFERRED_TOKEN_BINDING_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/draft-ietf-tokbind-ttrp">{@code
 Sec-Referred-Token-Binding-ID}</a> header field name.

 @since 25.1]]>
      </doc>
    </field>
    <field name="SEC_WEBSOCKET_ACCEPT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc6455">{@code
 Sec-WebSocket-Accept}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="SEC_WEBSOCKET_EXTENSIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc6455">{@code
 Sec-WebSocket-Extensions}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="SEC_WEBSOCKET_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc6455">{@code Sec-WebSocket-Key}</a>
 header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="SEC_WEBSOCKET_PROTOCOL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc6455">{@code
 Sec-WebSocket-Protocol}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="SEC_WEBSOCKET_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc6455">{@code
 Sec-WebSocket-Version}</a> header field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="SEC_BROWSING_TOPICS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://patcg-individual-drafts.github.io/topics/">{@code
 Sec-Browsing-Topics}</a> header field name.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="OBSERVE_BROWSING_TOPICS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://patcg-individual-drafts.github.io/topics/">{@code
 Observe-Browsing-Topics}</a> header field name.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="SEC_AD_AUCTION_FETCH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://wicg.github.io/turtledove/#handling-direct-from-seller-signals">{@code
 Sec-Ad-Auction-Fetch}</a> header field name.

 @since 33.0.0]]>
      </doc>
    </field>
    <field name="SEC_GPC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://privacycg.github.io/gpc-spec/#the-sec-gpc-header-field-for-http-requests">{@code
 Sec-GPC}</a> header field name.

 @since 33.2.0]]>
      </doc>
    </field>
    <field name="AD_AUCTION_SIGNALS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a
 href="https://wicg.github.io/turtledove/#handling-direct-from-seller-signals">{@code
 Ad-Auction-Signals}</a> header field name.

 @since 33.0.0]]>
      </doc>
    </field>
    <field name="AD_AUCTION_ALLOWED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://wicg.github.io/turtledove/#http-headerdef-ad-auction-allowed">{@code
 Ad-Auction-Allowed}</a> header field name.

 @since 33.2.0]]>
      </doc>
    </field>
    <field name="CDN_LOOP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc8586">{@code CDN-Loop}</a> header
 field name.

 @since 28.0]]>
      </doc>
    </field>
    <field name="ALT_SVC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7838#page-8">{@code Alt-Svc}</a>
 header field name.

 @since 33.4.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Contains constant definitions for the HTTP header field names. See:

 <ul>
   <li><a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a>
   <li><a href="http://www.ietf.org/rfc/rfc2183.txt">RFC 2183</a>
   <li><a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>
   <li><a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a>
   <li><a href="http://www.ietf.org/rfc/rfc5988.txt">RFC 5988</a>
 </ul>

 @author Kurt Alfred Kluever
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HttpHeaders -->
  <!-- start class com.google.common.net.HttpHeaders.ReferrerPolicyValues -->
  <class name="HttpHeaders.ReferrerPolicyValues" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="NO_REFERRER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NO_REFFERER_WHEN_DOWNGRADE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SAME_ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRICT_ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ORIGIN_WHEN_CROSS_ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRICT_ORIGIN_WHEN_CROSS_ORIGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNSAFE_URL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Values for the <a href="https://www.w3.org/TR/referrer-policy/">{@code Referrer-Policy}</a>
 header.

 @since 23.4]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.HttpHeaders.ReferrerPolicyValues -->
  <!-- start class com.google.common.net.InetAddresses -->
  <class name="InetAddresses" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="forString" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the {@link InetAddress} having the given string representation.

 <p>This deliberately avoids all nameservice lookups (e.g. no DNS).

 <p>This method accepts non-ASCII digits, for example {@code "１９２.１６８.０.１"} (those are fullwidth
 characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you
 want to accept ASCII digits only, you can use something like {@code
 CharMatcher.ascii().matchesAllOf(ipString)}.

 <p>The scope ID is validated against the interfaces on the machine, which requires permissions
 under Android.

 <p><b>Android users on API >= 29:</b> Prefer {@code InetAddresses.parseNumericAddress}.

 @param ipString {@code String} containing an IPv4 or IPv6 string literal, e.g. {@code
     "192.168.0.1"} or {@code "2001:db8::1"} or with a scope ID, e.g. {@code "2001:db8::1%eth0"}
 @return {@link InetAddress} representing the argument
 @throws IllegalArgumentException if the argument is not a valid IP string literal or if the
     address has a scope ID that fails validation against the interfaces on the machine (as
     required by Java's {@link InetAddress})]]>
      </doc>
    </method>
    <method name="isInetAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the supplied string is a valid IP string literal, {@code false}
 otherwise.

 <p>This method accepts non-ASCII digits, for example {@code "１９２.１６８.０.１"} (those are fullwidth
 characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you
 want to accept ASCII digits only, you can use something like {@code
 CharMatcher.ascii().matchesAllOf(ipString)}.

 <p>Note that if this method returns {@code true}, a call to {@link #forString(String)} can
 still throw if the address has a scope ID that fails validation against the interfaces on the
 machine.

 @param ipString {@code String} to evaluated as an IP string literal
 @return {@code true} if the argument is a valid IP string literal]]>
      </doc>
    </method>
    <method name="toAddrString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns the string representation of an {@link InetAddress}.

 <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6
 addresses, the output follows <a href="http://tools.ietf.org/html/rfc5952">RFC 5952</a> section
 4. The main difference is that this method uses "::" for zero compression, while Java's version
 uses the uncompressed form (except on Android, where the zero compression is also done). The
 other difference is that this method outputs any scope ID in the format that it was provided at
 creation time, while Android may always output it as an interface name, even if it was supplied
 as a numeric ID.

 <p>This method uses hexadecimal for all IPv6 addresses, including IPv4-mapped IPv6 addresses
 such as "::c000:201".

 @param ip {@link InetAddress} to be converted to an address string
 @return {@code String} containing the text-formatted IP address
 @since 10.0]]>
      </doc>
    </method>
    <method name="toUriString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns the string representation of an {@link InetAddress} suitable for inclusion in a URI.

 <p>For IPv4 addresses, this is identical to {@link InetAddress#getHostAddress()}, but for IPv6
 addresses it compresses zeroes and surrounds the text with square brackets; for example {@code
 "[2001:db8::1]"}.

 <p>Per section 3.2.2 of <a target="_parent"
 href="http://tools.ietf.org/html/rfc3986#section-3.2.2">RFC 3986</a>, a URI containing an IPv6
 string literal is of the form {@code "http://[2001:db8::1]:8888/index.html"}.

 <p>Use of either {@link InetAddresses#toAddrString}, {@link InetAddress#getHostAddress()}, or
 this method is recommended over {@link InetAddress#toString()} when an IP address string
 literal is desired. This is because {@link InetAddress#toString()} prints the hostname and the
 IP address string joined by a "/".

 @param ip {@link InetAddress} to be converted to URI string literal
 @return {@code String} containing URI-safe string literal]]>
      </doc>
    </method>
    <method name="forUriString" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostAddr" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an InetAddress representing the literal IPv4 or IPv6 host portion of a URL, encoded in
 the format specified by RFC 3986 section 3.2.2.

 <p>This method is similar to {@link InetAddresses#forString(String)}, however, it requires that
 IPv6 addresses are surrounded by square brackets.

 <p>This method is the inverse of {@link InetAddresses#toUriString(java.net.InetAddress)}.

 <p>This method accepts non-ASCII digits, for example {@code "１９２.１６８.０.１"} (those are fullwidth
 characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you
 want to accept ASCII digits only, you can use something like {@code
 CharMatcher.ascii().matchesAllOf(ipString)}.

 @param hostAddr an RFC 3986 section 3.2.2 encoded IPv4 or IPv6 address
 @return an InetAddress representing the address in {@code hostAddr}
 @throws IllegalArgumentException if {@code hostAddr} is not a valid IPv4 address, or IPv6
     address surrounded by square brackets, or if the address has a scope ID that fails
     validation against the interfaces on the machine (as required by Java's {@link
     InetAddress})]]>
      </doc>
    </method>
    <method name="isUriInetAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code true} if the supplied string is a valid URI IP string literal, {@code false}
 otherwise.

 <p>This method accepts non-ASCII digits, for example {@code "１９２.１６８.０.１"} (those are fullwidth
 characters). That is consistent with {@link InetAddress}, but not with various RFCs. If you
 want to accept ASCII digits only, you can use something like {@code
 CharMatcher.ascii().matchesAllOf(ipString)}.

 <p>Note that if this method returns {@code true}, a call to {@link #forUriString(String)} can
 still throw if the address has a scope ID that fails validation against the interfaces on the
 machine.

 @param ipString {@code String} to evaluated as an IP URI host string literal
 @return {@code true} if the argument is a valid IP URI host]]>
      </doc>
    </method>
    <method name="isCompatIPv4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an IPv6 "compat" address.

 <p>An "IPv4 compatible", or "compat", address is one with 96 leading bits of zero, with the
 remaining 32 bits interpreted as an IPv4 address. These are conventionally represented in
 string literals as {@code "::192.168.0.1"}, though {@code "::c0a8:1"} is also considered an
 IPv4 compatible address (and equivalent to {@code "::192.168.0.1"}).

 <p>For more on IPv4 compatible addresses see section 2.5.5.1 of <a target="_parent"
 href="http://tools.ietf.org/html/rfc4291#section-2.5.5.1">RFC 4291</a>.

 <p>NOTE: This method is different from {@link Inet6Address#isIPv4CompatibleAddress} in that it
 more correctly classifies {@code "::"} and {@code "::1"} as proper IPv6 addresses (which they
 are), NOT IPv4 compatible addresses (which they are generally NOT considered to be).

 @param ip {@link Inet6Address} to be examined for embedded IPv4 compatible address format
 @return {@code true} if the argument is a valid "compat" address]]>
      </doc>
    </method>
    <method name="getCompatIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in an IPv4 compatible address.

 @param ip {@link Inet6Address} to be examined for an embedded IPv4 address
 @return {@link Inet4Address} of the embedded IPv4 address
 @throws IllegalArgumentException if the argument is not a valid IPv4 compatible address]]>
      </doc>
    </method>
    <method name="is6to4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is a 6to4 address.

 <p>6to4 addresses begin with the {@code "2002::/16"} prefix. The next 32 bits are the IPv4
 address of the host to which IPv6-in-IPv4 tunneled packets should be routed.

 <p>For more on 6to4 addresses see section 2 of <a target="_parent"
 href="http://tools.ietf.org/html/rfc3056#section-2">RFC 3056</a>.

 @param ip {@link Inet6Address} to be examined for 6to4 address format
 @return {@code true} if the argument is a 6to4 address]]>
      </doc>
    </method>
    <method name="get6to4IPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in a 6to4 address.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 in 6to4 address
 @return {@link Inet4Address} of embedded IPv4 in 6to4 address
 @throws IllegalArgumentException if the argument is not a valid IPv6 6to4 address]]>
      </doc>
    </method>
    <method name="isTeredoAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is a Teredo address.

 <p>Teredo addresses begin with the {@code "2001::/32"} prefix.

 @param ip {@link Inet6Address} to be examined for Teredo address format
 @return {@code true} if the argument is a Teredo address]]>
      </doc>
    </method>
    <method name="getTeredoInfo" return="com.google.common.net.InetAddresses.TeredoInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the Teredo information embedded in a Teredo address.

 @param ip {@link Inet6Address} to be examined for embedded Teredo information
 @return extracted {@code TeredoInfo}
 @throws IllegalArgumentException if the argument is not a valid IPv6 Teredo address]]>
      </doc>
    </method>
    <method name="isIsatapAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an ISATAP address.

 <p>From RFC 5214: "ISATAP interface identifiers are constructed in Modified EUI-64 format [...]
 by concatenating the 24-bit IANA OUI (00-00-5E), the 8-bit hexadecimal value 0xFE, and a 32-bit
 IPv4 address in network byte order [...]"

 <p>For more on ISATAP addresses see section 6.1 of <a target="_parent"
 href="http://tools.ietf.org/html/rfc5214#section-6.1">RFC 5214</a>.

 @param ip {@link Inet6Address} to be examined for ISATAP address format
 @return {@code true} if the argument is an ISATAP address]]>
      </doc>
    </method>
    <method name="getIsatapIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Returns the IPv4 address embedded in an ISATAP address.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 in ISATAP address
 @return {@link Inet4Address} of embedded IPv4 in an ISATAP address
 @throws IllegalArgumentException if the argument is not a valid IPv6 ISATAP address]]>
      </doc>
    </method>
    <method name="hasEmbeddedIPv4ClientAddress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Examines the Inet6Address to determine if it is an IPv6 address of one of the specified address
 types that contain an embedded IPv4 address.

 <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial
 spoofability. With other transition addresses spoofing involves (at least) infection of one's
 BGP routing table.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 client address
 @return {@code true} if there is an embedded IPv4 client address
 @since 7.0]]>
      </doc>
    </method>
    <method name="getEmbeddedIPv4ClientAddress" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.Inet6Address"/>
      <doc>
      <![CDATA[Examines the Inet6Address to extract the embedded IPv4 client address if the InetAddress is an
 IPv6 address of one of the specified address types that contain an embedded IPv4 address.

 <p>NOTE: ISATAP addresses are explicitly excluded from this method due to their trivial
 spoofability. With other transition addresses spoofing involves (at least) infection of one's
 BGP routing table.

 @param ip {@link Inet6Address} to be examined for embedded IPv4 client address
 @return {@link Inet4Address} of embedded IPv4 client address
 @throws IllegalArgumentException if the argument does not have a valid embedded IPv4 address]]>
      </doc>
    </method>
    <method name="isMappedIPv4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipString" type="java.lang.String"/>
      <doc>
      <![CDATA[Evaluates whether the argument is an "IPv4 mapped" IPv6 address.

 <p>An "IPv4 mapped" address is anything in the range ::ffff:0:0/96 (sometimes written as
 ::ffff:0.0.0.0/96), with the last 32 bits interpreted as an IPv4 address.

 <p>For more on IPv4 mapped addresses see section 2.5.5.2 of <a target="_parent"
 href="http://tools.ietf.org/html/rfc4291#section-2.5.5.2">RFC 4291</a>.

 <p>Note: This method takes a {@code String} argument because {@link InetAddress} automatically
 collapses mapped addresses to IPv4. (It is actually possible to avoid this using one of the
 obscure {@link Inet6Address} methods, but it would be unwise to depend on such a
 poorly-documented feature.)

 <p>This method accepts non-ASCII digits. That is consistent with {@link InetAddress}, but not
 with various RFCs. If you want to accept ASCII digits only, you can use something like {@code
 CharMatcher.ascii().matchesAllOf(ipString)}.

 @param ipString {@code String} to be examined for embedded IPv4-mapped IPv6 address format
 @return {@code true} if the argument is a valid "mapped" address
 @since 10.0]]>
      </doc>
    </method>
    <method name="getCoercedIPv4Address" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Coerces an IPv6 address into an IPv4 address.

 <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,
 accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.
 This method does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits
 into 29 bits):

 <ul>
   <li>If the IPv6 address contains an embedded IPv4 address, the function hashes that.
   <li>Otherwise, it hashes the upper 64 bits of the IPv6 address.
 </ul>

 <p>A "coerced" IPv4 address is equivalent to itself.

 <p>NOTE: This method is failsafe for security purposes: ALL IPv6 addresses (except localhost
 (::1)) are hashed to avoid the security risk associated with extracting an embedded IPv4
 address that might permit elevated privileges.

 @param ip {@link InetAddress} to "coerce"
 @return {@link Inet4Address} represented "coerced" address
 @since 7.0]]>
      </doc>
    </method>
    <method name="coerceToInteger" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ip" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns an integer representing an IPv4 address regardless of whether the supplied argument is
 an IPv4 address or not.

 <p>IPv6 addresses are <b>coerced</b> to IPv4 addresses before being converted to integers.

 <p>As long as there are applications that assume that all IP addresses are IPv4 addresses and
 can therefore be converted safely to integers (for whatever purpose) this function can be used
 to handle IPv6 addresses as well until the application is suitably fixed.

 <p>NOTE: an IPv6 address coerced to an IPv4 address can only be used for such purposes as
 rudimentary identification or indexing into a collection of real {@link InetAddress}es. They
 cannot be used as real addresses for the purposes of network communication.

 @param ip {@link InetAddress} to convert
 @return {@code int}, "coerced" if ip is not an IPv4 address
 @since 7.0]]>
      </doc>
    </method>
    <method name="toBigInteger" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns a BigInteger representing the address.

 <p>Unlike {@code coerceToInteger}, IPv6 addresses are not coerced to IPv4 addresses.

 @param address {@link InetAddress} to convert
 @return {@code BigInteger} representation of the address
 @since 28.2]]>
      </doc>
    </method>
    <method name="fromInteger" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="int"/>
      <doc>
      <![CDATA[Returns an Inet4Address having the integer value specified by the argument.

 @param address {@code int}, the 32bit integer address to be converted
 @return {@link Inet4Address} equivalent of the argument]]>
      </doc>
    </method>
    <method name="fromIPv4BigInteger" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns the {@code Inet4Address} corresponding to a given {@code BigInteger}.

 @param address BigInteger representing the IPv4 address
 @return Inet4Address representation of the given BigInteger
 @throws IllegalArgumentException if the BigInteger is not between 0 and 2^32-1
 @since 28.2]]>
      </doc>
    </method>
    <method name="fromIPv6BigInteger" return="java.net.Inet6Address"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns the {@code Inet6Address} corresponding to a given {@code BigInteger}.

 @param address BigInteger representing the IPv6 address
 @return Inet6Address representation of the given BigInteger
 @throws IllegalArgumentException if the BigInteger is not between 0 and 2^128-1
 @since 28.2]]>
      </doc>
    </method>
    <method name="fromLittleEndianByteArray" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="byte[]"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns an address from a <b>little-endian ordered</b> byte array (the opposite of what {@link
 InetAddress#getByAddress} expects).

 <p>IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long.

 @param addr the raw IP address in little-endian byte order
 @return an InetAddress object created from the raw IP address
 @throws UnknownHostException if IP address is of illegal length]]>
      </doc>
    </method>
    <method name="decrement" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns a new InetAddress that is one less than the passed in address. This method works for
 both IPv4 and IPv6 addresses.

 @param address the InetAddress to decrement
 @return a new InetAddress that is one less than the passed in address
 @throws IllegalArgumentException if InetAddress is at the beginning of its range
 @since 18.0]]>
      </doc>
    </method>
    <method name="increment" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns a new InetAddress that is one more than the passed in address. This method works for
 both IPv4 and IPv6 addresses.

 @param address the InetAddress to increment
 @return a new InetAddress that is one more than the passed in address
 @throws IllegalArgumentException if InetAddress is at the end of its range
 @since 10.0]]>
      </doc>
    </method>
    <method name="isMaximum" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="address" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Returns true if the InetAddress is either 255.255.255.255 for IPv4 or
 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6.

 @return true if the InetAddress is either 255.255.255.255 for IPv4 or
     ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff for IPv6
 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@link InetAddress} instances.

 <p><b>Important note:</b> Unlike {@code InetAddress.getByName()}, the methods of this class never
 cause DNS services to be accessed. For this reason, you should prefer these methods as much as
 possible over their JDK equivalents whenever you are expecting to handle only IP address string
 literals -- there is no blocking DNS penalty for a malformed string.

 <p>When dealing with {@link Inet4Address} and {@link Inet6Address} objects as byte arrays (vis.
 {@code InetAddress.getAddress()}) they are 4 and 16 bytes in length, respectively, and represent
 the address in network byte order.

 <p>Examples of IP addresses and their byte representations:

 <dl>
   <dt>The IPv4 loopback address, {@code "127.0.0.1"}.
   <dd>{@code 7f 00 00 01}
   <dt>The IPv6 loopback address, {@code "::1"}.
   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01}
   <dt>From the IPv6 reserved documentation prefix ({@code 2001:db8::/32}), {@code "2001:db8::1"}.
   <dd>{@code 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01}
   <dt>An IPv6 "IPv4 compatible" (or "compat") address, {@code "::192.168.0.1"}.
   <dd>{@code 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01}
   <dt>An IPv6 "IPv4 mapped" address, {@code "::ffff:192.168.0.1"}.
   <dd>{@code 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01}
 </dl>

 <p>A few notes about IPv6 "IPv4 mapped" addresses and their observed use in Java.

 <p>"IPv4 mapped" addresses were originally a representation of IPv4 addresses for use on an IPv6
 socket that could receive both IPv4 and IPv6 connections (by disabling the {@code IPV6_V6ONLY}
 socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these "mapped" addresses
 were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in
 later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler.

 <p>Technically one <i>can</i> create a 128bit IPv6 address with the wire format of a "mapped"
 address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress
 creation methods appear to adhere doggedly to the original intent of the "mapped" address: all
 "mapped" addresses return {@link Inet4Address} objects.

 <p>For added safety, it is common for IPv6 network operators to filter all packets where either
 the source or destination address appears to be a "compat" or "mapped" address. Filtering
 suggestions usually recommend discarding any packets with source or destination addresses in the
 invalid range {@code ::/3}, which includes both of these bizarre address formats. For more
 information on "bogons", including lists of IPv6 bogon space, see:

 <ul>
   <li><a target="_parent"
       href="http://en.wikipedia.org/wiki/Bogon_filtering">http://en.wikipedia.
       org/wiki/Bogon_filtering</a>
   <li><a target="_parent"
       href="http://www.cymru.com/Bogons/ipv6.txt">http://www.cymru.com/Bogons/ ipv6.txt</a>
   <li><a target="_parent" href="http://www.cymru.com/Bogons/v6bogon.html">http://www.cymru.com/
       Bogons/v6bogon.html</a>
   <li><a target="_parent" href="http://www.space.net/~gert/RIPE/ipv6-filters.html">http://www.
       space.net/~gert/RIPE/ipv6-filters.html</a>
 </ul>

 @author Erik Kline
 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InetAddresses -->
  <!-- start class com.google.common.net.InetAddresses.TeredoInfo -->
  <class name="InetAddresses.TeredoInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TeredoInfo" type="Inet4Address, Inet4Address, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a TeredoInfo instance.

 <p>Both server and client can be {@code null}, in which case the value {@code "0.0.0.0"} will
 be assumed.

 @throws IllegalArgumentException if either of the {@code port} or the {@code flags} arguments
     are out of range of an unsigned short]]>
      </doc>
    </constructor>
    <method name="getServer" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClient" return="java.net.Inet4Address"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFlags" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simple immutable data class to encapsulate the information to be found in a Teredo address.

 <p>All of the fields in this class are encoded in various portions of the IPv6 address as part
 of the protocol. More protocols details can be found at: <a target="_parent"
 href="http://en.wikipedia.org/wiki/Teredo_tunneling">http://en.wikipedia.
 org/wiki/Teredo_tunneling</a>.

 <p>The RFC can be found here: <a target="_parent" href="http://tools.ietf.org/html/rfc4380">RFC
 4380</a>.

 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InetAddresses.TeredoInfo -->
  <!-- start class com.google.common.net.InternetDomainName -->
  <class name="InternetDomainName" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="from" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an instance of {@link InternetDomainName} after lenient validation. Specifically,
 validation against <a href="http://www.ietf.org/rfc/rfc3490.txt">RFC 3490</a>
 ("Internationalizing Domain Names in Applications") is skipped, while validation against <a
 href="http://www.ietf.org/rfc/rfc1035.txt">RFC 1035</a> is relaxed in the following ways:

 <ul>
   <li>Any part containing non-ASCII characters is considered valid.
   <li>Underscores ('_') are permitted wherever dashes ('-') are permitted.
   <li>Parts other than the final part may start with a digit, as mandated by <a
       href="https://tools.ietf.org/html/rfc1123#section-2">RFC 1123</a>.
 </ul>

 @param domain A domain name (not IP address)
 @throws IllegalArgumentException if {@code domain} is not syntactically valid according to
     {@link #isValid}
 @since 10.0 (previously named {@code fromLenient})]]>
      </doc>
    </method>
    <method name="parts" return="com.google.common.collect.ImmutableList&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the individual components of this domain name, normalized to all lower case. For
 example, for the domain name {@code mail.google.com}, this method returns the list {@code
 ["mail", "google", "com"]}.]]>
      </doc>
    </method>
    <method name="isPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name represents a <i>public suffix</i>, as defined by the Mozilla
 Foundation's <a href="http://publicsuffix.org/">Public Suffix List</a> (PSL). A public suffix
 is one under which Internet users can directly register names, such as {@code com}, {@code
 co.uk} or {@code pvt.k12.wy.us}. Examples of domain names that are <i>not</i> public suffixes
 include {@code google.com}, {@code foo.co.uk}, and {@code myblog.blogspot.com}.

 <p>Public suffixes are a proper superset of {@linkplain #isRegistrySuffix() registry suffixes}.
 The list of public suffixes additionally contains privately owned domain names under which
 Internet users can register subdomains. An example of a public suffix that is not a registry
 suffix is {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i>
 registry suffixes, since domain name registries collectively control all internet domain names.

 <p>For considerations on whether the public suffix or registry suffix designation is more
 suitable for your application, see <a
 href="https://github.com/google/guava/wiki/InternetDomainNameExplained">this article</a>.

 @return {@code true} if this domain name appears exactly on the public suffix list
 @since 6.0]]>
      </doc>
    </method>
    <method name="hasPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isPublicSuffix() public suffix},
 including if it is a public suffix itself. For example, returns {@code true} for {@code
 www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code
 google.invalid}. This is the recommended method for determining whether a domain is potentially
 an addressable host.

 <p>Note that this method is equivalent to {@link #hasRegistrySuffix()} because all registry
 suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.

 @since 6.0]]>
      </doc>
    </method>
    <method name="publicSuffix" return="InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@linkplain #isPublicSuffix() public suffix} portion of the domain name, or {@code
 null} if no public suffix is present.

 @since 6.0]]>
      </doc>
    </method>
    <method name="isUnderPublicSuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isPublicSuffix() public suffix},
 while not being a public suffix itself. For example, returns {@code true} for {@code
 www.google.com}, {@code foo.co.uk} and {@code myblog.blogspot.com}, but not for {@code com},
 {@code co.uk}, {@code google.invalid}, or {@code blogspot.com}.

 <p>This method can be used to determine whether it will probably be possible to set cookies on
 the domain, though even that depends on individual browsers' implementations of cookie
 controls. See <a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a> for details.

 @since 6.0]]>
      </doc>
    </method>
    <method name="isTopPrivateDomain" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name is composed of exactly one subdomain component followed by a
 {@linkplain #isPublicSuffix() public suffix}. For example, returns {@code true} for {@code
 google.com} {@code foo.co.uk}, and {@code myblog.blogspot.com}, but not for {@code
 www.google.com}, {@code co.uk}, or {@code blogspot.com}.

 <p>This method can be used to determine whether a domain is probably the highest level for
 which cookies may be set, though even that depends on individual browsers' implementations of
 cookie controls. See <a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a> for details.

 @since 6.0]]>
      </doc>
    </method>
    <method name="topPrivateDomain" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the portion of this domain name that is one level beneath the {@linkplain
 #isPublicSuffix() public suffix}. For example, for {@code x.adwords.google.co.uk} it returns
 {@code google.co.uk}, since {@code co.uk} is a public suffix. Similarly, for {@code
 myblog.blogspot.com} it returns the same domain, {@code myblog.blogspot.com}, since {@code
 blogspot.com} is a public suffix.

 <p>If {@link #isTopPrivateDomain()} is true, the current domain name instance is returned.

 <p>This method can be used to determine the probable highest level parent domain for which
 cookies may be set, though even that depends on individual browsers' implementations of cookie
 controls.

 @throws IllegalStateException if this domain does not end with a public suffix
 @since 6.0]]>
      </doc>
    </method>
    <method name="isRegistrySuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name represents a <i>registry suffix</i>, as defined by a subset
 of the Mozilla Foundation's <a href="http://publicsuffix.org/">Public Suffix List</a> (PSL). A
 registry suffix is one under which Internet users can directly register names via a domain name
 registrar, and have such registrations lawfully protected by internet-governing bodies such as
 ICANN. Examples of registry suffixes include {@code com}, {@code co.uk}, and {@code
 pvt.k12.wy.us}. Examples of domain names that are <i>not</i> registry suffixes include {@code
 google.com} and {@code foo.co.uk}.

 <p>Registry suffixes are a proper subset of {@linkplain #isPublicSuffix() public suffixes}. The
 list of public suffixes additionally contains privately owned domain names under which Internet
 users can register subdomains. An example of a public suffix that is not a registry suffix is
 {@code blogspot.com}. Note that it is true that all public suffixes <i>have</i> registry
 suffixes, since domain name registries collectively control all internet domain names.

 <p>For considerations on whether the public suffix or registry suffix designation is more
 suitable for your application, see <a
 href="https://github.com/google/guava/wiki/InternetDomainNameExplained">this article</a>.

 @return {@code true} if this domain name appears exactly on the public suffix list as part of
     the registry suffix section (labelled "ICANN").
 @since 23.3]]>
      </doc>
    </method>
    <method name="hasRegistrySuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},
 including if it is a registry suffix itself. For example, returns {@code true} for {@code
 www.google.com}, {@code foo.co.uk} and {@code com}, but not for {@code invalid} or {@code
 google.invalid}.

 <p>Note that this method is equivalent to {@link #hasPublicSuffix()} because all registry
 suffixes are public suffixes <i>and</i> all public suffixes have registry suffixes.

 @since 23.3]]>
      </doc>
    </method>
    <method name="registrySuffix" return="InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@linkplain #isRegistrySuffix() registry suffix} portion of the domain name, or
 {@code null} if no registry suffix is present.

 @since 23.3]]>
      </doc>
    </method>
    <method name="isUnderRegistrySuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name ends in a {@linkplain #isRegistrySuffix() registry suffix},
 while not being a registry suffix itself. For example, returns {@code true} for {@code
 www.google.com}, {@code foo.co.uk} and {@code blogspot.com}, but not for {@code com}, {@code
 co.uk}, or {@code google.invalid}.

 @since 23.3]]>
      </doc>
    </method>
    <method name="isTopDomainUnderRegistrySuffix" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain name is composed of exactly one subdomain component followed by a
 {@linkplain #isRegistrySuffix() registry suffix}. For example, returns {@code true} for {@code
 google.com}, {@code foo.co.uk}, and {@code blogspot.com}, but not for {@code www.google.com},
 {@code co.uk}, or {@code myblog.blogspot.com}.

 <p><b>Warning:</b> This method should not be used to determine the probable highest level
 parent domain for which cookies may be set. Use {@link #topPrivateDomain()} for that purpose.

 @since 23.3]]>
      </doc>
    </method>
    <method name="topDomainUnderRegistrySuffix" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the portion of this domain name that is one level beneath the {@linkplain
 #isRegistrySuffix() registry suffix}. For example, for {@code x.adwords.google.co.uk} it
 returns {@code google.co.uk}, since {@code co.uk} is a registry suffix. Similarly, for {@code
 myblog.blogspot.com} it returns {@code blogspot.com}, since {@code com} is a registry suffix.

 <p>If {@link #isTopDomainUnderRegistrySuffix()} is true, the current domain name instance is
 returned.

 <p><b>Warning:</b> This method should not be used to determine whether a domain is probably the
 highest level for which cookies may be set. Use {@link #isTopPrivateDomain()} for that purpose.

 @throws IllegalStateException if this domain does not end with a registry suffix
 @since 23.3]]>
      </doc>
    </method>
    <method name="hasParent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this domain is composed of two or more parts.]]>
      </doc>
    </method>
    <method name="parent" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code InternetDomainName} that is the immediate ancestor of this one; that is, the
 current domain with the leftmost part removed. For example, the parent of {@code
 www.google.com} is {@code google.com}.

 @throws IllegalStateException if the domain has no parent, as determined by {@link #hasParent}]]>
      </doc>
    </method>
    <method name="child" return="com.google.common.net.InternetDomainName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="leftParts" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates and returns a new {@code InternetDomainName} by prepending the argument and a dot to
 the current name. For example, {@code InternetDomainName.from("foo.com").child("www.bar")}
 returns a new {@code InternetDomainName} with the value {@code www.bar.foo.com}. Only lenient
 validation is performed, as described {@link #from(String) here}.

 @throws NullPointerException if leftParts is null
 @throws IllegalArgumentException if the resulting name is not valid]]>
      </doc>
    </method>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Indicates whether the argument is a syntactically valid domain name using lenient validation.
 Specifically, validation against <a href="http://www.ietf.org/rfc/rfc3490.txt">RFC 3490</a>
 ("Internationalizing Domain Names in Applications") is skipped.

 <p>The following two code snippets are equivalent:

 {@snippet :
 domainName = InternetDomainName.isValid(name)
     ? InternetDomainName.from(name)
     : DEFAULT_DOMAIN;
 }

 {@snippet :
 try {
   domainName = InternetDomainName.from(name);
 } catch (IllegalArgumentException e) {
   domainName = DEFAULT_DOMAIN;
 }
 }

 @since 8.0 (previously named {@code isValidLenient})]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the domain name, normalized to all lower case.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Equality testing is based on the text supplied by the caller, after normalization as described
 in the class documentation. For example, a non-ASCII Unicode domain name and the Punycode
 version of the same domain name would not be considered equal.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An immutable well-formed internet domain name, such as {@code com} or {@code foo.co.uk}. Only
 syntactic analysis is performed; no DNS lookups or other network interactions take place. Thus
 there is no guarantee that the domain actually exists on the internet.

 <p>One common use of this class is to determine whether a given string is likely to represent an
 addressable domain on the web -- that is, for a candidate string {@code "xxx"}, might browsing to
 {@code "http://xxx/"} result in a webpage being displayed? In the past, this test was frequently
 done by determining whether the domain ended with a {@linkplain #isPublicSuffix() public suffix}
 but was not itself a public suffix. However, this test is no longer accurate. There are many
 domains which are both public suffixes and addressable as hosts; {@code "uk.com"} is one example.
 Using the subset of public suffixes that are {@linkplain #isRegistrySuffix() registry suffixes},
 one can get a better result, as only a few registry suffixes are addressable. However, the most
 useful test to determine if a domain is a plausible web host is {@link #hasPublicSuffix()}. This
 will return {@code true} for many domains which (currently) are not hosts, such as {@code "com"},
 but given that any public suffix may become a host without warning, it is better to err on the
 side of permissiveness and thus avoid spurious rejection of valid sites. Of course, to actually
 determine addressability of any host, clients of this class will need to perform their own DNS
 lookups.

 <p>During construction, names are normalized in two ways:

 <ol>
   <li>ASCII uppercase characters are converted to lowercase.
   <li>Unicode dot separators other than the ASCII period ({@code '.'}) are converted to the ASCII
       period.
 </ol>

 <p>The normalized values will be returned from {@link #toString()} and {@link #parts()}, and will
 be reflected in the result of {@link #equals(Object)}.

 <p><a href="http://en.wikipedia.org/wiki/Internationalized_domain_name">Internationalized domain
 names</a> such as {@code 网络.cn} are supported, as are the equivalent <a
 href="http://en.wikipedia.org/wiki/Internationalized_domain_name">IDNA Punycode-encoded</a>
 versions.

 @author Catherine Berry
 @since 5.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.InternetDomainName -->
  <!-- start class com.google.common.net.MediaType -->
  <class name="MediaType" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="type" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the top-level media type. For example, {@code "text"} in {@code "text/plain"}.]]>
      </doc>
    </method>
    <method name="subtype" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the media subtype. For example, {@code "plain"} in {@code "text/plain"}.]]>
      </doc>
    </method>
    <method name="parameters" return="com.google.common.collect.ImmutableListMultimap&lt;java.lang.String, java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a multimap containing the parameters of this media type.]]>
      </doc>
    </method>
    <method name="charset" return="com.google.common.base.Optional&lt;java.nio.charset.Charset&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an optional charset for the value of the charset parameter if it is specified.

 @throws IllegalStateException if multiple charset values have been set for this media type
 @throws IllegalCharsetNameException if a charset value is present, but illegal
 @throws UnsupportedCharsetException if a charset value is present, but no support is available
     in this instance of the Java virtual machine]]>
      </doc>
    </method>
    <method name="withoutParameters" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance with the same type and subtype as this instance, but without any
 parameters.]]>
      </doc>
    </method>
    <method name="withParameters" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="com.google.common.collect.Multimap&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[<em>Replaces</em> all parameters with the given parameters.

 @throws IllegalArgumentException if any parameter or value is invalid]]>
      </doc>
    </method>
    <method name="withParameters" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="java.lang.String"/>
      <param name="values" type="java.lang.Iterable&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[<em>Replaces</em> all parameters with the given attribute with parameters using the given
 values. If there are no values, any existing parameters with the given attribute are removed.

 @throws IllegalArgumentException if either {@code attribute} or {@code values} is invalid
 @since 24.0]]>
      </doc>
    </method>
    <method name="withParameter" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[<em>Replaces</em> all parameters with the given attribute with a single parameter with the
 given value. If multiple parameters with the same attributes are necessary use {@link
 #withParameters(String, Iterable)}. Prefer {@link #withCharset} for setting the {@code charset}
 parameter when using a {@link Charset} object.

 @throws IllegalArgumentException if either {@code attribute} or {@code value} is invalid]]>
      </doc>
    </method>
    <method name="withCharset" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a new instance with the same type and subtype as this instance, with the {@code
 charset} parameter set to the {@link Charset#name name} of the given charset. Only one {@code
 charset} parameter will be present on the new instance regardless of the number set on this
 one.

 <p>If a charset must be specified that is not supported on this JVM (and thus is not
 representable as a {@link Charset} instance), use {@link #withParameter}.]]>
      </doc>
    </method>
    <method name="hasWildcard" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if either the type or subtype is the wildcard.]]>
      </doc>
    </method>
    <method name="is" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mediaTypeRange" type="com.google.common.net.MediaType"/>
      <doc>
      <![CDATA[Returns {@code true} if this instance falls within the range (as defined by <a
 href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">the HTTP Accept header</a>) given
 by the argument according to three criteria:

 <ol>
   <li>The type of the argument is the wildcard or equal to the type of this instance.
   <li>The subtype of the argument is the wildcard or equal to the subtype of this instance.
   <li>All of the parameters present in the argument are present in this instance.
 </ol>

 <p>For example:

 {@snippet :
 PLAIN_TEXT_UTF_8.is(PLAIN_TEXT_UTF_8) // true
 PLAIN_TEXT_UTF_8.is(HTML_UTF_8) // false
 PLAIN_TEXT_UTF_8.is(ANY_TYPE) // true
 PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE) // true
 PLAIN_TEXT_UTF_8.is(ANY_IMAGE_TYPE) // false
 PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_8)) // true
 PLAIN_TEXT_UTF_8.withoutParameters().is(ANY_TEXT_TYPE.withCharset(UTF_8)) // false
 PLAIN_TEXT_UTF_8.is(ANY_TEXT_TYPE.withCharset(UTF_16)) // false
 }

 <p>Note that while it is possible to have the same parameter declared multiple times within a
 media type this method does not consider the number of occurrences of a parameter. For example,
 {@code "text/plain; charset=UTF-8"} satisfies {@code "text/plain; charset=UTF-8;
 charset=UTF-8"}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.String"/>
      <param name="subtype" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new media type with the given type and subtype.

 @throws IllegalArgumentException if type or subtype is invalid or if a wildcard is used for the
     type, but not the subtype.]]>
      </doc>
    </method>
    <method name="parse" return="com.google.common.net.MediaType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses a media type from its string representation.

 @throws IllegalArgumentException if the input is not parsable]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the string representation of this media type in the format described in <a
 href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.]]>
      </doc>
    </method>
    <field name="ANY_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_TEXT_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_IMAGE_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_AUDIO_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_VIDEO_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_APPLICATION_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ANY_FONT_TYPE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wildcard matching any "font" top-level media type.

 @since 30.0]]>
      </doc>
    </field>
    <field name="CACHE_MANIFEST_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CSS_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CSV_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HTML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="I_CALENDAR_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MD_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in <a href="https://www.rfc-editor.org/rfc/rfc7763.html">RFC 7763</a>, this
 constant ({@code text/markdown}) is used for Markdown documents.

 @since 33.3.0]]>
      </doc>
    </field>
    <field name="PLAIN_TEXT_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TEXT_JAVASCRIPT_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://www.rfc-editor.org/rfc/rfc4329.txt">RFC 4329</a> declares {@link
 #JAVASCRIPT_UTF_8 application/javascript} to be the correct media type for JavaScript, but this
 may be necessary in certain situations for compatibility.]]>
      </doc>
    </field>
    <field name="TSV_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://www.iana.org/assignments/media-types/text/tab-separated-values">Tab separated
 values</a>.

 @since 15.0]]>
      </doc>
    </field>
    <field name="VCARD_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[UTF-8 encoded <a href="https://en.wikipedia.org/wiki/Wireless_Markup_Language">Wireless Markup
 Language</a>.

 @since 13.0]]>
      </doc>
    </field>
    <field name="XML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in <a href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023</a>, this constant
 ({@code text/xml}) is used for XML documents that are "readable by casual users." {@link
 #APPLICATION_XML_UTF_8} is provided for documents that are intended for applications.]]>
      </doc>
    </field>
    <field name="VTT_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in <a href="https://w3c.github.io/webvtt/#iana-text-vtt">the VTT spec</a>, this is
 used for Web Video Text Tracks (WebVTT) files, used with the HTML5 track element.

 @since 20.0]]>
      </doc>
    </field>
    <field name="BMP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://en.wikipedia.org/wiki/BMP_file_format">Bitmap file format</a> ({@code bmp}
 files).

 @since 13.0]]>
      </doc>
    </field>
    <field name="CRW" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <a href="https://en.wikipedia.org/wiki/Camera_Image_File_Format">Canon Image File
 Format</a> ({@code crw} files), a widely-used "raw image" format for cameras. It is found in
 {@code /etc/mime.types}, e.g. in <a href=
 "http://anonscm.debian.org/gitweb/?p=collab-maint/mime-support.git;a=blob;f=mime.types;hb=HEAD"
 >Debian 3.48-1</a>.

 @since 15.0]]>
      </doc>
    </field>
    <field name="GIF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ICO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JPEG" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PNG" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PSD" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Photoshop File Format ({@code psd} files) as defined by <a
 href="http://www.iana.org/assignments/media-types/image/vnd.adobe.photoshop">IANA</a>, and
 found in {@code /etc/mime.types}, e.g. <a
 href="http://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/conf/mime.types"></a> of the
 Apache <a href="http://httpd.apache.org/">HTTPD project</a>; for the specification, see <a
 href="http://www.adobe.com/devnet-apps/photoshop/fileformatashtml/PhotoshopFileFormats.htm">
 Adobe Photoshop Document Format</a> and <a
 href="http://en.wikipedia.org/wiki/Adobe_Photoshop#File_format">Wikipedia</a>; this is the
 regular output/input of Photoshop (which can also export to various image formats; note that
 files with extension "PSB" are in a distinct but related format).

 <p>This is a more recent replacement for the older, experimental type {@code x-photoshop}: <a
 href="http://tools.ietf.org/html/rfc2046#section-6">RFC-2046.6</a>.

 @since 15.0]]>
      </doc>
    </field>
    <field name="SVG_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TIFF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AVIF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://en.wikipedia.org/wiki/AVIF">AVIF image format</a>.

 @since NEXT]]>
      </doc>
    </field>
    <field name="WEBP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://en.wikipedia.org/wiki/WebP">WebP image format</a>.

 @since 13.0]]>
      </doc>
    </field>
    <field name="HEIF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://www.iana.org/assignments/media-types/image/heif">HEIF image format</a>.

 @since 28.1]]>
      </doc>
    </field>
    <field name="JP2K" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://tools.ietf.org/html/rfc3745">JP2K image format</a>.

 @since 28.1]]>
      </doc>
    </field>
    <field name="MP4_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MPEG_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OGG_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WEBM_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="L16_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[L16 audio, as defined by <a href="https://tools.ietf.org/html/rfc2586">RFC 2586</a>.

 @since 24.1]]>
      </doc>
    </field>
    <field name="L24_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[L24 audio, as defined by <a href="https://tools.ietf.org/html/rfc3190">RFC 3190</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="BASIC_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Basic Audio, as defined by <a href="http://tools.ietf.org/html/rfc2046#section-4.3">RFC
 2046</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="AAC_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Advanced Audio Coding. For more information, see <a
 href="https://en.wikipedia.org/wiki/Advanced_Audio_Coding">Advanced Audio Coding</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="VORBIS_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vorbis Audio, as defined by <a href="http://tools.ietf.org/html/rfc5215">RFC 5215</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="WMA_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Windows Media Audio. For more information, see <a
 href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx">file
 name extensions for Windows Media metafiles</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="WAX_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Windows Media metafiles. For more information, see <a
 href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx">file
 name extensions for Windows Media metafiles</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="VND_REAL_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Real Audio. For more information, see <a
 href="http://service.real.com/help/faq/rp8/configrp8win.html">this link</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="VND_WAVE_AUDIO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[WAVE format, as defined by <a href="https://tools.ietf.org/html/rfc2361">RFC 2361</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="MP4_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MPEG_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OGG_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="QUICKTIME" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WEBM_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WMV" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLV_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Flash video. For more information, see <a href=
 "http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7d48.html"
 >this link</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="THREE_GPP_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The 3GP multimedia container format. For more information, see <a
 href="ftp://www.3gpp.org/tsg_sa/TSG_SA/TSGS_23/Docs/PDF/SP-040065.pdf#page=10">3GPP TS
 26.244</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="THREE_GPP2_VIDEO" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The 3G2 multimedia container format. For more information, see <a
 href="http://www.3gpp2.org/Public_html/specs/C.S0050-B_v1.0_070521.pdf#page=16">3GPP2
 C.S0050-B</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="APPLICATION_XML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in <a href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023</a>, this constant
 ({@code application/xml}) is used for XML documents that are "unreadable by casual users."
 {@link #XML_UTF_8} is provided for documents that may be read by users.

 @since 14.0]]>
      </doc>
    </field>
    <field name="ATOM_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BZIP2" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DART_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Files in the <a href="https://www.dartlang.org/articles/embedding-in-html/">dart</a>
 programming language.

 @since 19.0]]>
      </doc>
    </field>
    <field name="APPLE_PASSBOOK" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a
 href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/PassKit_PG/DistributingPasses.html">Apple
 Passbook</a>.

 @since 19.0]]>
      </doc>
    </field>
    <field name="EOT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://en.wikipedia.org/wiki/Embedded_OpenType">Embedded OpenType</a> fonts. This is
 <a href="http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject">registered
 </a> with the IANA.

 @since 17.0]]>
      </doc>
    </field>
    <field name="EPUB" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in the <a href="http://idpf.org/epub">International Digital Publishing Forum</a>
 EPUB is the distribution and interchange format standard for digital publications and
 documents. This media type is defined in the <a
 href="http://www.idpf.org/epub/30/spec/epub30-ocf.html">EPUB Open Container Format</a>
 specification.

 @since 15.0]]>
      </doc>
    </field>
    <field name="FORM_DATA" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KEY_ARCHIVE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in <a href="https://www.rsa.com/rsalabs/node.asp?id=2138">PKCS #12: Personal
 Information Exchange Syntax Standard</a>, PKCS #12 defines an archive file format for storing
 many cryptography objects as a single file.

 @since 15.0]]>
      </doc>
    </field>
    <field name="APPLICATION_BINARY" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is a non-standard media type, but is commonly used in serving hosted binary files as it is
 <a href="http://code.google.com/p/browsersec/wiki/Part2#Survey_of_content_sniffing_behaviors">
 known not to trigger content sniffing in current browsers</a>. It <i>should not</i> be used in
 other situations as it is not specified by any RFC and does not appear in the <a
 href="http://www.iana.org/assignments/media-types">/IANA MIME Media Types</a> list. Consider
 {@link #OCTET_STREAM} for binary data that is not being served to a browser.

 @since 14.0]]>
      </doc>
    </field>
    <field name="CBOR" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in <a href="https://www.rfc-editor.org/rfc/rfc8949.html">RFC 8949</a>, this
 constant ({@code application/cbor}) is used for the Concise Binary Object Representation (CBOR)
 data format.

 @since 33.4.0]]>
      </doc>
    </field>
    <field name="GEO_JSON" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Media type for the <a href="https://tools.ietf.org/html/rfc7946">GeoJSON Format</a>, a
 geospatial data interchange format based on JSON.

 @since 28.0]]>
      </doc>
    </field>
    <field name="GZIP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HAL_JSON" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3">JSON Hypertext
 Application Language (HAL) documents</a>.

 @since 26.0]]>
      </doc>
    </field>
    <field name="JAVASCRIPT_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://www.rfc-editor.org/rfc/rfc4329.txt">RFC 4329</a> declares this to be the
 correct media type for JavaScript, but {@link #TEXT_JAVASCRIPT_UTF_8 text/javascript} may be
 necessary in certain situations for compatibility.]]>
      </doc>
    </field>
    <field name="JOSE" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For <a href="https://tools.ietf.org/html/rfc7515">JWS or JWE objects using the Compact
 Serialization</a>.

 @since 27.1]]>
      </doc>
    </field>
    <field name="JOSE_JSON" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For <a href="https://tools.ietf.org/html/rfc7515">JWS or JWE objects using the JSON
 Serialization</a>.

 @since 27.1]]>
      </doc>
    </field>
    <field name="JSON_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JWT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For <a href="https://tools.ietf.org/html/7519">JWT objects using the compact Serialization</a>.

 @since 32.0.0]]>
      </doc>
    </field>
    <field name="MANIFEST_JSON_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <a href="http://www.w3.org/TR/appmanifest/">Manifest for a web application</a>.

 @since 19.0]]>
      </doc>
    </field>
    <field name="KML" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://www.opengeospatial.org/standards/kml/">OGC KML (Keyhole Markup Language)</a>.]]>
      </doc>
    </field>
    <field name="KMZ" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://www.opengeospatial.org/standards/kml/">OGC KML (Keyhole Markup Language)</a>,
 compressed using the ZIP format into KMZ archives.]]>
      </doc>
    </field>
    <field name="MBOX" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The <a href="https://tools.ietf.org/html/rfc4155">mbox database format</a>.

 @since 13.0]]>
      </doc>
    </field>
    <field name="APPLE_MOBILE_CONFIG" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a
 href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/iPhoneOTAConfiguration/profile-service/profile-service.html">Apple
 over-the-air mobile configuration profiles</a>.

 @since 18.0]]>
      </doc>
    </field>
    <field name="MICROSOFT_EXCEL" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a
 href="https://learn.microsoft.com/en-us/archive/blogs/vsofficedeveloper/office-2007-file-format-mime-types-for-http-content-streaming-2">Microsoft
 Excel</a> spreadsheets.]]>
      </doc>
    </field>
    <field name="MICROSOFT_OUTLOOK" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000379.shtml">Microsoft
 Outlook</a> items.

 @since 27.1]]>
      </doc>
    </field>
    <field name="MICROSOFT_POWERPOINT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a
 href="https://learn.microsoft.com/en-us/archive/blogs/vsofficedeveloper/office-2007-file-format-mime-types-for-http-content-streaming-2">Microsoft
 Powerpoint</a> presentations.]]>
      </doc>
    </field>
    <field name="MICROSOFT_WORD" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a
 href="https://learn.microsoft.com/en-us/archive/blogs/vsofficedeveloper/office-2007-file-format-mime-types-for-http-content-streaming-2">Microsoft
 Word</a> documents.]]>
      </doc>
    </field>
    <field name="MEDIA_PRESENTATION_DESCRIPTION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Media type for <a
 href="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP">Dynamic Adaptive
 Streaming over HTTP (DASH)</a>. This is <a
 href="https://www.iana.org/assignments/media-types/application/dash+xml">registered</a> with
 the IANA.

 @since 28.2]]>
      </doc>
    </field>
    <field name="WASM_APPLICATION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[WASM applications. For more information see <a href="https://webassembly.org/">the Web Assembly
 overview</a>.

 @since 27.0]]>
      </doc>
    </field>
    <field name="NACL_APPLICATION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[NaCl applications. For more information see <a
 href="https://developer.chrome.com/native-client/devguide/coding/application-structure">the
 Developer Guide for Native Client Application Structure</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="NACL_PORTABLE_APPLICATION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[NaCl portable applications. For more information see <a
 href="https://developer.chrome.com/native-client/devguide/coding/application-structure">the
 Developer Guide for Native Client Application Structure</a>.

 @since 20.0]]>
      </doc>
    </field>
    <field name="OCTET_STREAM" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OGG_CONTAINER" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OOXML_DOCUMENT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OOXML_PRESENTATION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OOXML_SHEET" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_GRAPHICS" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_PRESENTATION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_SPREADSHEET" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENDOCUMENT_TEXT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OPENSEARCH_DESCRIPTION_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://tools.ietf.org/id/draft-ellermann-opensearch-01.html">OpenSearch</a>
 Description files are XML files that describe how a website can be used as a search engine by
 consumers (e.g. web browsers).

 @since 28.2]]>
      </doc>
    </field>
    <field name="PDF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POSTSCRIPT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PROTOBUF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://tools.ietf.org/html/draft-rfernando-protocol-buffers-00">Protocol buffers</a>

 @since 15.0]]>
      </doc>
    </field>
    <field name="RDF_XML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://en.wikipedia.org/wiki/RDF/XML">RDF/XML</a> documents, which are XML
 serializations of <a
 href="https://en.wikipedia.org/wiki/Resource_Description_Framework">Resource Description
 Framework</a> graphs.

 @since 14.0]]>
      </doc>
    </field>
    <field name="RTF_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SFNT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://tools.ietf.org/html/rfc8081">RFC 8081</a> declares {@link #FONT_SFNT
 font/sfnt} to be the correct media type for SFNT, but this may be necessary in certain
 situations for compatibility.

 @since 17.0]]>
      </doc>
    </field>
    <field name="SHOCKWAVE_FLASH" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SKETCHUP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code skp} files produced by the 3D Modeling software <a
 href="https://www.sketchup.com/">SketchUp</a>

 @since 13.0]]>
      </doc>
    </field>
    <field name="SOAP_XML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[As described in <a href="http://www.ietf.org/rfc/rfc3902.txt">RFC 3902</a>, this constant
 ({@code application/soap+xml}) is used to identify SOAP 1.2 message envelopes that have been
 serialized with XML 1.0.

 <p>For SOAP 1.1 messages, see {@code XML_UTF_8} per <a
 href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/">W3C Note on Simple Object Access Protocol
 (SOAP) 1.1</a>

 @since 20.0]]>
      </doc>
    </field>
    <field name="TAR" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WOFF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://tools.ietf.org/html/rfc8081">RFC 8081</a> declares {@link #FONT_WOFF
 font/woff} to be the correct media type for WOFF, but this may be necessary in certain
 situations for compatibility.

 @since 17.0]]>
      </doc>
    </field>
    <field name="WOFF2" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://tools.ietf.org/html/rfc8081">RFC 8081</a> declares {@link #FONT_WOFF2
 font/woff2} to be the correct media type for WOFF2, but this may be necessary in certain
 situations for compatibility.

 @since 20.0]]>
      </doc>
    </field>
    <field name="XHTML_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="XRD_UTF_8" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Extensible Resource Descriptors. This is not yet registered with the IANA, but it is specified
 by OASIS in the <a href="http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html">XRD
 definition</a> and implemented in projects such as <a
 href="http://code.google.com/p/webfinger/">WebFinger</a>.

 @since 14.0]]>
      </doc>
    </field>
    <field name="ZIP" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FONT_COLLECTION" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A collection of font outlines as defined by <a href="https://tools.ietf.org/html/rfc8081">RFC
 8081</a>.

 @since 30.0]]>
      </doc>
    </field>
    <field name="FONT_OTF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://en.wikipedia.org/wiki/OpenType">Open Type Font Format</a> (OTF) as defined by
 <a href="https://tools.ietf.org/html/rfc8081">RFC 8081</a>.

 @since 30.0]]>
      </doc>
    </field>
    <field name="FONT_SFNT" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://en.wikipedia.org/wiki/SFNT">Spline or Scalable Font Format</a> (SFNT). <a
 href="https://tools.ietf.org/html/rfc8081">RFC 8081</a> declares this to be the correct media
 type for SFNT, but {@link #SFNT application/font-sfnt} may be necessary in certain situations
 for compatibility.

 @since 30.0]]>
      </doc>
    </field>
    <field name="FONT_TTF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="https://en.wikipedia.org/wiki/TrueType">True Type Font Format</a> (TTF) as defined by
 <a href="https://tools.ietf.org/html/rfc8081">RFC 8081</a>.

 @since 30.0]]>
      </doc>
    </field>
    <field name="FONT_WOFF" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://en.wikipedia.org/wiki/Web_Open_Font_Format">Web Open Font Format</a> (WOFF). <a
 href="https://tools.ietf.org/html/rfc8081">RFC 8081</a> declares this to be the correct media
 type for SFNT, but {@link #WOFF application/font-woff} may be necessary in certain situations
 for compatibility.

 @since 30.0]]>
      </doc>
    </field>
    <field name="FONT_WOFF2" type="com.google.common.net.MediaType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<a href="http://en.wikipedia.org/wiki/Web_Open_Font_Format">Web Open Font Format</a> (WOFF2).
 <a href="https://tools.ietf.org/html/rfc8081">RFC 8081</a> declares this to be the correct
 media type for SFNT, but {@link #WOFF2 application/font-woff2} may be necessary in certain
 situations for compatibility.

 @since 30.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Represents an <a href="http://en.wikipedia.org/wiki/Internet_media_type">Internet Media Type</a>
 (also known as a MIME Type or Content Type). This class also supports the concept of media ranges
 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1">defined by HTTP/1.1</a>.
 As such, the {@code *} character is treated as a wildcard and is used to represent any acceptable
 type or subtype value. A media type may not have wildcard type with a declared subtype. The
 {@code *} character has no special meaning as part of a parameter. All values for type, subtype,
 parameter attributes or parameter values must be valid according to RFCs <a
 href="https://tools.ietf.org/html/rfc2045">2045</a> and <a
 href="https://tools.ietf.org/html/rfc2046">2046</a>.

 <p>All portions of the media type that are case-insensitive (type, subtype, parameter attributes)
 are normalized to lowercase. The value of the {@code charset} parameter is normalized to
 lowercase, but all others are left as-is.

 <p>Note that this specifically does <strong>not</strong> represent the value of the MIME {@code
 Content-Type} header and as such has no support for header-specific considerations such as line
 folding and comments.

 <p>For media types that take a charset the predefined constants default to UTF-8 and have a
 "_UTF_8" suffix. To get a version without a character set, use {@link #withoutParameters}.

 @since 12.0
 @author Gregory Kick]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.MediaType -->
  <!-- start class com.google.common.net.PercentEscaper -->
  <class name="PercentEscaper" extends="com.google.common.escape.UnicodeEscaper"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PercentEscaper" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a percent escaper with the specified safe characters and optional handling of the
 space character.

 <p>Not that it is allowed, but not necessarily desirable to specify {@code %} as a safe
 character. This has the effect of creating an escaper which has no well-defined inverse but it
 can be useful when escaping additional characters.

 @param safeChars a non-null string specifying additional safe characters for this escaper (the
     ranges 0..9, a..z and A..Z are always safe and should not be specified here)
 @param plusForSpace true if ASCII space should be escaped to {@code +} rather than {@code %20}
 @throws IllegalArgumentException if any of the parameters were invalid]]>
      </doc>
    </constructor>
    <method name="nextEscapeIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="escape" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Escapes the given Unicode code point in UTF-8.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code UnicodeEscaper} that escapes some set of Java characters using a UTF-8 based percent
 encoding scheme. The set of safe characters (those which remain unescaped) can be specified on
 construction.

 <p>This class is primarily used for creating URI escapers in {@link UrlEscapers} but can be used
 directly if required. While URI escapers impose specific semantics on which characters are
 considered 'safe', this class has a minimal set of restrictions.

 <p>When escaping a String, the following rules apply:

 <ul>
   <li>All specified safe characters remain unchanged.
   <li>If {@code plusForSpace} was specified, the space character " " is converted into a plus
       sign {@code "+"}.
   <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
       byte is then represented by the 3-character string "%XX", where "XX" is the two-digit,
       uppercase, hexadecimal representation of the byte value.
 </ul>

 <p>For performance reasons the only currently supported character encoding of this class is
 UTF-8.

 <p><b>Note:</b> This escaper produces <a
 href="https://url.spec.whatwg.org/#percent-encode">uppercase</a> hexadecimal sequences.

 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.PercentEscaper -->
  <!-- start class com.google.common.net.UrlEscapers -->
  <class name="UrlEscapers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="urlFormParameterEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Escaper} instance that escapes strings so they can be safely included in <a
 href="https://url.spec.whatwg.org/#application-x-www-form-urlencoded-percent-encode-set">URL
 form parameter names and values</a>. Escaping is performed with the UTF-8 character encoding.
 The caller is responsible for <a
 href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#multipart-form-data">replacing
 any unpaired carriage return or line feed characters with a CR+LF pair</a> on any non-file
 inputs before escaping them with this escaper.

 <p>When escaping a String, the following rules apply:

 <ul>
   <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain
       the same.
   <li>The special characters ".", "-", "*", and "_" remain the same.
   <li>The space character " " is converted into a plus sign "+".
   <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
       byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
       uppercase, hexadecimal representation of the byte value.
 </ul>

 <p>This escaper is suitable for escaping parameter names and values even when <a
 href="https://www.w3.org/TR/html401/appendix/notes.html#h-B.2.2">using the non-standard
 semicolon</a>, rather than the ampersand, as a parameter delimiter. Nevertheless, we recommend
 using the ampersand unless you must interoperate with systems that require semicolons.

 <p><b>Note:</b> Unlike other escapers, URL escapers produce <a
 href="https://url.spec.whatwg.org/#percent-encode">uppercase</a> hexadecimal sequences.]]>
      </doc>
    </method>
    <method name="urlPathSegmentEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Escaper} instance that escapes strings so they can be safely included in <a
 href="https://url.spec.whatwg.org/#syntax-url-path-segment">URL path segments</a>. The returned
 escaper escapes all non-ASCII characters, even though <a
 href="https://url.spec.whatwg.org/#url-code-points">many of these are accepted in modern
 URLs</a>. (<a href="https://url.spec.whatwg.org/#path-state">If the escaper were to leave these
 characters unescaped, they would be escaped by the consumer at parse time, anyway.</a>)
 Additionally, the escaper escapes the slash character ("/"). While slashes are acceptable in
 URL paths, they are considered by the specification to be separators between "path segments."
 This implies that, if you wish for your path to contain slashes, you must escape each segment
 separately and then join them.

 <p>When escaping a String, the following rules apply:

 <ul>
   <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain
       the same.
   <li>The unreserved characters ".", "-", "~", and "_" remain the same.
   <li>The general delimiters "@" and ":" remain the same.
   <li>The subdelimiters "!", "$", "&amp;", "'", "(", ")", "*", "+", ",", ";", and "=" remain
       the same.
   <li>The space character " " is converted into %20.
   <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
       byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
       uppercase, hexadecimal representation of the byte value.
 </ul>

 <p><b>Note:</b> Unlike other escapers, URL escapers produce <a
 href="https://url.spec.whatwg.org/#percent-encode">uppercase</a> hexadecimal sequences.]]>
      </doc>
    </method>
    <method name="urlFragmentEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Escaper} instance that escapes strings so they can be safely included in a <a
 href="https://url.spec.whatwg.org/#concept-url-fragment">URL fragment</a>. The returned escaper
 escapes all non-ASCII characters.

 <p>When escaping a String, the following rules apply:

 <ul>
   <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain
       the same.
   <li>The unreserved characters ".", "-", "~", and "_" remain the same.
   <li>The general delimiters "@" and ":" remain the same.
   <li>The subdelimiters "!", "$", "&amp;", "'", "(", ")", "*", "+", ",", ";", and "=" remain
       the same.
   <li>The space character " " is converted into %20.
   <li>Fragments allow unescaped "/" and "?", so they remain the same.
   <li>All other characters are converted into one or more bytes using UTF-8 encoding and each
       byte is then represented by the 3-character string "%XY", where "XY" is the two-digit,
       uppercase, hexadecimal representation of the byte value.
 </ul>

 <p><b>Note:</b> Unlike other escapers, URL escapers produce <a
 href="https://url.spec.whatwg.org/#percent-encode">uppercase</a> hexadecimal sequences.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[{@code Escaper} instances suitable for strings to be included in particular sections of URLs.

 <p>If the resulting URLs are inserted into an HTML or XML document, they will require additional
 escaping with {@link com.google.common.html.HtmlEscapers} or {@link
 com.google.common.xml.XmlEscapers}.

 @author David Beaumont
 @author Chris Povirk
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.net.UrlEscapers -->
</package>
<package name="com.google.common.primitives">
  <!-- start class com.google.common.primitives.Booleans -->
  <class name="Booleans" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="trueFirst" return="java.util.Comparator&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code Comparator<Boolean>} that sorts {@code true} before {@code false}.

 <p>This is particularly useful in Java 8+ in combination with {@code Comparator.comparing},
 e.g. {@code Comparator.comparing(Foo::hasBar, trueFirst())}.

 @since 21.0]]>
      </doc>
    </method>
    <method name="falseFirst" return="java.util.Comparator&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@code Comparator<Boolean>} that sorts {@code false} before {@code true}.

 <p>This is particularly useful in Java 8+ in combination with {@code Comparator.comparing},
 e.g. {@code Comparator.comparing(Foo::hasBar, falseFirst())}.

 @since 21.0]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link
 Boolean#hashCode(boolean)}.

 @param value a primitive {@code boolean} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="boolean"/>
      <param name="b" type="boolean"/>
      <doc>
      <![CDATA[Compares the two specified {@code boolean} values in the standard way ({@code false} is
 considered less than {@code true}). The sign of the value returned is the same as that of
 {@code ((Boolean) a).compareTo(b)}.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use the
 equivalent {@link Boolean#compare} method instead.

 @param a the first {@code boolean} to compare
 @param b the second {@code boolean} to compare
 @return a positive number if only {@code a} is {@code true}, a negative number if only {@code
     b} is true, or zero if {@code a == b}]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link java.util.BitSet} instead,
 replacing {@code Booleans.contains(array, true)} with {@code !bitSet.isEmpty()} and {@code
 Booleans.contains(array, false)} with {@code bitSet.nextClearBit(0) == sizeOfBitSet}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}.

 <p><b>Note:</b> consider representing the array as a {@link java.util.BitSet} instead, and
 using {@link java.util.BitSet#nextSetBit(int)} or {@link java.util.BitSet#nextClearBit(int)}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="target" type="boolean"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}.

 @param array an array of {@code boolean} values, possibly empty
 @param target a primitive {@code boolean} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="boolean[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new boolean[] {a, b}, new boolean[] {}, new boolean[] {c}} returns the array {@code {a,
 b, c}}.

 @param arrays zero or more {@code boolean} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code boolean} values separated by {@code separator}.
 For example, {@code join("-", false, true, false)} returns the string {@code
 "false-true-false"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code boolean} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;boolean[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code boolean} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(boolean, boolean)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the shorter array as the
 lesser. For example, {@code [] < [false] < [false, true] < [true]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(boolean[],
 boolean[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="boolean[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Boolean} instances into a new array of primitive {@code boolean}
 values.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 <p><b>Note:</b> consider representing the collection as a {@link java.util.BitSet} instead.

 @param collection a collection of {@code Boolean} objects
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="boolean[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>There are at most two distinct objects in this list, {@code (Boolean) true} and {@code
 (Boolean) false}. Java guarantees that those are always represented by the same objects.

 <p>The returned list is serializable.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <method name="countTrue" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="boolean[]"/>
      <doc>
      <![CDATA[Returns the number of {@code values} that are {@code true}.

 @since 16.0]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Booleans.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Booleans.asList(array).subList(fromIndex, toIndex))}, but is likely to be
 more efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Booleans.asList(array),
 distance)}, but is somewhat faster.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="boolean[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Booleans.asList(array).subList(fromIndex, toIndex), distance)}, but is
 somewhat faster.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code boolean} primitives, that are not already found in
 either {@link Boolean} or {@link Arrays}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Booleans -->
  <!-- start class com.google.common.primitives.Bytes -->
  <class name="Bytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link Byte#hashCode(byte)}.

 @param value a primitive {@code byte} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="target" type="byte"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}.

 @param array an array of {@code byte} values, possibly empty
 @param target a primitive {@code byte} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="concat" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="byte[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new byte[] {a, b}, new byte[] {}, new byte[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code byte} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="toArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to a {@code byte} value
 in the manner of {@link Number#byteValue}.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null
 @since 1.0 (parameter was {@code Collection<Byte>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Byte&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="byte[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of {@code Byte} objects
 written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for
 the returned list is unspecified.

 <p>The returned list is serializable.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Bytes.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Bytes.asList(array).subList(fromIndex, toIndex))}, but is likely to be more
 efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Bytes.asList(array),
 distance)}, but is somewhat faster.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Bytes.asList(array).subList(fromIndex, toIndex), distance)}, but is somewhat
 faster.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives, that are not already found in
 either {@link Byte} or {@link Arrays}, <i>and interpret bytes as neither signed nor unsigned</i>.
 The methods which specifically treat bytes as signed or unsigned are found in {@link SignedBytes}
 and {@link UnsignedBytes}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Bytes -->
  <!-- start class com.google.common.primitives.Chars -->
  <class name="Chars" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link
 Character#hashCode(char)}.

 @param value a primitive {@code char} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code char} type
 @return the {@code char} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link Character#MAX_VALUE}
     or less than {@link Character#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code char} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code char} if it is in the range of the {@code char} type,
     {@link Character#MAX_VALUE} if it is too large, or {@link Character#MIN_VALUE} if it is too
     small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="char"/>
      <param name="b" type="char"/>
      <doc>
      <![CDATA[Compares the two specified {@code char} values. The sign of the value returned is the same as
 that of {@code ((Character) a).compareTo(b)}.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use the
 equivalent {@link Character#compare} method instead.

 @param a the first {@code char} to compare
 @param b the second {@code char} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="target" type="char"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}.

 @param array an array of {@code char} values, possibly empty
 @param target a primitive {@code char} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="min" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code char} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="constrainToRange" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <param name="min" type="char"/>
      <param name="max" type="char"/>
      <doc>
      <![CDATA[Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.

 <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned
 unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code
 value} is greater than {@code max}, {@code max} is returned.

 @param value the {@code char} value to constrain
 @param min the lower bound (inclusive) of the range to constrain {@code value} to
 @param max the upper bound (inclusive) of the range to constrain {@code value} to
 @throws IllegalArgumentException if {@code min > max}
 @since 21.0]]>
      </doc>
    </method>
    <method name="concat" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="char[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new char[] {a, b}, new char[] {}, new char[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code char} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 2-element byte array; equivalent to
 {@code ByteBuffer.allocate(2).putChar(value).array()}. For example, the input value {@code
 '\\u5432'} would yield the byte array {@code {0x54, 0x32}}.

 <p>If you need to convert and concatenate several values (possibly even of different types),
 use a shared {@link java.nio.ByteBuffer} instance, or use {@link
 com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code char} value whose big-endian representation is stored in the first 2 bytes
 of {@code bytes}; equivalent to {@code ByteBuffer.wrap(bytes).getChar()}. For example, the
 input byte array {@code {0x54, 0x32}} would yield the {@code char} value {@code '\\u5432'}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that library exposes much more
 flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 2 elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code char} value whose byte representation is the given 2 bytes, in big-endian
 order; equivalent to {@code Chars.fromByteArray(new byte[] {b1, b2})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code char} values separated by {@code separator}.
 For example, {@code join("-", '1', '2', '3')} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code char} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;char[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code char} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>; not advisable
 for sorting user-visible strings as the ordering may not match the conventions of the user's
 locale. That is, it compares, using {@link #compare(char, char)}), the first pair of values
 that follow any common prefix, or when one array is a prefix of the other, treats the shorter
 array as the lesser. For example, {@code [] < ['a'] < ['a', 'b'] < ['b']}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(char[],
 char[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="toArray" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;java.lang.Character&gt;"/>
      <doc>
      <![CDATA[Copies a collection of {@code Character} instances into a new array of primitive {@code char}
 values.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 @param collection a collection of {@code Character} objects
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Chars.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Chars.asList(array).subList(fromIndex, toIndex))}, but is likely to be more
 efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Chars.asList(array),
 distance)}, but is considerably faster and avoids allocation and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Chars.asList(array).subList(fromIndex, toIndex), distance)}, but is
 considerably faster and avoids allocations and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Character&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="char[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of {@code Character} objects
 written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for
 the returned list is unspecified.

 <p>The returned list is serializable.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code char} value.

 <p>Prefer {@link Character#BYTES} instead.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code char} primitives, that are not already found in
 either {@link Character} or {@link Arrays}.

 <p>All the operations in this class treat {@code char} values strictly numerically; they are
 neither Unicode-aware nor locale-dependent.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Chars -->
  <!-- start class com.google.common.primitives.Doubles -->
  <class name="Doubles" extends="com.google.common.primitives.DoublesMethodsForWeb"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link Double#hashCode(double)}.

 @param value a primitive {@code double} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="double"/>
      <param name="b" type="double"/>
      <doc>
      <![CDATA[Compares the two specified {@code double} values. The sign of the value returned is the same as
 that of <code>((Double) a).{@linkplain Double#compareTo compareTo}(b)</code>. As with that
 method, {@code NaN} is treated as greater than all other values, and {@code 0.0 > -0.0}.

 <p><b>Note:</b> this method simply delegates to the JDK method {@link Double#compare}. It is
 provided for consistency with the other primitive types, whose compare methods were not added
 to the JDK until JDK 7.

 @param a the first {@code double} to compare
 @param b the second {@code double} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="isFinite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code value} represents a real number. This is equivalent to, but not
 necessarily implemented as, {@code !(Double.isInfinite(value) || Double.isNaN(value))}.

 <p>Prefer {@link Double#isFinite(double)} instead.

 @since 10.0]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}. Note
 that this always returns {@code false} when {@code target} is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}. Note
 that this always returns {@code -1} when {@code target} is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}. Note
 that this always returns {@code -1} when {@code target} is {@code NaN}.

 @param array an array of {@code double} values, possibly empty
 @param target a primitive {@code double} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="min" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of comparison as {@link
 Math#min(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules of comparison as
 {@link Math#max(double, double)}.

 @param array a <i>nonempty</i> array of {@code double} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="constrainToRange" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <param name="min" type="double"/>
      <param name="max" type="double"/>
      <doc>
      <![CDATA[Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.

 <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned
 unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code
 value} is greater than {@code max}, {@code max} is returned.

 <p><b>Java 21+ users:</b> Use {@code Math.clamp} instead.

 @param value the {@code double} value to constrain
 @param min the lower bound (inclusive) of the range to constrain {@code value} to
 @param max the upper bound (inclusive) of the range to constrain {@code value} to
 @throws IllegalArgumentException if {@code min > max}
 @since 21.0]]>
      </doc>
    </method>
    <method name="concat" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="double[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new double[] {a, b}, new double[] {}, new double[] {c}} returns the array {@code {a, b,
 c}}.

 @param arrays zero or more {@code double} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="stringConverter" return="com.google.common.base.Converter&lt;java.lang.String, java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable converter object that converts between strings and doubles using {@link
 Double#valueOf} and {@link Double#toString()}.

 @since 16.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code double} values, converted to strings as
 specified by {@link Double#toString(double)}, and separated by {@code separator}. For example,
 {@code join("-", 1.0, 2.0, 3.0)} returns the string {@code "1.0-2.0-3.0"}.

 <p>Note that {@link Double#toString(double)} formats {@code double} differently in GWT
 sometimes. In the previous example, it returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code double} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;double[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code double} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(double, double)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the shorter array as the
 lesser. For example, {@code [] < [1.0] < [1.0, 2.0] < [2.0]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(double[],
 double[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order.

 <p>Note that this method uses the total order imposed by {@link Double#compare}, which treats
 all NaN values as equal and 0.0 as greater than -0.0.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order.

 <p>Note that this method uses the total order imposed by {@link Double#compare}, which treats
 all NaN values as equal and 0.0 as greater than -0.0.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Doubles.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Doubles.asList(array).subList(fromIndex, toIndex))}, but is likely to be
 more efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Bytes.asList(array),
 distance)}, but is considerably faster and avoids allocation and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Bytes.asList(array).subList(fromIndex, toIndex), distance)}, but is
 considerably faster and avoids allocations and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <method name="toArray" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to a {@code double}
 value in the manner of {@link Number#doubleValue}.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null
 @since 1.0 (parameter was {@code Collection<Double>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="double[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of {@code Double} objects
 written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for
 the returned list is unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code NaN}, or if {@code NaN}
 is used as a parameter to any of its methods.

 <p>The returned list is serializable.

 <p><b>Note:</b> when possible, you should represent your data as an {@link
 ImmutableDoubleArray} instead, which has an {@link ImmutableDoubleArray#asList asList} view.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <method name="tryParse" return="Double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the specified string as a double-precision floating point value. The ASCII character
 {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.

 <p>Unlike {@link Double#parseDouble(String)}, this method returns {@code null} instead of
 throwing an exception if parsing fails. Valid inputs are exactly those accepted by {@link
 Double#valueOf(String)}, except that leading and trailing whitespace is not permitted.

 <p>This implementation is likely to be faster than {@code Double.parseDouble} if many failures
 are expected.

 @param string the string representation of a {@code double} value
 @return the floating point value represented by {@code string}, or {@code null} if {@code
     string} has a length of zero or cannot be parsed as a {@code double} value
 @throws NullPointerException if {@code string} is {@code null}
 @since 14.0]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code double} value.

 <p>Prefer {@link Double#BYTES} instead.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code double} primitives, that are not already found in
 either {@link Double} or {@link Arrays}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Doubles -->
  <!-- start class com.google.common.primitives.Floats -->
  <class name="Floats" extends="com.google.common.primitives.FloatsMethodsForWeb"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link Float#hashCode(float)}.

 @param value a primitive {@code float} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="float"/>
      <param name="b" type="float"/>
      <doc>
      <![CDATA[Compares the two specified {@code float} values using {@link Float#compare(float, float)}. You
 may prefer to invoke that method directly; this method exists only for consistency with the
 other utilities in this package.

 <p><b>Note:</b> this method simply delegates to the JDK method {@link Float#compare}. It is
 provided for consistency with the other primitive types, whose compare methods were not added
 to the JDK until JDK 7.

 @param a the first {@code float} to compare
 @param b the second {@code float} to compare
 @return the result of invoking {@link Float#compare(float, float)}]]>
      </doc>
    </method>
    <method name="isFinite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code value} represents a real number. This is equivalent to, but not
 necessarily implemented as, {@code !(Float.isInfinite(value) || Float.isNaN(value))}.

 <p>Prefer {@link Float#isFinite(float)} instead.

 @since 10.0]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}. Note
 that this always returns {@code false} when {@code target} is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}. Note
 that this always returns {@code -1} when {@code target} is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 <p>Note that this always returns {@code -1} when {@code target} contains {@code NaN}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="target" type="float"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}. Note
 that this always returns {@code -1} when {@code target} is {@code NaN}.

 @param array an array of {@code float} values, possibly empty
 @param target a primitive {@code float} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="min" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, using the same rules of comparison as {@link
 Math#min(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, using the same rules of comparison as
 {@link Math#max(float, float)}.

 @param array a <i>nonempty</i> array of {@code float} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="constrainToRange" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <param name="min" type="float"/>
      <param name="max" type="float"/>
      <doc>
      <![CDATA[Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.

 <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned
 unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code
 value} is greater than {@code max}, {@code max} is returned.

 <p><b>Java 21+ users:</b> Use {@code Math.clamp} instead.

 @param value the {@code float} value to constrain
 @param min the lower bound (inclusive) of the range to constrain {@code value} to
 @param max the upper bound (inclusive) of the range to constrain {@code value} to
 @throws IllegalArgumentException if {@code min > max}
 @since 21.0]]>
      </doc>
    </method>
    <method name="concat" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="float[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new float[] {a, b}, new float[] {}, new float[] {c}} returns the array {@code {a, b,
 c}}.

 @param arrays zero or more {@code float} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="stringConverter" return="com.google.common.base.Converter&lt;java.lang.String, java.lang.Float&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable converter object that converts between strings and floats using {@link
 Float#valueOf} and {@link Float#toString()}.

 @since 16.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code float} values, converted to strings as
 specified by {@link Float#toString(float)}, and separated by {@code separator}. For example,
 {@code join("-", 1.0f, 2.0f, 3.0f)} returns the string {@code "1.0-2.0-3.0"}.

 <p>Note that {@link Float#toString(float)} formats {@code float} differently in GWT. In the
 previous example, it returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code float} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;float[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code float} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(float, float)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the shorter array as the
 lesser. For example, {@code [] < [1.0f] < [1.0f, 2.0f] < [2.0f]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(float[],
 float[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order.

 <p>Note that this method uses the total order imposed by {@link Float#compare}, which treats
 all NaN values as equal and 0.0 as greater than -0.0.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order.

 <p>Note that this method uses the total order imposed by {@link Float#compare}, which treats
 all NaN values as equal and 0.0 as greater than -0.0.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Floats.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Floats.asList(array).subList(fromIndex, toIndex))}, but is likely to be
 more efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Floats.asList(array),
 distance)}, but is considerably faster and avoids allocation and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="float[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Floats.asList(array).subList(fromIndex, toIndex), distance)}, but is
 considerably faster and avoids allocations and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <method name="toArray" return="float[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to a {@code float}
 value in the manner of {@link Number#floatValue}.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null
 @since 1.0 (parameter was {@code Collection<Float>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Float&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="float[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of {@code Float} objects
 written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for
 the returned list is unspecified.

 <p>The returned list may have unexpected behavior if it contains {@code NaN}, or if {@code NaN}
 is used as a parameter to any of its methods.

 <p>The returned list is serializable.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <method name="tryParse" return="Float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the specified string as a single-precision floating point value. The ASCII character
 {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.

 <p>Unlike {@link Float#parseFloat(String)}, this method returns {@code null} instead of
 throwing an exception if parsing fails. Valid inputs are exactly those accepted by {@link
 Float#valueOf(String)}, except that leading and trailing whitespace is not permitted.

 <p>This implementation is likely to be faster than {@code Float.parseFloat} if many failures
 are expected.

 @param string the string representation of a {@code float} value
 @return the floating point value represented by {@code string}, or {@code null} if {@code
     string} has a length of zero or cannot be parsed as a {@code float} value
 @throws NullPointerException if {@code string} is {@code null}
 @since 14.0]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code float} value.

 <p>Prefer {@link Float#BYTES} instead.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code float} primitives, that are not already found in
 either {@link Float} or {@link Arrays}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Floats -->
  <!-- start class com.google.common.primitives.ImmutableDoubleArray -->
  <class name="ImmutableDoubleArray" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty array.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="double"/>
      <doc>
      <![CDATA[Returns an immutable array containing a single value.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="double"/>
      <param name="e1" type="double"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="double"/>
      <param name="e1" type="double"/>
      <param name="e2" type="double"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="double"/>
      <param name="e1" type="double"/>
      <param name="e2" type="double"/>
      <param name="e3" type="double"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="double"/>
      <param name="e1" type="double"/>
      <param name="e2" type="double"/>
      <param name="e3" type="double"/>
      <param name="e4" type="double"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="double"/>
      <param name="e1" type="double"/>
      <param name="e2" type="double"/>
      <param name="e3" type="double"/>
      <param name="e4" type="double"/>
      <param name="e5" type="double"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="double"/>
      <param name="rest" type="double[]"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.

 <p>The array {@code rest} must not be longer than {@code Integer.MAX_VALUE - 1}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="double[]"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Collection&lt;java.lang.Double&gt;"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;java.lang.Double&gt;"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.

 <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code
 values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link
 Builder#addAll(Iterable)}, with all the performance implications associated with that.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.DoubleStream"/>
      <doc>
      <![CDATA[Returns an immutable array containing all the values from {@code stream}, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Returns a new, empty builder for {@link ImmutableDoubleArray} instances, sized to hold up to
 {@code initialCapacity} values without resizing. The returned builder is not thread-safe.

 <p><b>Performance note:</b> When feasible, {@code initialCapacity} should be the exact number
 of values that will be added, if that knowledge is readily available. It is better to guess a
 value slightly too high than slightly too low. If the value is not exact, the {@link
 ImmutableDoubleArray} that is built will very likely occupy more memory than strictly
 necessary; to trim memory usage, build using {@code builder.build().trimmed()}.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty builder for {@link ImmutableDoubleArray} instances, with a default initial
 capacity. The returned builder is not thread-safe.

 <p><b>Performance note:</b> The {@link ImmutableDoubleArray} that is built will very likely
 occupy more memory than necessary; to trim memory usage, build using {@code
 builder.build().trimmed()}.]]>
      </doc>
    </method>
    <method name="length" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of values in this array.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there are no values in this array ({@link #length} is zero).]]>
      </doc>
    </method>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the {@code double} value present at the given index.

 @throws IndexOutOfBoundsException if {@code index} is negative, or greater than or equal to
     {@link #length}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no
 such index exists. Values are compared as if by {@link Double#equals}. Equivalent to {@code
 asList().indexOf(target)}.]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no
 such index exists. Values are compared as if by {@link Double#equals}. Equivalent to {@code
 asList().lastIndexOf(target)}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="double"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present at any index in this array. Values are
 compared as if by {@link Double#equals}. Equivalent to {@code asList().contains(target)}.]]>
      </doc>
    </method>
    <method name="forEach"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.DoubleConsumer"/>
      <doc>
      <![CDATA[Invokes {@code consumer} for each value contained in this array, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.DoubleStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a stream over the values in this array, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toArray" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, mutable copy of this array's values, as a primitive {@code double[]}.]]>
      </doc>
    </method>
    <method name="subArray" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[Returns a new immutable array containing the values in the specified range.

 <p><b>Performance note:</b> The returned array has the same full memory footprint as this one
 does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,
 end).trimmed()}.]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code
 double} values are boxed into {@link Double} instances on demand, which can be very expensive.
 The returned list should be used once and discarded. For any usages beyond that, pass the
 returned list to {@link com.google.common.collect.ImmutableList#copyOf(Collection)
 ImmutableList.copyOf} and use that list instead.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is an {@code ImmutableDoubleArray} containing the same
 values as this one, in the same order. Values are compared as if by {@link Double#equals}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unspecified hash code for the contents of this immutable array.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this array in the same form as {@link
 Arrays#toString(double[])}, for example {@code "[1, 2, 3]"}.]]>
      </doc>
    </method>
    <method name="trimmed" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable array containing the same values as {@code this} array. This is logically
 a no-op, and in some circumstances {@code this} itself is returned. However, if this instance
 is a {@link #subArray} view of a larger array, this method will copy only the appropriate range
 of values, resulting in an equivalent array with a smaller memory footprint.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable array of {@code double} values, with an API resembling {@link List}.

 <p>Advantages compared to {@code double[]}:

 <ul>
   <li>All the many well-known advantages of immutability (read <i>Effective Java</i>, third
       edition, Item 17).
   <li>Has the value-based (not identity-based) {@link #equals}, {@link #hashCode}, and {@link
       #toString} behavior you expect.
   <li>Offers useful operations beyond just {@code get} and {@code length}, so you don't have to
       hunt through classes like {@link Arrays} and {@link Doubles} for them.
   <li>Supports a copy-free {@link #subArray} view, so methods that accept this type don't need to
       add overloads that accept start and end indexes.
   <li>Can be streamed without "breaking the chain": {@code foo.getBarDoubles().stream()...}.
   <li>Access to all collection-based utilities via {@link #asList} (though at the cost of
       allocating garbage).
 </ul>

 <p>Disadvantages compared to {@code double[]}:

 <ul>
   <li>Memory footprint has a fixed overhead (about 24 bytes per instance).
   <li><i>Some</i> construction use cases force the data to be copied (though several construction
       APIs are offered that don't).
   <li>Can't be passed directly to methods that expect {@code double[]} (though the most common
       utilities do have replacements here).
   <li>Dependency on {@code com.google.common} / Guava.
 </ul>

 <p>Advantages compared to {@link com.google.common.collect.ImmutableList ImmutableList}{@code
 <Double>}:

 <ul>
   <li>Improved memory compactness and locality.
   <li>Can be queried without allocating garbage.
   <li>Access to {@code DoubleStream} features (like {@link DoubleStream#sum}) using {@code
       stream()} instead of the awkward {@code stream().mapToDouble(v -> v)}.
 </ul>

 <p>Disadvantages compared to {@code ImmutableList<Double>}:

 <ul>
   <li>Can't be passed directly to methods that expect {@code Iterable}, {@code Collection}, or
       {@code List} (though the most common utilities do have replacements here, and there is a
       lazy {@link #asList} view).
 </ul>

 @since 22.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.ImmutableDoubleArray -->
  <!-- start class com.google.common.primitives.ImmutableDoubleArray.Builder -->
  <class name="ImmutableDoubleArray.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="add" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Appends {@code value} to the end of the values the built {@link ImmutableDoubleArray} will
 contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="double[]"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableDoubleArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;java.lang.Double&gt;"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableDoubleArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Collection&lt;java.lang.Double&gt;"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableDoubleArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.DoubleStream"/>
      <doc>
      <![CDATA[Appends all values from {@code stream}, in order, to the end of the values the built {@link
 ImmutableDoubleArray} will contain.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableDoubleArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="com.google.common.primitives.ImmutableDoubleArray"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableDoubleArray} will contain.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.primitives.ImmutableDoubleArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable array. The builder can continue to be used after this call, to append
 more values and build again.

 <p><b>Performance note:</b> the returned array is backed by the same array as the builder, so
 no data is copied as part of this step, but this may occupy more memory than strictly
 necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for {@link ImmutableDoubleArray} instances; obtained using {@link
 ImmutableDoubleArray#builder}.]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.ImmutableDoubleArray.Builder -->
  <!-- start class com.google.common.primitives.ImmutableIntArray -->
  <class name="ImmutableIntArray" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty array.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="int"/>
      <doc>
      <![CDATA[Returns an immutable array containing a single value.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="int"/>
      <param name="e1" type="int"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="int"/>
      <param name="e1" type="int"/>
      <param name="e2" type="int"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="int"/>
      <param name="e1" type="int"/>
      <param name="e2" type="int"/>
      <param name="e3" type="int"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="int"/>
      <param name="e1" type="int"/>
      <param name="e2" type="int"/>
      <param name="e3" type="int"/>
      <param name="e4" type="int"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="int"/>
      <param name="e1" type="int"/>
      <param name="e2" type="int"/>
      <param name="e3" type="int"/>
      <param name="e4" type="int"/>
      <param name="e5" type="int"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="int"/>
      <param name="rest" type="int[]"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.

 <p>The array {@code rest} must not be longer than {@code Integer.MAX_VALUE - 1}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="int[]"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Collection&lt;java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.

 <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code
 values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link
 Builder#addAll(Iterable)}, with all the performance implications associated with that.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.IntStream"/>
      <doc>
      <![CDATA[Returns an immutable array containing all the values from {@code stream}, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Returns a new, empty builder for {@link ImmutableIntArray} instances, sized to hold up to
 {@code initialCapacity} values without resizing. The returned builder is not thread-safe.

 <p><b>Performance note:</b> When feasible, {@code initialCapacity} should be the exact number
 of values that will be added, if that knowledge is readily available. It is better to guess a
 value slightly too high than slightly too low. If the value is not exact, the {@link
 ImmutableIntArray} that is built will very likely occupy more memory than strictly necessary;
 to trim memory usage, build using {@code builder.build().trimmed()}.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty builder for {@link ImmutableIntArray} instances, with a default initial
 capacity. The returned builder is not thread-safe.

 <p><b>Performance note:</b> The {@link ImmutableIntArray} that is built will very likely occupy
 more memory than necessary; to trim memory usage, build using {@code
 builder.build().trimmed()}.]]>
      </doc>
    </method>
    <method name="length" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of values in this array.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there are no values in this array ({@link #length} is zero).]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the {@code int} value present at the given index.

 @throws IndexOutOfBoundsException if {@code index} is negative, or greater than or equal to
     {@link #length}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no
 such index exists. Equivalent to {@code asList().indexOf(target)}.]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no
 such index exists. Equivalent to {@code asList().lastIndexOf(target)}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present at any index in this array. Equivalent to
 {@code asList().contains(target)}.]]>
      </doc>
    </method>
    <method name="forEach"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.IntConsumer"/>
      <doc>
      <![CDATA[Invokes {@code consumer} for each value contained in this array, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.IntStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a stream over the values in this array, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toArray" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, mutable copy of this array's values, as a primitive {@code int[]}.]]>
      </doc>
    </method>
    <method name="subArray" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[Returns a new immutable array containing the values in the specified range.

 <p><b>Performance note:</b> The returned array has the same full memory footprint as this one
 does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,
 end).trimmed()}.]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code
 int} values are boxed into {@link Integer} instances on demand, which can be very expensive.
 The returned list should be used once and discarded. For any usages beyond that, pass the
 returned list to {@link com.google.common.collect.ImmutableList#copyOf(Collection)
 ImmutableList.copyOf} and use that list instead.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is an {@code ImmutableIntArray} containing the same
 values as this one, in the same order.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unspecified hash code for the contents of this immutable array.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this array in the same form as {@link
 Arrays#toString(int[])}, for example {@code "[1, 2, 3]"}.]]>
      </doc>
    </method>
    <method name="trimmed" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable array containing the same values as {@code this} array. This is logically
 a no-op, and in some circumstances {@code this} itself is returned. However, if this instance
 is a {@link #subArray} view of a larger array, this method will copy only the appropriate range
 of values, resulting in an equivalent array with a smaller memory footprint.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable array of {@code int} values, with an API resembling {@link List}.

 <p>Advantages compared to {@code int[]}:

 <ul>
   <li>All the many well-known advantages of immutability (read <i>Effective Java</i>, third
       edition, Item 17).
   <li>Has the value-based (not identity-based) {@link #equals}, {@link #hashCode}, and {@link
       #toString} behavior you expect.
   <li>Offers useful operations beyond just {@code get} and {@code length}, so you don't have to
       hunt through classes like {@link Arrays} and {@link Ints} for them.
   <li>Supports a copy-free {@link #subArray} view, so methods that accept this type don't need to
       add overloads that accept start and end indexes.
   <li>Can be streamed without "breaking the chain": {@code foo.getBarInts().stream()...}.
   <li>Access to all collection-based utilities via {@link #asList} (though at the cost of
       allocating garbage).
 </ul>

 <p>Disadvantages compared to {@code int[]}:

 <ul>
   <li>Memory footprint has a fixed overhead (about 24 bytes per instance).
   <li><i>Some</i> construction use cases force the data to be copied (though several construction
       APIs are offered that don't).
   <li>Can't be passed directly to methods that expect {@code int[]} (though the most common
       utilities do have replacements here).
   <li>Dependency on {@code com.google.common} / Guava.
 </ul>

 <p>Advantages compared to {@link com.google.common.collect.ImmutableList ImmutableList}{@code
 <Integer>}:

 <ul>
   <li>Improved memory compactness and locality.
   <li>Can be queried without allocating garbage.
   <li>Access to {@code IntStream} features (like {@link IntStream#sum}) using {@code stream()}
       instead of the awkward {@code stream().mapToInt(v -> v)}.
 </ul>

 <p>Disadvantages compared to {@code ImmutableList<Integer>}:

 <ul>
   <li>Can't be passed directly to methods that expect {@code Iterable}, {@code Collection}, or
       {@code List} (though the most common utilities do have replacements here, and there is a
       lazy {@link #asList} view).
 </ul>

 @since 22.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.ImmutableIntArray -->
  <!-- start class com.google.common.primitives.ImmutableIntArray.Builder -->
  <class name="ImmutableIntArray.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="add" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Appends {@code value} to the end of the values the built {@link ImmutableIntArray} will
 contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="int[]"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableIntArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableIntArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Collection&lt;java.lang.Integer&gt;"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableIntArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.IntStream"/>
      <doc>
      <![CDATA[Appends all values from {@code stream}, in order, to the end of the values the built {@link
 ImmutableIntArray} will contain.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableIntArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="com.google.common.primitives.ImmutableIntArray"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableIntArray} will contain.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.primitives.ImmutableIntArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable array. The builder can continue to be used after this call, to append
 more values and build again.

 <p><b>Performance note:</b> the returned array is backed by the same array as the builder, so
 no data is copied as part of this step, but this may occupy more memory than strictly
 necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for {@link ImmutableIntArray} instances; obtained using {@link
 ImmutableIntArray#builder}.]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.ImmutableIntArray.Builder -->
  <!-- start class com.google.common.primitives.ImmutableLongArray -->
  <class name="ImmutableLongArray" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the empty array.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="long"/>
      <doc>
      <![CDATA[Returns an immutable array containing a single value.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="long"/>
      <param name="e1" type="long"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="long"/>
      <param name="e1" type="long"/>
      <param name="e2" type="long"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="long"/>
      <param name="e1" type="long"/>
      <param name="e2" type="long"/>
      <param name="e3" type="long"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="long"/>
      <param name="e1" type="long"/>
      <param name="e2" type="long"/>
      <param name="e3" type="long"/>
      <param name="e4" type="long"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e0" type="long"/>
      <param name="e1" type="long"/>
      <param name="e2" type="long"/>
      <param name="e3" type="long"/>
      <param name="e4" type="long"/>
      <param name="e5" type="long"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="long"/>
      <param name="rest" type="long[]"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.

 <p>The array {@code rest} must not be longer than {@code Integer.MAX_VALUE - 1}.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="long[]"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Collection&lt;java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Returns an immutable array containing the given values, in order.

 <p><b>Performance note:</b> this method delegates to {@link #copyOf(Collection)} if {@code
 values} is a {@link Collection}. Otherwise it creates a {@link #builder} and uses {@link
 Builder#addAll(Iterable)}, with all the performance implications associated with that.]]>
      </doc>
    </method>
    <method name="copyOf" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.LongStream"/>
      <doc>
      <![CDATA[Returns an immutable array containing all the values from {@code stream}, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Returns a new, empty builder for {@link ImmutableLongArray} instances, sized to hold up to
 {@code initialCapacity} values without resizing. The returned builder is not thread-safe.

 <p><b>Performance note:</b> When feasible, {@code initialCapacity} should be the exact number
 of values that will be added, if that knowledge is readily available. It is better to guess a
 value slightly too high than slightly too low. If the value is not exact, the {@link
 ImmutableLongArray} that is built will very likely occupy more memory than strictly necessary;
 to trim memory usage, build using {@code builder.build().trimmed()}.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, empty builder for {@link ImmutableLongArray} instances, with a default initial
 capacity. The returned builder is not thread-safe.

 <p><b>Performance note:</b> The {@link ImmutableLongArray} that is built will very likely
 occupy more memory than necessary; to trim memory usage, build using {@code
 builder.build().trimmed()}.]]>
      </doc>
    </method>
    <method name="length" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of values in this array.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if there are no values in this array ({@link #length} is zero).]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the {@code long} value present at the given index.

 @throws IndexOutOfBoundsException if {@code index} is negative, or greater than or equal to
     {@link #length}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the smallest index for which {@link #get} returns {@code target}, or {@code -1} if no
 such index exists. Equivalent to {@code asList().indexOf(target)}.]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the largest index for which {@link #get} returns {@code target}, or {@code -1} if no
 such index exists. Equivalent to {@code asList().lastIndexOf(target)}.]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present at any index in this array. Equivalent to
 {@code asList().contains(target)}.]]>
      </doc>
    </method>
    <method name="forEach"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="java.util.function.LongConsumer"/>
      <doc>
      <![CDATA[Invokes {@code consumer} for each value contained in this array, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="stream" return="java.util.stream.LongStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a stream over the values in this array, in order.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toArray" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new, mutable copy of this array's values, as a primitive {@code long[]}.]]>
      </doc>
    </method>
    <method name="subArray" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[Returns a new immutable array containing the values in the specified range.

 <p><b>Performance note:</b> The returned array has the same full memory footprint as this one
 does (no actual copying is performed). To reduce memory usage, use {@code subArray(start,
 end).trimmed()}.]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable <i>view</i> of this array's values as a {@code List}; note that {@code
 long} values are boxed into {@link Long} instances on demand, which can be very expensive. The
 returned list should be used once and discarded. For any usages beyond that, pass the returned
 list to {@link com.google.common.collect.ImmutableList#copyOf(Collection) ImmutableList.copyOf}
 and use that list instead.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="Object"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code object} is an {@code ImmutableLongArray} containing the same
 values as this one, in the same order.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unspecified hash code for the contents of this immutable array.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this array in the same form as {@link
 Arrays#toString(long[])}, for example {@code "[1, 2, 3]"}.]]>
      </doc>
    </method>
    <method name="trimmed" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable array containing the same values as {@code this} array. This is logically
 a no-op, and in some circumstances {@code this} itself is returned. However, if this instance
 is a {@link #subArray} view of a larger array, this method will copy only the appropriate range
 of values, resulting in an equivalent array with a smaller memory footprint.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable array of {@code long} values, with an API resembling {@link List}.

 <p>Advantages compared to {@code long[]}:

 <ul>
   <li>All the many well-known advantages of immutability (read <i>Effective Java</i>, third
       edition, Item 17).
   <li>Has the value-based (not identity-based) {@link #equals}, {@link #hashCode}, and {@link
       #toString} behavior you expect.
   <li>Offers useful operations beyond just {@code get} and {@code length}, so you don't have to
       hunt through classes like {@link Arrays} and {@link Longs} for them.
   <li>Supports a copy-free {@link #subArray} view, so methods that accept this type don't need to
       add overloads that accept start and end indexes.
   <li>Can be streamed without "breaking the chain": {@code foo.getBarLongs().stream()...}.
   <li>Access to all collection-based utilities via {@link #asList} (though at the cost of
       allocating garbage).
 </ul>

 <p>Disadvantages compared to {@code long[]}:

 <ul>
   <li>Memory footprint has a fixed overhead (about 24 bytes per instance).
   <li><i>Some</i> construction use cases force the data to be copied (though several construction
       APIs are offered that don't).
   <li>Can't be passed directly to methods that expect {@code long[]} (though the most common
       utilities do have replacements here).
   <li>Dependency on {@code com.google.common} / Guava.
 </ul>

 <p>Advantages compared to {@link com.google.common.collect.ImmutableList ImmutableList}{@code
 <Long>}:

 <ul>
   <li>Improved memory compactness and locality.
   <li>Can be queried without allocating garbage.
   <li>Access to {@code LongStream} features (like {@link LongStream#sum}) using {@code stream()}
       instead of the awkward {@code stream().mapToLong(v -> v)}.
 </ul>

 <p>Disadvantages compared to {@code ImmutableList<Long>}:

 <ul>
   <li>Can't be passed directly to methods that expect {@code Iterable}, {@code Collection}, or
       {@code List} (though the most common utilities do have replacements here, and there is a
       lazy {@link #asList} view).
 </ul>

 @since 22.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.ImmutableLongArray -->
  <!-- start class com.google.common.primitives.ImmutableLongArray.Builder -->
  <class name="ImmutableLongArray.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="add" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Appends {@code value} to the end of the values the built {@link ImmutableLongArray} will
 contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="long[]"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableLongArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.lang.Iterable&lt;java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableLongArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="java.util.Collection&lt;java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableLongArray} will contain.]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.util.stream.LongStream"/>
      <doc>
      <![CDATA[Appends all values from {@code stream}, in order, to the end of the values the built {@link
 ImmutableLongArray} will contain.

 @since 33.4.0 (but since 22.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="addAll" return="com.google.common.primitives.ImmutableLongArray.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="com.google.common.primitives.ImmutableLongArray"/>
      <doc>
      <![CDATA[Appends {@code values}, in order, to the end of the values the built {@link
 ImmutableLongArray} will contain.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.primitives.ImmutableLongArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable array. The builder can continue to be used after this call, to append
 more values and build again.

 <p><b>Performance note:</b> the returned array is backed by the same array as the builder, so
 no data is copied as part of this step, but this may occupy more memory than strictly
 necessary. To copy the data to a right-sized backing array, use {@code .build().trimmed()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for {@link ImmutableLongArray} instances; obtained using {@link
 ImmutableLongArray#builder}.]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.ImmutableLongArray.Builder -->
  <!-- start class com.google.common.primitives.Ints -->
  <class name="Ints" extends="com.google.common.primitives.IntsMethodsForWeb"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link Integer#hashCode(int)}.

 @param value a primitive {@code int} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} value that is equal to {@code value}, if possible.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated. Use {@link
 Math#toIntExact(long)} instead, but be aware that that method throws {@link
 ArithmeticException} rather than {@link IllegalArgumentException}.

 @param value any value in the range of the {@code int} type
 @return the {@code int} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link Integer#MAX_VALUE} or
     less than {@link Integer#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code int} if it is in the range of the {@code int} type,
     {@link Integer#MAX_VALUE} if it is too large, or {@link Integer#MIN_VALUE} if it is too
     small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Compares the two specified {@code int} values. The sign of the value returned is the same as
 that of {@code ((Integer) a).compareTo(b)}.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use the
 equivalent {@link Integer#compare} method instead.

 @param a the first {@code int} to compare
 @param b the second {@code int} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="target" type="int"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}.

 @param array an array of {@code int} values, possibly empty
 @param target a primitive {@code int} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="min" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code int} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="constrainToRange" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <param name="min" type="int"/>
      <param name="max" type="int"/>
      <doc>
      <![CDATA[Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.

 <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned
 unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code
 value} is greater than {@code max}, {@code max} is returned.

 <p><b>Java 21+ users:</b> Use {@code Math.clamp} instead. Note that that method is capable of
 constraining a {@code long} input to an {@code int} range.

 @param value the {@code int} value to constrain
 @param min the lower bound (inclusive) of the range to constrain {@code value} to
 @param max the upper bound (inclusive) of the range to constrain {@code value} to
 @throws IllegalArgumentException if {@code min > max}
 @since 21.0]]>
      </doc>
    </method>
    <method name="concat" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="int[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new int[] {a, b}, new int[] {}, new int[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code int} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 4-element byte array; equivalent to
 {@code ByteBuffer.allocate(4).putInt(value).array()}. For example, the input value {@code
 0x12131415} would yield the byte array {@code {0x12, 0x13, 0x14, 0x15}}.

 <p>If you need to convert and concatenate several values (possibly even of different types),
 use a shared {@link java.nio.ByteBuffer} instance, or use {@link
 com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code int} value whose big-endian representation is stored in the first 4 bytes of
 {@code bytes}; equivalent to {@code ByteBuffer.wrap(bytes).getInt()}. For example, the input
 byte array {@code {0x12, 0x13, 0x14, 0x15, 0x33}} would yield the {@code int} value {@code
 0x12131415}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that library exposes much more
 flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 4 elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <param name="b3" type="byte"/>
      <param name="b4" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code int} value whose byte representation is the given 4 bytes, in big-endian
 order; equivalent to {@code Ints.fromByteArray(new byte[] {b1, b2, b3, b4})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="stringConverter" return="com.google.common.base.Converter&lt;java.lang.String, java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable converter object that converts between strings and integers using {@link
 Integer#decode} and {@link Integer#toString()}. The returned converter throws {@link
 NumberFormatException} if the input string is invalid.

 <p><b>Warning:</b> please see {@link Integer#decode} to understand exactly how strings are
 parsed. For example, the string {@code "0123"} is treated as <i>octal</i> and converted to the
 value {@code 83}.

 @since 16.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code int} values separated by {@code separator}. For
 example, {@code join("-", 1, 2, 3)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code int} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;int[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code int} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(int, int)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
 example, {@code [] < [1] < [1, 2] < [2]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(int[], int[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Ints.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Ints.asList(array).subList(fromIndex, toIndex))}, but is likely to be more
 efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Ints.asList(array),
 distance)}, but is considerably faster and avoids allocation and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Ints.asList(array).subList(fromIndex, toIndex), distance)}, but is
 considerably faster and avoids allocations and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <method name="toArray" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to a {@code int} value
 in the manner of {@link Number#intValue}.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null
 @since 1.0 (parameter was {@code Collection<Integer>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="int[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of {@code Integer} objects
 written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for
 the returned list is unspecified.

 <p>The returned list is serializable.

 <p><b>Note:</b> when possible, you should represent your data as an {@link ImmutableIntArray}
 instead, which has an {@link ImmutableIntArray#asList asList} view.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <method name="tryParse" return="Integer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the specified string as a signed decimal integer value. The ASCII character {@code '-'}
 (<code>'&#92;u002D'</code>) is recognized as the minus sign.

 <p>Unlike {@link Integer#parseInt(String)}, this method returns {@code null} instead of
 throwing an exception if parsing fails. Additionally, this method only accepts ASCII digits,
 and returns {@code null} if non-ASCII digits are present in the string.

 <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even though {@link
 Integer#parseInt(String)} accepts them.

 @param string the string representation of an integer value
 @return the integer value represented by {@code string}, or {@code null} if {@code string} has
     a length of zero or cannot be parsed as an integer value
 @throws NullPointerException if {@code string} is {@code null}
 @since 11.0]]>
      </doc>
    </method>
    <method name="tryParse" return="Integer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Parses the specified string as a signed integer value using the specified radix. The ASCII
 character {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.

 <p>Unlike {@link Integer#parseInt(String, int)}, this method returns {@code null} instead of
 throwing an exception if parsing fails. Additionally, this method only accepts ASCII digits,
 and returns {@code null} if non-ASCII digits are present in the string.

 <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even though {@link
 Integer#parseInt(String)} accepts them.

 @param string the string representation of an integer value
 @param radix the radix to use when parsing
 @return the integer value represented by {@code string} using {@code radix}, or {@code null} if
     {@code string} has a length of zero or cannot be parsed as an integer value
 @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >
     Character.MAX_RADIX}
 @throws NullPointerException if {@code string} is {@code null}
 @since 19.0]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code int} value.

 <p>Prefer {@link Integer#BYTES} instead.]]>
      </doc>
    </field>
    <field name="MAX_POWER_OF_TWO" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as an {@code int}.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code int} primitives, that are not already found in either
 {@link Integer} or {@link Arrays}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Ints -->
  <!-- start class com.google.common.primitives.Longs -->
  <class name="Longs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link Long#hashCode(long)}.

 @param value a primitive {@code long} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Compares the two specified {@code long} values. The sign of the value returned is the same as
 that of {@code ((Long) a).compareTo(b)}.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use the
 equivalent {@link Long#compare} method instead.

 @param a the first {@code long} to compare
 @param b the second {@code long} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="target" type="long"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}.

 @param array an array of {@code long} values, possibly empty
 @param target a primitive {@code long} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="min" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code long} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="constrainToRange" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <param name="min" type="long"/>
      <param name="max" type="long"/>
      <doc>
      <![CDATA[Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.

 <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned
 unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code
 value} is greater than {@code max}, {@code max} is returned.

 <p><b>Java 21+ users:</b> Use {@code Math.clamp} instead. Note that that method is capable of
 constraining a {@code long} input to an {@code int} range.

 @param value the {@code long} value to constrain
 @param min the lower bound (inclusive) of the range to constrain {@code value} to
 @param max the upper bound (inclusive) of the range to constrain {@code value} to
 @throws IllegalArgumentException if {@code min > max}
 @since 21.0]]>
      </doc>
    </method>
    <method name="concat" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="long[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new long[] {a, b}, new long[] {}, new long[] {c}} returns the array {@code {a, b, c}}.

 @param arrays zero or more {@code long} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in an 8-element byte array; equivalent to
 {@code ByteBuffer.allocate(8).putLong(value).array()}. For example, the input value {@code
 0x1213141516171819L} would yield the byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
 0x18, 0x19}}.

 <p>If you need to convert and concatenate several values (possibly even of different types),
 use a shared {@link java.nio.ByteBuffer} instance, or use {@link
 com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code long} value whose big-endian representation is stored in the first 8 bytes
 of {@code bytes}; equivalent to {@code ByteBuffer.wrap(bytes).getLong()}. For example, the
 input byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}} would yield the
 {@code long} value {@code 0x1213141516171819L}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that library exposes much more
 flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 8 elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <param name="b3" type="byte"/>
      <param name="b4" type="byte"/>
      <param name="b5" type="byte"/>
      <param name="b6" type="byte"/>
      <param name="b7" type="byte"/>
      <param name="b8" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code long} value whose byte representation is the given 8 bytes, in big-endian
 order; equivalent to {@code Longs.fromByteArray(new byte[] {b1, b2, b3, b4, b5, b6, b7, b8})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="tryParse" return="Long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the specified string as a signed decimal long value. The ASCII character {@code '-'} (
 <code>'&#92;u002D'</code>) is recognized as the minus sign.

 <p>Unlike {@link Long#parseLong(String)}, this method returns {@code null} instead of throwing
 an exception if parsing fails. Additionally, this method only accepts ASCII digits, and returns
 {@code null} if non-ASCII digits are present in the string.

 <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even though {@link
 Integer#parseInt(String)} accepts them.

 @param string the string representation of a long value
 @return the long value represented by {@code string}, or {@code null} if {@code string} has a
     length of zero or cannot be parsed as a long value
 @throws NullPointerException if {@code string} is {@code null}
 @since 14.0]]>
      </doc>
    </method>
    <method name="tryParse" return="Long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Parses the specified string as a signed long value using the specified radix. The ASCII
 character {@code '-'} (<code>'&#92;u002D'</code>) is recognized as the minus sign.

 <p>Unlike {@link Long#parseLong(String, int)}, this method returns {@code null} instead of
 throwing an exception if parsing fails. Additionally, this method only accepts ASCII digits,
 and returns {@code null} if non-ASCII digits are present in the string.

 <p>Note that strings prefixed with ASCII {@code '+'} are rejected, even though {@link
 Integer#parseInt(String)} accepts them.

 @param string the string representation of a long value
 @param radix the radix to use when parsing
 @return the long value represented by {@code string} using {@code radix}, or {@code null} if
     {@code string} has a length of zero or cannot be parsed as a long value
 @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >
     Character.MAX_RADIX}
 @throws NullPointerException if {@code string} is {@code null}
 @since 19.0]]>
      </doc>
    </method>
    <method name="stringConverter" return="com.google.common.base.Converter&lt;java.lang.String, java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable converter object that converts between strings and longs using {@link
 Long#decode} and {@link Long#toString()}. The returned converter throws {@link
 NumberFormatException} if the input string is invalid.

 <p><b>Warning:</b> please see {@link Long#decode} to understand exactly how strings are parsed.
 For example, the string {@code "0123"} is treated as <i>octal</i> and converted to the value
 {@code 83L}.

 @since 16.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code long} values separated by {@code separator}.
 For example, {@code join("-", 1L, 2L, 3L)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code long} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;long[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code long} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(long, long)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
 example, {@code [] < [1L] < [1L, 2L] < [2L]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(long[],
 long[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Longs.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Longs.asList(array).subList(fromIndex, toIndex))}, but is likely to be more
 efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Longs.asList(array),
 distance)}, but is considerably faster and avoids allocation and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Longs.asList(array).subList(fromIndex, toIndex), distance)}, but is
 considerably faster and avoids allocations and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <method name="toArray" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to a {@code long} value
 in the manner of {@link Number#longValue}.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null
 @since 1.0 (parameter was {@code Collection<Long>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="long[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of {@code Long} objects
 written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for
 the returned list is unspecified.

 <p>The returned list is serializable.

 <p><b>Note:</b> when possible, you should represent your data as an {@link ImmutableLongArray}
 instead, which has an {@link ImmutableLongArray#asList asList} view.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code long} value.

 <p>Prefer {@link Long#BYTES} instead.]]>
      </doc>
    </field>
    <field name="MAX_POWER_OF_TWO" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as a {@code long}.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code long} primitives, that are not already found in
 either {@link Long} or {@link Arrays}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Longs -->
  <!-- start class com.google.common.primitives.Primitives -->
  <class name="Primitives" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="allPrimitiveTypes" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of all nine primitive types (including {@code void}). Note that a
 simpler way to test whether a {@code Class} instance is a member of this set is to call {@link
 Class#isPrimitive}.

 @since 3.0]]>
      </doc>
    </method>
    <method name="allWrapperTypes" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an immutable set of all nine primitive-wrapper types (including {@link Void}).

 @since 3.0]]>
      </doc>
    </method>
    <method name="isWrapperType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code type} is one of the nine primitive-wrapper types, such as {@link
 Integer}.

 @see Class#isPrimitive]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding wrapper type of {@code type} if it is a primitive type; otherwise
 returns {@code type} itself. Idempotent.

 <pre>
     wrap(int.class) == Integer.class
     wrap(Integer.class) == Integer.class
     wrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <method name="unwrap" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the corresponding primitive type of {@code type} if it is a wrapper type; otherwise
 returns {@code type} itself. Idempotent.

 <pre>
     unwrap(Integer.class) == int.class
     unwrap(int.class) == int.class
     unwrap(String.class) == String.class
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains static utility methods pertaining to primitive types and their corresponding wrapper
 types.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Primitives -->
  <!-- start class com.google.common.primitives.Shorts -->
  <class name="Shorts" extends="com.google.common.primitives.ShortsMethodsForWeb"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a hash code for {@code value}; obsolete alternative to {@link Short#hashCode(short)}.

 @param value a primitive {@code short} value
 @return a hash code for the value]]>
      </doc>
    </method>
    <method name="checkedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code short} type
 @return the {@code short} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link Short#MAX_VALUE} or
     less than {@link Short#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code short} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code short} if it is in the range of the {@code short} type,
     {@link Short#MAX_VALUE} if it is too large, or {@link Short#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="short"/>
      <param name="b" type="short"/>
      <doc>
      <![CDATA[Compares the two specified {@code short} values. The sign of the value returned is the same as
 that of {@code ((Short) a).compareTo(b)}.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use the
 equivalent {@link Short#compare} method instead.

 @param a the first {@code short} to compare
 @param b the second {@code short} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns {@code true} if {@code target} is present as an element anywhere in {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return {@code true} if {@code array[i] == target} for some value of {@code i}]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the first appearance of the value {@code target} in {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the least index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short[]"/>
      <doc>
      <![CDATA[Returns the start position of the first occurrence of the specified {@code target} within
 {@code array}, or {@code -1} if there is no such occurrence.

 <p>More formally, returns the lowest index {@code i} such that {@code Arrays.copyOfRange(array,
 i, i + target.length)} contains exactly the same elements as {@code target}.

 @param array the array to search for the sequence {@code target}
 @param target the array to search for as a sub-sequence of {@code array}]]>
      </doc>
    </method>
    <method name="lastIndexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="target" type="short"/>
      <doc>
      <![CDATA[Returns the index of the last appearance of the value {@code target} in {@code array}.

 @param array an array of {@code short} values, possibly empty
 @param target a primitive {@code short} value
 @return the greatest index {@code i} for which {@code array[i] == target}, or {@code -1} if no
     such index exists.]]>
      </doc>
    </method>
    <method name="min" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code short} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="constrainToRange" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <param name="min" type="short"/>
      <param name="max" type="short"/>
      <doc>
      <![CDATA[Returns the value nearest to {@code value} which is within the closed range {@code [min..max]}.

 <p>If {@code value} is within the range {@code [min..max]}, {@code value} is returned
 unchanged. If {@code value} is less than {@code min}, {@code min} is returned, and if {@code
 value} is greater than {@code max}, {@code max} is returned.

 @param value the {@code short} value to constrain
 @param min the lower bound (inclusive) of the range to constrain {@code value} to
 @param max the upper bound (inclusive) of the range to constrain {@code value} to
 @throws IllegalArgumentException if {@code min > max}
 @since 21.0]]>
      </doc>
    </method>
    <method name="concat" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="short[][]"/>
      <doc>
      <![CDATA[Returns the values from each provided array combined into a single array. For example, {@code
 concat(new short[] {a, b}, new short[] {}, new short[] {c}} returns the array {@code {a, b,
 c}}.

 @param arrays zero or more {@code short} arrays
 @return a single array containing all the values from the source arrays, in order
 @throws IllegalArgumentException if the total number of elements in {@code arrays} does not fit
     in an {@code int}]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Returns a big-endian representation of {@code value} in a 2-element byte array; equivalent to
 {@code ByteBuffer.allocate(2).putShort(value).array()}. For example, the input value {@code
 (short) 0x1234} would yield the byte array {@code {0x12, 0x34}}.

 <p>If you need to convert and concatenate several values (possibly even of different types),
 use a shared {@link java.nio.ByteBuffer} instance, or use {@link
 com.google.common.io.ByteStreams#newDataOutput()} to get a growable buffer.]]>
      </doc>
    </method>
    <method name="fromByteArray" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Returns the {@code short} value whose big-endian representation is stored in the first 2 bytes
 of {@code bytes}; equivalent to {@code ByteBuffer.wrap(bytes).getShort()}. For example, the
 input byte array {@code {0x54, 0x32}} would yield the {@code short} value {@code 0x5432}.

 <p>Arguably, it's preferable to use {@link java.nio.ByteBuffer}; that library exposes much more
 flexibility at little cost in readability.

 @throws IllegalArgumentException if {@code bytes} has fewer than 2 elements]]>
      </doc>
    </method>
    <method name="fromBytes" return="short"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte"/>
      <param name="b2" type="byte"/>
      <doc>
      <![CDATA[Returns the {@code short} value whose byte representation is the given 2 bytes, in big-endian
 order; equivalent to {@code Shorts.fromByteArray(new byte[] {b1, b2})}.

 @since 7.0]]>
      </doc>
    </method>
    <method name="stringConverter" return="com.google.common.base.Converter&lt;java.lang.String, java.lang.Short&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a serializable converter object that converts between strings and shorts using {@link
 Short#decode} and {@link Short#toString()}. The returned converter throws {@link
 NumberFormatException} if the input string is invalid.

 <p><b>Warning:</b> please see {@link Short#decode} to understand exactly how strings are
 parsed. For example, the string {@code "0123"} is treated as <i>octal</i> and converted to the
 value {@code 83}.

 @since 16.0]]>
      </doc>
    </method>
    <method name="ensureCapacity" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="minLength" type="int"/>
      <param name="padding" type="int"/>
      <doc>
      <![CDATA[Returns an array containing the same values as {@code array}, but guaranteed to be of a
 specified minimum length. If {@code array} already has a length of at least {@code minLength},
 it is returned directly. Otherwise, a new array of size {@code minLength + padding} is
 returned, containing the values of {@code array}, and zeroes in the remaining places.

 @param array the source array
 @param minLength the minimum length the returned array must guarantee
 @param padding an extra amount to "grow" the array by if growth is necessary
 @throws IllegalArgumentException if {@code minLength} or {@code padding} is negative
 @return an array containing the values of {@code array}, with guaranteed minimum length {@code
     minLength}]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code short} values separated by {@code separator}.
 For example, {@code join("-", (short) 1, (short) 2, (short) 3)} returns the string {@code
 "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code short} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;short[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code short} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(short, short)}), the first pair of values that follow any
 common prefix, or when one array is a prefix of the other, treats the shorter array as the
 lesser. For example, {@code [] < [(short) 1] < [(short) 1, (short) 2] < [(short) 2]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(short[],
 short[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array}. This is equivalent to {@code
 Collections.reverse(Shorts.asList(array))}, but is likely to be more efficient.

 @since 23.1]]>
      </doc>
    </method>
    <method name="reverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Reverses the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive. This is equivalent to {@code
 Collections.reverse(Shorts.asList(array).subList(fromIndex, toIndex))}, but is likely to be
 more efficient.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 23.1]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="distance" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} of "distance" places, so that the first element is
 moved to index "distance", and the element at index {@code i} ends up at index {@code (distance
 + i) mod array.length}. This is equivalent to {@code Collections.rotate(Shorts.asList(array),
 distance)}, but is considerably faster and avoids allocation and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @since 32.0.0]]>
      </doc>
    </method>
    <method name="rotate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="short[]"/>
      <param name="distance" type="int"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Performs a right rotation of {@code array} between {@code fromIndex} inclusive and {@code
 toIndex} exclusive. This is equivalent to {@code
 Collections.rotate(Shorts.asList(array).subList(fromIndex, toIndex), distance)}, but is
 considerably faster and avoids allocations and garbage collection.

 <p>The provided "distance" may be negative, which will rotate left.

 @throws IndexOutOfBoundsException if {@code fromIndex < 0}, {@code toIndex > array.length}, or
     {@code toIndex > fromIndex}
 @since 32.0.0]]>
      </doc>
    </method>
    <method name="toArray" return="short[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="java.util.Collection&lt;? extends java.lang.Number&gt;"/>
      <doc>
      <![CDATA[Returns an array containing each value of {@code collection}, converted to a {@code short}
 value in the manner of {@link Number#shortValue}.

 <p>Elements are copied from the argument collection as if by {@code collection.toArray()}.
 Calling this method is as thread-safe as calling that method.

 @param collection a collection of {@code Number} instances
 @return an array containing the same values as {@code collection}, in the same order, converted
     to primitives
 @throws NullPointerException if {@code collection} or any of its elements is null
 @since 1.0 (parameter was {@code Collection<Short>} before 12.0)]]>
      </doc>
    </method>
    <method name="asList" return="java.util.List&lt;java.lang.Short&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingArray" type="short[]"/>
      <doc>
      <![CDATA[Returns a fixed-size list backed by the specified array, similar to {@link
 Arrays#asList(Object[])}. The list supports {@link List#set(int, Object)}, but any attempt to
 set a value to {@code null} will result in a {@link NullPointerException}.

 <p>The returned list maintains the values, but not the identities, of {@code Short} objects
 written to or read from it. For example, whether {@code list.get(0) == list.get(0)} is true for
 the returned list is unspecified.

 <p>The returned list is serializable.

 @param backingArray the array to back the list
 @return a list view of the array]]>
      </doc>
    </method>
    <field name="BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes required to represent a primitive {@code short} value.

 <p>Prefer {@link Short#BYTES} instead.]]>
      </doc>
    </field>
    <field name="MAX_POWER_OF_TWO" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as a {@code short}.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code short} primitives, that are not already found in
 either {@link Short} or {@link Arrays}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.Shorts -->
  <!-- start class com.google.common.primitives.SignedBytes -->
  <class name="SignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that is equal to {@code value}, if possible.

 @param value any value in the range of the {@code byte} type
 @return the {@code byte} value that equals {@code value}
 @throws IllegalArgumentException if {@code value} is greater than {@link Byte#MAX_VALUE} or
     less than {@link Byte#MIN_VALUE}]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} nearest in value to {@code value}.

 @param value any {@code long} value
 @return the same value cast to {@code byte} if it is in the range of the {@code byte} type,
     {@link Byte#MAX_VALUE} if it is too large, or {@link Byte#MIN_VALUE} if it is too small]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values. The sign of the value returned is the same as
 that of {@code ((Byte) a).compareTo(b)}.

 <p><b>Note:</b> this method behaves identically to {@link Byte#compare}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated by {@code separator}.
 For example, {@code join(":", 0x01, 0x02, -0x01)} returns the string {@code "1:2:-1"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code byte} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(byte, byte)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
 example, {@code [] < [0x01] < [0x01, 0x80] < [0x01, 0x7F] < [0x02]}. Values are treated as
 signed.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link
 java.util.Arrays#equals(byte[], byte[])}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order.

 @since 23.1]]>
      </doc>
    </method>
    <field name="MAX_POWER_OF_TWO" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as a signed {@code byte}.

 @since 10.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that interpret values as signed. The
 corresponding methods that treat the values as unsigned are found in {@link UnsignedBytes}, and
 the methods for which signedness is not an issue are in {@link Bytes}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.SignedBytes -->
  <!-- start class com.google.common.primitives.UnsignedBytes -->
  <class name="UnsignedBytes" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Returns the value of the given byte as an integer, when treated as unsigned. That is, returns
 {@code value + 256} if {@code value} is negative; {@code value} itself otherwise.

 <p>Prefer {@link Byte#toUnsignedInt(byte)} instead.

 @since 6.0]]>
      </doc>
    </method>
    <method name="checkedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is equal to {@code value}, if
 possible.

 @param value a value between 0 and 255 inclusive
 @return the {@code byte} value that, when treated as unsigned, equals {@code value}
 @throws IllegalArgumentException if {@code value} is negative or greater than 255]]>
      </doc>
    </method>
    <method name="saturatedCast" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code byte} value that, when treated as unsigned, is nearest in value to {@code
 value}.

 @param value any {@code long} value
 @return {@code (byte) 255} if {@code value >= 255}, {@code (byte) 0} if {@code value <= 0}, and
     {@code value} cast to {@code byte} otherwise]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="byte"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Compares the two specified {@code byte} values, treating them as unsigned values between 0 and
 255 inclusive. For example, {@code (byte) -127} is considered greater than {@code (byte) 127}
 because it is seen as having the value of positive {@code 129}.

 @param a the first {@code byte} to compare
 @param b the second {@code byte} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of {@code byte} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="byte"/>
      <doc>
      <![CDATA[Returns a string representation of x, where x is treated as unsigned.

 @since 13.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="byte"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of {@code x} for the given radix, where {@code x} is treated as
 unsigned.

 @param x the value to convert to a string.
 @param radix the radix to use while working with {@code x}
 @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}
     and {@link Character#MAX_RADIX}.
 @since 13.0]]>
      </doc>
    </method>
    <method name="parseUnsignedByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code byte} value represented by the given decimal string.

 @throws NumberFormatException if the string does not contain a valid unsigned {@code byte}
     value
 @throws NullPointerException if {@code string} is null (in contrast to {@link
     Byte#parseByte(String)})
 @since 13.0]]>
      </doc>
    </method>
    <method name="parseUnsignedByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns the unsigned {@code byte} value represented by a string with the given radix.

 @param string the string containing the unsigned {@code byte} representation to be parsed.
 @param radix the radix to use while parsing {@code string}
 @throws NumberFormatException if the string does not contain a valid unsigned {@code byte} with
     the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX} and {@link
     Character#MAX_RADIX}.
 @throws NullPointerException if {@code string} is null (in contrast to {@link
     Byte#parseByte(String)})
 @since 13.0]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied {@code byte} values separated by {@code separator}.
 For example, {@code join(":", (byte) 1, (byte) 2, (byte) 255)} returns the string {@code
 "1:2:255"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of {@code byte} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;byte[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two {@code byte} arrays <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(byte, byte)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
 example, {@code [] < [0x01] < [0x01, 0x7F] < [0x01, 0x80] < [0x02]}. Values are treated as
 unsigned.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link
 java.util.Arrays#equals(byte[], byte[])}.

 <p><b>Java 9+ users:</b> Use {@link Arrays#compareUnsigned(byte[], byte[])
 Arrays::compareUnsigned}.

 @since 2.0]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Sorts the array, treating its elements as unsigned bytes.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the array between {@code fromIndex} inclusive and {@code toIndex} exclusive, treating its
 elements as unsigned bytes.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order, interpreting them as unsigned 8-bit
 integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order, interpreting them as unsigned 8-bit integers.

 @since 23.1]]>
      </doc>
    </method>
    <field name="MAX_POWER_OF_TWO" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest power of two that can be represented as an unsigned {@code byte}.

 @since 10.0]]>
      </doc>
    </field>
    <field name="MAX_VALUE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The largest value that fits into an unsigned byte.

 @since 13.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code byte} primitives that interpret values as
 <i>unsigned</i> (that is, any negative value {@code b} is treated as the positive value {@code
 256 + b}). The corresponding methods that treat the values as signed are found in {@link
 SignedBytes}, and the methods for which signedness is not an issue are in {@link Bytes}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained">primitive utilities</a>.

 @author Kevin Bourrillion
 @author Martin Buchholz
 @author Hiroshi Yamauchi
 @author Louis Wasserman
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedBytes -->
  <!-- start class com.google.common.primitives.UnsignedInteger -->
  <class name="UnsignedInteger" extends="java.lang.Number"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable&lt;com.google.common.primitives.UnsignedInteger&gt;"/>
    <method name="fromIntBits" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bits" type="int"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} corresponding to a given bit representation. The argument is
 interpreted as an unsigned 32-bit value. Specifically, the sign bit of {@code bits} is
 interpreted as a normal bit, and all other bits are treated as usual.

 <p>If the argument is nonnegative, the returned result will be equal to {@code bits},
 otherwise, the result will be equal to {@code 2^32 + bits}.

 <p>To represent unsigned decimal constants, consider {@link #valueOf(long)} instead.

 @since 14.0]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} that is equal to {@code value}, if possible. The inverse
 operation of {@link #longValue()}.]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns a {@code UnsignedInteger} representing the same value as the specified {@link
 BigInteger}. This is the inverse operation of {@link #bigIntegerValue()}.

 @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^32}]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} holding the value of the specified {@code String}, parsed as
 an unsigned {@code int} value.

 @throws NumberFormatException if the string does not contain a parsable unsigned {@code int}
     value]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedInteger} holding the value of the specified {@code String}, parsed as
 an unsigned {@code int} value in the specified radix.

 @throws NumberFormatException if the string does not contain a parsable unsigned {@code int}
     value]]>
      </doc>
    </method>
    <method name="plus" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of adding this and {@code val}. If the result would have more than 32 bits,
 returns the low 32 bits of the result.

 @since 14.0]]>
      </doc>
    </method>
    <method name="minus" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of subtracting this and {@code val}. If the result would be negative,
 returns the low 32 bits of the result.

 @since 14.0]]>
      </doc>
    </method>
    <method name="times" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of multiplying this and {@code val}. If the result would have more than 32
 bits, returns the low 32 bits of the result.

 @since 14.0]]>
      </doc>
    </method>
    <method name="dividedBy" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns the result of dividing this by {@code val}.

 @throws ArithmeticException if {@code val} is zero
 @since 14.0]]>
      </doc>
    </method>
    <method name="mod" return="com.google.common.primitives.UnsignedInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Returns this mod {@code val}.

 @throws ArithmeticException if {@code val} is zero
 @since 14.0]]>
      </doc>
    </method>
    <method name="intValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as an {@code int}. This is an inverse
 operation to {@link #fromIntBits}.

 <p>Note that if this {@code UnsignedInteger} holds a value {@code >= 2^31}, the returned value
 will be equal to {@code this - 2^32}.]]>
      </doc>
    </method>
    <method name="longValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@code long}.]]>
      </doc>
    </method>
    <method name="floatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@code float}, analogous to a widening
 primitive conversion from {@code int} to {@code float}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="doubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@code double}, analogous to a widening
 primitive conversion from {@code int} to {@code double}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="bigIntegerValue" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedInteger} as a {@link BigInteger}.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.common.primitives.UnsignedInteger"/>
      <doc>
      <![CDATA[Compares this unsigned integer to another unsigned integer. Returns {@code 0} if they are
 equal, a negative number if {@code this < other}, and a positive number if {@code this >
 other}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedInteger} value, in base 10.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedInteger} value, in base {@code radix}. If
 {@code radix < Character.MIN_RADIX} or {@code radix > Character.MAX_RADIX}, the radix {@code
 10} is used.]]>
      </doc>
    </method>
    <field name="ZERO" type="com.google.common.primitives.UnsignedInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ONE" type="com.google.common.primitives.UnsignedInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_VALUE" type="com.google.common.primitives.UnsignedInteger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A wrapper class for unsigned {@code int} values, supporting arithmetic operations.

 <p>In some cases, when speed is more important than code readability, it may be faster simply to
 treat primitive {@code int} values as unsigned, using the methods from {@link UnsignedInts}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained#unsigned-support">unsigned
 primitive utilities</a>.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedInteger -->
  <!-- start class com.google.common.primitives.UnsignedInts -->
  <class name="UnsignedInts" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="int"/>
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Compares the two specified {@code int} values, treating them as unsigned values between {@code
 0} and {@code 2^32 - 1} inclusive.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use the
 equivalent {@link Integer#compareUnsigned(int, int)} method instead.

 @param a the first unsigned {@code int} to compare
 @param b the second unsigned {@code int} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="toLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Returns the value of the given {@code int} as a {@code long}, when treated as unsigned.

 <p><b>Java 8+ users:</b> use {@link Integer#toUnsignedLong(int)} instead.]]>
      </doc>
    </method>
    <method name="checkedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} value that, when treated as unsigned, is equal to {@code value}, if
 possible.

 @param value a value between 0 and 2<sup>32</sup>-1 inclusive
 @return the {@code int} value that, when treated as unsigned, equals {@code value}
 @throws IllegalArgumentException if {@code value} is negative or greater than or equal to
     2<sup>32</sup>
 @since 21.0]]>
      </doc>
    </method>
    <method name="saturatedCast" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns the {@code int} value that, when treated as unsigned, is nearest in value to {@code
 value}.

 @param value any {@code long} value
 @return {@code 2^32 - 1} if {@code value >= 2^32}, {@code 0} if {@code value <= 0}, and {@code
     value} cast to {@code int} otherwise
 @since 21.0]]>
      </doc>
    </method>
    <method name="min" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code int} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code int} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied unsigned {@code int} values separated by {@code
 separator}. For example, {@code join("-", 1, 2, 3)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of unsigned {@code int} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;int[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two arrays of unsigned {@code int} values <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(int, int)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
 example, {@code [] < [1] < [1, 2] < [2] < [1 << 31]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(int[], int[])}.

 <p><b>Java 9+ users:</b> Use {@link Arrays#compareUnsigned(int[], int[])
 Arrays::compareUnsigned}.]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Sorts the array, treating its elements as unsigned 32-bit integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the array between {@code fromIndex} inclusive and {@code toIndex} exclusive, treating its
 elements as unsigned 32-bit integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order, interpreting them as unsigned 32-bit
 integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order, interpreting them as unsigned 32-bit integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="divide" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="int"/>
      <param name="divisor" type="int"/>
      <doc>
      <![CDATA[Returns dividend / divisor, where the dividend and divisor are treated as unsigned 32-bit
 quantities.

 <p><b>Java 8+ users:</b> use {@link Integer#divideUnsigned(int, int)} instead.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0]]>
      </doc>
    </method>
    <method name="remainder" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="int"/>
      <param name="divisor" type="int"/>
      <doc>
      <![CDATA[Returns dividend % divisor, where the dividend and divisor are treated as unsigned 32-bit
 quantities.

 <p><b>Java 8+ users:</b> use {@link Integer#remainderUnsigned(int, int)} instead.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0]]>
      </doc>
    </method>
    <method name="decode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code int} value represented by the given string.

 <p>Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix:

 <ul>
   <li>{@code 0x}<i>HexDigits</i>
   <li>{@code 0X}<i>HexDigits</i>
   <li>{@code #}<i>HexDigits</i>
   <li>{@code 0}<i>OctalDigits</i>
 </ul>

 @throws NumberFormatException if the string does not contain a valid unsigned {@code int} value
 @since 13.0]]>
      </doc>
    </method>
    <method name="parseUnsignedInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code int} value represented by the given decimal string.

 <p><b>Java 8+ users:</b> use {@link Integer#parseUnsignedInt(String)} instead.

 @throws NumberFormatException if the string does not contain a valid unsigned {@code int} value
 @throws NullPointerException if {@code s} is null (in contrast to {@link
     Integer#parseInt(String)})]]>
      </doc>
    </method>
    <method name="parseUnsignedInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns the unsigned {@code int} value represented by a string with the given radix.

 <p><b>Java 8+ users:</b> use {@link Integer#parseUnsignedInt(String, int)} instead.

 @param string the string containing the unsigned integer representation to be parsed.
 @param radix the radix to use while parsing {@code s}; must be between {@link
     Character#MIN_RADIX} and {@link Character#MAX_RADIX}.
 @throws NumberFormatException if the string does not contain a valid unsigned {@code int}, or
     if supplied radix is invalid.
 @throws NullPointerException if {@code s} is null (in contrast to {@link
     Integer#parseInt(String)})]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of x, where x is treated as unsigned.

 <p><b>Java 8+ users:</b> use {@link Integer#toUnsignedString(int)} instead.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of {@code x} for the given radix, where {@code x} is treated as
 unsigned.

 <p><b>Java 8+ users:</b> use {@link Integer#toUnsignedString(int, int)} instead.

 @param x the value to convert to a string.
 @param radix the radix to use while working with {@code x}
 @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}
     and {@link Character#MAX_RADIX}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code int} primitives that interpret values as
 <i>unsigned</i> (that is, any negative value {@code x} is treated as the positive value {@code
 2^32 + x}). The methods for which signedness is not an issue are in {@link Ints}, as well as
 signed versions of methods for which signedness is an issue.

 <p>In addition, this class provides several static methods for converting an {@code int} to a
 {@code String} and a {@code String} to an {@code int} that treat the {@code int} as an unsigned
 number.

 <p>Users of these utilities must be <i>extremely careful</i> not to mix up signed and unsigned
 {@code int} values. When possible, it is recommended that the {@link UnsignedInteger} wrapper
 class be used, at a small efficiency penalty, to enforce the distinction in the type system.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained#unsigned-support">unsigned
 primitive utilities</a>.

 @author Louis Wasserman
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedInts -->
  <!-- start class com.google.common.primitives.UnsignedLong -->
  <class name="UnsignedLong" extends="java.lang.Number"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable&lt;com.google.common.primitives.UnsignedLong&gt;"/>
    <method name="fromLongBits" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bits" type="long"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedLong} corresponding to a given bit representation. The argument is
 interpreted as an unsigned 64-bit value. Specifically, the sign bit of {@code bits} is
 interpreted as a normal bit, and all other bits are treated as usual.

 <p>If the argument is nonnegative, the returned result will be equal to {@code bits},
 otherwise, the result will be equal to {@code 2^64 + bits}.

 <p>To represent decimal constants less than {@code 2^63}, consider {@link #valueOf(long)}
 instead.

 @since 14.0]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedLong} representing the same value as the specified {@code long}.

 @throws IllegalArgumentException if {@code value} is negative
 @since 14.0]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.math.BigInteger"/>
      <doc>
      <![CDATA[Returns a {@code UnsignedLong} representing the same value as the specified {@code BigInteger}.
 This is the inverse operation of {@link #bigIntegerValue()}.

 @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^64}]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedLong} holding the value of the specified {@code String}, parsed as an
 unsigned {@code long} value.

 @throws NumberFormatException if the string does not contain a parsable unsigned {@code long}
     value]]>
      </doc>
    </method>
    <method name="valueOf" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns an {@code UnsignedLong} holding the value of the specified {@code String}, parsed as an
 unsigned {@code long} value in the specified radix.

 @throws NumberFormatException if the string does not contain a parsable unsigned {@code long}
     value, or {@code radix} is not between {@link Character#MIN_RADIX} and {@link
     Character#MAX_RADIX}]]>
      </doc>
    </method>
    <method name="plus" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of adding this and {@code val}. If the result would have more than 64 bits,
 returns the low 64 bits of the result.

 @since 14.0]]>
      </doc>
    </method>
    <method name="minus" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of subtracting this and {@code val}. If the result would have more than 64
 bits, returns the low 64 bits of the result.

 @since 14.0]]>
      </doc>
    </method>
    <method name="times" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of multiplying this and {@code val}. If the result would have more than 64
 bits, returns the low 64 bits of the result.

 @since 14.0]]>
      </doc>
    </method>
    <method name="dividedBy" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns the result of dividing this by {@code val}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="mod" return="com.google.common.primitives.UnsignedLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="com.google.common.primitives.UnsignedLong"/>
      <doc>
      <![CDATA[Returns this modulo {@code val}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="intValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as an {@code int}.]]>
      </doc>
    </method>
    <method name="longValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@code long}. This is an inverse operation
 to {@link #fromLongBits}.

 <p>Note that if this {@code UnsignedLong} holds a value {@code >= 2^63}, the returned value
 will be equal to {@code this - 2^64}.]]>
      </doc>
    </method>
    <method name="floatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@code float}, analogous to a widening
 primitive conversion from {@code long} to {@code float}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="doubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@code double}, analogous to a widening
 primitive conversion from {@code long} to {@code double}, and correctly rounded.]]>
      </doc>
    </method>
    <method name="bigIntegerValue" return="java.math.BigInteger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code UnsignedLong} as a {@link BigInteger}.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="com.google.common.primitives.UnsignedLong"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedLong} value, in base 10.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of the {@code UnsignedLong} value, in base {@code radix}. If
 {@code radix < Character.MIN_RADIX} or {@code radix > Character.MAX_RADIX}, the radix {@code
 10} is used.]]>
      </doc>
    </method>
    <field name="ZERO" type="com.google.common.primitives.UnsignedLong"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ONE" type="com.google.common.primitives.UnsignedLong"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_VALUE" type="com.google.common.primitives.UnsignedLong"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A wrapper class for unsigned {@code long} values, supporting arithmetic operations.

 <p>In some cases, when speed is more important than code readability, it may be faster simply to
 treat primitive {@code long} values as unsigned, using the methods from {@link UnsignedLongs}.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained#unsigned-support">unsigned
 primitive utilities</a>.

 @author Louis Wasserman
 @author Colin Evans
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedLong -->
  <!-- start class com.google.common.primitives.UnsignedLongs -->
  <class name="UnsignedLongs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="long"/>
      <param name="b" type="long"/>
      <doc>
      <![CDATA[Compares the two specified {@code long} values, treating them as unsigned values between {@code
 0} and {@code 2^64 - 1} inclusive.

 <p><b>Note:</b> this method is now unnecessary and should be treated as deprecated; use the
 equivalent {@link Long#compareUnsigned(long, long)} method instead.

 @param a the first unsigned {@code long} to compare
 @param b the second unsigned {@code long} to compare
 @return a negative value if {@code a} is less than {@code b}; a positive value if {@code a} is
     greater than {@code b}; or zero if they are equal]]>
      </doc>
    </method>
    <method name="min" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the least value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code long} values
 @return the value present in {@code array} that is less than or equal to every other value in
     the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="max" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns the greatest value present in {@code array}, treating values as unsigned.

 @param array a <i>nonempty</i> array of unsigned {@code long} values
 @return the value present in {@code array} that is greater than or equal to every other value
     in the array according to {@link #compare}
 @throws IllegalArgumentException if {@code array} is empty]]>
      </doc>
    </method>
    <method name="join" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="separator" type="java.lang.String"/>
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Returns a string containing the supplied unsigned {@code long} values separated by {@code
 separator}. For example, {@code join("-", 1, 2, 3)} returns the string {@code "1-2-3"}.

 @param separator the text that should appear between consecutive values in the resulting string
     (but not at the start or end)
 @param array an array of unsigned {@code long} values, possibly empty]]>
      </doc>
    </method>
    <method name="lexicographicalComparator" return="java.util.Comparator&lt;long[]&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a comparator that compares two arrays of unsigned {@code long} values <a
 href="http://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>. That is, it
 compares, using {@link #compare(long, long)}), the first pair of values that follow any common
 prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
 example, {@code [] < [1L] < [1L, 2L] < [2L] < [1L << 63]}.

 <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
 support only identity equality), but it is consistent with {@link Arrays#equals(long[],
 long[])}.

 <p><b>Java 9+ users:</b> Use {@link Arrays#compareUnsigned(long[], long[])
 Arrays::compareUnsigned}.]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Sorts the array, treating its elements as unsigned 64-bit integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the array between {@code fromIndex} inclusive and {@code toIndex} exclusive, treating its
 elements as unsigned 64-bit integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} in descending order, interpreting them as unsigned 64-bit
 integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="sortDescending"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="fromIndex" type="int"/>
      <param name="toIndex" type="int"/>
      <doc>
      <![CDATA[Sorts the elements of {@code array} between {@code fromIndex} inclusive and {@code toIndex}
 exclusive in descending order, interpreting them as unsigned 64-bit integers.

 @since 23.1]]>
      </doc>
    </method>
    <method name="divide" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="long"/>
      <param name="divisor" type="long"/>
      <doc>
      <![CDATA[Returns dividend / divisor, where the dividend and divisor are treated as unsigned 64-bit
 quantities.

 <p><b>Java 8+ users:</b> use {@link Long#divideUnsigned(long, long)} instead.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0]]>
      </doc>
    </method>
    <method name="remainder" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dividend" type="long"/>
      <param name="divisor" type="long"/>
      <doc>
      <![CDATA[Returns dividend % divisor, where the dividend and divisor are treated as unsigned 64-bit
 quantities.

 <p><b>Java 8+ users:</b> use {@link Long#remainderUnsigned(long, long)} instead.

 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throws ArithmeticException if divisor is 0
 @since 11.0]]>
      </doc>
    </method>
    <method name="parseUnsignedLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code long} value represented by the given decimal string.

 <p><b>Java 8+ users:</b> use {@link Long#parseUnsignedLong(String)} instead.

 @throws NumberFormatException if the string does not contain a valid unsigned {@code long}
     value
 @throws NullPointerException if {@code string} is null (in contrast to {@link
     Long#parseLong(String)})]]>
      </doc>
    </method>
    <method name="parseUnsignedLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns the unsigned {@code long} value represented by a string with the given radix.

 <p><b>Java 8+ users:</b> use {@link Long#parseUnsignedLong(String, int)} instead.

 @param string the string containing the unsigned {@code long} representation to be parsed.
 @param radix the radix to use while parsing {@code string}
 @throws NumberFormatException if the string does not contain a valid unsigned {@code long} with
     the given radix, or if {@code radix} is not between {@link Character#MIN_RADIX} and {@link
     Character#MAX_RADIX}.
 @throws NullPointerException if {@code string} is null (in contrast to {@link
     Long#parseLong(String)})]]>
      </doc>
    </method>
    <method name="decode" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the unsigned {@code long} value represented by the given string.

 <p>Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix:

 <ul>
   <li>{@code 0x}<i>HexDigits</i>
   <li>{@code 0X}<i>HexDigits</i>
   <li>{@code #}<i>HexDigits</i>
   <li>{@code 0}<i>OctalDigits</i>
 </ul>

 @throws NumberFormatException if the string does not contain a valid unsigned {@code long}
     value
 @since 13.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <doc>
      <![CDATA[Returns a string representation of x, where x is treated as unsigned.

 <p><b>Java 8+ users:</b> use {@link Long#toUnsignedString(long)} instead.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="x" type="long"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[Returns a string representation of {@code x} for the given radix, where {@code x} is treated as
 unsigned.

 <p><b>Java 8+ users:</b> use {@link Long#toUnsignedString(long, int)} instead.

 @param x the value to convert to a string.
 @param radix the radix to use while working with {@code x}
 @throws IllegalArgumentException if {@code radix} is not between {@link Character#MIN_RADIX}
     and {@link Character#MAX_RADIX}.]]>
      </doc>
    </method>
    <field name="MAX_VALUE" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static utility methods pertaining to {@code long} primitives that interpret values as
 <i>unsigned</i> (that is, any negative value {@code x} is treated as the positive value {@code
 2^64 + x}). The methods for which signedness is not an issue are in {@link Longs}, as well as
 signed versions of methods for which signedness is an issue.

 <p>In addition, this class provides several static methods for converting a {@code long} to a
 {@code String} and a {@code String} to a {@code long} that treat the {@code long} as an unsigned
 number.

 <p>Users of these utilities must be <i>extremely careful</i> not to mix up signed and unsigned
 {@code long} values. When possible, it is recommended that the {@link UnsignedLong} wrapper class
 be used, at a small efficiency penalty, to enforce the distinction in the type system.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/PrimitivesExplained#unsigned-support">unsigned
 primitive utilities</a>.

 @author Louis Wasserman
 @author Brian Milch
 @author Colin Evans
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.primitives.UnsignedLongs -->
</package>
<package name="com.google.common.reflect">
  <!-- start class com.google.common.reflect.AbstractInvocationHandler -->
  <class name="AbstractInvocationHandler" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.reflect.InvocationHandler"/>
    <constructor name="AbstractInvocationHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="invoke" return="Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="proxy" type="java.lang.Object"/>
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="args" type="Object"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <ul>
   <li>{@code proxy.hashCode()} delegates to {@link AbstractInvocationHandler#hashCode}
   <li>{@code proxy.toString()} delegates to {@link AbstractInvocationHandler#toString}
   <li>{@code proxy.equals(argument)} returns true if:
       <ul>
         <li>{@code proxy} and {@code argument} are of the same type
         <li>and {@link AbstractInvocationHandler#equals} returns true for the {@link
             InvocationHandler} of {@code argument}
       </ul>
   <li>other method calls are dispatched to {@link #handleInvocation}.
 </ul>]]>
      </doc>
    </method>
    <method name="handleInvocation" return="Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="proxy" type="java.lang.Object"/>
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="args" type="java.lang.Object[]"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[{@link #invoke} delegates to this method upon any method invocation on the proxy instance,
 except {@link Object#equals}, {@link Object#hashCode} and {@link Object#toString}. The result
 will be returned as the proxied method's return value.

 <p>Unlike {@link #invoke}, {@code args} will never be null. When the method has no parameter,
 an empty array is passed in.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
      <doc>
      <![CDATA[By default delegates to {@link Object#equals} so instances are only equal if they are
 identical. {@code proxy.equals(argument)} returns true if:

 <ul>
   <li>{@code proxy} and {@code argument} are of the same type
   <li>and this method returns true for the {@link InvocationHandler} of {@code argument}
 </ul>

 <p>Subclasses can override this method to provide custom equality.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[By default delegates to {@link Object#hashCode}. The dynamic proxies' {@code hashCode()} will
 delegate to this method. Subclasses can override this method to provide custom equality.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[By default delegates to {@link Object#toString}. The dynamic proxies' {@code toString()} will
 delegate to this method. Subclasses can override this method to provide custom string
 representation for the proxies.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract implementation of {@link InvocationHandler} that handles {@link Object#equals}, {@link
 Object#hashCode} and {@link Object#toString}. For example:

 <pre>
 class Unsupported extends AbstractInvocationHandler {
   protected Object handleInvocation(Object proxy, Method method, Object[] args) {
     throw new UnsupportedOperationException();
   }
 }

 CharSequence unsupported = Reflection.newProxy(CharSequence.class, new Unsupported());
 </pre>

 @author Ben Yu
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.AbstractInvocationHandler -->
  <!-- start class com.google.common.reflect.ClassPath -->
  <class name="ClassPath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="from" return="com.google.common.reflect.ClassPath"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classloader" type="java.lang.ClassLoader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a {@code ClassPath} representing all classes and resources loadable from {@code
 classloader} and its ancestor class loaders.

 <p><b>Warning:</b> {@code ClassPath} can find classes and resources only from:

 <ul>
   <li>{@link URLClassLoader} instances' {@code file:} URLs
   <li>the {@linkplain ClassLoader#getSystemClassLoader() system class loader}. To search the
       system class loader even when it is not a {@link URLClassLoader} (as in Java 9), {@code
       ClassPath} searches the files from the {@code java.class.path} system property.
 </ul>

 @throws IOException if the attempt to read class path resources (jar files or directories)
     failed.]]>
      </doc>
    </method>
    <method name="getResources" return="com.google.common.collect.ImmutableSet&lt;com.google.common.reflect.ClassPath.ResourceInfo&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all resources loadable from the current class path, including the class files of all
 loadable classes but excluding the "META-INF/MANIFEST.MF" file.]]>
      </doc>
    </method>
    <method name="getAllClasses" return="com.google.common.collect.ImmutableSet&lt;com.google.common.reflect.ClassPath.ClassInfo&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all classes loadable from the current class path.

 @since 16.0]]>
      </doc>
    </method>
    <method name="getTopLevelClasses" return="com.google.common.collect.ImmutableSet&lt;com.google.common.reflect.ClassPath.ClassInfo&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all top level classes loadable from the current class path. Note that "top-level-ness"
 is determined heuristically by class name (see {@link ClassInfo#isTopLevel}).]]>
      </doc>
    </method>
    <method name="getTopLevelClasses" return="com.google.common.collect.ImmutableSet&lt;com.google.common.reflect.ClassPath.ClassInfo&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all top level classes whose package name is {@code packageName}.]]>
      </doc>
    </method>
    <method name="getTopLevelClassesRecursive" return="com.google.common.collect.ImmutableSet&lt;com.google.common.reflect.ClassPath.ClassInfo&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all top level classes whose package name is {@code packageName} or starts with {@code
 packageName} followed by a '.'.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Scans the source of a {@link ClassLoader} and finds all loadable classes and resources.

 <h2>Prefer <a href="https://github.com/classgraph/classgraph/wiki">ClassGraph</a> over {@code
 ClassPath}</h2>

 <p>We recommend using <a href="https://github.com/classgraph/classgraph/wiki">ClassGraph</a>
 instead of {@code ClassPath}. ClassGraph improves upon {@code ClassPath} in several ways,
 including addressing many of its limitations. Limitations of {@code ClassPath} include:

 <ul>
   <li>It looks only for files and JARs in URLs available from {@link URLClassLoader} instances or
       the {@linkplain ClassLoader#getSystemClassLoader() system class loader}. This means it does
       not look for classes in the <i>module path</i>.
   <li>It understands only {@code file:} URLs. This means that it does not understand <a
       href="https://openjdk.java.net/jeps/220">{@code jrt:/} URLs</a>, among <a
       href="https://github.com/classgraph/classgraph/wiki/Classpath-specification-mechanisms">others</a>.
   <li>It does not know how to look for classes when running under an Android VM. (ClassGraph does
       not support this directly, either, but ClassGraph documents how to <a
       href="https://github.com/classgraph/classgraph/wiki/Build-Time-Scanning">perform build-time
       classpath scanning and make the results available to an Android app</a>.)
   <li>Like all of Guava, it is not tested under Windows. We have gotten <a
       href="https://github.com/google/guava/issues/2130">a report of a specific bug under
       Windows</a>.
   <li>It <a href="https://github.com/google/guava/issues/2712">returns only one resource for a
       given path</a>, even if resources with that path appear in multiple jars or directories.
   <li>It assumes that <a href="https://github.com/google/guava/issues/3349">any class with a
       {@code $} in its name is a nested class</a>.
 </ul>

 <h2>{@code ClassPath} and symlinks</h2>

 <p>In the case of directory classloaders, symlinks are supported but cycles are not traversed.
 This guarantees discovery of each <em>unique</em> loadable resource. However, not all possible
 aliases for resources on cyclic paths will be listed.

 @author Ben Yu
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.ClassPath -->
  <!-- start class com.google.common.reflect.ClassPath.ClassInfo -->
  <class name="ClassPath.ClassInfo" extends="com.google.common.reflect.ClassPath.ResourceInfo"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getPackageName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the package name of the class, without attempting to load the class.

 <p>Behaves similarly to {@code class.getPackage().}{@link Package#getName() getName()} but
 does not require the class (or package) to be loaded.

 <p>But note that this method may behave differently for a class in the default package: For
 such classes, this method always returns an empty string. But under some version of Java,
 {@code class.getPackage().getName()} produces a {@code NullPointerException} because {@code
 class.getPackage()} returns {@code null}.]]>
      </doc>
    </method>
    <method name="getSimpleName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the simple name of the underlying class as given in the source code.

 <p>Behaves similarly to {@link Class#getSimpleName()} but does not require the class to be
 loaded.

 <p>But note that this class uses heuristics to identify the simple name. See a related
 discussion in <a href="https://github.com/google/guava/issues/3349">issue 3349</a>.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the fully qualified name of the class.

 <p>Behaves identically to {@link Class#getName()} but does not require the class to be
 loaded.]]>
      </doc>
    </method>
    <method name="isTopLevel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the class name "looks to be" top level (not nested), that is, it includes no
 '$' in the name. This method may return false for a top-level class that's intentionally
 named with the '$' character. If this is a concern, you could use {@link #load} and then
 check on the loaded {@link Class} object instead.

 @since 30.1]]>
      </doc>
    </method>
    <method name="load" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Loads (but doesn't link or initialize) the class.

 @throws LinkageError when there were errors in loading classes that this class depends on.
     For example, {@link NoClassDefFoundError}.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a class that can be loaded through {@link #load}.

 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.ClassPath.ClassInfo -->
  <!-- start class com.google.common.reflect.ClassPath.ResourceInfo -->
  <class name="ClassPath.ResourceInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="url" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the url identifying the resource.

 <p>See {@link ClassLoader#getResource}

 @throws NoSuchElementException if the resource cannot be loaded through the class loader,
     despite physically existing in the class path.]]>
      </doc>
    </method>
    <method name="asByteSource" return="com.google.common.io.ByteSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link ByteSource} view of the resource from which its bytes can be read.

 @throws NoSuchElementException if the resource cannot be loaded through the class loader,
     despite physically existing in the class path.
 @since 20.0]]>
      </doc>
    </method>
    <method name="asCharSource" return="com.google.common.io.CharSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
      <doc>
      <![CDATA[Returns a {@link CharSource} view of the resource from which its bytes can be read as
 characters decoded with the given {@code charset}.

 @throws NoSuchElementException if the resource cannot be loaded through the class loader,
     despite physically existing in the class path.
 @since 20.0]]>
      </doc>
    </method>
    <method name="getResourceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the fully qualified name of the resource. Such as "com/mycomp/foo/bar.txt".]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a class path resource that can be either a class file or any other resource file
 loadable from the class path.

 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.ClassPath.ResourceInfo -->
  <!-- start class com.google.common.reflect.ImmutableTypeToInstanceMap -->
  <class name="ImmutableTypeToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.reflect.TypeToInstanceMap&lt;B&gt;"/>
    <method name="of" return="com.google.common.reflect.ImmutableTypeToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an empty type to instance map.]]>
      </doc>
    </method>
    <method name="builder" return="com.google.common.reflect.ImmutableTypeToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new builder.]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unsupported operation">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @deprecated unsupported operation
 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unsupported operation">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @deprecated unsupported operation
 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="put" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unsupported operation">
      <param name="key" type="com.google.common.reflect.TypeToken&lt;? extends B&gt;"/>
      <param name="value" type="B"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @deprecated unsupported operation
 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unsupported operation">
      <param name="map" type="java.util.Map&lt;? extends com.google.common.reflect.TypeToken&lt;? extends B&gt;, ? extends B&gt;"/>
      <doc>
      <![CDATA[Guaranteed to throw an exception and leave the map unmodified.

 @deprecated unsupported operation
 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Map&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A type-to-instance map backed by an {@link ImmutableMap}. See also {@link
 MutableTypeToInstanceMap}.

 @author Ben Yu
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.ImmutableTypeToInstanceMap -->
  <!-- start class com.google.common.reflect.ImmutableTypeToInstanceMap.Builder -->
  <class name="ImmutableTypeToInstanceMap.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="put" return="com.google.common.reflect.ImmutableTypeToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,
 and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="put" return="com.google.common.reflect.ImmutableTypeToInstanceMap.Builder&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Associates {@code key} with {@code value} in the built map. Duplicate keys are not allowed,
 and will cause {@link #build} to fail.]]>
      </doc>
    </method>
    <method name="build" return="com.google.common.reflect.ImmutableTypeToInstanceMap&lt;B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new immutable type-to-instance map containing the entries provided to this builder.

 @throws IllegalArgumentException if duplicate keys were added]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A builder for creating immutable type-to-instance maps. Example:

 {@snippet :
 static final ImmutableTypeToInstanceMap<Handler<?>> HANDLERS =
     ImmutableTypeToInstanceMap.<Handler<?>>builder()
         .put(new TypeToken<Handler<Foo>>() {}, new FooHandler())
         .put(new TypeToken<Handler<Bar>>() {}, new SubBarHandler())
         .build();
 }

 <p>After invoking {@link #build()} it is still possible to add more entries and build again.
 Thus each map generated by this builder will be a superset of any map generated before it.

 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.ImmutableTypeToInstanceMap.Builder -->
  <!-- start class com.google.common.reflect.Invokable -->
  <class name="Invokable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.reflect.AnnotatedElement"/>
    <implements name="java.lang.reflect.Member"/>
    <method name="from" return="com.google.common.reflect.Invokable&lt;?, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns {@link Invokable} of {@code method}.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.reflect.Invokable&lt;T, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns {@link Invokable} of {@code constructor}.]]>
      </doc>
    </method>
    <method name="isAnnotationPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="annotationClass" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="getAnnotation" return="A"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="annotationClass" type="java.lang.Class&lt;A&gt;"/>
    </method>
    <method name="getAnnotations" return="java.lang.annotation.Annotation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeclaredAnnotations" return="java.lang.annotation.Annotation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeParameters" return="java.lang.reflect.TypeVariable[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link java.lang.reflect.GenericDeclaration#getTypeParameters()}.]]>
      </doc>
    </method>
    <method name="setAccessible"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[See {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)}.]]>
      </doc>
    </method>
    <method name="trySetAccessible" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link java.lang.reflect.AccessibleObject#trySetAccessible()}.]]>
      </doc>
    </method>
    <method name="isAccessible" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link java.lang.reflect.AccessibleObject#isAccessible()}.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getModifiers" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isSynthetic" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isPublic" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is public.]]>
      </doc>
    </method>
    <method name="isProtected" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is protected.]]>
      </doc>
    </method>
    <method name="isPackagePrivate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is package-private.]]>
      </doc>
    </method>
    <method name="isPrivate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is private.]]>
      </doc>
    </method>
    <method name="isStatic" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is static.]]>
      </doc>
    </method>
    <method name="isFinal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this method is final, per {@code Modifier.isFinal(getModifiers())}.

 <p>Note that a method may still be effectively "final", or non-overridable when it has no
 {@code final} keyword. For example, it could be private, or it could be declared by a final
 class. To tell whether a method is overridable, use {@link Invokable#isOverridable}.]]>
      </doc>
    </method>
    <method name="isAbstract" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the method is abstract.]]>
      </doc>
    </method>
    <method name="isNative" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the element is native.]]>
      </doc>
    </method>
    <method name="isSynchronized" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the method is synchronized.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isOverridable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this is an overridable method. Constructors, private, static or final
 methods, or methods declared by final classes are not overridable.]]>
      </doc>
    </method>
    <method name="isVarArgs" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this was declared to take a variable number of arguments.]]>
      </doc>
    </method>
    <method name="invoke" return="R"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="receiver" type="T"/>
      <param name="args" type="java.lang.Object[]"/>
      <exception name="InvocationTargetException" type="java.lang.reflect.InvocationTargetException"/>
      <exception name="IllegalAccessException" type="java.lang.IllegalAccessException"/>
      <doc>
      <![CDATA[Invokes with {@code receiver} as 'this' and {@code args} passed to the underlying method and
 returns the return value; or calls the underlying constructor with {@code args} and returns the
 constructed instance.

 @throws IllegalAccessException if this {@code Constructor} object enforces Java language access
     control and the underlying method or constructor is inaccessible.
 @throws IllegalArgumentException if the number of actual and formal parameters differ; if an
     unwrapping conversion for primitive arguments fails; or if, after possible unwrapping, a
     parameter value cannot be converted to the corresponding formal parameter type by a method
     invocation conversion.
 @throws InvocationTargetException if the underlying method or constructor throws an exception.]]>
      </doc>
    </method>
    <method name="getReturnType" return="com.google.common.reflect.TypeToken&lt;? extends R&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the return type of this {@code Invokable}.]]>
      </doc>
    </method>
    <method name="getParameters" return="com.google.common.collect.ImmutableList&lt;com.google.common.reflect.Parameter&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all declared parameters of this {@code Invokable}. Note that if this is a constructor
 of a non-static inner class, unlike {@link Constructor#getParameterTypes}, the hidden {@code
 this} parameter of the enclosing class is excluded from the returned parameters.]]>
      </doc>
    </method>
    <method name="getExceptionTypes" return="com.google.common.collect.ImmutableList&lt;com.google.common.reflect.TypeToken&lt;? extends java.lang.Throwable&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all declared exception types of this {@code Invokable}.]]>
      </doc>
    </method>
    <method name="returning" return="com.google.common.reflect.Invokable&lt;T, R1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="returnType" type="java.lang.Class&lt;R1&gt;"/>
      <doc>
      <![CDATA[Explicitly specifies the return type of this {@code Invokable}. For example:

 {@snippet :
 Method factoryMethod = Person.class.getMethod("create");
 Invokable<?, Person> factory = Invokable.of(getNameMethod).returning(Person.class);
 }]]>
      </doc>
    </method>
    <method name="returning" return="com.google.common.reflect.Invokable&lt;T, R1&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="returnType" type="com.google.common.reflect.TypeToken&lt;R1&gt;"/>
      <doc>
      <![CDATA[Explicitly specifies the return type of this {@code Invokable}.]]>
      </doc>
    </method>
    <method name="getDeclaringClass" return="java.lang.Class&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerType" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of {@code T}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Wrapper around either a {@link Method} or a {@link Constructor}. Convenience API is provided to
 make common reflective operation easier to deal with, such as {@link #isPublic}, {@link
 #getParameters} etc.

 <p>In addition to convenience methods, {@link TypeToken#method} and {@link TypeToken#constructor}
 will resolve the type parameters of the method or constructor in the context of the owner type,
 which may be a subtype of the declaring class. For example:

 {@snippet :
 Method getMethod = List.class.getMethod("get", int.class);
 Invokable<List<String>, ?> invokable = new TypeToken<List<String>>() {}.method(getMethod);
 assertEquals(TypeToken.of(String.class), invokable.getReturnType()); // Not Object.class!
 assertEquals(new TypeToken<List<String>>() {}, invokable.getOwnerType());
 }

 <p><b>Note:</b> earlier versions of this class inherited from {@link
 java.lang.reflect.AccessibleObject AccessibleObject} and {@link
 java.lang.reflect.GenericDeclaration GenericDeclaration}. Since version 31.0 that is no longer
 the case. However, most methods from those types are present with the same signature in this
 class.

 @param <T> the type that owns this method or constructor.
 @param <R> the return type of (or supertype thereof) the method or the declaring type of the
     constructor.
 @author Ben Yu
 @since 14.0 (no longer implements {@link AccessibleObject} or {@code GenericDeclaration} since
     31.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.Invokable -->
  <!-- start class com.google.common.reflect.MutableTypeToInstanceMap -->
  <class name="MutableTypeToInstanceMap" extends="com.google.common.collect.ForwardingMap&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.reflect.TypeToInstanceMap&lt;B&gt;"/>
    <constructor name="MutableTypeToInstanceMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new map.]]>
      </doc>
    </constructor>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
    </method>
    <method name="putInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
    </method>
    <method name="putInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
    </method>
    <method name="put" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unsupported operation">
      <param name="key" type="com.google.common.reflect.TypeToken&lt;? extends B&gt;"/>
      <param name="value" type="B extends java.lang.Object"/>
      <doc>
      <![CDATA[Not supported. Use {@link #putInstance} instead.

 @deprecated unsupported operation
 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="unsupported operation">
      <param name="map" type="java.util.Map&lt;? extends com.google.common.reflect.TypeToken&lt;? extends B&gt;, ? extends B&gt;"/>
      <doc>
      <![CDATA[Not supported. Use {@link #putInstance} instead.

 @deprecated unsupported operation
 @throws UnsupportedOperationException always]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="delegate" return="java.util.Map&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A mutable type-to-instance map. See also {@link ImmutableTypeToInstanceMap}.

 @author Ben Yu
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.MutableTypeToInstanceMap -->
  <!-- start class com.google.common.reflect.Parameter -->
  <class name="Parameter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.reflect.AnnotatedElement"/>
    <method name="getType" return="com.google.common.reflect.TypeToken&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type of the parameter.]]>
      </doc>
    </method>
    <method name="getDeclaringInvokable" return="com.google.common.reflect.Invokable&lt;?, ?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Invokable} that declares this parameter.]]>
      </doc>
    </method>
    <method name="isAnnotationPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="getAnnotation" return="A"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;A&gt;"/>
    </method>
    <method name="getAnnotations" return="java.lang.annotation.Annotation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotationsByType" return="A[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;A&gt;"/>
      <doc>
      <![CDATA[@since 18.0]]>
      </doc>
    </method>
    <method name="getDeclaredAnnotations" return="java.lang.annotation.Annotation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 18.0]]>
      </doc>
    </method>
    <method name="getDeclaredAnnotation" return="A"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;A&gt;"/>
      <doc>
      <![CDATA[@since 18.0]]>
      </doc>
    </method>
    <method name="getDeclaredAnnotationsByType" return="A[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;A&gt;"/>
      <doc>
      <![CDATA[@since 18.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents a method or constructor parameter.

 @author Ben Yu
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.Parameter -->
  <!-- start class com.google.common.reflect.Reflection -->
  <class name="Reflection" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getPackageName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the package name of {@code clazz} according to the Java Language Specification (section
 6.7). Unlike {@link Class#getPackage}, this method only parses the class name, without
 attempting to define the {@link Package} and hence load files.]]>
      </doc>
    </method>
    <method name="getPackageName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classFullName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the package name of {@code classFullName} according to the Java Language Specification
 (section 6.7). Unlike {@link Class#getPackage}, this method only parses the class name, without
 attempting to define the {@link Package} and hence load files.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Ensures that the given classes are initialized, as described in <a
 href="http://java.sun.com/docs/books/jls/third_edition/html/execution.html#12.4.2">JLS Section
 12.4.2</a>.

 <p>WARNING: Normally it's a smell if a class needs to be explicitly initialized, because static
 state hurts system maintainability and testability. In cases when you have no choice while
 interoperating with a legacy framework, this method helps to keep the code less ugly.

 @throws ExceptionInInitializerError if an exception is thrown during initialization of a class]]>
      </doc>
    </method>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="handler" type="java.lang.reflect.InvocationHandler"/>
      <doc>
      <![CDATA[Returns a proxy instance that implements {@code interfaceType} by dispatching method
 invocations to {@code handler}. The class loader of {@code interfaceType} will be used to
 define the proxy class. To implement multiple interfaces or specify a class loader, use {@link
 Proxy#newProxyInstance}.

 @throws IllegalArgumentException if {@code interfaceType} does not specify the type of a Java
     interface]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utilities relating to Java reflection.

 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.Reflection -->
  <!-- start class com.google.common.reflect.TypeParameter -->
  <class name="TypeParameter" extends="com.google.common.reflect.TypeCapture&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeParameter"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Captures a free type variable that can be used in {@link TypeToken#where}. For example:

 {@snippet :
 static <T> TypeToken<List<T>> listOf(Class<T> elementType) {
   return new TypeToken<List<T>>() {}
       .where(new TypeParameter<T>() {}, elementType);
 }
 }

 @author Ben Yu
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.TypeParameter -->
  <!-- start class com.google.common.reflect.TypeResolver -->
  <class name="TypeResolver" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeResolver"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="where" return="com.google.common.reflect.TypeResolver"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="formal" type="java.lang.reflect.Type"/>
      <param name="actual" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a new {@code TypeResolver} with type variables in {@code formal} mapping to types in
 {@code actual}.

 <p>For example, if {@code formal} is a {@code TypeVariable T}, and {@code actual} is {@code
 String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain
 #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve
 {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and
 {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they
 can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination
 thereof.

 @param formal The type whose type variables or itself is mapped to other type(s). It's almost
     always a bug if {@code formal} isn't a type variable and contains no type variable. Make
     sure you are passing the two parameters in the right order.
 @param actual The type that the formal type variable(s) are mapped to. It can be or contain yet
     other type variables, in which case these type variables will be further resolved if
     corresponding mappings exist in the current {@code TypeResolver} instance.]]>
      </doc>
    </method>
    <method name="resolveType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Resolves all type variables in {@code type} and all downstream types and returns a
 corresponding type with type variables resolved.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object of this class encapsulates type mappings from type variables. Mappings are established
 with {@link #where} and types are resolved using {@link #resolveType}.

 <p>Note that usually type mappings are already implied by the static type hierarchy (for example,
 the {@code E} type variable declared by class {@code List} naturally maps to {@code String} in
 the context of {@code class MyStringList implements List<String>}). In such case, prefer to use
 {@link TypeToken#resolveType} since it's simpler and more type safe. This class should only be
 used when the type mapping isn't implied by the static type hierarchy, but provided through other
 means such as an annotation or external configuration file.

 @author Ben Yu
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.TypeResolver -->
  <!-- start interface com.google.common.reflect.TypeToInstanceMap -->
  <interface name="TypeToInstanceMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map&lt;com.google.common.reflect.TypeToken&lt;? extends B&gt;, B&gt;"/>
    <method name="getInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value the specified class is mapped to, or {@code null} if no entry for this class
 is present. This will only return a value that was bound to this specific class, not a value
 that may have been bound to a subtype.

 <p>{@code getInstance(Foo.class)} is equivalent to {@code
 getInstance(TypeToken.of(Foo.class))}.]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the value the specified type is mapped to, or {@code null} if no entry for this type is
 present. This will only return a value that was bound to this specific type, not a value that
 may have been bound to a subtype.]]>
      </doc>
    </method>
    <method name="putInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Maps the specified class to the specified value. Does <i>not</i> associate this value with any
 of the class's supertypes.

 <p>{@code putInstance(Foo.class, foo)} is equivalent to {@code
 putInstance(TypeToken.of(Foo.class), foo)}.

 @return the value previously associated with this class (possibly {@code null}), or {@code
     null} if there was no previous entry.]]>
      </doc>
    </method>
    <method name="putInstance" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;T&gt;"/>
      <param name="value" type="T extends B"/>
      <doc>
      <![CDATA[Maps the specified type to the specified value. Does <i>not</i> associate this value with any
 of the type's supertypes.

 @return the value previously associated with this type (possibly {@code null}), or {@code null}
     if there was no previous entry.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A map, each entry of which maps a {@link TypeToken} to an instance of that type. In addition to
 implementing {@code Map}, the additional type-safe operations {@link #putInstance} and {@link
 #getInstance} are available.

 <p>Generally, implementations don't support {@link #put} and {@link #putAll} because there is no
 way to check an object at runtime to be an instance of a {@link TypeToken}. Instead, caller
 should use the type safe {@link #putInstance}.

 <p>Also, if caller suppresses unchecked warnings and passes in an {@code Iterable<String>} for
 type {@code Iterable<Integer>}, the map won't be able to detect and throw type error.

 <p>Like any other {@code Map<Class, Object>}, this map may contain entries for primitive types,
 and a primitive type and its corresponding wrapper type may map to different values.

 @param <B> the common supertype that all entries must share; often this is simply {@link Object}
 @author Ben Yu
 @since 13.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.reflect.TypeToInstanceMap -->
  <!-- start class com.google.common.reflect.TypeToken -->
  <class name="TypeToken" extends="com.google.common.reflect.TypeCapture&lt;T&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="TypeToken"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type token of {@code T}.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.

 <p>For example:

 {@snippet :
 TypeToken<List<String>> t = new TypeToken<List<String>>() {};
 }]]>
      </doc>
    </constructor>
    <constructor name="TypeToken" type="java.lang.Class&lt;?&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type token of {@code T} while resolving free type variables in the context of
 {@code declaringClass}.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the
 anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure.

 <p>For example:

 {@snippet :
 abstract class IKnowMyType<T> {
   TypeToken<T> getMyType() {
     return new TypeToken<T>(getClass()) {};
   }
 }

 new IKnowMyType<String>() {}.getMyType() => String
 }]]>
      </doc>
    </constructor>
    <method name="of" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns an instance of type token that wraps {@code type}.]]>
      </doc>
    </method>
    <method name="of" return="com.google.common.reflect.TypeToken&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns an instance of type token that wraps {@code type}.]]>
      </doc>
    </method>
    <method name="getRawType" return="java.lang.Class&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw type of {@code T}. Formally speaking, if {@code T} is returned by {@link
 java.lang.reflect.Method#getGenericReturnType}, the raw type is what's returned by {@link
 java.lang.reflect.Method#getReturnType} of the same method object. Specifically:

 <ul>
   <li>If {@code T} is a {@code Class} itself, {@code T} itself is returned.
   <li>If {@code T} is a {@link ParameterizedType}, the raw type of the parameterized type is
       returned.
   <li>If {@code T} is a {@link GenericArrayType}, the returned type is the corresponding array
       class. For example: {@code List<Integer>[] => List[]}.
   <li>If {@code T} is a type variable or a wildcard type, the raw type of the first upper bound
       is returned. For example: {@code <X extends Foo> => Foo}.
 </ul>]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the represented type.]]>
      </doc>
    </method>
    <method name="where" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="typeParam" type="com.google.common.reflect.TypeParameter&lt;X&gt;"/>
      <param name="typeArg" type="com.google.common.reflect.TypeToken&lt;X&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are
 substituted by {@code typeArg}. For example, it can be used to construct {@code Map<K, V>} for
 any {@code K} and {@code V} type:

 {@snippet :
 static <K, V> TypeToken<Map<K, V>> mapOf(
     TypeToken<K> keyType, TypeToken<V> valueType) {
   return new TypeToken<Map<K, V>>() {}
       .where(new TypeParameter<K>() {}, keyType)
       .where(new TypeParameter<V>() {}, valueType);
 }
 }

 @param <X> The parameter type
 @param typeParam the parameter type variable
 @param typeArg the actual type to substitute]]>
      </doc>
    </method>
    <method name="where" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="typeParam" type="com.google.common.reflect.TypeParameter&lt;X&gt;"/>
      <param name="typeArg" type="java.lang.Class&lt;X&gt;"/>
      <doc>
      <![CDATA[Returns a new {@code TypeToken} where type variables represented by {@code typeParam} are
 substituted by {@code typeArg}. For example, it can be used to construct {@code Map<K, V>} for
 any {@code K} and {@code V} type:

 {@snippet :
 static <K, V> TypeToken<Map<K, V>> mapOf(
     Class<K> keyType, Class<V> valueType) {
   return new TypeToken<Map<K, V>>() {}
       .where(new TypeParameter<K>() {}, keyType)
       .where(new TypeParameter<V>() {}, valueType);
 }
 }

 @param <X> The parameter type
 @param typeParam the parameter type variable
 @param typeArg the actual type to substitute]]>
      </doc>
    </method>
    <method name="resolveType" return="com.google.common.reflect.TypeToken&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Resolves the given {@code type} against the type context represented by this type. For example:

 {@snippet :
 new TypeToken<List<String>>() {}.resolveType(
     List.class.getMethod("get", int.class).getGenericReturnType())
 => String.class
 }]]>
      </doc>
    </method>
    <method name="getTypes" return="com.google.common.reflect.TypeToken&lt;T&gt;.TypeSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of interfaces and classes that this type is or is a subtype of. The returned
 types are parameterized with proper type arguments.

 <p>Subtypes are always listed before supertypes. But the reverse is not true. A type isn't
 necessarily a subtype of all the types following. Order between types without subtype
 relationship is arbitrary and not guaranteed.

 <p>If this type is a type variable or wildcard, upper bounds that are themselves type variables
 aren't included (their super interfaces and superclasses are).]]>
      </doc>
    </method>
    <method name="getSupertype" return="com.google.common.reflect.TypeToken&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="superclass" type="java.lang.Class&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns the generic form of {@code superclass}. For example, if this is {@code
 ArrayList<String>}, {@code Iterable<String>} is returned given the input {@code
 Iterable.class}.]]>
      </doc>
    </method>
    <method name="getSubtype" return="com.google.common.reflect.TypeToken&lt;? extends T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="subclass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns subtype of {@code this} with {@code subclass} as the raw class. For example, if this is
 {@code Iterable<String>} and {@code subclass} is {@code List}, {@code List<String>} is
 returned.]]>
      </doc>
    </method>
    <method name="isSupertypeOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns true if this type is a supertype of the given {@code type}. "Supertype" is defined
 according to <a
 href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type
 arguments</a> introduced with Java generics.

 @since 19.0]]>
      </doc>
    </method>
    <method name="isSupertypeOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns true if this type is a supertype of the given {@code type}. "Supertype" is defined
 according to <a
 href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type
 arguments</a> introduced with Java generics.

 @since 19.0]]>
      </doc>
    </method>
    <method name="isSubtypeOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.common.reflect.TypeToken&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns true if this type is a subtype of the given {@code type}. "Subtype" is defined
 according to <a
 href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type
 arguments</a> introduced with Java generics.

 @since 19.0]]>
      </doc>
    </method>
    <method name="isSubtypeOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="supertype" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns true if this type is a subtype of the given {@code type}. "Subtype" is defined
 according to <a
 href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5.1">the rules for type
 arguments</a> introduced with Java generics.

 @since 19.0]]>
      </doc>
    </method>
    <method name="isArray" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this type is known to be an array type, such as {@code int[]}, {@code T[]},
 {@code <? extends Map<String, Integer>[]>} etc.]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this type is one of the nine primitive types (including {@code void}).

 @since 15.0]]>
      </doc>
    </method>
    <method name="wrap" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the corresponding wrapper type if this is a primitive type; otherwise returns {@code
 this} itself. Idempotent.

 @since 15.0]]>
      </doc>
    </method>
    <method name="unwrap" return="com.google.common.reflect.TypeToken&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the corresponding primitive type if this is a wrapper type; otherwise returns {@code
 this} itself. Idempotent.

 @since 15.0]]>
      </doc>
    </method>
    <method name="getComponentType" return="TypeToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the array component type if this type represents an array ({@code int[]}, {@code T[]},
 {@code <? extends Map<String, Integer>[]>} etc.), or else {@code null} is returned.]]>
      </doc>
    </method>
    <method name="method" return="com.google.common.reflect.Invokable&lt;T, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns the {@link Invokable} for {@code method}, which must be a member of {@code T}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="constructor" return="com.google.common.reflect.Invokable&lt;T, T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="constructor" type="java.lang.reflect.Constructor&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the {@link Invokable} for {@code constructor}, which must be a member of {@code T}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="Object"/>
      <doc>
      <![CDATA[Returns true if {@code o} is another {@code TypeToken} that represents the same {@link Type}.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeReplace" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implemented to support serialization of subclasses.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Type} with generics.

 <p>Operations that are otherwise only available in {@link Class} are implemented to support
 {@code Type}, for example {@link #isSubtypeOf}, {@link #isArray} and {@link #getComponentType}.
 It also provides additional utilities such as {@link #getTypes}, {@link #resolveType}, etc.

 <p>There are three ways to get a {@code TypeToken} instance:

 <ul>
   <li>Wrap a {@code Type} obtained via reflection. For example: {@code
       TypeToken.of(method.getGenericReturnType())}.
   <li>Capture a generic type with a (usually anonymous) subclass. For example:
       {@snippet :
 new TypeToken<List<String>>() {}
 }
       <p>Note that it's critical that the actual type argument is carried by a subclass. The
       following code is wrong because it only captures the {@code <T>} type variable of the
       {@code listType()} method signature; while {@code <String>} is lost in erasure:
       {@snippet :
 class Util {
   static <T> TypeToken<List<T>> listType() {
     return new TypeToken<List<T>>() {};
   }
 }

 TypeToken<List<String>> stringListType = Util.<String>listType();
 }
   <li>Capture a generic type with a (usually anonymous) subclass and resolve it against a context
       class that knows what the type parameters are. For example:
       {@snippet :
 abstract class IKnowMyType<T> {
   TypeToken<T> type = new TypeToken<T>(getClass()) {};
 }
 new IKnowMyType<String>() {}.type => String
 }
 </ul>

 <p>{@code TypeToken} is serializable when no type variable is contained in the type.

 <p>Note to Guice users: {@code TypeToken} is similar to Guice's {@code TypeLiteral} class except
 that it is serializable and offers numerous additional utility methods.

 @author Bob Lee
 @author Sven Mawson
 @author Ben Yu
 @since 12.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.TypeToken -->
  <!-- start class com.google.common.reflect.TypeToken.TypeSet -->
  <class name="TypeToken.TypeSet" extends="com.google.common.collect.ForwardingSet&lt;com.google.common.reflect.TypeToken&lt;? super T&gt;&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="interfaces" return="com.google.common.reflect.TypeToken&lt;T&gt;.TypeSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the types that are interfaces implemented by this type.]]>
      </doc>
    </method>
    <method name="classes" return="com.google.common.reflect.TypeToken&lt;T&gt;.TypeSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the types that are classes.]]>
      </doc>
    </method>
    <method name="delegate" return="java.util.Set&lt;com.google.common.reflect.TypeToken&lt;? super T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="rawTypes" return="java.util.Set&lt;java.lang.Class&lt;? super T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw types of the types in this set, in the same order.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The set of interfaces and classes that {@code T} is or is a subtype of. {@link Object} is not
 included in the set if this type is an interface.

 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.reflect.TypeToken.TypeSet -->
</package>
<package name="com.google.common.util.concurrent">
  <!-- start class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <class name="AbstractExecutionThreadService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractExecutionThreadService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service. This method is invoked on the execution thread.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="run"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run the service. This method is invoked on the execution thread. Implementations must respond
 to stop requests. You could poll for lifecycle changes in a work loop:

 <pre>
   public void run() {
     while ({@link #isRunning()}) {
       // perform a unit of work
     }
   }
 </pre>

 <p>...or you could respond to stop requests by implementing {@link #triggerShutdown()}, which
 should cause {@link #run()} to return.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service. This method is invoked on the execution thread.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="triggerShutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoked to request the service to stop.

 <p>By default this method does nothing.

 <p>Currently, this method is invoked while holding a lock. If an implementation of this method
 blocks, it can prevent this service from changing state. If you need to performing a blocking
 operation in order to trigger shutdown, consider instead registering a listener and
 implementing {@code stopping}. Note, however, that {@code stopping} does not run at exactly the
 same times as {@code triggerShutdown}.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service. Subclasses may override
 this method to use a custom {@link Executor}, which may configure its worker thread with a
 specific name, thread group or priority. The returned executor's {@link
 Executor#execute(Runnable) execute()} method is called when this service is started, and should
 return promptly.

 <p>The default implementation returns a new {@link Executor} that sets the name of its threads
 to the string returned by {@link #serviceName}]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[@since 13.0]]>
      </doc>
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 14.0]]>
      </doc>
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="serviceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this service. {@link AbstractExecutionThreadService} may include the name
 in debugging output.

 <p>Subclasses may override this method.

 @since 14.0 (present in 10.0 as getServiceName)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Base class for services that can implement {@link #startUp}, {@link #run} and {@link #shutDown}
 methods. This class uses a single thread to execute the service; consider {@link AbstractService}
 if you would like to manage any threading manually.

 @author Jesse Wilson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractExecutionThreadService -->
  <!-- start class com.google.common.util.concurrent.AbstractFuture -->
  <class name="AbstractFuture" extends="com.google.common.util.concurrent.AbstractFutureState&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="get" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the
 current thread is interrupted during the call, even if the value is already available.

 @throws CancellationException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="get" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>The default {@link AbstractFuture} implementation throws {@code InterruptedException} if the
 current thread is interrupted during the call, even if the value is already available.

 @throws CancellationException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>If a cancellation attempt succeeds on a {@code Future} that had previously been {@linkplain
 #setFuture set asynchronously}, then the cancellation will also be propagated to the delegate
 {@code Future} that was supplied in the {@code setFuture} call.

 <p>Rather than override this method to perform additional cancellation work or cleanup,
 subclasses should override {@link #afterDone}, consulting {@link #isCancelled} and {@link
 #wasInterrupted} as necessary. This ensures that the work is done even if the future is
 cancelled without a call to {@code cancel}, such as by calling {@code
 setFuture(cancelledFuture)}.

 <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
 acquire other locks, risking deadlocks.]]>
      </doc>
    </method>
    <method name="interruptTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Subclasses can override this method to implement interruption of the future's computation. The
 method is invoked automatically by a successful call to {@link #cancel(boolean) cancel(true)}.

 <p>The default implementation does nothing.

 <p>This method is likely to be deprecated. Prefer to override {@link #afterDone}, checking
 {@link #wasInterrupted} to decide whether to interrupt your task.

 @since 10.0]]>
      </doc>
    </method>
    <method name="wasInterrupted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this future was cancelled with {@code mayInterruptIfRunning} set to {@code
 true}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @since 10.0]]>
      </doc>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Sets the result of this {@code Future} unless this {@code Future} has already been cancelled or
 set (including {@linkplain #setFuture set asynchronously}). When a call to this method returns,
 the {@code Future} is guaranteed to be {@linkplain #isDone done} <b>only if</b> the call was
 accepted (in which case it returns {@code true}). If it returns {@code false}, the {@code
 Future} may have previously been set asynchronously, in which case its result may not be known
 yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}
 method, only by a call to {@link #cancel}.

 <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
 acquire other locks, risking deadlocks.

 @param value the value to be used as the result
 @return true if the attempt was accepted, completing the {@code Future}]]>
      </doc>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Sets the failed result of this {@code Future} unless this {@code Future} has already been
 cancelled or set (including {@linkplain #setFuture set asynchronously}). When a call to this
 method returns, the {@code Future} is guaranteed to be {@linkplain #isDone done} <b>only if</b>
 the call was accepted (in which case it returns {@code true}). If it returns {@code false}, the
 {@code Future} may have previously been set asynchronously, in which case its result may not be
 known yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}
 method, only by a call to {@link #cancel}.

 <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
 acquire other locks, risking deadlocks.

 @param throwable the exception to be used as the failed result
 @return true if the attempt was accepted, completing the {@code Future}]]>
      </doc>
    </method>
    <method name="setFuture" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;"/>
      <doc>
      <![CDATA[Sets the result of this {@code Future} to match the supplied input {@code Future} once the
 supplied {@code Future} is done, unless this {@code Future} has already been cancelled or set
 (including "set asynchronously," defined below).

 <p>If the supplied future is {@linkplain #isDone done} when this method is called and the call
 is accepted, then this future is guaranteed to have been completed with the supplied future by
 the time this method returns. If the supplied future is not done and the call is accepted, then
 the future will be <i>set asynchronously</i>. Note that such a result, though not yet known,
 cannot be overridden by a call to a {@code set*} method, only by a call to {@link #cancel}.

 <p>If the call {@code setFuture(delegate)} is accepted and this {@code Future} is later
 cancelled, cancellation will be propagated to {@code delegate}. Additionally, any call to
 {@code setFuture} after any cancellation will propagate cancellation to the supplied {@code
 Future}.

 <p>Note that, even if the supplied future is cancelled and it causes this future to complete,
 it will never trigger interruption behavior. In particular, it will not cause this future to
 invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not
 return {@code true}.

 <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
 acquire other locks, risking deadlocks.

 @param future the future to delegate to
 @return true if the attempt was accepted, indicating that the {@code Future} was not previously
     cancelled or set.
 @since 19.0]]>
      </doc>
    </method>
    <method name="afterDone"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Callback method that is called exactly once after the future is completed.

 <p>If {@link #interruptTask} is also run during completion, {@link #afterDone} runs after it.

 <p>The default implementation of this method in {@code AbstractFuture} does nothing. This is
 intended for very lightweight cleanup work, for example, timing statistics or clearing fields.
 If your task does anything heavier consider, just using a listener with an executor.

 @since 20.0]]>
      </doc>
    </method>
    <method name="tryInternalFastPathGetFailure" return="Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Usually returns {@code null} but, if this {@code Future} has failed, may <i>optionally</i>
 return the cause of the failure. "Failure" means specifically "completed with an exception"; it
 does not include "was cancelled." To be explicit: If this method returns a non-null value,
 then:

 <ul>
   <li>{@code isDone()} must return {@code true}
   <li>{@code isCancelled()} must return {@code false}
   <li>{@code get()} must not block, and it must throw an {@code ExecutionException} with the
       return value of this method as its cause
 </ul>

 <p>This method is {@code protected} so that classes like {@code
 com.google.common.util.concurrent.SettableFuture} do not expose it to their users as an
 instance method. In the unlikely event that you need to call this method, call {@link
 InternalFutures#tryInternalFastPathGetFailure(InternalFutureFailureAccess)}.

 @since 27.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pendingToString" return="String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provide a human-readable explanation of why this future has not yet completed.

 @return null if an explanation cannot be provided (e.g. because the future is done).
 @since 23.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract implementation of {@link ListenableFuture}, intended for advanced users only. More
 common ways to create a {@code ListenableFuture} include instantiating a {@link SettableFuture},
 submitting a task to a {@link ListeningExecutorService}, and deriving a {@code Future} from an
 existing one, typically using methods like {@link Futures#transform(ListenableFuture,
 com.google.common.base.Function, java.util.concurrent.Executor) Futures.transform} and {@link
 Futures#catching(ListenableFuture, Class, com.google.common.base.Function,
 java.util.concurrent.Executor) Futures.catching}.

 <p>This class implements all methods in {@code ListenableFuture}. Subclasses should provide a way
 to set the result of the computation through the protected methods {@link #set(Object)}, {@link
 #setFuture(ListenableFuture)} and {@link #setException(Throwable)}. Subclasses may also override
 {@link #afterDone()}, which will be invoked automatically when the future completes. Subclasses
 should rarely override other methods.

 @author Sven Mawson
 @author Luke Sandberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractFuture -->
  <!-- start class com.google.common.util.concurrent.AbstractIdleService -->
  <class name="AbstractIdleService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractIdleService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="startUp"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Executor} that will be used to run this service. Subclasses may override
 this method to use a custom {@link Executor}, which may configure its worker thread with a
 specific name, thread group or priority. The returned executor's {@link
 Executor#execute(Runnable) execute()} method is called when this service is started and
 stopped, and should return promptly.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[@since 13.0]]>
      </doc>
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 14.0]]>
      </doc>
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="serviceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this service. {@link AbstractIdleService} may include the name in debugging
 output.

 @since 14.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Base class for services that do not need a thread while "running" but may need one during startup
 and shutdown. Subclasses can implement {@link #startUp} and {@link #shutDown} methods, each which
 run in an executor which by default uses a separate thread for each method.

 @author Chris Nokleberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractIdleService -->
  <!-- start class com.google.common.util.concurrent.AbstractListeningExecutorService -->
  <class name="AbstractListeningExecutorService" extends="java.util.concurrent.AbstractExecutorService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListeningExecutorService"/>
    <constructor name="AbstractListeningExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="newTaskFor" return="java.util.concurrent.RunnableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="value" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[@since 19.0 (present with return type {@code ListenableFutureTask} since 14.0)]]>
      </doc>
    </method>
    <method name="newTaskFor" return="java.util.concurrent.RunnableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <doc>
      <![CDATA[@since 19.0 (present with return type {@code ListenableFutureTask} since 14.0)]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="T extends java.lang.Object"/>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[Abstract {@link ListeningExecutorService} implementation that creates {@link ListenableFuture}
 instances for each {@link Runnable} and {@link Callable} submitted to it. These tasks are run
 with the abstract {@link #execute execute(Runnable)} method.

 <p>In addition to {@link #execute}, subclasses must implement all methods related to shutdown and
 termination.

 @author Chris Povirk
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractListeningExecutorService -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService -->
  <class name="AbstractScheduledService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractScheduledService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="runOneIteration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run one iteration of the scheduled task. If any invocation of this method throws an exception,
 the service will transition to the {@link Service.State#FAILED} state and this method will no
 longer be called.]]>
      </doc>
    </method>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Start the service.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="shutDown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Stop the service. This is guaranteed not to run concurrently with {@link #runOneIteration}.

 <p>By default this method does nothing.]]>
      </doc>
    </method>
    <method name="scheduler" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Scheduler} object used to configure this service. This method will only be
 called once.]]>
      </doc>
    </method>
    <method name="executor" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link ScheduledExecutorService} that will be used to execute the {@link #startUp},
 {@link #runOneIteration} and {@link #shutDown} methods. If this method is overridden the
 executor will not be {@linkplain ScheduledExecutorService#shutdown shutdown} when this service
 {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED
 fails}. Subclasses may override this method to supply a custom {@link ScheduledExecutorService}
 instance. This method is guaranteed to only be called once.

 <p>By default this returns a new {@link ScheduledExecutorService} with a single thread pool
 that sets the name of the thread to the {@linkplain #serviceName() service name}. Also, the
 pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service
 {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED
 fails}.]]>
      </doc>
    </method>
    <method name="serviceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of this service. {@link AbstractScheduledService} may include the name in
 debugging output.

 @since 14.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[@since 13.0]]>
      </doc>
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 14.0]]>
      </doc>
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@since 15.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Base class for services that can implement {@link #startUp} and {@link #shutDown} but while in
 the "running" state need to perform a periodic task. Subclasses can implement {@link #startUp},
 {@link #shutDown} and also a {@link #runOneIteration} method that will be executed periodically.

 <p>This class uses the {@link ScheduledExecutorService} returned from {@link #executor} to run
 the {@link #startUp} and {@link #shutDown} methods and also uses that service to schedule the
 {@link #runOneIteration} that will be executed periodically as specified by its {@link
 Scheduler}. When this service is asked to stop via {@link #stopAsync} it will cancel the periodic
 task (but not interrupt it) and wait for it to stop before running the {@link #shutDown} method.

 <p>Subclasses are guaranteed that the life cycle methods ({@link #runOneIteration}, {@link
 #startUp} and {@link #shutDown}) will never run concurrently. Notably, if any execution of {@link
 #runOneIteration} takes longer than its schedule defines, then subsequent executions may start
 late. Also, all life cycle methods are executed with a lock held, so subclasses can safely modify
 shared state without additional synchronization necessary for visibility to later executions of
 the life cycle methods.

 <h3>Usage Example</h3>

 <p>Here is a sketch of a service which crawls a website and uses the scheduling capabilities to
 rate limit itself.

 {@snippet :
 class CrawlingService extends AbstractScheduledService {
   private Set<Uri> visited;
   private Queue<Uri> toCrawl;
   protected void startUp() throws Exception {
     toCrawl = readStartingUris();
   }

   protected void runOneIteration() throws Exception {
     Uri uri = toCrawl.remove();
     Collection<Uri> newUris = crawl(uri);
     visited.add(uri);
     for (Uri newUri : newUris) {
       if (!visited.contains(newUri)) { toCrawl.add(newUri); }
     }
   }

   protected void shutDown() throws Exception {
     saveUris(toCrawl);
   }

   protected Scheduler scheduler() {
     return Scheduler.newFixedRateSchedule(0, 1, TimeUnit.SECONDS);
   }
 }
 }

 <p>This class uses the life cycle methods to read in a list of starting URIs and save the set of
 outstanding URIs when shutting down. Also, it takes advantage of the scheduling functionality to
 rate limit the number of queries we perform.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler -->
  <class name="AbstractScheduledService.CustomScheduler" extends="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CustomScheduler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="getNextSchedule" return="com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.Schedule"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Calculates the time at which to next invoke the task.

 <p>This is guaranteed to be called immediately after the task has completed an iteration and
 on the same thread as the previous execution of {@link
 AbstractScheduledService#runOneIteration}.

 @return a schedule that defines the delay before the next execution.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Scheduler} that provides a convenient way for the {@link AbstractScheduledService} to
 use a dynamically changing schedule. After every execution of the task, assuming it hasn't been
 cancelled, the {@link #getNextSchedule} method will be called.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.Schedule -->
  <class name="AbstractScheduledService.CustomScheduler.Schedule" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="protected"
    deprecated="not deprecated">
    <constructor name="Schedule" type="long, java.util.concurrent.TimeUnit"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param delay the time from now to delay execution
 @param unit the time unit of the delay parameter]]>
      </doc>
    </constructor>
    <constructor name="Schedule" type="java.time.Duration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param delay the time from now to delay execution
 @since 33.4.0 (but since 31.1 in the JRE flavor)]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A value object that represents an absolute delay until a task should be invoked.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService.CustomScheduler.Schedule -->
  <!-- start class com.google.common.util.concurrent.AbstractScheduledService.Scheduler -->
  <class name="AbstractScheduledService.Scheduler" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newFixedDelaySchedule" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialDelay" type="java.time.Duration"/>
      <param name="delay" type="java.time.Duration"/>
      <doc>
      <![CDATA[Returns a {@link Scheduler} that schedules the task using the {@link
 ScheduledExecutorService#scheduleWithFixedDelay} method.

 @param initialDelay the time to delay first execution
 @param delay the delay between the termination of one execution and the commencement of the
     next
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="newFixedDelaySchedule" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialDelay" type="long"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns a {@link Scheduler} that schedules the task using the {@link
 ScheduledExecutorService#scheduleWithFixedDelay} method.

 @param initialDelay the time to delay first execution
 @param delay the delay between the termination of one execution and the commencement of the
     next
 @param unit the time unit of the initialDelay and delay parameters]]>
      </doc>
    </method>
    <method name="newFixedRateSchedule" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialDelay" type="java.time.Duration"/>
      <param name="period" type="java.time.Duration"/>
      <doc>
      <![CDATA[Returns a {@link Scheduler} that schedules the task using the {@link
 ScheduledExecutorService#scheduleAtFixedRate} method.

 @param initialDelay the time to delay first execution
 @param period the period between successive executions of the task
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="newFixedRateSchedule" return="com.google.common.util.concurrent.AbstractScheduledService.Scheduler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialDelay" type="long"/>
      <param name="period" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns a {@link Scheduler} that schedules the task using the {@link
 ScheduledExecutorService#scheduleAtFixedRate} method.

 @param initialDelay the time to delay first execution
 @param period the period between successive executions of the task
 @param unit the time unit of the initialDelay and period parameters]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scheduler defines the policy for how the {@link AbstractScheduledService} should run its
 task.

 <p>Consider using the {@link #newFixedDelaySchedule} and {@link #newFixedRateSchedule} factory
 methods, these provide {@link Scheduler} instances for the common use case of running the
 service with a fixed schedule. If more flexibility is needed then consider subclassing {@link
 CustomScheduler}.

 @author Luke Sandberg
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractScheduledService.Scheduler -->
  <!-- start class com.google.common.util.concurrent.AbstractService -->
  <class name="AbstractService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <constructor name="AbstractService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="doStart"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method is called by {@link #startAsync} to initiate service startup. The invocation of
 this method should cause a call to {@link #notifyStarted()}, either during this method's run,
 or after it has returned. If startup fails, the invocation should cause a call to {@link
 #notifyFailed(Throwable)} instead.

 <p>This method should return promptly; prefer to do work on a different thread where it is
 convenient. It is invoked exactly once on service startup, even when {@link #startAsync} is
 called multiple times.]]>
      </doc>
    </method>
    <method name="doStop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method should be used to initiate service shutdown. The invocation of this method should
 cause a call to {@link #notifyStopped()}, either during this method's run, or after it has
 returned. If shutdown fails, the invocation should cause a call to {@link
 #notifyFailed(Throwable)} instead.

 <p>This method should return promptly; prefer to do work on a different thread where it is
 convenient. It is invoked exactly once on service shutdown, even when {@link #stopAsync} is
 called multiple times.

 <p>If {@link #stopAsync} is called on a {@link State#STARTING} service, this method is not
 invoked immediately. Instead, it will be deferred until after the service is {@link
 State#RUNNING}. Services that need to cancel startup work can override {@link #doCancelStart}.]]>
      </doc>
    </method>
    <method name="doCancelStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method is called by {@link #stopAsync} when the service is still starting (i.e. {@link
 #startAsync} has been called but {@link #notifyStarted} has not). Subclasses can override the
 method to cancel pending work and then call {@link #notifyStopped} to stop the service.

 <p>This method should return promptly; prefer to do work on a different thread where it is
 convenient. It is invoked exactly once on service shutdown, even when {@link #stopAsync} is
 called multiple times.

 <p>When this method is called {@link #state()} will return {@link State#STOPPING}, which is the
 external state observable by the caller of {@link #stopAsync}.

 @since 27.0]]>
      </doc>
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="notifyStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has started. It will cause
 the service to transition from {@link State#STARTING} to {@link State#RUNNING}.

 @throws IllegalStateException if the service is not {@link State#STARTING}.]]>
      </doc>
    </method>
    <method name="notifyStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implementing classes should invoke this method once their service has stopped. It will cause
 the service to transition from {@link State#STARTING} or {@link State#STOPPING} to {@link
 State#TERMINATED}.

 @throws IllegalStateException if the service is not one of {@link State#STOPPING}, {@link
     State#STARTING}, or {@link State#RUNNING}.]]>
      </doc>
    </method>
    <method name="notifyFailed"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="cause" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Invoke this method to transition the service to the {@link State#FAILED}. The service will
 <b>not be stopped</b> if it is running. Invoke this method when a service has failed critically
 or otherwise cannot be started nor stopped.]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 14.0]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[@since 13.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for implementing services that can handle {@link #doStart} and {@link #doStop}
 requests, responding to them with {@link #notifyStarted()} and {@link #notifyStopped()}
 callbacks. Its subclasses must manage threads manually; consider {@link
 AbstractExecutionThreadService} if you need only a single execution thread.

 @author Jesse Wilson
 @author Luke Sandberg
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AbstractService -->
  <!-- start interface com.google.common.util.concurrent.AsyncCallable -->
  <interface name="AsyncCallable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes a result {@code Future}. The output {@code Future} need not be {@linkplain
 Future#isDone done}, making {@code AsyncCallable} suitable for asynchronous derivations.

 <p>Throwing an exception from this method is equivalent to returning a failing {@link
 ListenableFuture}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Computes a value, possibly asynchronously. For an example usage and more information, see {@link
 Futures.FutureCombiner#callAsync(AsyncCallable, java.util.concurrent.Executor)}.

 <p>Much like {@link java.util.concurrent.Callable}, but returning a {@link ListenableFuture}
 result.

 @since 20.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.AsyncCallable -->
  <!-- start interface com.google.common.util.concurrent.AsyncFunction -->
  <interface name="AsyncFunction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="I extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns an output {@code Future} to use in place of the given {@code input}. The output {@code
 Future} need not be {@linkplain Future#isDone done}, making {@code AsyncFunction} suitable for
 asynchronous derivations.

 <p>Throwing an exception from this method is equivalent to returning a failing {@code Future}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Transforms a value, possibly asynchronously. For an example usage and more information, see
 {@link Futures#transformAsync(ListenableFuture, AsyncFunction, Executor)}.

 @author Chris Povirk
 @since 11.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.AsyncFunction -->
  <!-- start class com.google.common.util.concurrent.AtomicDouble -->
  <class name="AtomicDouble" extends="java.lang.Number"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomicDouble" type="double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDouble} with the given initial value.

 @param initialValue the initial value]]>
      </doc>
    </constructor>
    <constructor name="AtomicDouble"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDouble} with initial value {@code 0.0}.]]>
      </doc>
    </constructor>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current value.

 @return the current value]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Sets to the given value.

 @param newValue the new value]]>
      </doc>
    </method>
    <method name="lazySet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Eventually sets to the given value.

 @param newValue the new value]]>
      </doc>
    </method>
    <method name="getAndSet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Atomically sets to the given value and returns the old value.

 @param newValue the new value
 @return the previous value]]>
      </doc>
    </method>
    <method name="compareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the value to the given updated value if the current value is <a
 href="#bitEquals">bitwise equal</a> to the expected value.

 @param expect the expected value
 @param update the new value
 @return {@code true} if successful. False return indicates that the actual value was not
     bitwise equal to the expected value.]]>
      </doc>
    </method>
    <method name="weakCompareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the value to the given updated value if the current value is <a
 href="#bitEquals">bitwise equal</a> to the expected value.

 <p>May <a
 href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious">
 fail spuriously</a> and does not provide ordering guarantees, so is only rarely an appropriate
 alternative to {@code compareAndSet}.

 @param expect the expected value
 @param update the new value
 @return {@code true} if successful]]>
      </doc>
    </method>
    <method name="getAndAdd" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the current value.

 @param delta the value to add
 @return the previous value]]>
      </doc>
    </method>
    <method name="addAndGet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the current value.

 @param delta the value to add
 @return the updated value
 @since 31.1]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the String representation of the current value.

 @return the String representation of the current value]]>
      </doc>
    </method>
    <method name="intValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as an {@code int} after a narrowing primitive
 conversion.]]>
      </doc>
    </method>
    <method name="longValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as a {@code long} after a narrowing primitive
 conversion.]]>
      </doc>
    </method>
    <method name="floatValue" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as a {@code float} after a narrowing primitive
 conversion.]]>
      </doc>
    </method>
    <method name="doubleValue" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of this {@code AtomicDouble} as a {@code double}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code double} value that may be updated atomically. See the {@link
 java.util.concurrent.atomic} package specification for description of the properties of atomic
 variables. An {@code AtomicDouble} is used in applications such as atomic accumulation, and
 cannot be used as a replacement for a {@link Double}. However, this class does extend {@code
 Number} to allow uniform access by tools and utilities that deal with numerically-based classes.

 <p><a id="bitEquals"></a>This class compares primitive {@code double} values in methods such as
 {@link #compareAndSet} by comparing their bitwise representation using {@link
 Double#doubleToRawLongBits}, which differs from both the primitive double {@code ==} operator and
 from {@link Double#equals}, as if implemented by:

 {@snippet :
 static boolean bitEquals(double x, double y) {
   long xBits = Double.doubleToRawLongBits(x);
   long yBits = Double.doubleToRawLongBits(y);
   return xBits == yBits;
 }
 }

 <p>It is possible to write a more scalable updater, at the cost of giving up strict atomicity.
 See for example <a
 href="http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java.base/java/util/concurrent/atomic/DoubleAdder.html">
 DoubleAdder</a>.

 @author Doug Lea
 @author Martin Buchholz
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AtomicDouble -->
  <!-- start class com.google.common.util.concurrent.AtomicDoubleArray -->
  <class name="AtomicDoubleArray" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="AtomicDoubleArray" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDoubleArray} of the given length, with all elements initially zero.

 @param length the length of the array]]>
      </doc>
    </constructor>
    <constructor name="AtomicDoubleArray" type="double[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code AtomicDoubleArray} with the same length as, and all elements copied from,
 the given array.

 @param array the array to copy elements from
 @throws NullPointerException if array is null]]>
      </doc>
    </constructor>
    <method name="length" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the length of the array.

 @return the length of the array]]>
      </doc>
    </method>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Gets the current value at position {@code i}.

 @param i the index
 @return the current value]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Atomically sets the element at position {@code i} to the given value.

 @param i the index
 @param newValue the new value]]>
      </doc>
    </method>
    <method name="lazySet"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Eventually sets the element at position {@code i} to the given value.

 @param i the index
 @param newValue the new value]]>
      </doc>
    </method>
    <method name="getAndSet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="newValue" type="double"/>
      <doc>
      <![CDATA[Atomically sets the element at position {@code i} to the given value and returns the old value.

 @param i the index
 @param newValue the new value
 @return the previous value]]>
      </doc>
    </method>
    <method name="compareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the element at position {@code i} to the given updated value if the current
 value is <a href="#bitEquals">bitwise equal</a> to the expected value.

 @param i the index
 @param expect the expected value
 @param update the new value
 @return true if successful. False return indicates that the actual value was not equal to the
     expected value.]]>
      </doc>
    </method>
    <method name="weakCompareAndSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="expect" type="double"/>
      <param name="update" type="double"/>
      <doc>
      <![CDATA[Atomically sets the element at position {@code i} to the given updated value if the current
 value is <a href="#bitEquals">bitwise equal</a> to the expected value.

 <p>May <a
 href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html#Spurious">
 fail spuriously</a> and does not provide ordering guarantees, so is only rarely an appropriate
 alternative to {@code compareAndSet}.

 @param i the index
 @param expect the expected value
 @param update the new value
 @return true if successful]]>
      </doc>
    </method>
    <method name="getAndAdd" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the element at index {@code i}.

 @param i the index
 @param delta the value to add
 @return the previous value]]>
      </doc>
    </method>
    <method name="addAndGet" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="delta" type="double"/>
      <doc>
      <![CDATA[Atomically adds the given value to the element at index {@code i}.

 @param i the index
 @param delta the value to add
 @return the updated value
 @since 31.1]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the String representation of the current values of array.

 @return the String representation of the current values of array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code double} array in which elements may be updated atomically. See the {@link
 java.util.concurrent.atomic} package specification for description of the properties of atomic
 variables.

 <p><a id="bitEquals"></a>This class compares primitive {@code double} values in methods such as
 {@link #compareAndSet} by comparing their bitwise representation using {@link
 Double#doubleToRawLongBits}, which differs from both the primitive double {@code ==} operator and
 from {@link Double#equals}, as if implemented by:

 {@snippet :
 static boolean bitEquals(double x, double y) {
   long xBits = Double.doubleToRawLongBits(x);
   long yBits = Double.doubleToRawLongBits(y);
   return xBits == yBits;
 }
 }

 @author Doug Lea
 @author Martin Buchholz
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AtomicDoubleArray -->
  <!-- start class com.google.common.util.concurrent.AtomicLongMap -->
  <class name="AtomicLongMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="com.google.common.util.concurrent.AtomicLongMap&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an {@code AtomicLongMap}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.util.concurrent.AtomicLongMap&lt;K&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Creates an {@code AtomicLongMap} with the same mappings as the specified {@code Map}.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns the value associated with {@code key}, or zero if there is no value associated with
 {@code key}.]]>
      </doc>
    </method>
    <method name="incrementAndGet" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Increments by one the value currently associated with {@code key}, and returns the new value.]]>
      </doc>
    </method>
    <method name="decrementAndGet" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Decrements by one the value currently associated with {@code key}, and returns the new value.]]>
      </doc>
    </method>
    <method name="addAndGet" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Adds {@code delta} to the value currently associated with {@code key}, and returns the new
 value.]]>
      </doc>
    </method>
    <method name="getAndIncrement" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Increments by one the value currently associated with {@code key}, and returns the old value.]]>
      </doc>
    </method>
    <method name="getAndDecrement" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Decrements by one the value currently associated with {@code key}, and returns the old value.]]>
      </doc>
    </method>
    <method name="getAndAdd" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Adds {@code delta} to the value currently associated with {@code key}, and returns the old
 value.]]>
      </doc>
    </method>
    <method name="put" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="newValue" type="long"/>
      <doc>
      <![CDATA[Associates {@code newValue} with {@code key} in this map, and returns the value previously
 associated with {@code key}, or zero if there was no such value.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map&lt;? extends K, ? extends java.lang.Long&gt;"/>
      <doc>
      <![CDATA[Copies all of the mappings from the specified map to this map. The effect of this call is
 equivalent to that of calling {@code put(k, v)} on this map once for each mapping from key
 {@code k} to value {@code v} in the specified map. The behavior of this operation is undefined
 if the specified map is modified while the operation is in progress.]]>
      </doc>
    </method>
    <method name="remove" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Removes and returns the value associated with {@code key}. If {@code key} is not in the map,
 this method has no effect and returns zero.]]>
      </doc>
    </method>
    <method name="removeIfZero" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Atomically remove {@code key} from the map iff its associated value is 0.

 @since 20.0]]>
      </doc>
    </method>
    <method name="removeAllZeros"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all mappings from this map whose values are zero.

 <p>This method is not atomic: the map may be visible in intermediate states, where some of the
 zero values have been removed and others have not.]]>
      </doc>
    </method>
    <method name="sum" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sum of all values in this map.

 <p>This method is not atomic: the sum may or may not include other concurrent operations.]]>
      </doc>
    </method>
    <method name="asMap" return="java.util.Map&lt;K, java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a live, read-only view of the map backing this {@code AtomicLongMap}.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if this map contains a mapping for the specified key.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value mappings in this map. If the map contains more than {@code
 Integer.MAX_VALUE} elements, returns {@code Integer.MAX_VALUE}.]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this map contains no key-value mappings.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all of the mappings from this map. The map will be empty after this call returns.

 <p>This method is not atomic: the map may not be empty after returning if there were concurrent
 writes.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A map containing {@code long} values that can be atomically updated. While writes to a
 traditional {@code Map} rely on {@code put(K, V)}, the typical mechanism for writing to this map
 is {@code addAndGet(K, long)}, which adds a {@code long} to the value currently associated with
 {@code K}. If a key has not yet been associated with a value, its implicit value is zero.

 <p>Most methods in this class treat absent values and zero values identically, as individually
 documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty}, {@link
 #asMap}, and {@link #toString}.

 <p>Instances of this class may be used by multiple threads concurrently. All operations are
 atomic unless otherwise noted.

 <p>Instances of this class are serializable if the keys are serializable.

 <p><b>Note:</b> If your values are always positive and less than 2^31, you may wish to use a
 {@link com.google.common.collect.Multiset} such as {@link
 com.google.common.collect.ConcurrentHashMultiset} instead.

 <p><b>Warning:</b> Unlike {@code Multiset}, entries whose values are zero are not automatically
 removed from the map. Instead they must be removed manually with {@link #removeAllZeros}.

 @author Charles Fry
 @since 11.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.AtomicLongMap -->
  <!-- start class com.google.common.util.concurrent.Atomics -->
  <class name="Atomics" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReference" return="java.util.concurrent.atomic.AtomicReference&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an {@code AtomicReference} instance with no initial value.

 @return a new {@code AtomicReference} with no initial value]]>
      </doc>
    </method>
    <method name="newReference" return="java.util.concurrent.atomic.AtomicReference&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialValue" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Creates an {@code AtomicReference} instance with the given initial value.

 @param initialValue the initial value
 @return a new {@code AtomicReference} with the given initial value]]>
      </doc>
    </method>
    <method name="newReferenceArray" return="java.util.concurrent.atomic.AtomicReferenceArray&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Creates an {@code AtomicReferenceArray} instance of given length.

 @param length the length of the array
 @return a new {@code AtomicReferenceArray} with the given length]]>
      </doc>
    </method>
    <method name="newReferenceArray" return="java.util.concurrent.atomic.AtomicReferenceArray&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="E[]"/>
      <doc>
      <![CDATA[Creates an {@code AtomicReferenceArray} instance with the same length as, and all elements
 copied from, the given array.

 @param array the array to copy elements from
 @return a new {@code AtomicReferenceArray} copied from the given array]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to classes in the {@code java.util.concurrent.atomic} package.

 @author Kurt Alfred Kluever
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Atomics -->
  <!-- start class com.google.common.util.concurrent.Callables -->
  <class name="Callables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="returning" return="java.util.concurrent.Callable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[Creates a {@code Callable} which immediately returns a preset value each time it is called.]]>
      </doc>
    </method>
    <method name="asAsyncCallable" return="com.google.common.util.concurrent.AsyncCallable&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="listeningExecutorService" type="com.google.common.util.concurrent.ListeningExecutorService"/>
      <doc>
      <![CDATA[Creates an {@link AsyncCallable} from a {@link Callable}.

 <p>The {@link AsyncCallable} returns the {@link ListenableFuture} resulting from {@link
 ListeningExecutorService#submit(Callable)}.

 @since 20.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Callable} interface.

 @author Isaac Shum
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Callables -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture -->
  <class name="ClosingFuture" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="submit" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="com.google.common.util.concurrent.ClosingFuture.ClosingCallable&lt;V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Starts a {@link ClosingFuture} pipeline by submitting a callable block to an executor.

 @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for
     execution]]>
      </doc>
    </method>
    <method name="submitAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="com.google.common.util.concurrent.ClosingFuture.AsyncClosingCallable&lt;V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Starts a {@link ClosingFuture} pipeline by submitting a callable block to an executor.

 @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for
     execution
 @since 30.1]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <doc>
      <![CDATA[Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.

 <p>{@code future}'s value will not be closed when the pipeline is done even if {@code V}
 implements {@link AutoCloseable}. In order to start a pipeline with a value that will be closed
 when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.]]>
      </doc>
    </method>
    <method name="eventuallyClosing" return="com.google.common.util.concurrent.ClosingFuture&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Creating {@link Future}s of closeable types is dangerous in general because the
     underlying value may never be closed if the {@link Future} is canceled after its operation
     begins. Consider replacing code that creates {@link ListenableFuture}s of closeable types,
     including those that pass them to this method, with {@link #submit(ClosingCallable,
     Executor)} in order to ensure that resources do not leak. Or, to start a pipeline with a
     {@link ListenableFuture} that doesn't create values that should be closed, use {@link
     ClosingFuture#from}.">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;C&gt;"/>
      <param name="closingExecutor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.

 <p>If {@code future} succeeds, its value will be closed (using {@code closingExecutor)}) when
 the pipeline is done, even if the pipeline is canceled or fails.

 <p>Cancelling the pipeline will not cancel {@code future}, so that the pipeline can access its
 value in order to close it.

 @param future the future to create the {@code ClosingFuture} from. For discussion of the
     future's result type {@code C}, see {@link DeferredCloser#eventuallyClose(Object,
     Executor)}.
 @param closingExecutor the future's result will be closed on this executor
 @deprecated Creating {@link Future}s of closeable types is dangerous in general because the
     underlying value may never be closed if the {@link Future} is canceled after its operation
     begins. Consider replacing code that creates {@link ListenableFuture}s of closeable types,
     including those that pass them to this method, with {@link #submit(ClosingCallable,
     Executor)} in order to ensure that resources do not leak. Or, to start a pipeline with a
     {@link ListenableFuture} that doesn't create values that should be closed, use {@link
     ClosingFuture#from}.]]>
      </doc>
    </method>
    <method name="whenAllComplete" return="com.google.common.util.concurrent.ClosingFuture.Combiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ClosingFuture&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Starts specifying how to combine {@link ClosingFuture}s into a single pipeline.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the {@code futures}, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="whenAllComplete" return="com.google.common.util.concurrent.ClosingFuture.Combiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future1" type="com.google.common.util.concurrent.ClosingFuture&lt;?&gt;"/>
      <param name="moreFutures" type="com.google.common.util.concurrent.ClosingFuture[]"/>
      <doc>
      <![CDATA[Starts specifying how to combine {@link ClosingFuture}s into a single pipeline.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the arguments, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.ClosingFuture.Combiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ClosingFuture&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Starts specifying how to combine {@link ClosingFuture}s into a single pipeline, assuming they
 all succeed. If any fail, the resulting pipeline will fail.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the {@code futures}, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.ClosingFuture.Combiner2&lt;V1, V2&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future1" type="com.google.common.util.concurrent.ClosingFuture&lt;V1&gt;"/>
      <param name="future2" type="com.google.common.util.concurrent.ClosingFuture&lt;V2&gt;"/>
      <doc>
      <![CDATA[Starts specifying how to combine two {@link ClosingFuture}s into a single pipeline, assuming
 they all succeed. If any fail, the resulting pipeline will fail.

 <p>Calling this method allows you to use lambdas or method references typed with the types of
 the input {@link ClosingFuture}s.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the arguments, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.ClosingFuture.Combiner3&lt;V1, V2, V3&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future1" type="com.google.common.util.concurrent.ClosingFuture&lt;V1&gt;"/>
      <param name="future2" type="com.google.common.util.concurrent.ClosingFuture&lt;V2&gt;"/>
      <param name="future3" type="com.google.common.util.concurrent.ClosingFuture&lt;V3&gt;"/>
      <doc>
      <![CDATA[Starts specifying how to combine three {@link ClosingFuture}s into a single pipeline, assuming
 they all succeed. If any fail, the resulting pipeline will fail.

 <p>Calling this method allows you to use lambdas or method references typed with the types of
 the input {@link ClosingFuture}s.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the arguments, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.ClosingFuture.Combiner4&lt;V1, V2, V3, V4&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future1" type="com.google.common.util.concurrent.ClosingFuture&lt;V1&gt;"/>
      <param name="future2" type="com.google.common.util.concurrent.ClosingFuture&lt;V2&gt;"/>
      <param name="future3" type="com.google.common.util.concurrent.ClosingFuture&lt;V3&gt;"/>
      <param name="future4" type="com.google.common.util.concurrent.ClosingFuture&lt;V4&gt;"/>
      <doc>
      <![CDATA[Starts specifying how to combine four {@link ClosingFuture}s into a single pipeline, assuming
 they all succeed. If any fail, the resulting pipeline will fail.

 <p>Calling this method allows you to use lambdas or method references typed with the types of
 the input {@link ClosingFuture}s.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the arguments, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.ClosingFuture.Combiner5&lt;V1, V2, V3, V4, V5&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future1" type="com.google.common.util.concurrent.ClosingFuture&lt;V1&gt;"/>
      <param name="future2" type="com.google.common.util.concurrent.ClosingFuture&lt;V2&gt;"/>
      <param name="future3" type="com.google.common.util.concurrent.ClosingFuture&lt;V3&gt;"/>
      <param name="future4" type="com.google.common.util.concurrent.ClosingFuture&lt;V4&gt;"/>
      <param name="future5" type="com.google.common.util.concurrent.ClosingFuture&lt;V5&gt;"/>
      <doc>
      <![CDATA[Starts specifying how to combine five {@link ClosingFuture}s into a single pipeline, assuming
 they all succeed. If any fail, the resulting pipeline will fail.

 <p>Calling this method allows you to use lambdas or method references typed with the types of
 the input {@link ClosingFuture}s.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the arguments, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.ClosingFuture.Combiner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future1" type="com.google.common.util.concurrent.ClosingFuture&lt;?&gt;"/>
      <param name="future2" type="com.google.common.util.concurrent.ClosingFuture&lt;?&gt;"/>
      <param name="future3" type="com.google.common.util.concurrent.ClosingFuture&lt;?&gt;"/>
      <param name="future4" type="com.google.common.util.concurrent.ClosingFuture&lt;?&gt;"/>
      <param name="future5" type="com.google.common.util.concurrent.ClosingFuture&lt;?&gt;"/>
      <param name="future6" type="com.google.common.util.concurrent.ClosingFuture&lt;?&gt;"/>
      <param name="moreFutures" type="com.google.common.util.concurrent.ClosingFuture[]"/>
      <doc>
      <![CDATA[Starts specifying how to combine {@link ClosingFuture}s into a single pipeline, assuming they
 all succeed. If any fail, the resulting pipeline will fail.

 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from any of
     the arguments, or if any has already been {@linkplain #finishToFuture() finished}]]>
      </doc>
    </method>
    <method name="statusFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a future that finishes when this step does. Calling {@code get()} on the returned
 future returns {@code null} if the step is successful or throws the same exception that would
 be thrown by calling {@code finishToFuture().get()} if this were the last step. Calling {@code
 cancel()} on the returned future has no effect on the {@code ClosingFuture} pipeline.

 <p>{@code statusFuture} differs from most methods on {@code ClosingFuture}: You can make calls
 to {@code statusFuture} <i>in addition to</i> the call you make to {@link #finishToFuture()} or
 a derivation method <i>on the same instance</i>. This is important because calling {@code
 statusFuture} alone does not provide a way to close the pipeline.]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.ClosingFunction&lt;? super V, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
 to its value. The function can use a {@link DeferredCloser} to capture objects to be closed
 when the pipeline is done.

 <p>If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code
 ClosingFuture} will be equivalent to this one.

 <p>If the function throws an exception, that exception is used as the result of the derived
 {@code ClosingFuture}.

 <p>Example usage:

 {@snippet :
 ClosingFuture<List<Row>> rowsFuture =
     queryFuture.transform((closer, result) -> result.getRows(), executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
 about heavyweight listeners are also applicable to heavyweight functions passed to this method.

 <p>After calling this method, you may not call {@link #finishToFuture()}, {@link
 #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
 the original {@code ClosingFuture} instance.

 @param function transforms the value of this step to the value of the derived step
 @param executor executor to run the function in
 @return the derived step
 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this
     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()
     finished}]]>
      </doc>
    </method>
    <method name="transformAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.AsyncClosingFunction&lt;? super V, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
 that returns a {@code ClosingFuture} to its value. The function can use a {@link
 DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
 captured by the returned {@link ClosingFuture}).

 <p>If this {@code ClosingFuture} succeeds, the derived one will be equivalent to the one
 returned by the function.

 <p>If this {@code ClosingFuture} fails, the function will not be called, and the derived {@code
 ClosingFuture} will be equivalent to this one.

 <p>If the function throws an exception, that exception is used as the result of the derived
 {@code ClosingFuture}. But if the exception is thrown after the function creates a {@code
 ClosingFuture}, then none of the closeable objects in that {@code ClosingFuture} will be
 closed.

 <p>Usage guidelines for this method:

 <ul>
   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a
       {@code ClosingFuture}. If possible, prefer calling {@link #transform(ClosingFunction,
       Executor)} instead, with a function that returns the next value directly.
   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}
       for every closeable object this step creates in order to capture it for later closing.
   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
       ClosingFuture} call {@link #from(ListenableFuture)}.
   <li>In case this step doesn't create new closeables, you can adapt an API that returns a
       {@link ListenableFuture} to return a {@code ClosingFuture} by wrapping it with a call to
       {@link #withoutCloser(AsyncFunction)}
 </ul>

 <p>Example usage:

 {@snippet :
 // Result.getRowsClosingFuture() returns a ClosingFuture.
 ClosingFuture<List<Row>> rowsFuture =
     queryFuture.transformAsync((closer, result) -> result.getRowsClosingFuture(), executor);

 // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the
 // number of written rows. openOutputFile() returns a FileOutputStream (which implements
 // AutoCloseable).
 ClosingFuture<Integer> rowsFuture2 =
     queryFuture.transformAsync(
         (closer, result) -> {
           FileOutputStream fos = closer.eventuallyClose(openOutputFile(), closingExecutor);
           return ClosingFuture.from(result.writeRowsToOutputStreamFuture(fos));
      },
      executor);

 // Result.getRowsFuture() returns a ListenableFuture (no new closeables are created).
 ClosingFuture<List<Row>> rowsFuture3 =
     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);

 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
 about heavyweight listeners are also applicable to heavyweight functions passed to this method.
 (Specifically, {@code directExecutor} functions should avoid heavyweight operations inside
 {@code AsyncClosingFunction.apply}. Any heavyweight operations should occur in other threads
 responsible for completing the returned {@code ClosingFuture}.)

 <p>After calling this method, you may not call {@link #finishToFuture()}, {@link
 #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
 the original {@code ClosingFuture} instance.

 @param function transforms the value of this step to a {@code ClosingFuture} with the value of
     the derived step
 @param executor executor to run the function in
 @return the derived step
 @throws IllegalStateException if a {@code ClosingFuture} has already been derived from this
     one, or if this {@code ClosingFuture} has already been {@linkplain #finishToFuture()
     finished}]]>
      </doc>
    </method>
    <method name="withoutCloser" return="com.google.common.util.concurrent.ClosingFuture.AsyncClosingFunction&lt;V, U&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.AsyncFunction&lt;V, U&gt;"/>
      <doc>
      <![CDATA[Returns an {@link AsyncClosingFunction} that applies an {@link AsyncFunction} to an input,
 ignoring the DeferredCloser and returning a {@code ClosingFuture} derived from the returned
 {@link ListenableFuture}.

 <p>Use this method to pass a transformation to {@link #transformAsync(AsyncClosingFunction,
 Executor)} or to {@link #catchingAsync(Class, AsyncClosingFunction, Executor)} as long as it
 meets these conditions:

 <ul>
   <li>It does not need to capture any {@link AutoCloseable} objects by calling {@link
       DeferredCloser#eventuallyClose(Object, Executor)}.
   <li>It returns a {@link ListenableFuture}.
 </ul>

 <p>Example usage:

 {@snippet :
 // Result.getRowsFuture() returns a ListenableFuture.
 ClosingFuture<List<Row>> rowsFuture =
     queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor);
 }

 @param function transforms the value of a {@code ClosingFuture} step to a {@link
     ListenableFuture} with the value of a derived step]]>
      </doc>
    </method>
    <method name="catching" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exceptionType" type="java.lang.Class&lt;X&gt;"/>
      <param name="fallback" type="com.google.common.util.concurrent.ClosingFuture.ClosingFunction&lt;? super X, ? extends V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
 to its exception if it is an instance of a given exception type. The function can use a {@link
 DeferredCloser} to capture objects to be closed when the pipeline is done.

 <p>If this {@code ClosingFuture} succeeds or fails with a different exception type, the
 function will not be called, and the derived {@code ClosingFuture} will be equivalent to this
 one.

 <p>If the function throws an exception, that exception is used as the result of the derived
 {@code ClosingFuture}.

 <p>Example usage:

 {@snippet :
 ClosingFuture<QueryResult> queryFuture =
     queryFuture.catching(
         QueryException.class, (closer, x) -> Query.emptyQueryResult(), executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
 about heavyweight listeners are also applicable to heavyweight functions passed to this method.

 <p>After calling this method, you may not call {@link #finishToFuture()}, {@link
 #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
 the original {@code ClosingFuture} instance.

 @param exceptionType the exception type that triggers use of {@code fallback}. The exception
     type is matched against this step's exception. "This step's exception" means the cause of
     the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
     underlying this step or, if {@code get()} throws a different kind of exception, that
     exception itself. To avoid hiding bugs and other unrecoverable errors, callers should
     prefer more specific types, avoiding {@code Throwable.class} in particular.
 @param fallback the function to be called if this step fails with the expected exception type.
     The function's argument is this step's exception. "This step's exception" means the cause
     of the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
     underlying this step or, if {@code get()} throws a different kind of exception, that
     exception itself.
 @param executor the executor that runs {@code fallback} if the input fails]]>
      </doc>
    </method>
    <method name="catchingAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exceptionType" type="java.lang.Class&lt;X&gt;"/>
      <param name="fallback" type="com.google.common.util.concurrent.ClosingFuture.AsyncClosingFunction&lt;? super X, ? extends V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from this one by applying a function
 that returns a {@code ClosingFuture} to its exception if it is an instance of a given exception
 type. The function can use a {@link DeferredCloser} to capture objects to be closed when the
 pipeline is done (other than those captured by the returned {@link ClosingFuture}).

 <p>If this {@code ClosingFuture} fails with an exception of the given type, the derived {@code
 ClosingFuture} will be equivalent to the one returned by the function.

 <p>If this {@code ClosingFuture} succeeds or fails with a different exception type, the
 function will not be called, and the derived {@code ClosingFuture} will be equivalent to this
 one.

 <p>If the function throws an exception, that exception is used as the result of the derived
 {@code ClosingFuture}. But if the exception is thrown after the function creates a {@code
 ClosingFuture}, then none of the closeable objects in that {@code ClosingFuture} will be
 closed.

 <p>Usage guidelines for this method:

 <ul>
   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a
       {@code ClosingFuture}. If possible, prefer calling {@link #catching(Class,
       ClosingFunction, Executor)} instead, with a function that returns the next value
       directly.
   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}
       for every closeable object this step creates in order to capture it for later closing.
   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
       ClosingFuture} call {@link #from(ListenableFuture)}.
   <li>In case this step doesn't create new closeables, you can adapt an API that returns a
       {@link ListenableFuture} to return a {@code ClosingFuture} by wrapping it with a call to
       {@link #withoutCloser(AsyncFunction)}
 </ul>

 <p>Example usage:

 {@snippet :
 // Fall back to a secondary input stream in case of IOException.
 ClosingFuture<InputStream> inputFuture =
     firstInputFuture.catchingAsync(
         IOException.class, (closer, x) -> secondaryInputStreamClosingFuture(), executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link ListenableFuture#addListener} documentation. All its warnings
 about heavyweight listeners are also applicable to heavyweight functions passed to this method.
 (Specifically, {@code directExecutor} functions should avoid heavyweight operations inside
 {@code AsyncClosingFunction.apply}. Any heavyweight operations should occur in other threads
 responsible for completing the returned {@code ClosingFuture}.)

 <p>After calling this method, you may not call {@link #finishToFuture()}, {@link
 #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, or any other derivation method on
 the original {@code ClosingFuture} instance.

 @param exceptionType the exception type that triggers use of {@code fallback}. The exception
     type is matched against this step's exception. "This step's exception" means the cause of
     the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
     underlying this step or, if {@code get()} throws a different kind of exception, that
     exception itself. To avoid hiding bugs and other unrecoverable errors, callers should
     prefer more specific types, avoiding {@code Throwable.class} in particular.
 @param fallback the function to be called if this step fails with the expected exception type.
     The function's argument is this step's exception. "This step's exception" means the cause
     of the {@link ExecutionException} thrown by {@link Future#get()} on the {@link Future}
     underlying this step or, if {@code get()} throws a different kind of exception, that
     exception itself.
 @param executor the executor that runs {@code fallback} if the input fails]]>
      </doc>
    </method>
    <method name="finishToFuture" return="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Marks this step as the last step in the {@code ClosingFuture} pipeline.

 <p>The returned {@link Future} is completed when the pipeline's computation completes, or when
 the pipeline is cancelled.

 <p>All objects the pipeline has captured for closing will begin to be closed asynchronously
 <b>after</b> the returned {@code Future} is done: the future completes before closing starts,
 rather than once it has finished.

 <p>After calling this method, you may not call {@link
 #finishToValueAndCloser(ValueAndCloserConsumer, Executor)}, this method, or any other
 derivation method on the original {@code ClosingFuture} instance.

 @return a {@link Future} that represents the final value or exception of the pipeline]]>
      </doc>
    </method>
    <method name="finishToValueAndCloser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="consumer" type="com.google.common.util.concurrent.ClosingFuture.ValueAndCloserConsumer&lt;? super V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Marks this step as the last step in the {@code ClosingFuture} pipeline. When this step is done,
 {@code receiver} will be called with an object that contains the result of the operation. The
 receiver can store the {@link ValueAndCloser} outside the receiver for later synchronous use.

 <p>After calling this method, you may not call {@link #finishToFuture()}, this method again, or
 any other derivation method on the original {@code ClosingFuture} instance.

 @param consumer a callback whose method will be called (using {@code executor}) when this
     operation is done]]>
      </doc>
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
      <doc>
      <![CDATA[Attempts to cancel execution of this step. This attempt will fail if the step has already
 completed, has already been cancelled, or could not be cancelled for some other reason. If
 successful, and this step has not started when {@code cancel} is called, this step should never
 run.

 <p>If successful, causes the objects captured by this step (if already started) and its input
 step(s) for later closing to be closed on their respective {@link Executor}s. If any such calls
 specified {@link MoreExecutors#directExecutor()}, those objects will be closed synchronously.

 @param mayInterruptIfRunning {@code true} if the thread executing this task should be
     interrupted; otherwise, in-progress tasks are allowed to complete, but the step will be
     cancelled regardless
 @return {@code false} if the step could not be cancelled, typically because it has already
     completed normally; {@code true} otherwise]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finalize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A step in a pipeline of an asynchronous computation. When the last step in the computation is
 complete, some objects captured during the computation are closed.

 <p>A pipeline of {@code ClosingFuture}s is a tree of steps. Each step represents either an
 asynchronously-computed intermediate value, or else an exception that indicates the failure or
 cancellation of the operation so far. The only way to extract the value or exception from a step
 is by declaring that step to be the last step of the pipeline. Nevertheless, we refer to the
 "value" of a successful step or the "result" (value or exception) of any step.

 <ol>
   <li>A pipeline starts at its leaf step (or steps), which is created from either a callable
       block or a {@link ListenableFuture}.
   <li>Each other step is derived from one or more input steps. At each step, zero or more objects
       can be captured for later closing.
   <li>There is one last step (the root of the tree), from which you can extract the final result
       of the computation. After that result is available (or the computation fails), all objects
       captured by any of the steps in the pipeline are closed.
 </ol>

 <h3>Starting a pipeline</h3>

 Start a {@code ClosingFuture} pipeline {@linkplain #submit(ClosingCallable, Executor) from a
 callable block} that may capture objects for later closing. To start a pipeline from a {@link
 ListenableFuture} that doesn't create resources that should be closed later, you can use {@link
 #from(ListenableFuture)} instead.

 <h3>Derived steps</h3>

 A {@code ClosingFuture} step can be derived from one or more input {@code ClosingFuture} steps in
 ways similar to {@link FluentFuture}s:

 <ul>
   <li>by transforming the value from a successful input step,
   <li>by catching the exception from a failed input step, or
   <li>by combining the results of several input steps.
 </ul>

 Each derivation can capture the next value or any intermediate objects for later closing.

 <p>A step can be the input to at most one derived step. Once you transform its value, catch its
 exception, or combine it with others, you cannot do anything else with it, including declare it
 to be the last step of the pipeline.

 <h4>Transforming</h4>

 To derive the next step by asynchronously applying a function to an input step's value, call
 {@link #transform(ClosingFunction, Executor)} or {@link #transformAsync(AsyncClosingFunction,
 Executor)} on the input step.

 <h4>Catching</h4>

 To derive the next step from a failed input step, call {@link #catching(Class, ClosingFunction,
 Executor)} or {@link #catchingAsync(Class, AsyncClosingFunction, Executor)} on the input step.

 <h4>Combining</h4>

 To derive a {@code ClosingFuture} from two or more input steps, pass the input steps to {@link
 #whenAllComplete(Iterable)} or {@link #whenAllSucceed(Iterable)} or its overloads.

 <h3>Cancelling</h3>

 Any step in a pipeline can be {@linkplain #cancel(boolean) cancelled}, even after another step
 has been derived, with the same semantics as cancelling a {@link Future}. In addition, a
 successfully cancelled step will immediately start closing all objects captured for later closing
 by it and by its input steps.

 <h3>Ending a pipeline</h3>

 Each {@code ClosingFuture} pipeline must be ended. To end a pipeline, decide whether you want to
 close the captured objects automatically or manually.

 <h4>Automatically closing</h4>

 You can extract a {@link Future} that represents the result of the last step in the pipeline by
 calling {@link #finishToFuture()}. All objects the pipeline has captured for closing will begin
 to be closed asynchronously <b>after</b> the returned {@code Future} is done: the future
 completes before closing starts, rather than once it has finished.

 {@snippet :
 FluentFuture<UserName> userName =
     ClosingFuture.submit(
             closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor),
             executor)
         .transformAsync((closer, transaction) -> transaction.queryClosingFuture("..."), executor)
         .transform((closer, result) -> result.get("userName"), directExecutor())
         .catching(DBException.class, e -> "no user", directExecutor())
         .finishToFuture();
 }

 In this example, when the {@code userName} {@link Future} is done, the transaction and the query
 result cursor will both be closed, even if the operation is cancelled or fails.

 <h4>Manually closing</h4>

 If you want to close the captured objects manually, after you've used the final result, call
 {@link #finishToValueAndCloser(ValueAndCloserConsumer, Executor)} to get an object that holds the
 final result. You then call {@link ValueAndCloser#closeAsync()} to close the captured objects.

 {@snippet :
     ClosingFuture.submit(
             closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor),
             executor)
     .transformAsync((closer, transaction) -> transaction.queryClosingFuture("..."), executor)
     .transform((closer, result) -> result.get("userName"), directExecutor())
     .catching(DBException.class, e -> "no user", directExecutor())
     .finishToValueAndCloser(
         valueAndCloser -> this.userNameValueAndCloser = valueAndCloser, executor);

 // later
 try { // get() will throw if the operation failed or was cancelled.
   UserName userName = userNameValueAndCloser.get();
   // do something with userName
 } finally {
   userNameValueAndCloser.closeAsync();
 }
 }

 In this example, when {@code userNameValueAndCloser.closeAsync()} is called, the transaction and
 the query result cursor will both be closed, even if the operation is cancelled or fails.

 <p>Note that if you don't call {@code closeAsync()}, the captured objects will not be closed. The
 automatic-closing approach described above is safer.

 @param <V> the type of the value of this step
 @since 30.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.AsyncClosingCallable -->
  <interface name="ClosingFuture.AsyncClosingCallable"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes a result, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
 not before this method completes), even if this method throws or the pipeline is cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An operation that computes a {@link ClosingFuture} of a result.

 @param <V> the type of the result
 @since 30.1]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.AsyncClosingCallable -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.AsyncClosingFunction -->
  <interface name="ClosingFuture.AsyncClosingFunction"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="input" type="T extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to an input, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
 not before this method completes), even if this method throws or the pipeline is cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function from an input to a {@link ClosingFuture} of a result.

 @param <T> the type of the input to the function
 @param <U> the type of the result of the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.AsyncClosingFunction -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.ClosingCallable -->
  <interface name="ClosingFuture.ClosingCallable"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="V extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes a result, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
 not before this method completes), even if this method throws or the pipeline is cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An operation that computes a result.

 @param <V> the type of the result]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.ClosingCallable -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.ClosingFunction -->
  <interface name="ClosingFuture.ClosingFunction"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="U extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="input" type="T extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to an input, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done (but
 not before this method completes), even if this method throws or the pipeline is cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function from an input to a result.

 @param <T> the type of the input to the function
 @param <U> the type of the result of the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.ClosingFunction -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.Combiner -->
  <class name="ClosingFuture.Combiner" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="combiningCallable" type="com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable&lt;V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 combining function to their values. The function can use a {@link DeferredCloser} to capture
 objects to be closed when the pipeline is done.

 <p>If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs
 fail, so will the returned step.

 <p>If the combiningCallable throws a {@code CancellationException}, the pipeline will be
 cancelled.

 <p>If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown
 {@code ExecutionException} will be extracted and used as the failure of the derived step.]]>
      </doc>
    </method>
    <method name="callAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="combiningCallable" type="com.google.common.util.concurrent.ClosingFuture.Combiner.AsyncCombiningCallable&lt;V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 {@code ClosingFuture}-returning function to their values. The function can use a {@link
 DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
 captured by the returned {@link ClosingFuture}).

 <p>If this combiner was returned by a {@link #whenAllSucceed} method and any of the inputs
 fail, so will the returned step.

 <p>If the combiningCallable throws a {@code CancellationException}, the pipeline will be
 cancelled.

 <p>If the combiningCallable throws an {@code ExecutionException}, the cause of the thrown
 {@code ExecutionException} will be extracted and used as the failure of the derived step.

 <p>If the combiningCallable throws any other exception, it will be used as the failure of the
 derived step.

 <p>If an exception is thrown after the combiningCallable creates a {@code ClosingFuture},
 then none of the closeable objects in that {@code ClosingFuture} will be closed.

 <p>Usage guidelines for this method:

 <ul>
   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a
       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
       Executor)} instead, with a function that returns the next value directly.
   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}
       for every closeable object this step creates in order to capture it for later closing.
   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
       ClosingFuture} call {@link #from(ListenableFuture)}.
 </ul>

 <p>The same warnings about doing heavyweight operations within {@link
 ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.]]>
      </doc>
    </method>
    <field name="inputs" type="com.google.common.collect.ImmutableList&lt;com.google.common.util.concurrent.ClosingFuture&lt;?&gt;&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A builder of a {@link ClosingFuture} step that is derived from more than one input step.

 <p>See {@link #whenAllComplete(Iterable)} and {@link #whenAllSucceed(Iterable)} for how to
 instantiate this class.

 <p>Example:

 {@snippet :
 final ClosingFuture<BufferedReader> file1ReaderFuture = ...;
 final ClosingFuture<BufferedReader> file2ReaderFuture = ...;
 ListenableFuture<Integer> numberOfDifferentLines =
       ClosingFuture.whenAllSucceed(file1ReaderFuture, file2ReaderFuture)
           .call(
               (closer, peeker) -> {
                 BufferedReader file1Reader = peeker.getDone(file1ReaderFuture);
                 BufferedReader file2Reader = peeker.getDone(file2ReaderFuture);
                 return countDifferentLines(file1Reader, file2Reader);
               },
               executor)
           .closing(executor);
 }]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.Combiner -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner.AsyncCombiningCallable -->
  <interface name="ClosingFuture.Combiner.AsyncCombiningCallable"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ClosingFuture&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="peeker" type="com.google.common.util.concurrent.ClosingFuture.Peeker"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes a {@link ClosingFuture} result, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.

 @param peeker used to get the value of any of the input futures]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An operation that returns a {@link ClosingFuture} result and may throw an exception.

 @param <V> the type of the result]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner.AsyncCombiningCallable -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable -->
  <interface name="ClosingFuture.Combiner.CombiningCallable"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="V extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="peeker" type="com.google.common.util.concurrent.ClosingFuture.Peeker"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Computes a result, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.

 @param peeker used to get the value of any of the input futures]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An operation that returns a result and may throw an exception.

 @param <V> the type of the result]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.Combiner2 -->
  <class name="ClosingFuture.Combiner2" extends="com.google.common.util.concurrent.ClosingFuture.Combiner"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner2.ClosingFunction2&lt;V1, V2, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 combining function to their values. The function can use a {@link DeferredCloser} to capture
 objects to be closed when the pipeline is done.

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and
 any of the inputs fail, so will the returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.]]>
      </doc>
    </method>
    <method name="callAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner2.AsyncClosingFunction2&lt;V1, V2, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 {@code ClosingFuture}-returning function to their values. The function can use a {@link
 DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
 captured by the returned {@link ClosingFuture}).

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} and
 any of the inputs fail, so will the returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.

 <p>If the function throws any other exception, it will be used as the failure of the derived
 step.

 <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
 the closeable objects in that {@code ClosingFuture} will be closed.

 <p>Usage guidelines for this method:

 <ul>
   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a
       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
       Executor)} instead, with a function that returns the next value directly.
   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}
       for every closeable object this step creates in order to capture it for later closing.
   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
       ClosingFuture} call {@link #from(ListenableFuture)}.
 </ul>

 <p>The same warnings about doing heavyweight operations within {@link
 ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A generic {@link Combiner} that lets you use a lambda or method reference to combine two {@link
 ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture)} to start this
 combination.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.Combiner2 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner2.AsyncClosingFunction2 -->
  <interface name="ClosingFuture.Combiner2.AsyncClosingFunction2"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to two inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a {@link ClosingFuture} when applied to the values of the two futures
 passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner2.AsyncClosingFunction2 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner2.ClosingFunction2 -->
  <interface name="ClosingFuture.Combiner2.ClosingFunction2"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="U extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to two inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a value when applied to the values of the two futures passed to
 {@link #whenAllSucceed(ClosingFuture, ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner2.ClosingFunction2 -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.Combiner3 -->
  <class name="ClosingFuture.Combiner3" extends="com.google.common.util.concurrent.ClosingFuture.Combiner"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner3.ClosingFunction3&lt;V1, V2, V3, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 combining function to their values. The function can use a {@link DeferredCloser} to capture
 objects to be closed when the pipeline is done.

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture)} and any of the inputs fail, so will the returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.]]>
      </doc>
    </method>
    <method name="callAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner3.AsyncClosingFunction3&lt;V1, V2, V3, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 {@code ClosingFuture}-returning function to their values. The function can use a {@link
 DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
 captured by the returned {@link ClosingFuture}).

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture)} and any of the inputs fail, so will the returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.

 <p>If the function throws any other exception, it will be used as the failure of the derived
 step.

 <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
 the closeable objects in that {@code ClosingFuture} will be closed.

 <p>Usage guidelines for this method:

 <ul>
   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a
       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
       Executor)} instead, with a function that returns the next value directly.
   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}
       for every closeable object this step creates in order to capture it for later closing.
   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
       ClosingFuture} call {@link #from(ListenableFuture)}.
 </ul>

 <p>The same warnings about doing heavyweight operations within {@link
 ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A generic {@link Combiner} that lets you use a lambda or method reference to combine three
 {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture)} to start this combination.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.Combiner3 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner3.AsyncClosingFunction3 -->
  <interface name="ClosingFuture.Combiner3.AsyncClosingFunction3"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <param name="value3" type="V3 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to three inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a {@link ClosingFuture} when applied to the values of the three
 futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner3.AsyncClosingFunction3 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner3.ClosingFunction3 -->
  <interface name="ClosingFuture.Combiner3.ClosingFunction3"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="U extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <param name="value3" type="V3 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to three inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a value when applied to the values of the three futures passed to
 {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner3.ClosingFunction3 -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.Combiner4 -->
  <class name="ClosingFuture.Combiner4" extends="com.google.common.util.concurrent.ClosingFuture.Combiner"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner4.ClosingFunction4&lt;V1, V2, V3, V4, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 combining function to their values. The function can use a {@link DeferredCloser} to capture
 objects to be closed when the pipeline is done.

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.]]>
      </doc>
    </method>
    <method name="callAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner4.AsyncClosingFunction4&lt;V1, V2, V3, V4, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 {@code ClosingFuture}-returning function to their values. The function can use a {@link
 DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
 captured by the returned {@link ClosingFuture}).

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.

 <p>If the function throws any other exception, it will be used as the failure of the derived
 step.

 <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
 the closeable objects in that {@code ClosingFuture} will be closed.

 <p>Usage guidelines for this method:

 <ul>
   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a
       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
       Executor)} instead, with a function that returns the next value directly.
   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}
       for every closeable object this step creates in order to capture it for later closing.
   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
       ClosingFuture} call {@link #from(ListenableFuture)}.
 </ul>

 <p>The same warnings about doing heavyweight operations within {@link
 ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A generic {@link Combiner} that lets you use a lambda or method reference to combine four
 {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture)} to start this combination.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <V4> the type returned by the fourth future]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.Combiner4 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner4.AsyncClosingFunction4 -->
  <interface name="ClosingFuture.Combiner4.AsyncClosingFunction4"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <param name="value3" type="V3 extends java.lang.Object"/>
      <param name="value4" type="V4 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to four inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a {@link ClosingFuture} when applied to the values of the four
 futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <V4> the type returned by the fourth future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner4.AsyncClosingFunction4 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner4.ClosingFunction4 -->
  <interface name="ClosingFuture.Combiner4.ClosingFunction4"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="U extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <param name="value3" type="V3 extends java.lang.Object"/>
      <param name="value4" type="V4 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to four inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a value when applied to the values of the four futures passed to
 {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <V4> the type returned by the fourth future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner4.ClosingFunction4 -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.Combiner5 -->
  <class name="ClosingFuture.Combiner5" extends="com.google.common.util.concurrent.ClosingFuture.Combiner"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner5.ClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 combining function to their values. The function can use a {@link DeferredCloser} to capture
 objects to be closed when the pipeline is done.

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the
 returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.]]>
      </doc>
    </method>
    <method name="callAsync" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.ClosingFuture.Combiner5.AsyncClosingFunction5&lt;V1, V2, V3, V4, V5, U&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code ClosingFuture} pipeline step derived from the inputs by applying a
 {@code ClosingFuture}-returning function to their values. The function can use a {@link
 DeferredCloser} to capture objects to be closed when the pipeline is done (other than those
 captured by the returned {@link ClosingFuture}).

 <p>If this combiner was returned by {@link #whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture, ClosingFuture)} and any of the inputs fail, so will the
 returned step.

 <p>If the function throws a {@code CancellationException}, the pipeline will be cancelled.

 <p>If the function throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and used as the failure of the derived step.

 <p>If the function throws any other exception, it will be used as the failure of the derived
 step.

 <p>If an exception is thrown after the function creates a {@code ClosingFuture}, then none of
 the closeable objects in that {@code ClosingFuture} will be closed.

 <p>Usage guidelines for this method:

 <ul>
   <li>Use this method only when calling an API that returns a {@link ListenableFuture} or a
       {@code ClosingFuture}. If possible, prefer calling {@link #call(CombiningCallable,
       Executor)} instead, with a function that returns the next value directly.
   <li>Call {@link DeferredCloser#eventuallyClose(Object, Executor) closer.eventuallyClose()}
       for every closeable object this step creates in order to capture it for later closing.
   <li>Return a {@code ClosingFuture}. To turn a {@link ListenableFuture} into a {@code
       ClosingFuture} call {@link #from(ListenableFuture)}.
 </ul>

 <p>The same warnings about doing heavyweight operations within {@link
 ClosingFuture#transformAsync(AsyncClosingFunction, Executor)} apply here.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A generic {@link Combiner} that lets you use a lambda or method reference to combine five
 {@link ClosingFuture}s. Use {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)} to start this combination.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <V4> the type returned by the fourth future
 @param <V5> the type returned by the fifth future]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.Combiner5 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner5.AsyncClosingFunction5 -->
  <interface name="ClosingFuture.Combiner5.AsyncClosingFunction5"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="com.google.common.util.concurrent.ClosingFuture&lt;U&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <param name="value3" type="V3 extends java.lang.Object"/>
      <param name="value4" type="V4 extends java.lang.Object"/>
      <param name="value5" type="V5 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to five inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a {@link ClosingFuture} when applied to the values of the five
 futures passed to {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <V4> the type returned by the fourth future
 @param <V5> the type returned by the fifth future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner5.AsyncClosingFunction5 -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.Combiner5.ClosingFunction5 -->
  <interface name="ClosingFuture.Combiner5.ClosingFunction5"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="U extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closer" type="com.google.common.util.concurrent.ClosingFuture.DeferredCloser"/>
      <param name="value1" type="V1 extends java.lang.Object"/>
      <param name="value2" type="V2 extends java.lang.Object"/>
      <param name="value3" type="V3 extends java.lang.Object"/>
      <param name="value4" type="V4 extends java.lang.Object"/>
      <param name="value5" type="V5 extends java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Applies this function to five inputs, or throws an exception if unable to do so.

 <p>Any objects that are passed to {@link DeferredCloser#eventuallyClose(Object, Executor)
 closer.eventuallyClose()} will be closed when the {@link ClosingFuture} pipeline is done
 (but not before this method completes), even if this method throws or the pipeline is
 cancelled.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A function that returns a value when applied to the values of the five futures passed to
 {@link #whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture)}.

 @param <V1> the type returned by the first future
 @param <V2> the type returned by the second future
 @param <V3> the type returned by the third future
 @param <V4> the type returned by the fourth future
 @param <V5> the type returned by the fifth future
 @param <U> the type returned by the function]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.Combiner5.ClosingFunction5 -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.DeferredCloser -->
  <class name="ClosingFuture.DeferredCloser" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="eventuallyClose" return="C extends java.lang.Object &amp; java.lang.AutoCloseable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeable" type="C extends java.lang.Object &amp; java.lang.AutoCloseable"/>
      <param name="closingExecutor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Captures an object to be closed when a {@link ClosingFuture} pipeline is done.

 <p>Be careful when targeting an older SDK than you are building against (most commonly when
 building for Android): Ensure that any object you pass implements the interface not just in
 your current SDK version but also at the oldest version you support. For example, <a
 href="https://developer.android.com/sdk/api_diff/28/changes/android.media.MediaDrm#android.media.MediaDrm.close_added()">API
 Level 28</a> is the first version in which {@code MediaDrm} is {@code AutoCloseable}. To
 support older versions, pass a wrapper {@code AutoCloseable} with a method reference like
 {@code mediaDrm::release}.

 @param closeable the object to be closed
 @param closingExecutor the object will be closed on this executor
 @return the first argument]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that can capture objects to be closed later, when a {@link ClosingFuture} pipeline is
 done.]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.DeferredCloser -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.Peeker -->
  <class name="ClosingFuture.Peeker" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getDone" return="D extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="closingFuture" type="com.google.common.util.concurrent.ClosingFuture&lt;D&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns the value of {@code closingFuture}.

 @throws ExecutionException if {@code closingFuture} is a failed step
 @throws CancellationException if the {@code closingFuture}'s future was cancelled
 @throws IllegalArgumentException if {@code closingFuture} is not one of the futures passed to
     {@link #whenAllComplete(Iterable)} or {@link #whenAllComplete(Iterable)}
 @throws IllegalStateException if called outside of a call to {@link
     CombiningCallable#call(DeferredCloser, Peeker)} or {@link
     AsyncCombiningCallable#call(DeferredCloser, Peeker)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that can return the value of the {@link ClosingFuture}s that are passed to {@link
 #whenAllComplete(Iterable)} or {@link #whenAllSucceed(Iterable)}.

 <p>Only for use by a {@link CombiningCallable} or {@link AsyncCombiningCallable} object.]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.Peeker -->
  <!-- start class com.google.common.util.concurrent.ClosingFuture.ValueAndCloser -->
  <class name="ClosingFuture.ValueAndCloser" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns the final value of the associated {@link ClosingFuture}, or throws an exception as
 {@link Future#get()} would.

 <p>Because the asynchronous operation has already completed, this method is synchronous and
 returns immediately.

 @throws CancellationException if the computation was cancelled
 @throws ExecutionException if the computation threw an exception]]>
      </doc>
    </method>
    <method name="closeAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Starts closing all closeable objects captured during the {@link ClosingFuture}'s asynchronous
 operation on the {@link Executor}s specified by calls to {@link
 DeferredCloser#eventuallyClose(Object, Executor)}.

 <p>If any such calls specified {@link MoreExecutors#directExecutor()}, those objects will be
 closed synchronously.

 <p>Idempotent: objects will be closed at most once.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that holds the final result of an asynchronous {@link ClosingFuture} operation and
 allows the user to close all the closeable objects that were captured during it for later
 closing.

 <p>The asynchronous operation will have completed before this object is created.

 @param <V> the type of the value of a successful operation
 @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ClosingFuture.ValueAndCloser -->
  <!-- start interface com.google.common.util.concurrent.ClosingFuture.ValueAndCloserConsumer -->
  <interface name="ClosingFuture.ValueAndCloserConsumer"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueAndCloser" type="com.google.common.util.concurrent.ClosingFuture.ValueAndCloser&lt;V&gt;"/>
      <doc>
      <![CDATA[Accepts a {@link ValueAndCloser} for the last step in a {@link ClosingFuture} pipeline.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents an operation that accepts a {@link ValueAndCloser} for the last step in a {@link
 ClosingFuture} pipeline.

 @param <V> the type of the final value of a successful pipeline
 @see ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ClosingFuture.ValueAndCloserConsumer -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory -->
  <class name="CycleDetectingLockFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newInstance" return="com.google.common.util.concurrent.CycleDetectingLockFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="policy" type="com.google.common.util.concurrent.CycleDetectingLockFactory.Policy"/>
      <doc>
      <![CDATA[Creates a new factory with the specified policy.]]>
      </doc>
    </method>
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantLock(lockName, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantLock} with the given fairness policy. The {@code lockName} is used in
 the warning or exception output to help identify the locks involved in the detected deadlock.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantReadWriteLock(lockName, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockName" type="java.lang.String"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantReadWriteLock} with the given fairness policy. The {@code lockName}
 is used in the warning or exception output to help identify the locks involved in the detected
 deadlock.]]>
      </doc>
    </method>
    <method name="newInstanceWithExplicitOrdering" return="com.google.common.util.concurrent.CycleDetectingLockFactory.WithExplicitOrdering&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enumClass" type="java.lang.Class&lt;E&gt;"/>
      <param name="policy" type="com.google.common.util.concurrent.CycleDetectingLockFactory.Policy"/>
      <doc>
      <![CDATA[Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The {@code CycleDetectingLockFactory} creates {@link ReentrantLock} instances and {@link
 ReentrantReadWriteLock} instances that detect potential deadlock by checking for cycles in lock
 acquisition order.

 <p>Potential deadlocks detected when calling the {@code lock()}, {@code lockInterruptibly()}, or
 {@code tryLock()} methods will result in the execution of the {@link Policy} specified when
 creating the factory. The currently available policies are:

 <ul>
   <li>DISABLED
   <li>WARN
   <li>THROW
 </ul>

 <p>The locks created by a factory instance will detect lock acquisition cycles with locks created
 by other {@code CycleDetectingLockFactory} instances (except those with {@code Policy.DISABLED}).
 A lock's behavior when a cycle is detected, however, is defined by the {@code Policy} of the
 factory that created it. This allows detection of cycles across components while delegating
 control over lock behavior to individual components.

 <p>Applications are encouraged to use a {@code CycleDetectingLockFactory} to create any locks for
 which external/unmanaged code is executed while the lock is held. (See caveats under
 <strong>Performance</strong>).

 <p><strong>Cycle Detection</strong>

 <p>Deadlocks can arise when locks are acquired in an order that forms a cycle. In a simple
 example involving two locks and two threads, deadlock occurs when one thread acquires Lock A, and
 then Lock B, while another thread acquires Lock B, and then Lock A:

 <pre>
 Thread1: acquire(LockA) --X acquire(LockB)
 Thread2: acquire(LockB) --X acquire(LockA)
 </pre>

 <p>Neither thread will progress because each is waiting for the other. In more complex
 applications, cycles can arise from interactions among more than 2 locks:

 <pre>
 Thread1: acquire(LockA) --X acquire(LockB)
 Thread2: acquire(LockB) --X acquire(LockC)
 ...
 ThreadN: acquire(LockN) --X acquire(LockA)
 </pre>

 <p>The implementation detects cycles by constructing a directed graph in which each lock
 represents a node and each edge represents an acquisition ordering between two locks.

 <ul>
   <li>Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired locks when the
       Thread acquires its first hold (and releases its last remaining hold).
   <li>Before the lock is acquired, the lock is checked against the current set of acquired
       locks---to each of the acquired locks, an edge from the soon-to-be-acquired lock is either
       verified or created.
   <li>If a new edge needs to be created, the outgoing edges of the acquired locks are traversed
       to check for a cycle that reaches the lock to be acquired. If no cycle is detected, a new
       "safe" edge is created.
   <li>If a cycle is detected, an "unsafe" (cyclic) edge is created to represent a potential
       deadlock situation, and the appropriate Policy is executed.
 </ul>

 <p>Note that detection of potential deadlock does not necessarily indicate that deadlock will
 happen, as it is possible that higher level application logic prevents the cyclic lock
 acquisition from occurring. One example of a false positive is:

 <pre>
 LockA -&gt; LockB -&gt; LockC
 LockA -&gt; LockC -&gt; LockB
 </pre>

 <p><strong>ReadWriteLocks</strong>

 <p>While {@code ReadWriteLock} instances have different properties and can form cycles without
 potential deadlock, this class treats {@code ReadWriteLock} instances as equivalent to
 traditional exclusive locks. Although this increases the false positives that the locks detect
 (i.e. cycles that will not actually result in deadlock), it simplifies the algorithm and
 implementation considerably. The assumption is that a user of this factory wishes to eliminate
 any cyclic acquisition ordering.

 <p><strong>Explicit Lock Acquisition Ordering</strong>

 <p>The {@link CycleDetectingLockFactory.WithExplicitOrdering} class can be used to enforce an
 application-specific ordering in addition to performing general cycle detection.

 <p><strong>Garbage Collection</strong>

 <p>In order to allow proper garbage collection of unused locks, the edges of the lock graph are
 weak references.

 <p><strong>Performance</strong>

 <p>The extra bookkeeping done by cycle detecting locks comes at some cost to performance.
 Benchmarks (as of December 2011) show that:

 <ul>
   <li>for an unnested {@code lock()} and {@code unlock()}, a cycle detecting lock takes 38ns as
       opposed to the 24ns taken by a plain lock.
   <li>for nested locking, the cost increases with the depth of the nesting:
       <ul>
         <li>2 levels: average of 64ns per lock()/unlock()
         <li>3 levels: average of 77ns per lock()/unlock()
         <li>4 levels: average of 99ns per lock()/unlock()
         <li>5 levels: average of 103ns per lock()/unlock()
         <li>10 levels: average of 184ns per lock()/unlock()
         <li>20 levels: average of 393ns per lock()/unlock()
       </ul>
 </ul>

 <p>As such, the CycleDetectingLockFactory may not be suitable for performance-critical
 applications which involve tightly-looped or deeply-nested locking algorithms.

 @author Darick Tong
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory.Policies -->
  <class name="CycleDetectingLockFactory.Policies" extends="java.lang.Enum&lt;com.google.common.util.concurrent.CycleDetectingLockFactory.Policies&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.CycleDetectingLockFactory.Policy"/>
    <method name="values" return="com.google.common.util.concurrent.CycleDetectingLockFactory.Policies[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.util.concurrent.CycleDetectingLockFactory.Policies"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Pre-defined {@link Policy} implementations.

 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory.Policies -->
  <!-- start interface com.google.common.util.concurrent.CycleDetectingLockFactory.Policy -->
  <interface name="CycleDetectingLockFactory.Policy"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handlePotentialDeadlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException"/>
      <doc>
      <![CDATA[Called when a potential deadlock is encountered. Implementations can throw the given {@code
 exception} and/or execute other desired logic.

 <p>Note that the method will be called even upon an invocation of {@code tryLock()}. Although
 {@code tryLock()} technically recovers from deadlock by eventually timing out, this behavior
 is chosen based on the assumption that it is the application's wish to prohibit any cyclical
 lock acquisitions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encapsulates the action to be taken when a potential deadlock is encountered. Clients can use
 one of the predefined {@link Policies} or specify a custom implementation. Implementations must
 be thread-safe.

 @since 13.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.CycleDetectingLockFactory.Policy -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException -->
  <class name="CycleDetectingLockFactory.PotentialDeadlockException" extends="com.google.common.util.concurrent.CycleDetectingLockFactory.ExampleStackTrace"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getConflictingStackTrace" return="com.google.common.util.concurrent.CycleDetectingLockFactory.ExampleStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Appends the chain of messages from the {@code conflictingStackTrace} to the original {@code
 message}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a detected cycle in lock acquisition ordering. The exception includes a causal chain
 of {@code ExampleStackTrace} instances to illustrate the cycle, e.g.

 <pre>
 com....PotentialDeadlockException: Potential Deadlock from LockC -&gt; ReadWriteA
   at ...
   at ...
 Caused by: com...ExampleStackTrace: LockB -&gt; LockC
   at ...
   at ...
 Caused by: com...ExampleStackTrace: ReadWriteA -&gt; LockB
   at ...
   at ...
 </pre>

 <p>Instances are logged for the {@code Policies.WARN}, and thrown for {@code Policies.THROW}.

 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory.PotentialDeadlockException -->
  <!-- start class com.google.common.util.concurrent.CycleDetectingLockFactory.WithExplicitOrdering -->
  <class name="CycleDetectingLockFactory.WithExplicitOrdering" extends="com.google.common.util.concurrent.CycleDetectingLockFactory"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantLock(rank, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantLock} with the given fairness policy and rank. The values returned
 by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the lock in
 warning or exception output.

 @throws IllegalStateException If the factory has already created a {@code Lock} with the
     specified rank.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Equivalent to {@code newReentrantReadWriteLock(rank, false)}.]]>
      </doc>
    </method>
    <method name="newReentrantReadWriteLock" return="java.util.concurrent.locks.ReentrantReadWriteLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rank" type="E extends java.lang.Enum&lt;E&gt;"/>
      <param name="fair" type="boolean"/>
      <doc>
      <![CDATA[Creates a {@link ReentrantReadWriteLock} with the given fairness policy and rank. The values
 returned by {@link Enum#getDeclaringClass()} and {@link Enum#name()} are used to describe the
 lock in warning or exception output.

 @throws IllegalStateException If the factory has already created a {@code Lock} with the
     specified rank.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code CycleDetectingLockFactory.WithExplicitOrdering} provides the additional enforcement of
 an application-specified ordering of lock acquisitions. The application defines the allowed
 ordering with an {@code Enum} whose values each correspond to a lock type. The order in which
 the values are declared dictates the allowed order of lock acquisition. In other words, locks
 corresponding to smaller values of {@link Enum#ordinal()} should only be acquired before locks
 with larger ordinals. Example:

 {@snippet :
 enum MyLockOrder {
   FIRST, SECOND, THIRD;
 }

 CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory =
   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(Policies.THROW);

 Lock lock1 = factory.newReentrantLock(MyLockOrder.FIRST);
 Lock lock2 = factory.newReentrantLock(MyLockOrder.SECOND);
 Lock lock3 = factory.newReentrantLock(MyLockOrder.THIRD);

 lock1.lock();
 lock3.lock();
 lock2.lock();  // will throw an IllegalStateException
 }

 <p>As with all locks created by instances of {@code CycleDetectingLockFactory} explicitly
 ordered locks participate in general cycle detection with all other cycle detecting locks, and
 a lock's behavior when detecting a cyclic lock acquisition is defined by the {@code Policy} of
 the factory that created it.

 <p>Note, however, that although multiple locks can be created for a given Enum value, whether
 it be through separate factory instances or through multiple calls to the same factory,
 attempting to acquire multiple locks with the same Enum value (within the same thread) will
 result in an IllegalStateException regardless of the factory's policy. For example:

 {@snippet :
 CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory1 =
   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);
 CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory2 =
   CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);

 Lock lockA = factory1.newReentrantLock(MyLockOrder.FIRST);
 Lock lockB = factory1.newReentrantLock(MyLockOrder.FIRST);
 Lock lockC = factory2.newReentrantLock(MyLockOrder.FIRST);

 lockA.lock();

 lockB.lock();  // will throw an IllegalStateException
 lockC.lock();  // will throw an IllegalStateException

 lockA.lock();  // reentrant acquisition is okay
 }

 <p>It is the responsibility of the application to ensure that multiple lock instances with the
 same rank are never acquired in the same thread.

 @param <E> The Enum type representing the explicit lock ordering.
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.CycleDetectingLockFactory.WithExplicitOrdering -->
  <!-- start class com.google.common.util.concurrent.ExecutionError -->
  <class name="ExecutionError" extends="java.lang.Error"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExecutionError"
      static="false" final="false" visibility="protected"
      deprecated="Prefer {@linkplain ExecutionError(Error)} a constructor that accepts a cause: Users
     of this class typically expect for instances to have a non-null cause. At the moment, you
     can lEsS_tHaNi>usuallylEsS_tHaN/i> still preserve behavior by passing an explicit {@code null} cause. Note,
     however, that passing an explicit {@code null} cause prevents anyone from calling {@link
     #initCause} later, so it is not quite equivalent to using a constructor that omits the
     cause.">
      <doc>
      <![CDATA[Creates a new instance with {@code null} as its detail message and no cause.

 @deprecated Prefer {@linkplain ExecutionError(Error)} a constructor that accepts a cause: Users
     of this class typically expect for instances to have a non-null cause. At the moment, you
     can <i>usually</i> still preserve behavior by passing an explicit {@code null} cause. Note,
     however, that passing an explicit {@code null} cause prevents anyone from calling {@link
     #initCause} later, so it is not quite equivalent to using a constructor that omits the
     cause.]]>
      </doc>
    </constructor>
    <constructor name="ExecutionError" type="String"
      static="false" final="false" visibility="protected"
      deprecated="Prefer {@linkplain ExecutionError(String, Error)} a constructor that accepts a
     cause: Users of this class typically expect for instances to have a non-null cause. At the
     moment, you can lEsS_tHaNi>usuallylEsS_tHaN/i> still preserve behavior by passing an explicit {@code null}
     cause. Note, however, that passing an explicit {@code null} cause prevents anyone from
     calling {@link #initCause} later, so it is not quite equivalent to using a constructor that
     omits the cause.">
      <doc>
      <![CDATA[Creates a new instance with the given detail message and no cause.

 @deprecated Prefer {@linkplain ExecutionError(String, Error)} a constructor that accepts a
     cause: Users of this class typically expect for instances to have a non-null cause. At the
     moment, you can <i>usually</i> still preserve behavior by passing an explicit {@code null}
     cause. Note, however, that passing an explicit {@code null} cause prevents anyone from
     calling {@link #initCause} later, so it is not quite equivalent to using a constructor that
     omits the cause.]]>
      </doc>
    </constructor>
    <constructor name="ExecutionError" type="String, Error"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given detail message and cause. Prefer to provide a
 non-nullable {@code cause}, as many users expect to find one.]]>
      </doc>
    </constructor>
    <constructor name="ExecutionError" type="Error"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with {@code null} as its detail message and the given cause. Prefer to
 provide a non-nullable {@code cause}, as many users expect to find one.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[{@link Error} variant of {@link java.util.concurrent.ExecutionException}. As with {@code
 ExecutionException}, the error's {@linkplain #getCause() cause} comes from a failed task,
 possibly run in another thread. That cause should itself be an {@code Error}; if not, use {@code
 ExecutionException} or {@link UncheckedExecutionException}. This allows the client code to
 continue to distinguish between exceptions and errors, even when they come from other threads.

 @author Chris Povirk
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ExecutionError -->
  <!-- start class com.google.common.util.concurrent.ExecutionList -->
  <class name="ExecutionList" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExecutionList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty {@link ExecutionList}.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Adds the {@code Runnable} and accompanying {@code Executor} to the list of listeners to
 execute. If execution has already begun, the listener is executed immediately.

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
 documentation.]]>
      </doc>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Runs this execution list, executing all existing pairs in the order they were added. However,
 note that listeners added after this point may be executed before those previously added, and
 note that the execution order of all listeners is ultimately chosen by the implementations of
 the supplied executors.

 <p>This method is idempotent. Calling it several times in parallel is semantically equivalent
 to calling it exactly once.

 @since 10.0 (present in 1.0 as {@code run})]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A support class for {@code ListenableFuture} implementations to manage their listeners. An
 instance contains a list of listeners, each with an associated {@code Executor}, and guarantees
 that every {@code Runnable} that is {@linkplain #add added} will be executed after {@link
 #execute()} is called. Any {@code Runnable} added after the call to {@code execute} is still
 guaranteed to execute. There is no guarantee, however, that listeners will be executed in the
 order that they are added.

 <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown
 during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception
 thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught and logged.

 @author Nishant Thakkar
 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ExecutionList -->
  <!-- start class com.google.common.util.concurrent.ExecutionSequencer -->
  <class name="ExecutionSequencer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.ExecutionSequencer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance.]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Enqueues a task to run when the previous task (if any) completes.

 <p>Cancellation does not propagate from the output future to a callable that has begun to
 execute, but if the output future is cancelled before {@link Callable#call()} is invoked,
 {@link Callable#call()} will not be invoked.]]>
      </doc>
    </method>
    <method name="submitAsync" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="com.google.common.util.concurrent.AsyncCallable&lt;T&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Enqueues a task to run when the previous task (if any) completes.

 <p>Cancellation does not propagate from the output future to the future returned from {@code
 callable} or a callable that has begun to execute, but if the output future is cancelled before
 {@link AsyncCallable#call()} is invoked, {@link AsyncCallable#call()} will not be invoked.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Serializes execution of tasks, somewhat like an "asynchronous {@code synchronized} block." Each
 {@linkplain #submit enqueued} callable will not be submitted to its associated executor until the
 previous callable has returned -- and, if the previous callable was an {@link AsyncCallable}, not
 until the {@code Future} it returned is {@linkplain Future#isDone done} (successful, failed, or
 cancelled).

 <p>This class serializes execution of <i>submitted</i> tasks but not any <i>listeners</i> of
 those tasks.

 <p>Submitted tasks have a happens-before order as defined in the Java Language Specification.
 Tasks execute with the same happens-before order that the function calls to {@link #submit} and
 {@link #submitAsync} that submitted those tasks had.

 <p>This class has limited support for cancellation and other "early completions":

 <ul>
   <li>While calls to {@code submit} and {@code submitAsync} return a {@code Future} that can be
       cancelled, cancellation never propagates to a task that has started to run -- neither to
       the callable itself nor to any {@code Future} returned by an {@code AsyncCallable}.
       (However, cancellation can prevent an <i>unstarted</i> task from running.) Therefore, the
       next task will wait for any running callable (or pending {@code Future} returned by an
       {@code AsyncCallable}) to complete, without interrupting it (and without calling {@code
       cancel} on the {@code Future}). So beware: <i>Even if you cancel every preceding {@code
       Future} returned by this class, the next task may still have to wait.</i>.
   <li>Once an {@code AsyncCallable} returns a {@code Future}, this class considers that task to
       be "done" as soon as <i>that</i> {@code Future} completes in any way. Notably, a {@code
       Future} is "completed" even if it is cancelled while its underlying work continues on a
       thread, an RPC, etc. The {@code Future} is also "completed" if it fails "early" -- for
       example, if the deadline expires on a {@code Future} returned from {@link
       Futures#withTimeout} while the {@code Future} it wraps continues its underlying work. So
       beware: <i>Your {@code AsyncCallable} should not complete its {@code Future} until it is
       safe for the next task to start.</i>
 </ul>

 <p>This class is similar to {@link MoreExecutors#newSequentialExecutor}. This class is different
 in a few ways:

 <ul>
   <li>Each task may be associated with a different executor.
   <li>Tasks may be of type {@code AsyncCallable}.
   <li>Running tasks <i>cannot</i> be interrupted. (Note that {@code newSequentialExecutor} does
       not return {@code Future} objects, so it doesn't support interruption directly, either.
       However, utilities that <i>use</i> that executor have the ability to interrupt tasks
       running on it. This class, by contrast, does not expose an {@code Executor} API.)
 </ul>

 <p>If you don't need the features of this class, you may prefer {@code newSequentialExecutor} for
 its simplicity and ability to accommodate interruption.

 @since 26.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ExecutionSequencer -->
  <!-- start class com.google.common.util.concurrent.FakeTimeLimiter -->
  <class name="FakeTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <constructor name="FakeTimeLimiter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link FakeTimeLimiter}.]]>
      </doc>
    </constructor>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="callUninterruptiblyWithTimeout" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="runWithTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="runUninterruptiblyWithTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter implementation which actually does not attempt to limit time at all. This may be
 desirable to use in some unit tests. More importantly, attempting to debug a call which is
 time-limited would be extremely annoying, so this gives you a time-limiter you can easily swap in
 for your real time-limiter while you're debugging.

 @author Kevin Bourrillion
 @author Jens Nyman
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.FakeTimeLimiter -->
  <!-- start class com.google.common.util.concurrent.FluentFuture -->
  <class name="FluentFuture" extends="com.google.common.util.concurrent.GwtFluentFutureCatchingSpecialization&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="from" return="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <doc>
      <![CDATA[Converts the given {@code ListenableFuture} to an equivalent {@code FluentFuture}.

 <p>If the given {@code ListenableFuture} is already a {@code FluentFuture}, it is returned
 directly. If not, it is wrapped in a {@code FluentFuture} that delegates all calls to the
 original {@code ListenableFuture}.]]>
      </doc>
    </method>
    <method name="from" return="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="no need to use this">
      <param name="future" type="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"/>
      <doc>
      <![CDATA[Simply returns its argument.

 @deprecated no need to use this
 @since 28.0]]>
      </doc>
    </method>
    <method name="catching" return="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="exceptionType" type="java.lang.Class&lt;X&gt;"/>
      <param name="fallback" type="com.google.common.base.Function&lt;? super X, ? extends V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a {@code Future} whose result is taken from this {@code Future} or, if this {@code
 Future} fails with the given {@code exceptionType}, from the result provided by the {@code
 fallback}. {@link Function#apply} is not invoked until the primary input has failed, so if the
 primary input succeeds, it is never invoked. If, during the invocation of {@code fallback}, an
 exception is thrown, this exception is used as the result of the output {@code Future}.

 <p>Usage example:

 {@snippet :
 // Falling back to a zero counter in case an exception happens when processing the RPC to fetch
 // counters.
 ListenableFuture<Integer> faultTolerantFuture =
     fetchCounters().catching(FetchException.class, x -> 0, directExecutor());
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link #addListener} documentation. All its warnings about heavyweight
 listeners are also applicable to heavyweight functions passed to this method.

 <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It
 can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}
 and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link
 #transform}.

 @param exceptionType the exception type that triggers use of {@code fallback}. The exception
     type is matched against the input's exception. "The input's exception" means the cause of
     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a
     different kind of exception, that exception itself. To avoid hiding bugs and other
     unrecoverable errors, callers should prefer more specific types, avoiding {@code
     Throwable.class} in particular.
 @param fallback the {@link Function} to be called if the input fails with the expected
     exception type. The function's argument is the input's exception. "The input's exception"
     means the cause of the {@link ExecutionException} thrown by {@code this.get()} or, if
     {@code get()} throws a different kind of exception, that exception itself.
 @param executor the executor that runs {@code fallback} if the input fails]]>
      </doc>
    </method>
    <method name="catchingAsync" return="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="exceptionType" type="java.lang.Class&lt;X&gt;"/>
      <param name="fallback" type="com.google.common.util.concurrent.AsyncFunction&lt;? super X, ? extends V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a {@code Future} whose result is taken from this {@code Future} or, if this {@code
 Future} fails with the given {@code exceptionType}, from the result provided by the {@code
 fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has failed, so if
 the primary input succeeds, it is never invoked. If, during the invocation of {@code fallback},
 an exception is thrown, this exception is used as the result of the output {@code Future}.

 <p>Usage examples:

 {@snippet :
 // Falling back to a zero counter in case an exception happens when processing the RPC to fetch
 // counters.
 ListenableFuture<Integer> faultTolerantFuture =
     fetchCounters().catchingAsync(
         FetchException.class, x -> immediateFuture(0), directExecutor());
 }

 <p>The fallback can also choose to propagate the original exception when desired:

 {@snippet :
 // Falling back to a zero counter only in case the exception was a
 // TimeoutException.
 ListenableFuture<Integer> faultTolerantFuture =
     fetchCounters().catchingAsync(
         FetchException.class,
         e -> {
           if (omitDataOnFetchFailure) {
             return immediateFuture(0);
           }
           throw e;
         },
         directExecutor());
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link #addListener} documentation. All its warnings about heavyweight
 listeners are also applicable to heavyweight functions passed to this method. (Specifically,
 {@code directExecutor} functions should avoid heavyweight operations inside {@code
 AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for
 completing the returned {@code Future}.)

 <p>This method is similar to {@link java.util.concurrent.CompletableFuture#exceptionally}. It
 can also serve some of the use cases of {@link java.util.concurrent.CompletableFuture#handle}
 and {@link java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link
 #transform}.

 @param exceptionType the exception type that triggers use of {@code fallback}. The exception
     type is matched against the input's exception. "The input's exception" means the cause of
     the {@link ExecutionException} thrown by {@code this.get()} or, if {@code get()} throws a
     different kind of exception, that exception itself. To avoid hiding bugs and other
     unrecoverable errors, callers should prefer more specific types, avoiding {@code
     Throwable.class} in particular.
 @param fallback the {@link AsyncFunction} to be called if the input fails with the expected
     exception type. The function's argument is the input's exception. "The input's exception"
     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if
     {@code get()} throws a different kind of exception, that exception itself.
 @param executor the executor that runs {@code fallback} if the input fails]]>
      </doc>
    </method>
    <method name="withTimeout" return="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="java.time.Duration"/>
      <param name="scheduledExecutor" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Returns a future that delegates to this future but will finish early (via a {@link
 TimeoutException} wrapped in an {@link ExecutionException}) if the specified timeout expires.
 If the timeout expires, not only will the output future finish, but also the input future
 ({@code this}) will be cancelled and interrupted.

 @param timeout when to time out the future
 @param scheduledExecutor The executor service to enforce the timeout.
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="withTimeout" return="com.google.common.util.concurrent.FluentFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="scheduledExecutor" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Returns a future that delegates to this future but will finish early (via a {@link
 TimeoutException} wrapped in an {@link ExecutionException}) if the specified timeout expires.
 If the timeout expires, not only will the output future finish, but also the input future
 ({@code this}) will be cancelled and interrupted.

 @param timeout when to time out the future
 @param unit the time unit of the time parameter
 @param scheduledExecutor The executor service to enforce the timeout.]]>
      </doc>
    </method>
    <method name="transformAsync" return="com.google.common.util.concurrent.FluentFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.util.concurrent.AsyncFunction&lt;? super V, T&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code Future} whose result is asynchronously derived from the result of this
 {@code Future}. If the input {@code Future} fails, the returned {@code Future} fails with the
 same exception (and the function is not invoked).

 <p>More precisely, the returned {@code Future} takes its result from a {@code Future} produced
 by applying the given {@code AsyncFunction} to the result of the original {@code Future}.
 Example usage:

 {@snippet :
 FluentFuture<RowKey> rowKeyFuture = FluentFuture.from(indexService.lookUp(query));
 ListenableFuture<QueryResult> queryFuture =
     rowKeyFuture.transformAsync(dataService::readFuture, executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link #addListener} documentation. All its warnings about heavyweight
 listeners are also applicable to heavyweight functions passed to this method. (Specifically,
 {@code directExecutor} functions should avoid heavyweight operations inside {@code
 AsyncFunction.apply}. Any heavyweight operations should occur in other threads responsible for
 completing the returned {@code Future}.)

 <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
 input future and that of the future returned by the chain function. That is, if the returned
 {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the
 other two is cancelled, the returned {@code Future} will receive a callback in which it will
 attempt to cancel itself.

 <p>This method is similar to {@link java.util.concurrent.CompletableFuture#thenCompose} and
 {@link java.util.concurrent.CompletableFuture#thenComposeAsync}. It can also serve some of the
 use cases of {@link java.util.concurrent.CompletableFuture#handle} and {@link
 java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link #catching}.

 @param function A function to transform the result of this future to the result of the output
     future
 @param executor Executor to run the function in.
 @return A future that holds result of the function (if the input succeeded) or the original
     input's failure (if not)]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.util.concurrent.FluentFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="com.google.common.base.Function&lt;? super V, T&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code Future} whose result is derived from the result of this {@code Future}. If
 this input {@code Future} fails, the returned {@code Future} fails with the same exception (and
 the function is not invoked). Example usage:

 {@snippet :
 ListenableFuture<List<Row>> rowsFuture =
     queryFuture.transform(QueryResult::getRows, executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link #addListener} documentation. All its warnings about heavyweight
 listeners are also applicable to heavyweight functions passed to this method.

 <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
 input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel
 the input, and if the input is cancelled, the returned {@code Future} will receive a callback
 in which it will attempt to cancel itself.

 <p>An example use of this method is to convert a serializable object returned from an RPC into
 a POJO.

 <p>This method is similar to {@link java.util.concurrent.CompletableFuture#thenApply} and
 {@link java.util.concurrent.CompletableFuture#thenApplyAsync}. It can also serve some of the
 use cases of {@link java.util.concurrent.CompletableFuture#handle} and {@link
 java.util.concurrent.CompletableFuture#handleAsync} when used along with {@link #catching}.

 @param function A Function to transform the results of this future to the results of the
     returned future.
 @param executor Executor to run the function in.
 @return A future that holds result of the transformation.]]>
      </doc>
    </method>
    <method name="addCallback"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="callback" type="com.google.common.util.concurrent.FutureCallback&lt;? super V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers separate success and failure callbacks to be run when this {@code Future}'s
 computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the
 computation is already complete, immediately.

 <p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of
 callbacks, but any callback added through this method is guaranteed to be called once the
 computation is complete.

 <p>Example:

 {@snippet :
 future.addCallback(
     new FutureCallback<QueryResult>() {
       public void onSuccess(QueryResult result) {
         storeInCache(result);
       }
       public void onFailure(Throwable t) {
         reportError(t);
       }
     }, executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link #addListener} documentation. All its warnings about heavyweight
 listeners are also applicable to heavyweight callbacks passed to this method.

 <p>For a more general interface to attach a completion listener, see {@link #addListener}.

 <p>This method is similar to {@link java.util.concurrent.CompletableFuture#whenComplete} and
 {@link java.util.concurrent.CompletableFuture#whenCompleteAsync}. It also serves the use case
 of {@link java.util.concurrent.CompletableFuture#thenAccept} and {@link
 java.util.concurrent.CompletableFuture#thenAcceptAsync}.

 @param callback The callback to invoke when this {@code Future} is completed.
 @param executor The executor to run {@code callback} when the future completes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link ListenableFuture} that supports fluent chains of operations. For example:

 {@snippet :
 ListenableFuture<Boolean> adminIsLoggedIn =
     FluentFuture.from(usersDatabase.getAdminUser())
         .transform(User::getId, directExecutor())
         .transform(ActivityService::isLoggedIn, threadPool)
         .catching(RpcException.class, e -> false, directExecutor());
 }

 <h3>Alternatives</h3>

 <h4>Frameworks</h4>

 <p>When chaining together a graph of asynchronous operations, you will often find it easier to
 use a framework. Frameworks automate the process, often adding features like monitoring,
 debugging, and cancellation. Examples of frameworks include:

 <ul>
   <li><a href="https://dagger.dev/producers.html">Dagger Producers</a>
 </ul>

 <h4>{@link java.util.concurrent.CompletableFuture} / {@link java.util.concurrent.CompletionStage}
 </h4>

 <p>Users of {@code CompletableFuture} will likely want to continue using {@code
 CompletableFuture}. {@code FluentFuture} is targeted at people who use {@code ListenableFuture},
 who can't use Java 8, or who want an API more focused than {@code CompletableFuture}. (If you
 need to adapt between {@code CompletableFuture} and {@code ListenableFuture}, consider <a
 href="https://github.com/lukas-krecan/future-converter">Future Converter</a>.)

 <h3>Extension</h3>

 If you want a class like {@code FluentFuture} but with extra methods, we recommend declaring your
 own subclass of {@link ListenableFuture}, complete with a method like {@link #from} to adapt an
 existing {@code ListenableFuture}, implemented atop a {@link ForwardingListenableFuture} that
 forwards to that future and adds the desired methods.

 @since 23.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.FluentFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingBlockingDeque -->
  <class name="ForwardingBlockingDeque" extends="com.google.common.collect.ForwardingDeque&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.BlockingDeque&lt;E&gt;"/>
    <constructor name="ForwardingBlockingDeque"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.BlockingDeque&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="remainingCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="putFirst"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="putLast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offerFirst" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offerLast" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="takeFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="takeLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="pollFirst" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="pollLast" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="take" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="maxElements" type="int"/>
    </method>
    <doc>
    <![CDATA[A {@link BlockingDeque} which forwards all its method calls to another {@code BlockingDeque}.
 Subclasses should override one or more methods to modify the behavior of the backing deque as
 desired per the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>Warning:</b> The methods of {@code ForwardingBlockingDeque} forward <b>indiscriminately</b>
 to the methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change
 the behaviour of {@link #offer} which can lead to unexpected behaviour. In this case, you should
 override {@code offer} as well, either providing your own implementation, or delegating to the
 provided {@code standardOffer} method.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingBlockingDeque}.

 <p>The {@code standard} methods are not guaranteed to be thread-safe, even when all of the
 methods that they depend on are thread-safe.

 @author Emily Soldal
 @since 21.0 (since 14.0 as {@link com.google.common.collect.ForwardingBlockingDeque})]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingBlockingDeque -->
  <!-- start class com.google.common.util.concurrent.ForwardingBlockingQueue -->
  <class name="ForwardingBlockingQueue" extends="com.google.common.collect.ForwardingQueue&lt;E&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
    <constructor name="ForwardingBlockingQueue"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.BlockingQueue&lt;E&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
      <param name="maxElements" type="int"/>
    </method>
    <method name="drainTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.util.Collection&lt;? super E&gt;"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="poll" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="remainingCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="take" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[A {@link BlockingQueue} which forwards all its method calls to another {@link BlockingQueue}.
 Subclasses should override one or more methods to modify the behavior of the backing collection
 as desired per the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator
 pattern</a>.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingBlockingQueue}.

 @author Raimundo Mirisola
 @param <E> the type of elements held in this collection
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingBlockingQueue -->
  <!-- start class com.google.common.util.concurrent.ForwardingExecutorService -->
  <class name="ForwardingExecutorService" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <constructor name="ForwardingExecutorService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.ExecutorService"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="invokeAny" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="invokeAny" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdownNow" return="java.util.List&lt;java.lang.Runnable&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="T extends java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[An executor service which forwards all its method calls to another executor service. Subclasses
 should override one or more methods to modify the behavior of the backing executor service as
 desired per the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingExecutorService}.

 @author Kurt Alfred Kluever
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingExecutorService -->
  <!-- start class com.google.common.util.concurrent.ForwardingFuture -->
  <class name="ForwardingFuture" extends="com.google.common.collect.ForwardingObject"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <constructor name="ForwardingFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="java.util.concurrent.Future&lt;? extends V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[A {@link Future} which forwards all its method calls to another future. Subclasses should
 override one or more methods to modify the behavior of the backing future as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>Most subclasses can just use {@link SimpleForwardingFuture}.

 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture -->
  <class name="ForwardingFuture.SimpleForwardingFuture" extends="com.google.common.util.concurrent.ForwardingFuture&lt;V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimpleForwardingFuture" type="java.util.concurrent.Future&lt;V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="java.util.concurrent.Future&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingFuture} where subclasses can pass in an already
 constructed {@link Future} as the delegate.

 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingFuture.SimpleForwardingFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingListenableFuture -->
  <class name="ForwardingListenableFuture" extends="com.google.common.util.concurrent.ForwardingFuture&lt;V&gt;"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <constructor name="ForwardingListenableFuture"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <doc>
    <![CDATA[A {@link ListenableFuture} which forwards all its method calls to another future. Subclasses
 should override one or more methods to modify the behavior of the backing future as desired per
 the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p>Most subclasses can just use {@link SimpleForwardingListenableFuture}.

 @author Shardul Deo
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture -->
  <class name="ForwardingListenableFuture.SimpleForwardingListenableFuture" extends="com.google.common.util.concurrent.ForwardingListenableFuture&lt;V&gt;"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimpleForwardingListenableFuture" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simplified version of {@link ForwardingListenableFuture} where subclasses can pass in an
 already constructed {@link ListenableFuture} as the delegate.

 @since 9.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ForwardingListeningExecutorService -->
  <class name="ForwardingListeningExecutorService" extends="com.google.common.util.concurrent.ForwardingExecutorService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListeningExecutorService"/>
    <constructor name="ForwardingListeningExecutorService"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="delegate" return="com.google.common.util.concurrent.ListeningExecutorService"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="T extends java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A listening executor service which forwards all its method calls to another listening executor
 service. Subclasses should override one or more methods to modify the behavior of the backing
 executor service as desired per the <a
 href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.

 <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code
 default} methods. Instead, it inherits their default implementations. When those implementations
 invoke methods, they invoke methods on the {@code ForwardingListeningExecutorService}.

 @author Isaac Shum
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ForwardingListeningExecutorService -->
  <!-- start interface com.google.common.util.concurrent.FutureCallback -->
  <interface name="FutureCallback"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onSuccess"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Invoked with the result of the {@code Future} computation when it is successful.]]>
      </doc>
    </method>
    <method name="onFailure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Invoked when a {@code Future} computation fails or is canceled.

 <p>If the future's {@link Future#get() get} method throws an {@link ExecutionException}, then
 the cause is passed to this method. Any other thrown object is passed unaltered.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callback for accepting the results of a {@link java.util.concurrent.Future} computation
 asynchronously.

 <p>To attach to a {@link ListenableFuture} use {@link Futures#addCallback}.

 @author Anthony Zana
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.FutureCallback -->
  <!-- start class com.google.common.util.concurrent.Futures -->
  <class name="Futures" extends="com.google.common.util.concurrent.GwtFuturesCatchingSpecialization"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="immediateFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFuture} which has its value set immediately upon construction. The
 getters just return the value. This {@code Future} can't be canceled or timed out and its
 {@code isDone()} method always returns {@code true}.]]>
      </doc>
    </method>
    <method name="immediateVoidFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;java.lang.Void&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a successful {@code ListenableFuture<Void>}. This method is equivalent to {@code
 immediateFuture(null)} except that it is restricted to produce futures of type {@code Void}.

 @since 29.0]]>
      </doc>
    </method>
    <method name="immediateFailedFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Returns a {@code ListenableFuture} which has an exception set immediately upon construction.

 <p>The returned {@code Future} can't be cancelled, and its {@code isDone()} method always
 returns {@code true}. Calling {@code get()} will immediately throw the provided {@code
 Throwable} wrapped in an {@code ExecutionException}.]]>
      </doc>
    </method>
    <method name="immediateCancelledFuture" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a {@code ListenableFuture} which is cancelled immediately upon construction, so that
 {@code isCancelled()} always returns {@code true}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;O&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.

 @throws RejectedExecutionException if the task cannot be scheduled for execution
 @since 28.2]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;java.lang.Void&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Executes {@code runnable} on the specified {@code executor}, returning a {@code Future} that
 will complete after execution.

 @throws RejectedExecutionException if the task cannot be scheduled for execution
 @since 28.2]]>
      </doc>
    </method>
    <method name="submitAsync" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="com.google.common.util.concurrent.AsyncCallable&lt;O&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.

 @throws RejectedExecutionException if the task cannot be scheduled for execution
 @since 23.0]]>
      </doc>
    </method>
    <method name="scheduleAsync" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="com.google.common.util.concurrent.AsyncCallable&lt;O&gt;"/>
      <param name="delay" type="java.time.Duration"/>
      <param name="executorService" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Schedules {@code callable} on the specified {@code executor}, returning a {@code Future}.

 @throws RejectedExecutionException if the task cannot be scheduled for execution
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="scheduleAsync" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="com.google.common.util.concurrent.AsyncCallable&lt;O&gt;"/>
      <param name="delay" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="executorService" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Schedules {@code callable} on the specified {@code executor}, returning a {@code Future}.

 @throws RejectedExecutionException if the task cannot be scheduled for execution
 @since 23.0]]>
      </doc>
    </method>
    <method name="catching" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;"/>
      <param name="exceptionType" type="java.lang.Class&lt;X&gt;"/>
      <param name="fallback" type="com.google.common.base.Function&lt;? super X, ? extends V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the
 primary input fails with the given {@code exceptionType}, from the result provided by the
 {@code fallback}. {@link Function#apply} is not invoked until the primary input has failed, so
 if the primary input succeeds, it is never invoked. If, during the invocation of {@code
 fallback}, an exception is thrown, this exception is used as the result of the output {@code
 Future}.

 <p>Usage example:

 {@snippet :
 ListenableFuture<Integer> fetchCounterFuture = ...;

 // Falling back to a zero counter in case an exception happens when
 // processing the RPC to fetch counters.
 ListenableFuture<Integer> faultTolerantFuture = Futures.catching(
     fetchCounterFuture, FetchException.class, x -> 0, directExecutor());
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the warnings the {@link MoreExecutors#directExecutor} documentation.

 @param input the primary input {@code Future}
 @param exceptionType the exception type that triggers use of {@code fallback}. The exception
     type is matched against the input's exception. "The input's exception" means the cause of
     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a
     different kind of exception, that exception itself. To avoid hiding bugs and other
     unrecoverable errors, callers should prefer more specific types, avoiding {@code
     Throwable.class} in particular.
 @param fallback the {@link Function} to be called if {@code input} fails with the expected
     exception type. The function's argument is the input's exception. "The input's exception"
     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if
     {@code get()} throws a different kind of exception, that exception itself.
 @param executor the executor that runs {@code fallback} if {@code input} fails
 @since 19.0]]>
      </doc>
    </method>
    <method name="catchingAsync" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;"/>
      <param name="exceptionType" type="java.lang.Class&lt;X&gt;"/>
      <param name="fallback" type="com.google.common.util.concurrent.AsyncFunction&lt;? super X, ? extends V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a {@code Future} whose result is taken from the given primary {@code input} or, if the
 primary input fails with the given {@code exceptionType}, from the result provided by the
 {@code fallback}. {@link AsyncFunction#apply} is not invoked until the primary input has
 failed, so if the primary input succeeds, it is never invoked. If, during the invocation of
 {@code fallback}, an exception is thrown, this exception is used as the result of the output
 {@code Future}.

 <p>Usage examples:

 {@snippet :
 ListenableFuture<Integer> fetchCounterFuture = ...;

 // Falling back to a zero counter in case an exception happens when
 // processing the RPC to fetch counters.
 ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(
     fetchCounterFuture, FetchException.class, x -> immediateFuture(0), directExecutor());
 }

 <p>The fallback can also choose to propagate the original exception when desired:

 {@snippet :
 ListenableFuture<Integer> fetchCounterFuture = ...;

 // Falling back to a zero counter only in case the exception was a
 // TimeoutException.
 ListenableFuture<Integer> faultTolerantFuture = Futures.catchingAsync(
     fetchCounterFuture,
     FetchException.class,
     e -> {
       if (omitDataOnFetchFailure) {
         return immediateFuture(0);
       }
       throw e;
     },
     directExecutor());
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the warnings the {@link MoreExecutors#directExecutor} documentation.

 @param input the primary input {@code Future}
 @param exceptionType the exception type that triggers use of {@code fallback}. The exception
     type is matched against the input's exception. "The input's exception" means the cause of
     the {@link ExecutionException} thrown by {@code input.get()} or, if {@code get()} throws a
     different kind of exception, that exception itself. To avoid hiding bugs and other
     unrecoverable errors, callers should prefer more specific types, avoiding {@code
     Throwable.class} in particular.
 @param fallback the {@link AsyncFunction} to be called if {@code input} fails with the expected
     exception type. The function's argument is the input's exception. "The input's exception"
     means the cause of the {@link ExecutionException} thrown by {@code input.get()} or, if
     {@code get()} throws a different kind of exception, that exception itself.
 @param executor the executor that runs {@code fallback} if {@code input} fails
 @since 19.0 (similar functionality in 14.0 as {@code withFallback})]]>
      </doc>
    </method>
    <method name="withTimeout" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <param name="time" type="java.time.Duration"/>
      <param name="scheduledExecutor" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Returns a future that delegates to another but will finish early (via a {@link
 TimeoutException} wrapped in an {@link ExecutionException}) if the specified duration expires.

 <p>The delegate future is interrupted and cancelled if it times out.

 @param delegate The future to delegate to.
 @param time when to time out the future
 @param scheduledExecutor The executor service to enforce the timeout.
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="withTimeout" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <param name="scheduledExecutor" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Returns a future that delegates to another but will finish early (via a {@link
 TimeoutException} wrapped in an {@link ExecutionException}) if the specified duration expires.

 <p>The delegate future is interrupted and cancelled if it times out.

 @param delegate The future to delegate to.
 @param time when to time out the future
 @param unit the time unit of the time parameter
 @param scheduledExecutor The executor service to enforce the timeout.
 @since 19.0]]>
      </doc>
    </method>
    <method name="transformAsync" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.util.concurrent.AsyncFunction&lt;? super I, ? extends O&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code Future} whose result is asynchronously derived from the result of the
 given {@code Future}. If the given {@code Future} fails, the returned {@code Future} fails with
 the same exception (and the function is not invoked).

 <p>More precisely, the returned {@code Future} takes its result from a {@code Future} produced
 by applying the given {@code AsyncFunction} to the result of the original {@code Future}.
 Example usage:

 {@snippet :
 ListenableFuture<RowKey> rowKeyFuture = indexService.lookUp(query);
 ListenableFuture<QueryResult> queryFuture =
     transformAsync(rowKeyFuture, dataService::readFuture, executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the warnings the {@link MoreExecutors#directExecutor} documentation.

 <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
 input future and that of the future returned by the chain function. That is, if the returned
 {@code Future} is cancelled, it will attempt to cancel the other two, and if either of the
 other two is cancelled, the returned {@code Future} will receive a callback in which it will
 attempt to cancel itself.

 @param input The future to transform
 @param function A function to transform the result of the input future to the result of the
     output future
 @param executor Executor to run the function in.
 @return A future that holds result of the function (if the input succeeded) or the original
     input's failure (if not)
 @since 19.0 (in 11.0 as {@code transform})]]>
      </doc>
    </method>
    <method name="transform" return="com.google.common.util.concurrent.ListenableFuture&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="com.google.common.util.concurrent.ListenableFuture&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns a new {@code Future} whose result is derived from the result of the given {@code
 Future}. If {@code input} fails, the returned {@code Future} fails with the same exception (and
 the function is not invoked). Example usage:

 {@snippet :
 ListenableFuture<QueryResult> queryFuture = ...;
 ListenableFuture<List<Row>> rowsFuture =
     transform(queryFuture, QueryResult::getRows, executor);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the warnings the {@link MoreExecutors#directExecutor} documentation.

 <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
 input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel
 the input, and if the input is cancelled, the returned {@code Future} will receive a callback
 in which it will attempt to cancel itself.

 <p>An example use of this method is to convert a serializable object returned from an RPC into
 a POJO.

 @param input The future to transform
 @param function A Function to transform the results of the provided future to the results of
     the returned future.
 @param executor Executor to run the function in.
 @return A future that holds result of the transformation.
 @since 9.0 (in 2.0 as {@code compose})]]>
      </doc>
    </method>
    <method name="lazyTransform" return="java.util.concurrent.Future&lt;O&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.util.concurrent.Future&lt;I&gt;"/>
      <param name="function" type="com.google.common.base.Function&lt;? super I, ? extends O&gt;"/>
      <doc>
      <![CDATA[Like {@link #transform(ListenableFuture, Function, Executor)} except that the transformation
 {@code function} is invoked on each call to {@link Future#get() get()} on the returned future.

 <p>The returned {@code Future} reflects the input's cancellation state directly, and any
 attempt to cancel the returned Future is likewise passed through to the input Future.

 <p>Note that calls to {@linkplain Future#get(long, TimeUnit) timed get} only apply the timeout
 to the execution of the underlying {@code Future}, <em>not</em> to the execution of the
 transformation function.

 <p>The primary audience of this method is callers of {@code transform} who don't have a {@code
 ListenableFuture} available and do not mind repeated, lazy function evaluation.

 @param input The future to transform
 @param function A Function to transform the results of the provided future to the results of
     the returned future.
 @return A future that returns the result of the transformation.
 @since 10.0]]>
      </doc>
    </method>
    <method name="allAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="com.google.common.util.concurrent.ListenableFuture[]"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the values of all its
 input futures, if all succeed.

 <p>The list of results is in the same order as the input list.

 <p>This differs from {@link #successfulAsList(ListenableFuture[])} in that it will return a
 failed future if any of the items fails.

 <p>Canceling this future will attempt to cancel all the component futures, and if any of the
 provided futures fails or is canceled, this one is, too.

 @param futures futures to combine
 @return a future that provides a list of the results of the component futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="allAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the values of all its
 input futures, if all succeed.

 <p>The list of results is in the same order as the input list.

 <p>This differs from {@link #successfulAsList(Iterable)} in that it will return a failed future
 if any of the items fails.

 <p>Canceling this future will attempt to cancel all the component futures, and if any of the
 provided futures fails or is canceled, this one is, too.

 @param futures futures to combine
 @return a future that provides a list of the results of the component futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="whenAllComplete" return="com.google.common.util.concurrent.Futures.FutureCombiner&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="com.google.common.util.concurrent.ListenableFuture[]"/>
      <doc>
      <![CDATA[Creates a {@link FutureCombiner} that processes the completed futures whether or not they're
 successful.

 <p>Any failures from the input futures will not be propagated to the returned future.

 @since 20.0]]>
      </doc>
    </method>
    <method name="whenAllComplete" return="com.google.common.util.concurrent.Futures.FutureCombiner&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a {@link FutureCombiner} that processes the completed futures whether or not they're
 successful.

 <p>Any failures from the input futures will not be propagated to the returned future.

 @since 20.0]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.Futures.FutureCombiner&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="com.google.common.util.concurrent.ListenableFuture[]"/>
      <doc>
      <![CDATA[Creates a {@link FutureCombiner} requiring that all passed in futures are successful.

 <p>If any input fails, the returned future fails immediately.

 @since 20.0]]>
      </doc>
    </method>
    <method name="whenAllSucceed" return="com.google.common.util.concurrent.Futures.FutureCombiner&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a {@link FutureCombiner} requiring that all passed in futures are successful.

 <p>If any input fails, the returned future fails immediately.

 @since 20.0]]>
      </doc>
    </method>
    <method name="nonCancellationPropagating" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a {@code ListenableFuture} whose result is set from the supplied future when it
 completes. Cancelling the supplied future will also cancel the returned future, but cancelling
 the returned future will have no effect on the supplied future.

 @since 15.0]]>
      </doc>
    </method>
    <method name="successfulAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="com.google.common.util.concurrent.ListenableFuture[]"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the values of all its
 successful input futures. The list of results is in the same order as the input list, and if
 any of the provided futures fails or is canceled, its corresponding position will contain
 {@code null} (which is indistinguishable from the future having a successful value of {@code
 null}).

 <p>The list of results is in the same order as the input list.

 <p>This differs from {@link #allAsList(ListenableFuture[])} in that it's tolerant of failed
 futures for any of the items, representing them as {@code null} in the result list.

 <p>Canceling this future will attempt to cancel all the component futures.

 @param futures futures to combine
 @return a future that provides a list of the results of the component futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="successfulAsList" return="com.google.common.util.concurrent.ListenableFuture&lt;java.util.List&lt;V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;&gt;"/>
      <doc>
      <![CDATA[Creates a new {@code ListenableFuture} whose value is a list containing the values of all its
 successful input futures. The list of results is in the same order as the input list, and if
 any of the provided futures fails or is canceled, its corresponding position will contain
 {@code null} (which is indistinguishable from the future having a successful value of {@code
 null}).

 <p>The list of results is in the same order as the input list.

 <p>This differs from {@link #allAsList(Iterable)} in that it's tolerant of failed futures for
 any of the items, representing them as {@code null} in the result list.

 <p>Canceling this future will attempt to cancel all the component futures.

 @param futures futures to combine
 @return a future that provides a list of the results of the component futures
 @since 10.0]]>
      </doc>
    </method>
    <method name="inCompletionOrder" return="com.google.common.collect.ImmutableList&lt;com.google.common.util.concurrent.ListenableFuture&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="futures" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.ListenableFuture&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a list of delegate futures that correspond to the futures received in the order that
 they complete. Delegate futures return the same value or throw the same exception as the
 corresponding input future returns/throws.

 <p>"In the order that they complete" means, for practical purposes, about what you would
 expect, but there are some subtleties. First, we do guarantee that, if the output future at
 index n is done, the output future at index n-1 is also done. (But as usual with futures, some
 listeners for future n may complete before some for future n-1.) However, it is possible, if
 one input completes with result X and another later with result Y, for Y to come before X in
 the output future list. (Such races are impossible to solve without global synchronization of
 all future completions. And they should have little practical impact.)

 <p>Cancelling a delegate future propagates to input futures once all the delegates complete,
 either from cancellation or because an input future has completed. If N futures are passed in,
 and M delegates are cancelled, the remaining M input futures will be cancelled once N - M of
 the input futures complete. If all the delegates are cancelled, all the input futures will be
 too.

 @since 17.0]]>
      </doc>
    </method>
    <method name="addCallback"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
      <param name="callback" type="com.google.common.util.concurrent.FutureCallback&lt;? super V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers separate success and failure callbacks to be run when the {@code Future}'s
 computation is {@linkplain java.util.concurrent.Future#isDone() complete} or, if the
 computation is already complete, immediately.

 <p>The callback is run on {@code executor}. There is no guaranteed ordering of execution of
 callbacks, but any callback added through this method is guaranteed to be called once the
 computation is complete.

 <p>Exceptions thrown by a {@code callback} will be propagated up to the executor. Any exception
 thrown during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an
 exception thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught
 and logged.

 <p>Example:

 {@snippet :
 ListenableFuture<QueryResult> future = ...;
 Executor e = ...
 addCallback(future,
     new FutureCallback<QueryResult>() {
       public void onSuccess(QueryResult result) {
         storeInCache(result);
       }
       public void onFailure(Throwable t) {
         reportError(t);
       }
     }, e);
 }

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the warnings the {@link MoreExecutors#directExecutor} documentation.

 <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link
 ListenableFuture#addListener addListener}.

 @param future The future attach the callback to.
 @param callback The callback to invoke when {@code future} is completed.
 @param executor The executor to run {@code callback} when the future completes.
 @since 10.0]]>
      </doc>
    </method>
    <method name="getDone" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Returns the result of the input {@code Future}, which must have already completed.

 <p>The benefits of this method are twofold. First, the name "getDone" suggests to readers that
 the {@code Future} is already done. Second, if buggy code calls {@code getDone} on a {@code
 Future} that is still pending, the program will throw instead of block. This can be important
 for APIs like {@link #whenAllComplete whenAllComplete(...)}{@code .}{@link
 FutureCombiner#call(Callable, Executor) call(...)}, where it is easy to use a new input from
 the {@code call} implementation but forget to add it to the arguments of {@code
 whenAllComplete}.

 <p>If you are looking for a method to determine whether a given {@code Future} is done, use the
 instance method {@link Future#isDone()}.

 @throws ExecutionException if the {@code Future} failed with an exception
 @throws CancellationException if the {@code Future} was cancelled
 @throws IllegalStateException if the {@code Future} is not done
 @since 20.0]]>
      </doc>
    </method>
    <method name="getChecked" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="exceptionClass" type="java.lang.Class&lt;X&gt;"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns the result of {@link Future#get()}, converting most exceptions to a new instance of the
 given checked exception type. This reduces boilerplate for a common use of {@code Future} in
 which it is unnecessary to programmatically distinguish between exception types or to extract
 other information from the exception instance.

 <p>Exceptions from {@code Future.get} are treated as follows:

 <ul>
   <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause
       is a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code
       RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.
   <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the
       interrupt).
   <li>Any {@link CancellationException} is propagated untouched, as is any other {@link
       RuntimeException} (though {@code get} implementations are discouraged from throwing such
       exceptions).
 </ul>

 <p>The overall principle is to continue to treat every checked exception as a checked
 exception, every unchecked exception as an unchecked exception, and every error as an error. In
 addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the
 new stack trace matches that of the current thread.

 <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor
 that accepts zero or more arguments, all of type {@code String} or {@code Throwable}
 (preferring constructors with at least one {@code String}, then preferring constructors with at
 least one {@code Throwable}) and calling the constructor via reflection. If the exception did
 not already have a cause, one is set by calling {@link Throwable#initCause(Throwable)} on it.
 If no such constructor exists, an {@code IllegalArgumentException} is thrown.

 @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}
     whose cause is not itself a checked exception
 @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a
     {@code RuntimeException} as its cause
 @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code
     Error} as its cause
 @throws CancellationException if {@code get} throws a {@code CancellationException}
 @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or
     does not have a suitable constructor
 @since 19.0 (in 10.0 as {@code get})]]>
      </doc>
    </method>
    <method name="getChecked" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="exceptionClass" type="java.lang.Class&lt;X&gt;"/>
      <param name="timeout" type="java.time.Duration"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new
 instance of the given checked exception type. This reduces boilerplate for a common use of
 {@code Future} in which it is unnecessary to programmatically distinguish between exception
 types or to extract other information from the exception instance.

 <p>Exceptions from {@code Future.get} are treated as follows:

 <ul>
   <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause
       is a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code
       RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.
   <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the
       interrupt).
   <li>Any {@link TimeoutException} is wrapped in an {@code X}.
   <li>Any {@link CancellationException} is propagated untouched, as is any other {@link
       RuntimeException} (though {@code get} implementations are discouraged from throwing such
       exceptions).
 </ul>

 <p>The overall principle is to continue to treat every checked exception as a checked
 exception, every unchecked exception as an unchecked exception, and every error as an error. In
 addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the
 new stack trace matches that of the current thread.

 <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor
 that accepts zero or more arguments, all of type {@code String} or {@code Throwable}
 (preferring constructors with at least one {@code String}, then preferring constructors with at
 least one {@code Throwable}) and calling the constructor via reflection. If the exception did
 not already have a cause, one is set by calling {@link Throwable#initCause(Throwable)} on it.
 If no such constructor exists, an {@code IllegalArgumentException} is thrown.

 @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}
     whose cause is not itself a checked exception
 @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a
     {@code RuntimeException} as its cause
 @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code
     Error} as its cause
 @throws CancellationException if {@code get} throws a {@code CancellationException}
 @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or
     does not have a suitable constructor
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="getChecked" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="exceptionClass" type="java.lang.Class&lt;X&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns the result of {@link Future#get(long, TimeUnit)}, converting most exceptions to a new
 instance of the given checked exception type. This reduces boilerplate for a common use of
 {@code Future} in which it is unnecessary to programmatically distinguish between exception
 types or to extract other information from the exception instance.

 <p>Exceptions from {@code Future.get} are treated as follows:

 <ul>
   <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@code X} if the cause
       is a checked exception, an {@link UncheckedExecutionException} if the cause is a {@code
       RuntimeException}, or an {@link ExecutionError} if the cause is an {@code Error}.
   <li>Any {@link InterruptedException} is wrapped in an {@code X} (after restoring the
       interrupt).
   <li>Any {@link TimeoutException} is wrapped in an {@code X}.
   <li>Any {@link CancellationException} is propagated untouched, as is any other {@link
       RuntimeException} (though {@code get} implementations are discouraged from throwing such
       exceptions).
 </ul>

 <p>The overall principle is to continue to treat every checked exception as a checked
 exception, every unchecked exception as an unchecked exception, and every error as an error. In
 addition, the cause of any {@code ExecutionException} is wrapped in order to ensure that the
 new stack trace matches that of the current thread.

 <p>Instances of {@code exceptionClass} are created by choosing an arbitrary public constructor
 that accepts zero or more arguments, all of type {@code String} or {@code Throwable}
 (preferring constructors with at least one {@code String}) and calling the constructor via
 reflection. If the exception did not already have a cause, one is set by calling {@link
 Throwable#initCause(Throwable)} on it. If no such constructor exists, an {@code
 IllegalArgumentException} is thrown.

 @throws X if {@code get} throws any checked exception except for an {@code ExecutionException}
     whose cause is not itself a checked exception
 @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with a
     {@code RuntimeException} as its cause
 @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code
     Error} as its cause
 @throws CancellationException if {@code get} throws a {@code CancellationException}
 @throws IllegalArgumentException if {@code exceptionClass} extends {@code RuntimeException} or
     does not have a suitable constructor
 @since 19.0 (in 10.0 as {@code get} and with different parameter order)]]>
      </doc>
    </method>
    <method name="getUnchecked" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns the result of calling {@link Future#get()} uninterruptibly on a task known not to throw
 a checked exception. This makes {@code Future} more suitable for lightweight, fast-running
 tasks that, barring bugs in the code, will not fail. This gives it exception-handling behavior
 similar to that of {@code ForkJoinTask.join}.

 <p>Exceptions from {@code Future.get} are treated as follows:

 <ul>
   <li>Any {@link ExecutionException} has its <i>cause</i> wrapped in an {@link
       UncheckedExecutionException} (if the cause is an {@code Exception}) or {@link
       ExecutionError} (if the cause is an {@code Error}).
   <li>Any {@link InterruptedException} causes a retry of the {@code get} call. The interrupt is
       restored before {@code getUnchecked} returns.
   <li>Any {@link CancellationException} is propagated untouched. So is any other {@link
       RuntimeException} ({@code get} implementations are discouraged from throwing such
       exceptions).
 </ul>

 <p>The overall principle is to eliminate all checked exceptions: to loop to avoid {@code
 InterruptedException}, to pass through {@code CancellationException}, and to wrap any exception
 from the underlying computation in an {@code UncheckedExecutionException} or {@code
 ExecutionError}.

 <p>For an uninterruptible {@code get} that preserves other exceptions, see {@link
 Uninterruptibles#getUninterruptibly(Future)}.

 @throws UncheckedExecutionException if {@code get} throws an {@code ExecutionException} with an
     {@code Exception} as its cause
 @throws ExecutionError if {@code get} throws an {@code ExecutionException} with an {@code
     Error} as its cause
 @throws CancellationException if {@code get} throws a {@code CancellationException}
 @since 10.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Future} interface.

 <p>Many of these methods use the {@link ListenableFuture} API; consult the Guava User Guide
 article on <a href="https://github.com/google/guava/wiki/ListenableFutureExplained">{@code
 ListenableFuture}</a>.

 <p>The main purpose of {@code ListenableFuture} is to help you chain together a graph of
 asynchronous operations. You can chain them together manually with calls to methods like {@link
 Futures#transform(ListenableFuture, Function, Executor) Futures.transform}, but you will often
 find it easier to use a framework. Frameworks automate the process, often adding features like
 monitoring, debugging, and cancellation. Examples of frameworks include:

 <ul>
   <li><a href="https://dagger.dev/producers.html">Dagger Producers</a>
 </ul>

 <p>If you do chain your operations manually, you may want to use {@link FluentFuture}.

 @author Kevin Bourrillion
 @author Nishant Thakkar
 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Futures -->
  <!-- start class com.google.common.util.concurrent.Futures.FutureCombiner -->
  <class name="Futures.FutureCombiner" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="callAsync" return="com.google.common.util.concurrent.ListenableFuture&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="combiner" type="com.google.common.util.concurrent.AsyncCallable&lt;C&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Creates the {@link ListenableFuture} which will return the result of calling {@link
 AsyncCallable#call} in {@code combiner} when all futures complete, using the specified {@code
 executor}.

 <p>If the combiner throws a {@code CancellationException}, the returned future will be
 cancelled.

 <p>If the combiner throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and returned as the cause of the new {@code
 ExecutionException} that gets thrown by the returned combined future.

 <p>Canceling this future will attempt to cancel all the component futures.

 @return a future whose result is based on {@code combiner} (or based on the input futures
     passed to {@code whenAllSucceed}, if that is the method you used to create this {@code
     FutureCombiner}). Even if you don't care about the value of the future, you should
     typically check whether it failed: See <a
     href="https://errorprone.info/bugpattern/FutureReturnValueIgnored">https://errorprone.info/bugpattern/FutureReturnValueIgnored</a>.]]>
      </doc>
    </method>
    <method name="call" return="com.google.common.util.concurrent.ListenableFuture&lt;C&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="combiner" type="java.util.concurrent.Callable&lt;C&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Creates the {@link ListenableFuture} which will return the result of calling {@link
 Callable#call} in {@code combiner} when all futures complete, using the specified {@code
 executor}.

 <p>If the combiner throws a {@code CancellationException}, the returned future will be
 cancelled.

 <p>If the combiner throws an {@code ExecutionException}, the cause of the thrown {@code
 ExecutionException} will be extracted and returned as the cause of the new {@code
 ExecutionException} that gets thrown by the returned combined future.

 <p>Canceling this future will attempt to cancel all the component futures.

 @return a future whose result is based on {@code combiner} (or based on the input futures
     passed to {@code whenAllSucceed}, if that is the method you used to create this {@code
     FutureCombiner}). Even if you don't care about the value of the future, you should
     typically check whether it failed: See <a
     href="https://errorprone.info/bugpattern/FutureReturnValueIgnored">https://errorprone.info/bugpattern/FutureReturnValueIgnored</a>.]]>
      </doc>
    </method>
    <method name="run" return="com.google.common.util.concurrent.ListenableFuture&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="combiner" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Creates the {@link ListenableFuture} which will return the result of running {@code combiner}
 when all Futures complete. {@code combiner} will run using {@code executor}.

 <p>If the combiner throws a {@code CancellationException}, the returned future will be
 cancelled.

 <p>Canceling this Future will attempt to cancel all the component futures.

 @since 23.6
 @return a future whose result is based on {@code combiner} (or based on the input futures
     passed to {@code whenAllSucceed}, if that is the method you used to create this {@code
     FutureCombiner}). Even though the future never produces a value other than {@code null},
     you should typically check whether it failed: See <a
     href="https://errorprone.info/bugpattern/FutureReturnValueIgnored">https://errorprone.info/bugpattern/FutureReturnValueIgnored</a>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A helper to create a new {@code ListenableFuture} whose result is generated from a combination
 of input futures.

 <p>See {@link #whenAllComplete} and {@link #whenAllSucceed} for how to instantiate this class.

 <p>Example:

 {@snippet :
 final ListenableFuture<Instant> loginDateFuture =
     loginService.findLastLoginDate(username);
 final ListenableFuture<List<String>> recentCommandsFuture =
     recentCommandsService.findRecentCommands(username);
 ListenableFuture<UsageHistory> usageFuture =
     Futures.whenAllSucceed(loginDateFuture, recentCommandsFuture)
         .call(
             () ->
                 new UsageHistory(
                     username,
                     Futures.getDone(loginDateFuture),
                     Futures.getDone(recentCommandsFuture)),
             executor);
 }

 @since 20.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Futures.FutureCombiner -->
  <!-- start class com.google.common.util.concurrent.JdkFutureAdapters -->
  <class name="JdkFutureAdapters" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="listenInPoolThread" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <doc>
      <![CDATA[Assigns a thread to the given {@link Future} to provide {@link ListenableFuture} functionality.

 <p><b>Warning:</b> If the input future does not already implement {@code ListenableFuture}, the
 returned future will emulate {@link ListenableFuture#addListener} by taking a thread from an
 internal, unbounded pool at the first call to {@code addListener} and holding it until the
 future is {@linkplain Future#isDone() done}.

 <p>Prefer to create {@code ListenableFuture} instances with {@link SettableFuture}, {@link
 MoreExecutors#listeningDecorator( java.util.concurrent.ExecutorService)}, {@link
 ListenableFutureTask}, {@link AbstractFuture}, and other utilities over creating plain {@code
 Future} instances to be upgraded to {@code ListenableFuture} after the fact.]]>
      </doc>
    </method>
    <method name="listenInPoolThread" return="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Submits a blocking task for the given {@link Future} to provide {@link ListenableFuture}
 functionality.

 <p><b>Warning:</b> If the input future does not already implement {@code ListenableFuture}, the
 returned future will emulate {@link ListenableFuture#addListener} by submitting a task to the
 given executor at the first call to {@code addListener}. The task must be started by the
 executor promptly, or else the returned {@code ListenableFuture} may fail to work. The task's
 execution consists of blocking until the input future is {@linkplain Future#isDone() done}, so
 each call to this method may claim and hold a thread for an arbitrary length of time. Use of
 bounded executors or other executors that may fail to execute a task promptly may result in
 deadlocks.

 <p>Prefer to create {@code ListenableFuture} instances with {@link SettableFuture}, {@link
 MoreExecutors#listeningDecorator( java.util.concurrent.ExecutorService)}, {@link
 ListenableFutureTask}, {@link AbstractFuture}, and other utilities over creating plain {@code
 Future} instances to be upgraded to {@code ListenableFuture} after the fact.

 @since 12.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities necessary for working with libraries that supply plain {@link Future} instances. Note
 that, whenever possible, it is strongly preferred to modify those libraries to return {@code
 ListenableFuture} directly.

 <p>For interoperability between {@code ListenableFuture} and <b>{@code CompletableFuture}</b>,
 consider <a href="https://github.com/lukas-krecan/future-converter">Future Converter</a>.

 @author Sven Mawson
 @since 10.0 (replacing {@code Futures.makeListenable}, which existed in 1.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.JdkFutureAdapters -->
  <!-- start interface com.google.common.util.concurrent.ListenableFuture -->
  <interface name="ListenableFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future&lt;V&gt;"/>
    <method name="addListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers a listener to be {@linkplain Executor#execute(Runnable) run} on the given executor.
 The listener will run when the {@code Future}'s computation is {@linkplain Future#isDone()
 complete} or, if the computation is already complete, immediately.

 <p>There is no guaranteed ordering of execution of listeners, but any listener added through
 this method is guaranteed to be called once the computation is complete.

 <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown
 during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an exception
 thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught and
 logged.

 <p>Note: If your listener is lightweight -- and will not cause stack overflow by completing
 more futures or adding more {@code directExecutor()} listeners inline -- consider {@link
 MoreExecutors#directExecutor}. Otherwise, avoid it: See the warnings on the docs for {@code
 directExecutor}.

 <p>This is the most general listener interface. For common operations performed using
 listeners, see {@link Futures}. For a simplified but general listener interface, see {@link
 Futures#addCallback addCallback()}.

 <p>Memory consistency effects: Actions in a thread prior to adding a listener <a
 href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5">
 <i>happen-before</i></a> its execution begins, perhaps in another thread.

 <p>Guava implementations of {@code ListenableFuture} promptly release references to listeners
 after executing them.

 @param listener the listener to run when the computation is complete
 @param executor the executor to run the listener in
 @throws RejectedExecutionException if we tried to execute the listener immediately but the
     executor rejected it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link Future} that accepts completion listeners. Each listener has an associated executor, and
 it is invoked using this executor once the future's computation is {@linkplain Future#isDone()
 complete}. If the computation has already completed when the listener is added, the listener will
 execute immediately.

 <p>See the Guava User Guide article on <a
 href="https://github.com/google/guava/wiki/ListenableFutureExplained">{@code
 ListenableFuture}</a>.

 <p>This class is GWT-compatible.

 <h3>Purpose</h3>

 <p>The main purpose of {@code ListenableFuture} is to help you chain together a graph of
 asynchronous operations. You can chain them together manually with calls to methods like {@link
 Futures#transform(ListenableFuture, com.google.common.base.Function, Executor) Futures.transform}
 (or {@link FluentFuture#transform(com.google.common.base.Function, Executor)
 FluentFuture.transform}), but you will often find it easier to use a framework. Frameworks
 automate the process, often adding features like monitoring, debugging, and cancellation.
 Examples of frameworks include:

 <ul>
   <li><a href="https://dagger.dev/producers.html">Dagger Producers</a>
 </ul>

 <p>The main purpose of {@link #addListener addListener} is to support this chaining. You will
 rarely use it directly, in part because it does not provide direct access to the {@code Future}
 result. (If you want such access, you may prefer {@link Futures#addCallback
 Futures.addCallback}.) Still, direct {@code addListener} calls are occasionally useful:

 {@snippet :
 final String name = ...;
 inFlight.add(name);
 ListenableFuture<Result> future = service.query(name);
 future.addListener(new Runnable() {
   public void run() {
     processedCount.incrementAndGet();
     inFlight.remove(name);
     lastProcessed.set(name);
     logger.info("Done with {0}", name);
   }
 }, executor);
 }

 <h3>How to get an instance</h3>

 <p>We encourage you to return {@code ListenableFuture} from your methods so that your users can
 take advantage of the {@linkplain Futures utilities built atop the class}. The way that you will
 create {@code ListenableFuture} instances depends on how you currently create {@code Future}
 instances:

 <ul>
   <li>If you receive them from an {@code java.util.concurrent.ExecutorService}, convert that
       service to a {@link ListeningExecutorService}, usually by calling {@link
       MoreExecutors#listeningDecorator(java.util.concurrent.ExecutorService)
       MoreExecutors.listeningDecorator}.
   <li>If you manually call {@link java.util.concurrent.FutureTask#set} or a similar method,
       create a {@link SettableFuture} instead. (If your needs are more complex, you may prefer
       {@link AbstractFuture}.)
 </ul>

 <p><b>Test doubles</b>: If you need a {@code ListenableFuture} for your test, try a {@link
 SettableFuture} or one of the methods in the {@link Futures#immediateFuture Futures.immediate*}
 family. <b>Avoid</b> creating a mock or stub {@code Future}. Mock and stub implementations are
 fragile because they assume that only certain methods will be called and because they often
 implement subtleties of the API improperly.

 <p><b>Custom implementation</b>: Avoid implementing {@code ListenableFuture} from scratch. If you
 can't get by with the standard implementations, prefer to derive a new {@code Future} instance
 with the methods in {@link Futures} or, if necessary, to extend {@link AbstractFuture}.

 <p>Occasionally, an API will return a plain {@code Future} and it will be impossible to change
 the return type. For this case, we provide a more expensive workaround in {@code
 JdkFutureAdapters}. However, when possible, it is more efficient and reliable to create a {@code
 ListenableFuture} directly.

 @author Sven Mawson
 @author Nishant Thakkar
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListenableFuture -->
  <!-- start class com.google.common.util.concurrent.ListenableFutureTask -->
  <class name="ListenableFutureTask" extends="java.util.concurrent.FutureTask&lt;V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <method name="create" return="com.google.common.util.concurrent.ListenableFutureTask&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;V&gt;"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the given {@code
 Callable}.

 @param callable the callable task
 @since 10.0]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.util.concurrent.ListenableFutureTask&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="result" type="V extends java.lang.Object"/>
      <doc>
      <![CDATA[Creates a {@code ListenableFutureTask} that will upon running, execute the given {@code
 Runnable}, and arrange that {@code get} will return the given result on successful completion.

 @param runnable the runnable task
 @param result the result to return on successful completion. If you don't need a particular
     result, consider using constructions of the form: {@code ListenableFuture<?> f =
     ListenableFutureTask.create(runnable, null)}
 @since 10.0]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="java.lang.Runnable"/>
      <param name="exec" type="java.util.concurrent.Executor"/>
    </method>
    <method name="get" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Internal implementation detail used to invoke the listeners.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link FutureTask} that also implements the {@link ListenableFuture} interface. Unlike {@code
 FutureTask}, {@code ListenableFutureTask} does not provide an overrideable {@link
 FutureTask#done() done()} method. For similar functionality, call {@link #addListener}.

 <p>Few users should use this class. It is intended primarily for those who are implementing an
 {@code ExecutorService}. Most users should call {@link ListeningExecutorService#submit(Callable)
 ListeningExecutorService.submit} on a service obtained from {@link
 MoreExecutors#listeningDecorator}.

 @author Sven Mawson
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ListenableFutureTask -->
  <!-- start interface com.google.common.util.concurrent.ListenableScheduledFuture -->
  <interface name="ListenableScheduledFuture"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ScheduledFuture&lt;V&gt;"/>
    <implements name="com.google.common.util.concurrent.ListenableFuture&lt;V&gt;"/>
    <doc>
    <![CDATA[Helper interface to implement both {@link ListenableFuture} and {@link ScheduledFuture}.

 @author Anthony Zana
 @since 15.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListenableScheduledFuture -->
  <!-- start interface com.google.common.util.concurrent.ListeningExecutorService -->
  <interface name="ListeningExecutorService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <doc>
      <![CDATA[@return a {@code ListenableFuture} representing pending completion of the task
 @throws RejectedExecutionException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[@return a {@code ListenableFuture} representing pending completion of the task
 @throws RejectedExecutionException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="submit" return="com.google.common.util.concurrent.ListenableFuture&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
      <param name="result" type="T extends java.lang.Object"/>
      <doc>
      <![CDATA[@return a {@code ListenableFuture} representing pending completion of the task
 @throws RejectedExecutionException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>All elements in the returned list must be {@link ListenableFuture} instances. The easiest
 way to obtain a {@code List<ListenableFuture<T>>} from this method is an unchecked (but safe)
 cast:

 <pre>
   {@code @SuppressWarnings("unchecked") // guaranteed by invokeAll contract}
   {@code List<ListenableFuture<T>> futures = (List) executor.invokeAll(tasks);}
 </pre>

 @return A list of {@code ListenableFuture} instances representing the tasks, in the same
     sequential order as produced by the iterator for the given task list, each of which has
     completed.
 @throws RejectedExecutionException {@inheritDoc}
 @throws NullPointerException if any task is null]]>
      </doc>
    </method>
    <method name="invokeAll" return="java.util.List&lt;java.util.concurrent.Future&lt;T&gt;&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tasks" type="java.util.Collection&lt;? extends java.util.concurrent.Callable&lt;T&gt;&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 <p>All elements in the returned list must be {@link ListenableFuture} instances. The easiest
 way to obtain a {@code List<ListenableFuture<T>>} from this method is an unchecked (but safe)
 cast:

 <pre>
   {@code @SuppressWarnings("unchecked") // guaranteed by invokeAll contract}
   {@code List<ListenableFuture<T>> futures = (List) executor.invokeAll(tasks, timeout, unit);}
 </pre>

 @return a list of {@code ListenableFuture} instances representing the tasks, in the same
     sequential order as produced by the iterator for the given task list. If the operation did
     not time out, each task will have completed. If it did time out, some of these tasks will
     not have completed.
 @throws RejectedExecutionException {@inheritDoc}
 @throws NullPointerException if any task is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link ExecutorService} that returns {@link ListenableFuture} instances. To create an instance
 from an existing {@link ExecutorService}, call {@link
 MoreExecutors#listeningDecorator(ExecutorService)}.

 @author Chris Povirk
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListeningExecutorService -->
  <!-- start interface com.google.common.util.concurrent.ListeningScheduledExecutorService -->
  <interface name="ListeningScheduledExecutorService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ScheduledExecutorService"/>
    <implements name="com.google.common.util.concurrent.ListeningExecutorService"/>
    <method name="schedule" return="com.google.common.util.concurrent.ListenableScheduledFuture&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[@since 15.0 (previously returned ScheduledFuture)]]>
      </doc>
    </method>
    <method name="schedule" return="com.google.common.util.concurrent.ListenableScheduledFuture&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;V&gt;"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[@since 15.0 (previously returned ScheduledFuture)]]>
      </doc>
    </method>
    <method name="scheduleAtFixedRate" return="com.google.common.util.concurrent.ListenableScheduledFuture&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="initialDelay" type="long"/>
      <param name="period" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[@since 15.0 (previously returned ScheduledFuture)]]>
      </doc>
    </method>
    <method name="scheduleWithFixedDelay" return="com.google.common.util.concurrent.ListenableScheduledFuture&lt;?&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="initialDelay" type="long"/>
      <param name="delay" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[@since 15.0 (previously returned ScheduledFuture)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link ScheduledExecutorService} that returns {@link ListenableFuture} instances from its
 {@code ExecutorService} methods. To create an instance from an existing {@link
 ScheduledExecutorService}, call {@link
 MoreExecutors#listeningDecorator(ScheduledExecutorService)}.

 @author Chris Povirk
 @since 10.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.ListeningScheduledExecutorService -->
  <!-- start class com.google.common.util.concurrent.Monitor -->
  <class name="Monitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Monitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a monitor with a non-fair (but fast) ordering policy. Equivalent to {@code
 Monitor(false)}.]]>
      </doc>
    </constructor>
    <constructor name="Monitor" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a monitor with the given ordering policy.

 @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but
     fast) one]]>
      </doc>
    </constructor>
    <method name="newGuard" return="com.google.common.util.concurrent.Monitor.Guard"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isSatisfied" type="java.util.function.BooleanSupplier"/>
      <doc>
      <![CDATA[Creates a new {@linkplain Guard guard} for this monitor.

 @param isSatisfied the new guard's boolean condition (see {@link Guard#isSatisfied
     isSatisfied()})
 @since 33.4.0 (but since 21.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="enter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enters this monitor. Blocks indefinitely.]]>
      </doc>
    </method>
    <method name="enter" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="java.time.Duration"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks at most the given time.

 @return whether the monitor was entered
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="enter" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks at most the given time.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterInterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks indefinitely, but may be interrupted.

 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="enterInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="java.time.Duration"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks at most the given time, and may be interrupted.

 @return whether the monitor was entered
 @throws InterruptedException if interrupted while waiting
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="enterInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor. Blocks at most the given time, and may be interrupted.

 @return whether the monitor was entered
 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="tryEnter" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enters this monitor if it is possible to do so immediately. Does not block.

 <p><b>Note:</b> This method disregards the fairness setting of this monitor.

 @return whether the monitor was entered]]>
      </doc>
    </method>
    <method name="enterWhen"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks indefinitely, but may be interrupted.

 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="enterWhen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="java.time.Duration"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks at most the given time, including both
 the time to acquire the lock and the time to wait for the guard to be satisfied, and may be
 interrupted.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @throws InterruptedException if interrupted while waiting
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="enterWhen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks at most the given time, including both
 the time to acquire the lock and the time to wait for the guard to be satisfied, and may be
 interrupted.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="enterWhenUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks indefinitely.]]>
      </doc>
    </method>
    <method name="enterWhenUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="java.time.Duration"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks at most the given time, including both
 the time to acquire the lock and the time to wait for the guard to be satisfied.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="enterWhenUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Enters this monitor when the guard is satisfied. Blocks at most the given time, including both
 the time to acquire the lock and the time to wait for the guard to be satisfied.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied]]>
      </doc>
    </method>
    <method name="enterIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does
 not wait for the guard to be satisfied.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied]]>
      </doc>
    </method>
    <method name="enterIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="java.time.Duration"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the
 lock, but does not wait for the guard to be satisfied.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="enterIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the
 lock, but does not wait for the guard to be satisfied.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied]]>
      </doc>
    </method>
    <method name="enterIfInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks indefinitely acquiring the lock, but does
 not wait for the guard to be satisfied, and may be interrupted.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="enterIfInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="java.time.Duration"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the
 lock, but does not wait for the guard to be satisfied, and may be interrupted.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="enterIfInterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Enters this monitor if the guard is satisfied. Blocks at most the given time acquiring the
 lock, but does not wait for the guard to be satisfied, and may be interrupted.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied]]>
      </doc>
    </method>
    <method name="tryEnterIf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Enters this monitor if it is possible to do so immediately and the guard is satisfied. Does not
 block acquiring the lock and does not wait for the guard to be satisfied.

 <p><b>Note:</b> This method disregards the fairness setting of this monitor.

 @return whether the monitor was entered, which guarantees that the guard is now satisfied]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits indefinitely, but may be interrupted. May be called
 only by a thread currently occupying this monitor.

 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="waitFor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="java.time.Duration"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May
 be called only by a thread currently occupying this monitor.

 @return whether the guard is now satisfied
 @throws InterruptedException if interrupted while waiting
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="waitFor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits at most the given time, and may be interrupted. May
 be called only by a thread currently occupying this monitor.

 @return whether the guard is now satisfied
 @throws InterruptedException if interrupted while waiting]]>
      </doc>
    </method>
    <method name="waitForUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits indefinitely. May be called only by a thread
 currently occupying this monitor.]]>
      </doc>
    </method>
    <method name="waitForUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="java.time.Duration"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits at most the given time. May be called only by a
 thread currently occupying this monitor.

 @return whether the guard is now satisfied
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="waitForUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Waits for the guard to be satisfied. Waits at most the given time. May be called only by a
 thread currently occupying this monitor.

 @return whether the guard is now satisfied]]>
      </doc>
    </method>
    <method name="leave"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Leaves this monitor. May be called only by a thread currently occupying this monitor.]]>
      </doc>
    </method>
    <method name="isFair" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this monitor is using a fair ordering policy.]]>
      </doc>
    </method>
    <method name="isOccupied" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this monitor is occupied by any thread. This method is designed for use in
 monitoring of the system state, not for synchronization control.]]>
      </doc>
    </method>
    <method name="isOccupiedByCurrentThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the current thread is occupying this monitor (has entered more times than it
 has left).]]>
      </doc>
    </method>
    <method name="getOccupiedDepth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of times the current thread has entered this monitor in excess of the number
 of times it has left. Returns 0 if the current thread is not occupying this monitor.]]>
      </doc>
    </method>
    <method name="getQueueLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an estimate of the number of threads waiting to enter this monitor. The value is only
 an estimate because the number of threads may change dynamically while this method traverses
 internal data structures. This method is designed for use in monitoring of the system state,
 not for synchronization control.]]>
      </doc>
    </method>
    <method name="hasQueuedThreads" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether any threads are waiting to enter this monitor. Note that because cancellations
 may occur at any time, a {@code true} return does not guarantee that any other thread will ever
 enter this monitor. This method is designed primarily for use in monitoring of the system
 state.]]>
      </doc>
    </method>
    <method name="hasQueuedThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
      <doc>
      <![CDATA[Queries whether the given thread is waiting to enter this monitor. Note that because
 cancellations may occur at any time, a {@code true} return does not guarantee that this thread
 will ever enter this monitor. This method is designed primarily for use in monitoring of the
 system state.]]>
      </doc>
    </method>
    <method name="hasWaiters" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Queries whether any threads are waiting for the given guard to become satisfied. Note that
 because timeouts and interrupts may occur at any time, a {@code true} return does not guarantee
 that the guard becoming satisfied in the future will awaken any threads. This method is
 designed primarily for use in monitoring of the system state.]]>
      </doc>
    </method>
    <method name="getWaitQueueLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="guard" type="com.google.common.util.concurrent.Monitor.Guard"/>
      <doc>
      <![CDATA[Returns an estimate of the number of threads waiting for the given guard to become satisfied.
 Note that because timeouts and interrupts may occur at any time, the estimate serves only as an
 upper bound on the actual number of waiters. This method is designed for use in monitoring of
 the system state, not for synchronization control.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A synchronization abstraction supporting waiting on arbitrary boolean conditions.

 <p>This class is intended as a replacement for {@link ReentrantLock}. Code using {@code Monitor}
 is less error-prone and more readable than code using {@code ReentrantLock}, without significant
 performance loss. {@code Monitor} even has the potential for performance gain by optimizing the
 evaluation and signaling of conditions. Signaling is entirely <a
 href="http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling">implicit</a>. By
 eliminating explicit signaling, this class can guarantee that only one thread is awakened when a
 condition becomes true (no "signaling storms" due to use of {@link
 java.util.concurrent.locks.Condition#signalAll Condition.signalAll}) and that no signals are lost
 (no "hangs" due to incorrect use of {@link java.util.concurrent.locks.Condition#signal
 Condition.signal}).

 <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet
 <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also
 reentrant, so a thread may enter a monitor any number of times, and then must leave the same
 number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization
 semantics as the built-in Java language synchronization primitives.

 <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be
 followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the
 monitor cleanly:

 {@snippet :
 monitor.enter();
 try {
   // do things while occupying the monitor
 } finally {
   monitor.leave();
 }
 }

 <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear
 as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that
 the current thread leaves the monitor cleanly:

 {@snippet :
 if (monitor.tryEnter()) {
   try {
     // do things while occupying the monitor
   } finally {
     monitor.leave();
   }
 } else {
   // do other things since the monitor was not available
 }
 }

 <h2>Comparison with {@code synchronized} and {@code ReentrantLock}</h2>

 <p>The following examples show a simple threadsafe holder expressed using {@code synchronized},
 {@link ReentrantLock}, and {@code Monitor}.

 <h3>{@code synchronized}</h3>

 <p>This version is the fewest lines of code, largely because the synchronization mechanism used
 is built into the language and runtime. But the programmer has to remember to avoid a couple of
 common bugs: The {@code wait()} must be inside a {@code while} instead of an {@code if}, and
 {@code notifyAll()} must be used instead of {@code notify()} because there are two different
 logical conditions being awaited.

 {@snippet :
 public class SafeBox<V> {
   private V value;

   public synchronized V get() throws InterruptedException {
     while (value == null) {
       wait();
     }
     V result = value;
     value = null;
     notifyAll();
     return result;
   }

   public synchronized void set(V newValue) throws InterruptedException {
     while (value != null) {
       wait();
     }
     value = newValue;
     notifyAll();
   }
 }
 }

 <h3>{@code ReentrantLock}</h3>

 <p>This version is much more verbose than the {@code synchronized} version, and still suffers
 from the need for the programmer to remember to use {@code while} instead of {@code if}. However,
 one advantage is that we can introduce two separate {@code Condition} objects, which allows us to
 use {@code signal()} instead of {@code signalAll()}, which may be a performance benefit.

 {@snippet :
 public class SafeBox<V> {
   private V value;
   private final ReentrantLock lock = new ReentrantLock();
   private final Condition valuePresent = lock.newCondition();
   private final Condition valueAbsent = lock.newCondition();

   public V get() throws InterruptedException {
     lock.lock();
     try {
       while (value == null) {
         valuePresent.await();
       }
       V result = value;
       value = null;
       valueAbsent.signal();
       return result;
     } finally {
       lock.unlock();
     }
   }

   public void set(V newValue) throws InterruptedException {
     lock.lock();
     try {
       while (value != null) {
         valueAbsent.await();
       }
       value = newValue;
       valuePresent.signal();
     } finally {
       lock.unlock();
     }
   }
 }
 }

 <h3>{@code Monitor}</h3>

 <p>This version adds some verbosity around the {@code Guard} objects, but removes that same
 verbosity, and more, from the {@code get} and {@code set} methods. {@code Monitor} implements the
 same efficient signaling as we had to hand-code in the {@code ReentrantLock} version above.
 Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to
 remember to use {@code while} instead of {@code if}.

 {@snippet :
 public class SafeBox<V> {
   private V value;
   private final Monitor monitor = new Monitor();
   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);
   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);

   public V get() throws InterruptedException {
     monitor.enterWhen(valuePresent);
     try {
       V result = value;
       value = null;
       return result;
     } finally {
       monitor.leave();
     }
   }

   public void set(V newValue) throws InterruptedException {
     monitor.enterWhen(valueAbsent);
     try {
       value = newValue;
     } finally {
       monitor.leave();
     }
   }
 }
 }

 @author Justin T. Sampson
 @author Martin Buchholz
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Monitor -->
  <!-- start class com.google.common.util.concurrent.Monitor.Guard -->
  <class name="Monitor.Guard" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Guard" type="com.google.common.util.concurrent.Monitor"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="isSatisfied" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Evaluates this guard's boolean condition. This method is always called with the associated
 monitor already occupied. Implementations of this method must depend only on state protected
 by the associated monitor, and must not modify that state.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A boolean condition for which a thread may wait. A {@code Guard} is associated with a single
 {@code Monitor}. The monitor may check the guard at arbitrary times from any thread occupying
 the monitor, so code should not be written to rely on how often a guard might or might not be
 checked.

 <p>If a {@code Guard} is passed into any method of a {@code Monitor} other than the one it is
 associated with, an {@link IllegalMonitorStateException} is thrown.

 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Monitor.Guard -->
  <!-- start class com.google.common.util.concurrent.MoreExecutors -->
  <class name="MoreExecutors" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <param name="terminationTimeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application
 is complete. It does so by using daemon threads and adding a shutdown hook to wait for their
 completion.

 <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the application is finished
 @param terminationTimeout how long to wait for the executor to finish before terminating the
     JVM
 @return an unmodifiable version of the input which will not hang the JVM
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application
 is complete. It does so by using daemon threads and adding a shutdown hook to wait for their
 completion.

 <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the application is finished
 @param terminationTimeout how long to wait for the executor to finish before terminating the
     JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingExecutorService" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ThreadPoolExecutor into an ExecutorService that exits when the application
 is complete. It does so by using daemon threads and adding a shutdown hook to wait for their
 completion.

 <p>This method waits 120 seconds before continuing with JVM termination, even if the executor
 has not finished its work.

 <p>This is mainly for fixed thread pools. See {@link Executors#newFixedThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <param name="terminationTimeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when
 the application is complete. It does so by using daemon threads and adding a shutdown hook to
 wait for their completion.

 <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the application is finished
 @param terminationTimeout how long to wait for the executor to finish before terminating the
     JVM
 @return an unmodifiable version of the input which will not hang the JVM
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when
 the application is complete. It does so by using daemon threads and adding a shutdown hook to
 wait for their completion.

 <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the application is finished
 @param terminationTimeout how long to wait for the executor to finish before terminating the
     JVM
 @param timeUnit unit of time for the time parameter
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="getExitingScheduledExecutorService" return="java.util.concurrent.ScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ScheduledThreadPoolExecutor"/>
      <doc>
      <![CDATA[Converts the given ScheduledThreadPoolExecutor into a ScheduledExecutorService that exits when
 the application is complete. It does so by using daemon threads and adding a shutdown hook to
 wait for their completion.

 <p>This method waits 120 seconds before continuing with JVM termination, even if the executor
 has not finished its work.

 <p>This is mainly for fixed thread pools. See {@link Executors#newScheduledThreadPool(int)}.

 @param executor the executor to modify to make sure it exits when the application is finished
 @return an unmodifiable version of the input which will not hang the JVM]]>
      </doc>
    </method>
    <method name="addDelayedShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="terminationTimeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Add a shutdown hook to wait for thread completion in the given {@link ExecutorService service}.
 This is useful if the given service uses daemon threads, and we want to keep the JVM from
 exiting immediately on shutdown, instead giving these daemon threads a chance to terminate
 normally.

 @param service ExecutorService which uses daemon threads
 @param terminationTimeout how long to wait for the executor to finish before terminating the
     JVM
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="addDelayedShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="terminationTimeout" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Add a shutdown hook to wait for thread completion in the given {@link ExecutorService service}.
 This is useful if the given service uses daemon threads, and we want to keep the JVM from
 exiting immediately on shutdown, instead giving these daemon threads a chance to terminate
 normally.

 @param service ExecutorService which uses daemon threads
 @param terminationTimeout how long to wait for the executor to finish before terminating the
     JVM
 @param timeUnit unit of time for the time parameter]]>
      </doc>
    </method>
    <method name="newDirectExecutorService" return="com.google.common.util.concurrent.ListeningExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an executor service that runs each task in the thread that invokes {@code
 execute/submit}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}. This applies both to
 individually submitted tasks and to collections of tasks submitted via {@code invokeAll} or
 {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are
 run to completion before a {@code Future} is returned to the caller (unless the executor has
 been shutdown).

 <p>Although all tasks are immediately executed in the thread that submitted the task, this
 {@code ExecutorService} imposes a small locking overhead on each task submission in order to
 implement shutdown and termination behavior.

 <p>The implementation deviates from the {@code ExecutorService} specification with regards to
 the {@code shutdownNow} method. First, "best-effort" with regards to canceling running tasks is
 implemented as "no-effort". No interrupts or other attempts are made to stop threads executing
 tasks. Second, the returned list will always be empty, as any submitted task is considered to
 have started execution. This applies also to tasks given to {@code invokeAll} or {@code
 invokeAny} which are pending serial execution, even the subset of the tasks that have not yet
 started execution. It is unclear from the {@code ExecutorService} specification if these should
 be included, and it's much easier to implement the interpretation that they not be. Finally, a
 call to {@code shutdown} or {@code shutdownNow} may result in concurrent calls to {@code
 invokeAll/invokeAny} throwing RejectedExecutionException, although a subset of the tasks may
 already have been executed.

 @since 18.0 (present as MoreExecutors.sameThreadExecutor() since 10.0)]]>
      </doc>
    </method>
    <method name="directExecutor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Executor} that runs each task in the thread that invokes {@link
 Executor#execute execute}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}.

 <p>This executor is appropriate for tasks that are lightweight and not deeply chained.
 Inappropriate {@code directExecutor} usage can cause problems, and these problems can be
 difficult to reproduce because they depend on timing. For example:

 <ul>
   <li>When a {@code ListenableFuture} listener is registered to run under {@code
       directExecutor}, the listener can execute in any of three possible threads:
       <ol>
         <li>When a thread attaches a listener to a {@code ListenableFuture} that's already
             complete, the listener runs immediately in that thread.
         <li>When a thread attaches a listener to a {@code ListenableFuture} that's
             <em>in</em>complete and the {@code ListenableFuture} later completes normally, the
             listener runs in the thread that completes the {@code ListenableFuture}.
         <li>When a listener is attached to a {@code ListenableFuture} and the {@code
             ListenableFuture} gets cancelled, the listener runs immediately in the thread that
             cancelled the {@code Future}.
       </ol>
       Given all these possibilities, it is frequently possible for listeners to execute in UI
       threads, RPC network threads, or other latency-sensitive threads. In those cases, slow
       listeners can harm responsiveness, slow the system as a whole, or worse. (See also the
       note about locking below.)
   <li>If many tasks will be triggered by the same event, one heavyweight task may delay other
       tasks -- even tasks that are not themselves {@code directExecutor} tasks.
   <li>If many such tasks are chained together (such as with {@code
       future.transform(...).transform(...).transform(...)....}), they may overflow the stack.
       (In simple cases, callers can avoid this by registering all tasks with the same {@link
       MoreExecutors#newSequentialExecutor} wrapper around {@code directExecutor()}. More
       complex cases may require using thread pools or making deeper changes.)
   <li>If an exception propagates out of a {@code Runnable}, it is not necessarily seen by any
       {@code UncaughtExceptionHandler} for the thread. For example, if the callback passed to
       {@link Futures#addCallback} throws an exception, that exception will be typically be
       logged by the {@link ListenableFuture} implementation, even if the thread is configured
       to do something different. In other cases, no code will catch the exception, and it may
       terminate whichever thread happens to trigger the execution.
 </ul>

 A specific warning about locking: Code that executes user-supplied tasks, such as {@code
 ListenableFuture} listeners, should take care not to do so while holding a lock. Additionally,
 as a further line of defense, prefer not to perform any locking inside a task that will be run
 under {@code directExecutor}: Not only might the wait for a lock be long, but if the running
 thread was holding a lock, the listener may deadlock or break lock isolation.

 <p>This instance is equivalent to:

 {@snippet :
 final class DirectExecutor implements Executor {
   public void execute(Runnable r) {
     r.run();
   }
 }
 }

 <p>This should be preferred to {@link #newDirectExecutorService()} because implementing the
 {@link ExecutorService} subinterface necessitates significant performance overhead.

 @since 18.0]]>
      </doc>
    </method>
    <method name="newSequentialExecutor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Returns an {@link Executor} that runs each task executed sequentially, such that no two tasks
 are running concurrently.

 <p>{@linkplain Executor#execute executed} tasks have a happens-before order as defined in the
 Java Language Specification. Tasks execute with the same happens-before order that the function
 calls to {@link Executor#execute execute()} that submitted those tasks had.

 <p>The executor uses {@code delegate} in order to {@link Executor#execute execute} each task in
 turn, and does not create any threads of its own.

 <p>After execution begins on a thread from the {@code delegate} {@link Executor}, tasks are
 polled and executed from a task queue until there are no more tasks. The thread will not be
 released until there are no more tasks to run.

 <p>If a task is submitted while a thread is executing tasks from the task queue, the thread
 will not be released until that submitted task is also complete.

 <p>If a task is {@linkplain Thread#interrupt interrupted} while a task is running:

 <ol>
   <li>execution will not stop until the task queue is empty.
   <li>tasks will begin execution with the thread marked as not interrupted - any interruption
       applies only to the task that was running at the point of interruption.
   <li>if the thread was interrupted before the SequentialExecutor's worker begins execution,
       the interrupt will be restored to the thread after it completes so that its {@code
       delegate} Executor may process the interrupt.
   <li>subtasks are run with the thread uninterrupted and interrupts received during execution
       of a task are ignored.
 </ol>

 <p>{@code RuntimeException}s thrown by tasks are simply logged and the executor keeps trucking.
 If an {@code Error} is thrown, the error will propagate and execution will stop until the next
 time a task is submitted.

 <p>When an {@code Error} is thrown by an executed task, previously submitted tasks may never
 run. An attempt will be made to restart execution on the next call to {@code execute}. If the
 {@code delegate} has begun to reject execution, the previously submitted tasks may never run,
 despite not throwing a RejectedExecutionException synchronously with the call to {@code
 execute}. If this behaviour is problematic, use an Executor with a single thread (e.g. {@link
 Executors#newSingleThreadExecutor}).

 @since 23.3 (since 23.1 as {@code sequentialExecutor})]]>
      </doc>
    </method>
    <method name="listeningDecorator" return="com.google.common.util.concurrent.ListeningExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="java.util.concurrent.ExecutorService"/>
      <doc>
      <![CDATA[Creates an {@link ExecutorService} whose {@code submit} and {@code invokeAll} methods submit
 {@link ListenableFutureTask} instances to the given delegate executor. Those methods, as well
 as {@code execute} and {@code invokeAny}, are implemented in terms of calls to {@code
 delegate.execute}. All other methods are forwarded unchanged to the delegate. This implies that
 the returned {@code ListeningExecutorService} never calls the delegate's {@code submit}, {@code
 invokeAll}, and {@code invokeAny} methods, so any special handling of tasks must be implemented
 in the delegate's {@code execute} method or by wrapping the returned {@code
 ListeningExecutorService}.

 <p>If the delegate executor was already an instance of {@code ListeningExecutorService}, it is
 returned untouched, and the rest of this documentation does not apply.

 @since 10.0]]>
      </doc>
    </method>
    <method name="listeningDecorator" return="com.google.common.util.concurrent.ListeningScheduledExecutorService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="java.util.concurrent.ScheduledExecutorService"/>
      <doc>
      <![CDATA[Creates a {@link ScheduledExecutorService} whose {@code submit} and {@code invokeAll} methods
 submit {@link ListenableFutureTask} instances to the given delegate executor. Those methods, as
 well as {@code execute} and {@code invokeAny}, are implemented in terms of calls to {@code
 delegate.execute}. All other methods are forwarded unchanged to the delegate. This implies that
 the returned {@code ListeningScheduledExecutorService} never calls the delegate's {@code
 submit}, {@code invokeAll}, and {@code invokeAny} methods, so any special handling of tasks
 must be implemented in the delegate's {@code execute} method or by wrapping the returned {@code
 ListeningScheduledExecutorService}.

 <p>If the delegate executor was already an instance of {@code
 ListeningScheduledExecutorService}, it is returned untouched, and the rest of this
 documentation does not apply.

 @since 10.0]]>
      </doc>
    </method>
    <method name="platformThreadFactory" return="java.util.concurrent.ThreadFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a default thread factory used to create new threads.

 <p>When running on AppEngine with access to <a
 href="https://cloud.google.com/appengine/docs/standard/java/javadoc/">AppEngine legacy
 APIs</a>, this method returns {@code ThreadManager.currentRequestThreadFactory()}. Otherwise,
 it returns {@link Executors#defaultThreadFactory()}.

 @since 14.0]]>
      </doc>
    </method>
    <method name="shutdownAndAwaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Shuts down the given executor service gradually, first disabling new submissions and later, if
 necessary, cancelling remaining tasks.

 <p>The method takes the following steps:

 <ol>
   <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.
   <li>awaits executor service termination for half of the specified timeout.
   <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling
       pending tasks and interrupting running tasks.
   <li>awaits executor service termination for the other half of the specified timeout.
 </ol>

 <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link
 ExecutorService#shutdownNow()} and returns.

 <p>For a version of this method that waits <i>indefinitely</i>, use {@link
 ExecutorService#close}.

 @param service the {@code ExecutorService} to shut down
 @param timeout the maximum time to wait for the {@code ExecutorService} to terminate
 @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}
     if the call timed out or was interrupted
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="shutdownAndAwaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Shuts down the given executor service gradually, first disabling new submissions and later, if
 necessary, cancelling remaining tasks.

 <p>The method takes the following steps:

 <ol>
   <li>calls {@link ExecutorService#shutdown()}, disabling acceptance of new submitted tasks.
   <li>awaits executor service termination for half of the specified timeout.
   <li>if the timeout expires, it calls {@link ExecutorService#shutdownNow()}, cancelling
       pending tasks and interrupting running tasks.
   <li>awaits executor service termination for the other half of the specified timeout.
 </ol>

 <p>If, at any step of the process, the calling thread is interrupted, the method calls {@link
 ExecutorService#shutdownNow()} and returns.

 <p>For a version of this method that waits <i>indefinitely</i>, use {@link
 ExecutorService#close}.

 @param service the {@code ExecutorService} to shut down
 @param timeout the maximum time to wait for the {@code ExecutorService} to terminate
 @param unit the time unit of the timeout argument
 @return {@code true} if the {@code ExecutorService} was terminated successfully, {@code false}
     if the call timed out or was interrupted
 @since 17.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},
 and {@link java.util.concurrent.ThreadFactory}.

 @author Eric Fellheimer
 @author Kyle Littlefield
 @author Justin Mahoney
 @since 3.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.MoreExecutors -->
  <!-- start class com.google.common.util.concurrent.RateLimiter -->
  <class name="RateLimiter" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.RateLimiter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permitsPerSecond" type="double"/>
      <doc>
      <![CDATA[Creates a {@code RateLimiter} with the specified stable throughput, given as "permits per
 second" (commonly referred to as <i>QPS</i>, queries per second).

 <p>The returned {@code RateLimiter} ensures that on average no more than {@code
 permitsPerSecond} are issued during any given second, with sustained requests being smoothly
 spread over each second. When the incoming request rate exceeds {@code permitsPerSecond} the
 rate limiter will release one permit every {@code (1.0 / permitsPerSecond)} seconds. When the
 rate limiter is unused, bursts of up to {@code permitsPerSecond} permits will be allowed, with
 subsequent requests being smoothly limited at the stable rate of {@code permitsPerSecond}.

 @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
     permits become available per second
 @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.util.concurrent.RateLimiter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permitsPerSecond" type="double"/>
      <param name="warmupPeriod" type="java.time.Duration"/>
      <doc>
      <![CDATA[Creates a {@code RateLimiter} with the specified stable throughput, given as "permits per
 second" (commonly referred to as <i>QPS</i>, queries per second), and a <i>warmup period</i>,
 during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches its maximum
 rate at the end of the period (as long as there are enough requests to saturate it). Similarly,
 if the {@code RateLimiter} is left <i>unused</i> for a duration of {@code warmupPeriod}, it
 will gradually return to its "cold" state, i.e. it will go through the same warming up process
 as when it was first created.

 <p>The returned {@code RateLimiter} is intended for cases where the resource that actually
 fulfills the requests (e.g., a remote server) needs "warmup" time, rather than being
 immediately accessed at the stable (maximum) rate.

 <p>The returned {@code RateLimiter} starts in a "cold" state (i.e. the warmup period will
 follow), and if it is left unused for long enough, it will return to that state.

 @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
     permits become available per second
 @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its rate,
     before reaching its stable (maximum) rate
 @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or {@code
     warmupPeriod} is negative
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="create" return="com.google.common.util.concurrent.RateLimiter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permitsPerSecond" type="double"/>
      <param name="warmupPeriod" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Creates a {@code RateLimiter} with the specified stable throughput, given as "permits per
 second" (commonly referred to as <i>QPS</i>, queries per second), and a <i>warmup period</i>,
 during which the {@code RateLimiter} smoothly ramps up its rate, until it reaches its maximum
 rate at the end of the period (as long as there are enough requests to saturate it). Similarly,
 if the {@code RateLimiter} is left <i>unused</i> for a duration of {@code warmupPeriod}, it
 will gradually return to its "cold" state, i.e. it will go through the same warming up process
 as when it was first created.

 <p>The returned {@code RateLimiter} is intended for cases where the resource that actually
 fulfills the requests (e.g., a remote server) needs "warmup" time, rather than being
 immediately accessed at the stable (maximum) rate.

 <p>The returned {@code RateLimiter} starts in a "cold" state (i.e. the warmup period will
 follow), and if it is left unused for long enough, it will return to that state.

 @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in how many
     permits become available per second
 @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its rate,
     before reaching its stable (maximum) rate
 @param unit the time unit of the warmupPeriod argument
 @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or {@code
     warmupPeriod} is negative]]>
      </doc>
    </method>
    <method name="setRate"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="permitsPerSecond" type="double"/>
      <doc>
      <![CDATA[Updates the stable rate of this {@code RateLimiter}, that is, the {@code permitsPerSecond}
 argument provided in the factory method that constructed the {@code RateLimiter}. Currently
 throttled threads will <b>not</b> be awakened as a result of this invocation, thus they do not
 observe the new rate; only subsequent requests will.

 <p>Note though that, since each request repays (by waiting, if necessary) the cost of the
 <i>previous</i> request, this means that the very next request after an invocation to {@code
 setRate} will not be affected by the new rate; it will pay the cost of the previous request,
 which is in terms of the previous rate.

 <p>The behavior of the {@code RateLimiter} is not modified in any other way, e.g. if the {@code
 RateLimiter} was configured with a warmup period of 20 seconds, it still has a warmup period of
 20 seconds after this method invocation.

 @param permitsPerSecond the new stable rate of this {@code RateLimiter}
 @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero]]>
      </doc>
    </method>
    <method name="getRate" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the stable rate (as {@code permits per seconds}) with which this {@code RateLimiter} is
 configured with. The initial value of this is the same as the {@code permitsPerSecond} argument
 passed in the factory method that produced this {@code RateLimiter}, and it is only updated
 after invocations to {@linkplain #setRate}.]]>
      </doc>
    </method>
    <method name="acquire" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Acquires a single permit from this {@code RateLimiter}, blocking until the request can be
 granted. Tells the amount of time slept, if any.

 <p>This method is equivalent to {@code acquire(1)}.

 @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
 @since 16.0 (present in 13.0 with {@code void} return type})]]>
      </doc>
    </method>
    <method name="acquire" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permits" type="int"/>
      <doc>
      <![CDATA[Acquires the given number of permits from this {@code RateLimiter}, blocking until the request
 can be granted. Tells the amount of time slept, if any.

 @param permits the number of permits to acquire
 @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
 @throws IllegalArgumentException if the requested number of permits is negative or zero
 @since 16.0 (present in 13.0 with {@code void} return type})]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Acquires a permit from this {@code RateLimiter} if it can be obtained without exceeding the
 specified {@code timeout}, or returns {@code false} immediately (without waiting) if the permit
 would not have been granted before the timeout expired.

 <p>This method is equivalent to {@code tryAcquire(1, timeout)}.

 @param timeout the maximum time to wait for the permit. Negative values are treated as zero.
 @return {@code true} if the permit was acquired, {@code false} otherwise
 @throws IllegalArgumentException if the requested number of permits is negative or zero
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Acquires a permit from this {@code RateLimiter} if it can be obtained without exceeding the
 specified {@code timeout}, or returns {@code false} immediately (without waiting) if the permit
 would not have been granted before the timeout expired.

 <p>This method is equivalent to {@code tryAcquire(1, timeout, unit)}.

 @param timeout the maximum time to wait for the permit. Negative values are treated as zero.
 @param unit the time unit of the timeout argument
 @return {@code true} if the permit was acquired, {@code false} otherwise
 @throws IllegalArgumentException if the requested number of permits is negative or zero]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permits" type="int"/>
      <doc>
      <![CDATA[Acquires permits from this {@link RateLimiter} if it can be acquired immediately without delay.

 <p>This method is equivalent to {@code tryAcquire(permits, 0, anyUnit)}.

 @param permits the number of permits to acquire
 @return {@code true} if the permits were acquired, {@code false} otherwise
 @throws IllegalArgumentException if the requested number of permits is negative or zero
 @since 14.0]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Acquires a permit from this {@link RateLimiter} if it can be acquired immediately without
 delay.

 <p>This method is equivalent to {@code tryAcquire(1)}.

 @return {@code true} if the permit was acquired, {@code false} otherwise
 @since 14.0]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permits" type="int"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Acquires the given number of permits from this {@code RateLimiter} if it can be obtained
 without exceeding the specified {@code timeout}, or returns {@code false} immediately (without
 waiting) if the permits would not have been granted before the timeout expired.

 @param permits the number of permits to acquire
 @param timeout the maximum time to wait for the permits. Negative values are treated as zero.
 @return {@code true} if the permits were acquired, {@code false} otherwise
 @throws IllegalArgumentException if the requested number of permits is negative or zero
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Acquires the given number of permits from this {@code RateLimiter} if it can be obtained
 without exceeding the specified {@code timeout}, or returns {@code false} immediately (without
 waiting) if the permits would not have been granted before the timeout expired.

 @param permits the number of permits to acquire
 @param timeout the maximum time to wait for the permits. Negative values are treated as zero.
 @param unit the time unit of the timeout argument
 @return {@code true} if the permits were acquired, {@code false} otherwise
 @throws IllegalArgumentException if the requested number of permits is negative or zero]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A rate limiter. Conceptually, a rate limiter distributes permits at a configurable rate. Each
 {@link #acquire()} blocks if necessary until a permit is available, and then takes it. Once
 acquired, permits need not be released.

 <p>{@code RateLimiter} is safe for concurrent use: It will restrict the total rate of calls from
 all threads. Note, however, that it does not guarantee fairness.

 <p>Rate limiters are often used to restrict the rate at which some physical or logical resource
 is accessed. This is in contrast to {@link java.util.concurrent.Semaphore} which restricts the
 number of concurrent accesses instead of the rate (note though that concurrency and rate are
 closely related, e.g. see <a href="http://en.wikipedia.org/wiki/Little%27s_law">Little's
 Law</a>).

 <p>A {@code RateLimiter} is defined primarily by the rate at which permits are issued. Absent
 additional configuration, permits will be distributed at a fixed rate, defined in terms of
 permits per second. Permits will be distributed smoothly, with the delay between individual
 permits being adjusted to ensure that the configured rate is maintained.

 <p>It is possible to configure a {@code RateLimiter} to have a warmup period during which time
 the permits issued each second steadily increases until it hits the stable rate.

 <p>As an example, imagine that we have a list of tasks to execute, but we don't want to submit
 more than 2 per second:

 {@snippet :
 final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is "2 permits per second"
 void submitTasks(List<Runnable> tasks, Executor executor) {
   for (Runnable task : tasks) {
     rateLimiter.acquire(); // may wait
     executor.execute(task);
   }
 }
 }

 <p>As another example, imagine that we produce a stream of data, and we want to cap it at 5kb per
 second. This could be accomplished by requiring a permit per byte, and specifying a rate of 5000
 permits per second:

 {@snippet :
 final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second
 void submitPacket(byte[] packet) {
   rateLimiter.acquire(packet.length);
   networkService.send(packet);
 }
 }

 <p>It is important to note that the number of permits requested <i>never</i> affects the
 throttling of the request itself (an invocation to {@code acquire(1)} and an invocation to {@code
 acquire(1000)} will result in exactly the same throttling, if any), but it affects the throttling
 of the <i>next</i> request. I.e., if an expensive task arrives at an idle RateLimiter, it will be
 granted immediately, but it is the <i>next</i> request that will experience extra throttling,
 thus paying for the cost of the expensive task.

 @author Dimitris Andreou
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.RateLimiter -->
  <!-- start class com.google.common.util.concurrent.Runnables -->
  <class name="Runnables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="doNothing" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Runnable} instance that does nothing when run.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods pertaining to the {@link Runnable} interface.

 @since 16.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Runnables -->
  <!-- start interface com.google.common.util.concurrent.Service -->
  <interface name="Service"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service state is {@link State#NEW}, this initiates service startup and returns
 immediately. A stopped service may not be restarted.

 @return this
 @throws IllegalStateException if the service is not {@link State#NEW}
 @since 15.0]]>
      </doc>
    </method>
    <method name="isRunning" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if this service is {@linkplain State#RUNNING running}.]]>
      </doc>
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the lifecycle state of the service.]]>
      </doc>
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the service is {@linkplain State#STARTING starting} or {@linkplain State#RUNNING running},
 this initiates service shutdown and returns immediately. If the service is {@linkplain
 State#NEW new}, it is {@linkplain State#TERMINATED terminated} without having been started nor
 stopped. If the service has already been stopped, this method returns immediately without
 taking action.

 @return this
 @since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Waits for the {@link Service} to reach the {@linkplain State#RUNNING running state}.

 @throws IllegalStateException if the service reaches a state from which it is not possible to
     enter the {@link State#RUNNING} state. e.g. if the {@code state} is {@code
     State#TERMINATED} when this method is called then this will throw an IllegalStateException.
 @since 15.0]]>
      </doc>
    </method>
    <method name="awaitRunning"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Waits for the {@link Service} to reach the {@linkplain State#RUNNING running state} for no more
 than the given time.

 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @throws TimeoutException if the service has not reached the given state within the deadline
 @throws IllegalStateException if the service reaches a state from which it is not possible to
     enter the {@link State#RUNNING RUNNING} state. e.g. if the {@code state} is {@code
     State#TERMINATED} when this method is called then this will throw an IllegalStateException.
 @since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Waits for the {@link Service} to reach the {@linkplain State#TERMINATED terminated state}.

 @throws IllegalStateException if the service {@linkplain State#FAILED fails}.
 @since 15.0]]>
      </doc>
    </method>
    <method name="awaitTerminated"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Waits for the {@link Service} to reach a terminal state (either {@link Service.State#TERMINATED
 terminated} or {@link Service.State#FAILED failed}) for no more than the given time.

 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @throws TimeoutException if the service has not reached the given state within the deadline
 @throws IllegalStateException if the service {@linkplain State#FAILED fails}.
 @since 15.0]]>
      </doc>
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@link Throwable} that caused this service to fail.

 @throws IllegalStateException if this service's state isn't {@linkplain State#FAILED FAILED}.
 @since 14.0]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given
 executor. The listener will have the corresponding transition method called whenever the
 service changes state. The listener will not have previous state changes replayed, so it is
 suggested that listeners are added before the service starts.

 <p>{@code addListener} guarantees execution ordering across calls to a given listener but not
 across calls to multiple listeners. Specifically, a given listener will have its callbacks
 invoked in the same order as the underlying service enters those states. Additionally, at most
 one of the listener's callbacks will execute at once. However, multiple listeners' callbacks
 may execute concurrently, and listeners may execute in an order different from the one in which
 they were registered.

 <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown
 during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and
 logged.

 @param listener the listener to run when the service changes state is complete
 @param executor the executor in which the listeners callback methods will be run. For fast,
     lightweight listeners that would be safe to execute in any thread, consider {@link
     MoreExecutors#directExecutor}.
 @since 13.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object with an operational state, plus asynchronous {@link #startAsync()} and {@link
 #stopAsync()} lifecycle methods to transition between states. Example services include
 webservers, RPC servers and timers.

 <p>The normal lifecycle of a service is:

 <ul>
   <li>{@linkplain State#NEW NEW} -&gt;
   <li>{@linkplain State#STARTING STARTING} -&gt;
   <li>{@linkplain State#RUNNING RUNNING} -&gt;
   <li>{@linkplain State#STOPPING STOPPING} -&gt;
   <li>{@linkplain State#TERMINATED TERMINATED}
 </ul>

 <p>There are deviations from this if there are failures or if {@link Service#stopAsync} is called
 before the {@link Service} reaches the {@linkplain State#RUNNING RUNNING} state. The set of legal
 transitions form a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>,
 therefore every method of the listener will be called at most once. N.B. The {@link State#FAILED}
 and {@link State#TERMINATED} states are terminal states, once a service enters either of these
 states it cannot ever leave them.

 <p>Implementors of this interface are strongly encouraged to extend one of the abstract classes
 in this package which implement this interface and make the threading and state management
 easier.

 @author Jesse Wilson
 @author Luke Sandberg
 @since 9.0 (in 1.0 as {@code com.google.common.base.Service})]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.Service -->
  <!-- start class com.google.common.util.concurrent.Service.Listener -->
  <class name="Service.Listener" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Listener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="starting"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when the service transitions from {@linkplain State#NEW NEW} to {@linkplain
 State#STARTING STARTING}. This occurs when {@link Service#startAsync} is called the first
 time.]]>
      </doc>
    </method>
    <method name="running"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when the service transitions from {@linkplain State#STARTING STARTING} to {@linkplain
 State#RUNNING RUNNING}. This occurs when a service has successfully started.]]>
      </doc>
    </method>
    <method name="stopping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.util.concurrent.Service.State"/>
      <doc>
      <![CDATA[Called when the service transitions to the {@linkplain State#STOPPING STOPPING} state. The
 only valid values for {@code from} are {@linkplain State#STARTING STARTING} or {@linkplain
 State#RUNNING RUNNING}. This occurs when {@link Service#stopAsync} is called.

 @param from The previous state that is being transitioned from.]]>
      </doc>
    </method>
    <method name="terminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.util.concurrent.Service.State"/>
      <doc>
      <![CDATA[Called when the service transitions to the {@linkplain State#TERMINATED TERMINATED} state.
 The {@linkplain State#TERMINATED TERMINATED} state is a terminal state in the transition
 diagram. Therefore, if this method is called, no other methods will be called on the {@link
 Listener}.

 @param from The previous state that is being transitioned from. Failure can occur in any
     state with the exception of {@linkplain State#FAILED FAILED} and {@linkplain
     State#TERMINATED TERMINATED}.]]>
      </doc>
    </method>
    <method name="failed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="com.google.common.util.concurrent.Service.State"/>
      <param name="failure" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Called when the service transitions to the {@linkplain State#FAILED FAILED} state. The
 {@linkplain State#FAILED FAILED} state is a terminal state in the transition diagram.
 Therefore, if this method is called, no other methods will be called on the {@link Listener}.

 @param from The previous state that is being transitioned from. Failure can occur in any
     state with the exception of {@linkplain State#NEW NEW} or {@linkplain State#TERMINATED
     TERMINATED}.
 @param failure The exception that caused the failure.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A listener for the various state changes that a {@link Service} goes through in its lifecycle.

 <p>All methods are no-ops by default, implementors should override the ones they care about.

 @author Luke Sandberg
 @since 15.0 (present as an interface in 13.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Service.Listener -->
  <!-- start class com.google.common.util.concurrent.Service.State -->
  <class name="Service.State" extends="java.lang.Enum&lt;com.google.common.util.concurrent.Service.State&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.common.util.concurrent.Service.State[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The lifecycle states of a service.

 <p>The ordering of the {@link State} enum is defined such that if there is a state transition
 from {@code A -> B} then {@code A.compareTo(B) < 0}. N.B. The converse is not true, i.e. if
 {@code A.compareTo(B) < 0} then there is <b>not</b> guaranteed to be a valid state transition
 {@code A -> B}.

 @since 9.0 (in 1.0 as {@code com.google.common.base.Service.State})]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Service.State -->
  <!-- start class com.google.common.util.concurrent.ServiceManager -->
  <class name="ServiceManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.ServiceManagerBridge"/>
    <constructor name="ServiceManager" type="java.lang.Iterable&lt;? extends com.google.common.util.concurrent.Service&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new instance for managing the given services.

 @param services The services to manage
 @throws IllegalArgumentException if not all services are {@linkplain State#NEW new} or if there
     are any duplicate services.]]>
      </doc>
    </constructor>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.ServiceManager.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
      <doc>
      <![CDATA[Registers a {@link Listener} to be {@linkplain Executor#execute executed} on the given
 executor. The listener will not have previous state changes replayed, so it is suggested that
 listeners are added before any of the managed services are {@linkplain Service#startAsync
 started}.

 <p>{@code addListener} guarantees execution ordering across calls to a given listener but not
 across calls to multiple listeners. Specifically, a given listener will have its callbacks
 invoked in the same order as the underlying service enters those states. Additionally, at most
 one of the listener's callbacks will execute at once. However, multiple listeners' callbacks
 may execute concurrently, and listeners may execute in an order different from the one in which
 they were registered.

 <p>RuntimeExceptions thrown by a listener will be caught and logged. Any exception thrown
 during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and
 logged.

 <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
 the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
 documentation.

 @param listener the listener to run when the manager changes state
 @param executor the executor in which the listeners callback methods will be run.]]>
      </doc>
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.ServiceManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service {@linkplain Service#startAsync startup} on all the services being managed. It
 is only valid to call this method if all of the services are {@linkplain State#NEW new}.

 @return this
 @throws IllegalStateException if any of the Services are not {@link State#NEW new} when the
     method is called.]]>
      </doc>
    </method>
    <method name="awaitHealthy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy}. The manager
 will become healthy after all the component services have reached the {@linkplain State#RUNNING
 running} state.

 @throws IllegalStateException if the service manager reaches a state from which it cannot
     become {@linkplain #isHealthy() healthy}.]]>
      </doc>
    </method>
    <method name="awaitHealthy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="java.time.Duration"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more
 than the given time. The manager will become healthy after all the component services have
 reached the {@linkplain State#RUNNING running} state.

 @param timeout the maximum time to wait
 @throws TimeoutException if not all of the services have finished starting within the deadline
 @throws IllegalStateException if the service manager reaches a state from which it cannot
     become {@linkplain #isHealthy() healthy}.
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="awaitHealthy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Waits for the {@link ServiceManager} to become {@linkplain #isHealthy() healthy} for no more
 than the given time. The manager will become healthy after all the component services have
 reached the {@linkplain State#RUNNING running} state.

 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @throws TimeoutException if not all of the services have finished starting within the deadline
 @throws IllegalStateException if the service manager reaches a state from which it cannot
     become {@linkplain #isHealthy() healthy}.]]>
      </doc>
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.ServiceManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initiates service {@linkplain Service#stopAsync shutdown} if necessary on all the services
 being managed.

 @return this]]>
      </doc>
    </method>
    <method name="awaitStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Waits for the all the services to reach a terminal state. After this method returns all
 services will either be {@linkplain Service.State#TERMINATED terminated} or {@linkplain
 Service.State#FAILED failed}.]]>
      </doc>
    </method>
    <method name="awaitStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="java.time.Duration"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Waits for the all the services to reach a terminal state for no more than the given time. After
 this method returns all services will either be {@linkplain Service.State#TERMINATED
 terminated} or {@linkplain Service.State#FAILED failed}.

 @param timeout the maximum time to wait
 @throws TimeoutException if not all of the services have stopped within the deadline
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="awaitStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Waits for the all the services to reach a terminal state for no more than the given time. After
 this method returns all services will either be {@linkplain Service.State#TERMINATED
 terminated} or {@linkplain Service.State#FAILED failed}.

 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @throws TimeoutException if not all of the services have stopped within the deadline]]>
      </doc>
    </method>
    <method name="isHealthy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if all services are currently in the {@linkplain State#RUNNING running} state.

 <p>Users who want more detailed information should use the {@link #servicesByState} method to
 get detailed information about which services are not running.]]>
      </doc>
    </method>
    <method name="servicesByState" return="com.google.common.collect.ImmutableSetMultimap&lt;com.google.common.util.concurrent.Service.State, com.google.common.util.concurrent.Service&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides a snapshot of the current state of all the services under management.

 <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will
 correspond to a point in time view of the services.

 @since 29.0 (present with return type {@code ImmutableMultimap} since 14.0)]]>
      </doc>
    </method>
    <method name="startupTimes" return="com.google.common.collect.ImmutableMap&lt;com.google.common.util.concurrent.Service, java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the service load times. This value will only return startup times for services that
 have finished starting.

 @return Map of services and their corresponding startup time in millis, the map entries will be
     ordered by startup time.]]>
      </doc>
    </method>
    <method name="startupDurations" return="com.google.common.collect.ImmutableMap&lt;com.google.common.util.concurrent.Service, java.time.Duration&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the service load times. This value will only return startup times for services that
 have finished starting.

 @return Map of services and their corresponding startup time, the map entries will be ordered
     by startup time.
 @since 33.4.0 (but since 31.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A manager for monitoring and controlling a set of {@linkplain Service services}. This class
 provides methods for {@linkplain #startAsync() starting}, {@linkplain #stopAsync() stopping} and
 {@linkplain #servicesByState inspecting} a collection of {@linkplain Service services}.
 Additionally, users can monitor state transitions with the {@linkplain Listener listener}
 mechanism.

 <p>While it is recommended that service lifecycles be managed via this class, state transitions
 initiated via other mechanisms do not impact the correctness of its methods. For example, if the
 services are started by some mechanism besides {@link #startAsync}, the listeners will be invoked
 when appropriate and {@link #awaitHealthy} will still work as expected.

 <p>Here is a simple example of how to use a {@code ServiceManager} to start a server.

 {@snippet :
 class Server {
   public static void main(String[] args) {
     Set<Service> services = ...;
     ServiceManager manager = new ServiceManager(services);
     manager.addListener(new Listener() {
         public void stopped() {}
         public void healthy() {
           // Services have been initialized and are healthy, start accepting requests...
         }
         public void failure(Service service) {
           // Something failed, at this point we could log it, notify a load balancer, or take
           // some other action.  For now we will just exit.
           System.exit(1);
         }
       },
       MoreExecutors.directExecutor());

     Runtime.getRuntime().addShutdownHook(new Thread() {
       public void run() {
         // Give the services 5 seconds to stop to ensure that we are responsive to shutdown
         // requests.
         try {
           manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS);
         } catch (TimeoutException timeout) {
           // stopping timed out
         }
       }
     });
     manager.startAsync();  // start all the services asynchronously
   }
 }
 }

 <p>This class uses the ServiceManager's methods to start all of its services, to respond to
 service failure and to ensure that when the JVM is shutting down all the services are stopped.

 @author Luke Sandberg
 @since 14.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ServiceManager -->
  <!-- start class com.google.common.util.concurrent.ServiceManager.Listener -->
  <class name="ServiceManager.Listener" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Listener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for use by subclasses.]]>
      </doc>
    </constructor>
    <method name="healthy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when the service initially becomes healthy.

 <p>This will be called at most once after all the services have entered the {@linkplain
 State#RUNNING running} state. If any services fail during start up or {@linkplain
 State#FAILED fail}/{@linkplain State#TERMINATED terminate} before all other services have
 started {@linkplain State#RUNNING running} then this method will not be called.]]>
      </doc>
    </method>
    <method name="stopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when the all of the component services have reached a terminal state, either
 {@linkplain State#TERMINATED terminated} or {@linkplain State#FAILED failed}.]]>
      </doc>
    </method>
    <method name="failure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="com.google.common.util.concurrent.Service"/>
      <doc>
      <![CDATA[Called when a component service has {@linkplain State#FAILED failed}.

 @param service The service that failed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A listener for the aggregate state changes of the services that are under management. Users
 that need to listen to more fine-grained events (such as when each particular {@linkplain
 Service service} starts, or terminates), should attach {@linkplain Service.Listener service
 listeners} to each individual service.

 @author Luke Sandberg
 @since 15.0 (present as an interface in 14.0)]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ServiceManager.Listener -->
  <!-- start class com.google.common.util.concurrent.SettableFuture -->
  <class name="SettableFuture" extends="com.google.common.util.concurrent.AbstractFuture.TrustedFuture&lt;V&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.common.util.concurrent.SettableFuture&lt;V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@code SettableFuture} that can be completed or cancelled by a later method call.]]>
      </doc>
    </method>
    <method name="set" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="V extends java.lang.Object"/>
    </method>
    <method name="setException" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
    </method>
    <method name="setFuture" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="com.google.common.util.concurrent.ListenableFuture&lt;? extends V&gt;"/>
    </method>
    <doc>
    <![CDATA[A {@link ListenableFuture} whose result can be set by a {@link #set(Object)}, {@link
 #setException(Throwable)} or {@link #setFuture(ListenableFuture)} call. It can also, like any
 other {@code Future}, be {@linkplain #cancel cancelled}.

 <p>{@code SettableFuture} is the recommended {@code ListenableFuture} implementation when your
 task cannot be implemented with {@link ListeningExecutorService}, the various {@link Futures}
 utility methods, or {@link ListenableFutureTask}. Those APIs have less opportunity for developer
 error. If your needs are more complex than {@code SettableFuture} supports, use {@link
 AbstractFuture}, which offers an extensible version of the API.

 @author Sven Mawson
 @since 9.0 (in 1.0 as {@code ValueFuture})]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.SettableFuture -->
  <!-- start class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <class name="SimpleTimeLimiter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.TimeLimiter"/>
    <method name="create" return="com.google.common.util.concurrent.SimpleTimeLimiter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ExecutorService"/>
      <doc>
      <![CDATA[Creates a TimeLimiter instance using the given executor service to execute method calls.

 <p><b>Warning:</b> using a bounded executor may be counterproductive! If the thread pool fills
 up, any time callers spend waiting for a thread may count toward their time limit, and in this
 case the call may even time out before the target method is ever invoked.

 @param executor the ExecutorService that will execute the method calls on the target objects;
     for example, a {@link Executors#newCachedThreadPool()}.
 @since 22.0]]>
      </doc>
    </method>
    <method name="newProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="callWithTimeout" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="callUninterruptiblyWithTimeout" return="T extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="runWithTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="runUninterruptiblyWithTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[A TimeLimiter that runs method calls in the background using an {@link ExecutorService}. If the
 time limit expires for a given method call, the thread running the call will be interrupted.

 @author Kevin Bourrillion
 @author Jens Nyman
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.SimpleTimeLimiter -->
  <!-- start class com.google.common.util.concurrent.Striped -->
  <class name="Striped" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="L"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the stripe that corresponds to the passed key. It is always guaranteed that if {@code
 key1.equals(key2)}, then {@code get(key1) == get(key2)}.

 @param key an arbitrary, non-null key
 @return the stripe that the passed key corresponds to]]>
      </doc>
    </method>
    <method name="getAt" return="L"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the stripe at the specified index. Valid indexes are 0, inclusively, to {@code size()},
 exclusively.

 @param index the index of the stripe to return; must be in {@code [0...size())}
 @return the stripe at the specified index]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of stripes in this instance.]]>
      </doc>
    </method>
    <method name="bulkGet" return="java.lang.Iterable&lt;L&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable&lt;? extends java.lang.Object&gt;"/>
      <doc>
      <![CDATA[Returns the stripes that correspond to the passed objects, in ascending (as per {@link
 #getAt(int)}) order. Thus, threads that use the stripes in the order returned by this method
 are guaranteed to not deadlock each other.

 <p>It should be noted that using a {@code Striped<L>} with relatively few stripes, and {@code
 bulkGet(keys)} with a relative large number of keys can cause an excessive number of shared
 stripes (much like the birthday paradox, where much fewer than anticipated birthdays are needed
 for a pair of them to match). Please consider carefully the implications of the number of
 stripes, the intended concurrency level, and the typical number of keys used in a {@code
 bulkGet(keys)} operation. See <a href="http://www.mathpages.com/home/kmath199.htm">Balls in
 Bins model</a> for mathematical formulas that can be used to estimate the probability of
 collisions.

 @param keys arbitrary non-null keys
 @return the stripes corresponding to the objects (one per each object, derived by delegating to
     {@link #get(Object)}; may contain duplicates), in an increasing index order.]]>
      </doc>
    </method>
    <method name="custom" return="com.google.common.util.concurrent.Striped&lt;L&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <param name="supplier" type="com.google.common.base.Supplier&lt;L&gt;"/>
      <doc>
      <![CDATA[Creates a {@code Striped<L>} with eagerly initialized, strongly referenced locks. Every lock is
 obtained from the passed supplier.

 @param stripes the minimum number of stripes (locks) required
 @param supplier a {@code Supplier<L>} object to obtain locks from
 @return a new {@code Striped<L>}
 @since NEXT]]>
      </doc>
    </method>
    <method name="lock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.Lock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Lock>} with eagerly initialized, strongly referenced locks. Every lock
 is reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<Lock>}]]>
      </doc>
    </method>
    <method name="lazyWeakLock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.Lock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Lock>} with lazily initialized, weakly referenced locks. Every lock is
 reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<Lock>}]]>
      </doc>
    </method>
    <method name="semaphore" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.Semaphore&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <param name="permits" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Semaphore>} with eagerly initialized, strongly referenced semaphores,
 with the specified number of permits.

 @param stripes the minimum number of stripes (semaphores) required
 @param permits the number of permits in each semaphore
 @return a new {@code Striped<Semaphore>}]]>
      </doc>
    </method>
    <method name="lazyWeakSemaphore" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.Semaphore&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <param name="permits" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<Semaphore>} with lazily initialized, weakly referenced semaphores,
 with the specified number of permits.

 @param stripes the minimum number of stripes (semaphores) required
 @param permits the number of permits in each semaphore
 @return a new {@code Striped<Semaphore>}]]>
      </doc>
    </method>
    <method name="readWriteLock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.ReadWriteLock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<ReadWriteLock>} with eagerly initialized, strongly referenced
 read-write locks. Every lock is reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<ReadWriteLock>}]]>
      </doc>
    </method>
    <method name="lazyWeakReadWriteLock" return="com.google.common.util.concurrent.Striped&lt;java.util.concurrent.locks.ReadWriteLock&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stripes" type="int"/>
      <doc>
      <![CDATA[Creates a {@code Striped<ReadWriteLock>} with lazily initialized, weakly referenced read-write
 locks. Every lock is reentrant.

 @param stripes the minimum number of stripes (locks) required
 @return a new {@code Striped<ReadWriteLock>}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A striped {@code Lock/Semaphore/ReadWriteLock}. This offers the underlying lock striping similar
 to that of {@code ConcurrentHashMap} in a reusable form, and extends it for semaphores and
 read-write locks. Conceptually, lock striping is the technique of dividing a lock into many
 <i>stripes</i>, increasing the granularity of a single lock and allowing independent operations
 to lock different stripes and proceed concurrently, instead of creating contention for a single
 lock.

 <p>The guarantee provided by this class is that equal keys lead to the same lock (or semaphore),
 i.e. {@code if (key1.equals(key2))} then {@code striped.get(key1) == striped.get(key2)} (assuming
 {@link Object#hashCode()} is correctly implemented for the keys). Note that if {@code key1} is
 <strong>not</strong> equal to {@code key2}, it is <strong>not</strong> guaranteed that {@code
 striped.get(key1) != striped.get(key2)}; the elements might nevertheless be mapped to the same
 lock. The lower the number of stripes, the higher the probability of this happening.

 <p>There are three flavors of this class: {@code Striped<Lock>}, {@code Striped<Semaphore>}, and
 {@code Striped<ReadWriteLock>}. For each type, two implementations are offered: {@linkplain
 #lock(int) strong} and {@linkplain #lazyWeakLock(int) weak} {@code Striped<Lock>}, {@linkplain
 #semaphore(int, int) strong} and {@linkplain #lazyWeakSemaphore(int, int) weak} {@code
 Striped<Semaphore>}, and {@linkplain #readWriteLock(int) strong} and {@linkplain
 #lazyWeakReadWriteLock(int) weak} {@code Striped<ReadWriteLock>}. <i>Strong</i> means that all
 stripes (locks/semaphores) are initialized eagerly, and are not reclaimed unless {@code Striped}
 itself is reclaimable. <i>Weak</i> means that locks/semaphores are created lazily, and they are
 allowed to be reclaimed if nobody is holding on to them. This is useful, for example, if one
 wants to create a {@code Striped<Lock>} of many locks, but worries that in most cases only a
 small portion of these would be in use.

 <p>Prior to this class, one might be tempted to use {@code Map<K, Lock>}, where {@code K}
 represents the task. This maximizes concurrency by having each unique key mapped to a unique
 lock, but also maximizes memory footprint. On the other extreme, one could use a single lock for
 all tasks, which minimizes memory footprint but also minimizes concurrency. Instead of choosing
 either of these extremes, {@code Striped} allows the user to trade between required concurrency
 and memory footprint. For example, if a set of tasks are CPU-bound, one could easily create a
 very compact {@code Striped<Lock>} of {@code availableProcessors() * 4} stripes, instead of
 possibly thousands of locks which could be created in a {@code Map<K, Lock>} structure.

 @author Dimitris Andreou
 @since 13.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Striped -->
  <!-- start class com.google.common.util.concurrent.ThreadFactoryBuilder -->
  <class name="ThreadFactoryBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThreadFactoryBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new {@link ThreadFactory} builder.

 <p><b>Java 21+ users:</b> use {@link Thread#ofPlatform()} instead, translating other calls on
 the builder as documented on each method (except for the rarely used {@link #setThreadFactory},
 which does not have an equivalent).]]>
      </doc>
    </constructor>
    <method name="setNameFormat" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nameFormat" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the naming format to use when naming threads ({@link Thread#setName}) which are created
 with this ThreadFactory.

 <p><b>Java 21+ users:</b> use {@link Thread.Builder#name(String, long)} instead. Note that
 {@link #setNameFormat} accepts a thread name <i>format string</i> (e.g., {@code
 threadFactoryBuilder.setNameFormat("rpc-pool-%d")}), while {@code threadBuilder.name()} accepts
 a thread name <i>prefix</i> and initial counter value (e.g., {@code
 threadBuilder.name("rpc-pool-", 0)}.

 @param nameFormat a {@link String#format(String, Object...)}-compatible format String, to which
     a unique integer (0, 1, etc.) will be supplied as the single parameter. This integer will
     be unique to the built instance of the ThreadFactory and will be assigned sequentially. For
     example, {@code "rpc-pool-%d"} will generate thread names like {@code "rpc-pool-0"}, {@code
     "rpc-pool-1"}, {@code "rpc-pool-2"}, etc.
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setDaemon" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemon" type="boolean"/>
      <doc>
      <![CDATA[Sets daemon or not for new threads created with this ThreadFactory.

 <p><b>Java 21+ users:</b> use {@link Thread.Builder.OfPlatform#daemon(boolean)} instead.

 @param daemon whether or not new Threads created with this ThreadFactory will be daemon threads
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setPriority" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="int"/>
      <doc>
      <![CDATA[Sets the priority for new threads created with this ThreadFactory.

 <p><b>Warning:</b> relying on the thread scheduler is <a
 href="http://errorprone.info/bugpattern/ThreadPriorityCheck">discouraged</a>.

 <p><b>Java 21+ users:</b> use {@link Thread.Builder.OfPlatform#priority(int)} instead.

 @param priority the priority for new Threads created with this ThreadFactory
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setUncaughtExceptionHandler" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uncaughtExceptionHandler" type="java.lang.Thread.UncaughtExceptionHandler"/>
      <doc>
      <![CDATA[Sets the {@link UncaughtExceptionHandler} for new threads created with this ThreadFactory.

 <p><b>Java 21+ users:</b> use {@link
 Thread.Builder#uncaughtExceptionHandler(Thread.UncaughtExceptionHandler)} instead.

 @param uncaughtExceptionHandler the uncaught exception handler for new Threads created with
     this ThreadFactory
 @return this for the builder pattern]]>
      </doc>
    </method>
    <method name="setThreadFactory" return="com.google.common.util.concurrent.ThreadFactoryBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingThreadFactory" type="java.util.concurrent.ThreadFactory"/>
      <doc>
      <![CDATA[Sets the backing {@link ThreadFactory} for new threads created with this ThreadFactory. Threads
 will be created by invoking #newThread(Runnable) on this backing {@link ThreadFactory}.

 @param backingThreadFactory the backing {@link ThreadFactory} which will be delegated to during
     thread creation.
 @return this for the builder pattern
 @see MoreExecutors]]>
      </doc>
    </method>
    <method name="build" return="java.util.concurrent.ThreadFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new thread factory using the options supplied during the building process. After
 building, it is still possible to change the options used to build the ThreadFactory and/or
 build again. State is not shared amongst built instances.

 <p><b>Java 21+ users:</b> use {@link Thread.Builder#factory()} instead.

 @return the fully constructed {@link ThreadFactory}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A ThreadFactory builder, providing any combination of these features:

 <ul>
   <li>whether threads should be marked as {@linkplain Thread#setDaemon daemon} threads
   <li>a {@linkplain ThreadFactoryBuilder#setNameFormat naming format}
   <li>a {@linkplain Thread#setPriority thread priority}
   <li>an {@linkplain Thread#setUncaughtExceptionHandler uncaught exception handler}
   <li>a {@linkplain ThreadFactory#newThread backing thread factory}
 </ul>

 <p>If no backing thread factory is provided, a default backing thread factory is used as if by
 calling {@code setThreadFactory(}{@link Executors#defaultThreadFactory()}{@code )}.

 <p><b>Java 21+ users:</b> consider using the {@code Thread.Builder} interface instead. E.g.,
 instead of {@code new ThreadFactoryBuilder().setPriority(priority).setDaemon(false).build()}, use
 {@code Thread.ofPlatform().priority(priority).daemon(false).factory()}.

 @author Kurt Alfred Kluever
 @since 4.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.ThreadFactoryBuilder -->
  <!-- start interface com.google.common.util.concurrent.TimeLimiter -->
  <interface name="TimeLimiter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newProxy" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="T"/>
      <param name="interfaceType" type="java.lang.Class&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Returns an instance of {@code interfaceType} that delegates all method calls to the {@code
 target} object, enforcing the specified time limit on each call. This time-limited delegation
 is also performed for calls to {@link Object#equals}, {@link Object#hashCode}, and {@link
 Object#toString}.

 <p>If the target method call finishes before the limit is reached, the return value or
 exception is propagated to the caller exactly as-is. If, on the other hand, the time limit is
 reached, the proxy will attempt to abort the call to the target, and will throw an {@link
 UncheckedTimeoutException} to the caller.

 <p>It is important to note that the primary purpose of the proxy object is to return control to
 the caller when the timeout elapses; aborting the target method call is of secondary concern.
 The particular nature and strength of the guarantees made by the proxy is
 implementation-dependent. However, it is important that each of the methods on the target
 object behaves appropriately when its thread is interrupted.

 <p>For example, to return the value of {@code target.someMethod()}, but substitute {@code
 DEFAULT_VALUE} if this method call takes over 50 ms, you can use this code:

 <pre>
   TimeLimiter limiter = . . .;
   TargetType proxy = limiter.newProxy(
       target, TargetType.class, 50, TimeUnit.MILLISECONDS);
   try {
     return proxy.someMethod();
   } catch (UncheckedTimeoutException e) {
     return DEFAULT_VALUE;
   }
 </pre>

 @param target the object to proxy
 @param interfaceType the interface you wish the returned proxy to implement
 @param timeoutDuration with timeoutUnit, the maximum length of time that callers are willing to
     wait on each method call to the proxy
 @param timeoutUnit with timeoutDuration, the maximum length of time that callers are willing to
     wait on each method call to the proxy
 @return a time-limiting proxy
 @throws IllegalArgumentException if {@code interfaceType} is a regular class, enum, or
     annotation type, rather than an interface]]>
      </doc>
    </method>
    <method name="callWithTimeout" return="T extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Invokes a specified Callable, timing out after the specified time limit. If the target method
 call finishes before the limit is reached, the return value or a wrapped exception is
 propagated. If, on the other hand, the time limit is reached, we attempt to abort the call to
 the target, and throw a {@link TimeoutException} to the caller.

 @param callable the Callable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @return the result returned by the Callable
 @throws TimeoutException if the time limit is reached
 @throws InterruptedException if the current thread was interrupted during execution
 @throws ExecutionException if {@code callable} throws a checked exception
 @throws UncheckedExecutionException if {@code callable} throws a {@code RuntimeException}
 @throws ExecutionError if {@code callable} throws an {@code Error}
 @since 22.0]]>
      </doc>
    </method>
    <method name="callUninterruptiblyWithTimeout" return="T extends java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable&lt;T&gt;"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Invokes a specified Callable, timing out after the specified time limit. If the target method
 call finishes before the limit is reached, the return value or a wrapped exception is
 propagated. If, on the other hand, the time limit is reached, we attempt to abort the call to
 the target, and throw a {@link TimeoutException} to the caller.

 <p>The difference with {@link #callWithTimeout(Callable, long, TimeUnit)} is that this method
 will ignore interrupts on the current thread.

 @param callable the Callable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @return the result returned by the Callable
 @throws TimeoutException if the time limit is reached
 @throws ExecutionException if {@code callable} throws a checked exception
 @throws UncheckedExecutionException if {@code callable} throws a {@code RuntimeException}
 @throws ExecutionError if {@code callable} throws an {@code Error}
 @since 22.0]]>
      </doc>
    </method>
    <method name="runWithTimeout"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Invokes a specified Runnable, timing out after the specified time limit. If the target method
 run finishes before the limit is reached, this method returns or a wrapped exception is
 propagated. If, on the other hand, the time limit is reached, we attempt to abort the run, and
 throw a {@link TimeoutException} to the caller.

 @param runnable the Runnable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @throws TimeoutException if the time limit is reached
 @throws InterruptedException if the current thread was interrupted during execution
 @throws UncheckedExecutionException if {@code runnable} throws a {@code RuntimeException}
 @throws ExecutionError if {@code runnable} throws an {@code Error}
 @since 22.0]]>
      </doc>
    </method>
    <method name="runUninterruptiblyWithTimeout"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
      <param name="timeoutDuration" type="long"/>
      <param name="timeoutUnit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Invokes a specified Runnable, timing out after the specified time limit. If the target method
 run finishes before the limit is reached, this method returns or a wrapped exception is
 propagated. If, on the other hand, the time limit is reached, we attempt to abort the run, and
 throw a {@link TimeoutException} to the caller.

 <p>The difference with {@link #runWithTimeout(Runnable, long, TimeUnit)} is that this method
 will ignore interrupts on the current thread.

 @param runnable the Runnable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @throws TimeoutException if the time limit is reached
 @throws UncheckedExecutionException if {@code runnable} throws a {@code RuntimeException}
 @throws ExecutionError if {@code runnable} throws an {@code Error}
 @since 22.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Imposes a time limit on method calls.

 @author Kevin Bourrillion
 @author Jens Nyman
 @since 1.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.common.util.concurrent.TimeLimiter -->
  <!-- start class com.google.common.util.concurrent.UncaughtExceptionHandlers -->
  <class name="UncaughtExceptionHandlers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="systemExit" return="java.lang.Thread.UncaughtExceptionHandler"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an exception handler that exits the system. This is particularly useful for the main
 thread, which may start up other, non-daemon threads, but fail to fully initialize the
 application successfully.

 <p>Example usage:

 <pre>
 public static void main(String[] args) {
   Thread.currentThread().setUncaughtExceptionHandler(UncaughtExceptionHandlers.systemExit());
   ...
 </pre>

 <p>The returned handler logs any exception at severity {@code SEVERE} and then shuts down the
 process with an exit status of 1, indicating abnormal termination.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories for {@link UncaughtExceptionHandler} instances.

 @author Gregory Kick
 @since 8.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncaughtExceptionHandlers -->
  <!-- start class com.google.common.util.concurrent.UncheckedExecutionException -->
  <class name="UncheckedExecutionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedExecutionException"
      static="false" final="false" visibility="protected"
      deprecated="Prefer {@linkplain UncheckedExecutionException(Throwable)} a constructor that
     accepts a cause: Users of this class typically expect for instances to have a non-null
     cause. At the moment, you can lEsS_tHaNi>usuallylEsS_tHaN/i> still preserve behavior by passing an explicit
     {@code null} cause. Note, however, that passing an explicit {@code null} cause prevents
     anyone from calling {@link #initCause} later, so it is not quite equivalent to using a
     constructor that omits the cause.">
      <doc>
      <![CDATA[Creates a new instance with {@code null} as its detail message and no cause.

 @deprecated Prefer {@linkplain UncheckedExecutionException(Throwable)} a constructor that
     accepts a cause: Users of this class typically expect for instances to have a non-null
     cause. At the moment, you can <i>usually</i> still preserve behavior by passing an explicit
     {@code null} cause. Note, however, that passing an explicit {@code null} cause prevents
     anyone from calling {@link #initCause} later, so it is not quite equivalent to using a
     constructor that omits the cause.]]>
      </doc>
    </constructor>
    <constructor name="UncheckedExecutionException" type="String"
      static="false" final="false" visibility="protected"
      deprecated="Prefer {@linkplain UncheckedExecutionException(String, Throwable)} a constructor
     that accepts a cause: Users of this class typically expect for instances to have a non-null
     cause. At the moment, you can lEsS_tHaNi>usuallylEsS_tHaN/i> still preserve behavior by passing an explicit
     {@code null} cause. Note, however, that passing an explicit {@code null} cause prevents
     anyone from calling {@link #initCause} later, so it is not quite equivalent to using a
     constructor that omits the cause.">
      <doc>
      <![CDATA[Creates a new instance with the given detail message and no cause.

 @deprecated Prefer {@linkplain UncheckedExecutionException(String, Throwable)} a constructor
     that accepts a cause: Users of this class typically expect for instances to have a non-null
     cause. At the moment, you can <i>usually</i> still preserve behavior by passing an explicit
     {@code null} cause. Note, however, that passing an explicit {@code null} cause prevents
     anyone from calling {@link #initCause} later, so it is not quite equivalent to using a
     constructor that omits the cause.]]>
      </doc>
    </constructor>
    <constructor name="UncheckedExecutionException" type="String, Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with the given detail message and cause. Prefer to provide a
 non-nullable {@code cause}, as many users expect to find one.]]>
      </doc>
    </constructor>
    <constructor name="UncheckedExecutionException" type="Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance with {@code null} as its detail message and the given cause. Prefer to
 provide a non-nullable {@code cause}, as many users expect to find one.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Unchecked variant of {@link java.util.concurrent.ExecutionException}. As with {@code
 ExecutionException}, the exception's {@linkplain #getCause() cause} comes from a failed task,
 possibly run in another thread.

 <p>{@code UncheckedExecutionException} is intended as an alternative to {@code
 ExecutionException} when the exception thrown by a task is an unchecked exception. However, it
 may also wrap a checked exception in some cases.

 <p>When wrapping an {@code Error} from another thread, prefer {@link ExecutionError}. When
 wrapping a checked exception, prefer {@code ExecutionException}.

 @author Charles Fry
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncheckedExecutionException -->
  <!-- start class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <class name="UncheckedTimeoutException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedTimeoutException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedTimeoutException" type="String, Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Unchecked version of {@link java.util.concurrent.TimeoutException}.

 @author Kevin Bourrillion
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.UncheckedTimeoutException -->
  <!-- start class com.google.common.util.concurrent.Uninterruptibles -->
  <class name="Uninterruptibles" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="awaitUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="latch" type="java.util.concurrent.CountDownLatch"/>
      <doc>
      <![CDATA[Invokes {@code latch.}{@link CountDownLatch#await() await()} uninterruptibly.]]>
      </doc>
    </method>
    <method name="awaitUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="latch" type="java.util.concurrent.CountDownLatch"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code latch.}{@link CountDownLatch#await(long, TimeUnit) await(timeout, unit)}
 uninterruptibly.

 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="awaitUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="latch" type="java.util.concurrent.CountDownLatch"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code latch.}{@link CountDownLatch#await(long, TimeUnit) await(timeout, unit)}
 uninterruptibly.]]>
      </doc>
    </method>
    <method name="awaitUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="condition" type="java.util.concurrent.locks.Condition"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}
 uninterruptibly.

 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="awaitUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="condition" type="java.util.concurrent.locks.Condition"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}
 uninterruptibly.

 @since 23.6]]>
      </doc>
    </method>
    <method name="joinUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toJoin" type="java.lang.Thread"/>
      <doc>
      <![CDATA[Invokes {@code toJoin.}{@link Thread#join() join()} uninterruptibly.]]>
      </doc>
    </method>
    <method name="joinUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toJoin" type="java.lang.Thread"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code unit.}{@link TimeUnit#timedJoin(Thread, long) timedJoin(toJoin, timeout)}
 uninterruptibly.

 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="joinUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toJoin" type="java.lang.Thread"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code unit.}{@link TimeUnit#timedJoin(Thread, long) timedJoin(toJoin, timeout)}
 uninterruptibly.]]>
      </doc>
    </method>
    <method name="getUninterruptibly" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Invokes {@code future.}{@link Future#get() get()} uninterruptibly.

 <p>Similar methods:

 <ul>
   <li>To retrieve a result from a {@code Future} that is already done, use {@link
       Futures#getDone Futures.getDone}.
   <li>To treat {@link InterruptedException} uniformly with other exceptions, use {@link
       Futures#getChecked(Future, Class) Futures.getChecked}.
   <li>To get uninterruptibility and remove checked exceptions, use {@link
       Futures#getUnchecked}.
 </ul>

 @throws ExecutionException if the computation threw an exception
 @throws CancellationException if the computation was cancelled]]>
      </doc>
    </method>
    <method name="getUninterruptibly" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="timeout" type="java.time.Duration"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Invokes {@code future.}{@link Future#get(long, TimeUnit) get(timeout, unit)} uninterruptibly.

 <p>Similar methods:

 <ul>
   <li>To retrieve a result from a {@code Future} that is already done, use {@link
       Futures#getDone Futures.getDone}.
   <li>To treat {@link InterruptedException} uniformly with other exceptions, use {@link
       Futures#getChecked(Future, Class, long, TimeUnit) Futures.getChecked}.
   <li>To get uninterruptibility and remove checked exceptions, use {@link
       Futures#getUnchecked}.
 </ul>

 @throws ExecutionException if the computation threw an exception
 @throws CancellationException if the computation was cancelled
 @throws TimeoutException if the wait timed out
 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="getUninterruptibly" return="V extends java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future&lt;V&gt;"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Invokes {@code future.}{@link Future#get(long, TimeUnit) get(timeout, unit)} uninterruptibly.

 <p>Similar methods:

 <ul>
   <li>To retrieve a result from a {@code Future} that is already done, use {@link
       Futures#getDone Futures.getDone}.
   <li>To treat {@link InterruptedException} uniformly with other exceptions, use {@link
       Futures#getChecked(Future, Class, long, TimeUnit) Futures.getChecked}.
   <li>To get uninterruptibility and remove checked exceptions, use {@link
       Futures#getUnchecked}.
 </ul>

 @throws ExecutionException if the computation threw an exception
 @throws CancellationException if the computation was cancelled
 @throws TimeoutException if the wait timed out]]>
      </doc>
    </method>
    <method name="takeUninterruptibly" return="E"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queue" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <doc>
      <![CDATA[Invokes {@code queue.}{@link BlockingQueue#take() take()} uninterruptibly.]]>
      </doc>
    </method>
    <method name="putUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queue" type="java.util.concurrent.BlockingQueue&lt;E&gt;"/>
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Invokes {@code queue.}{@link BlockingQueue#put(Object) put(element)} uninterruptibly.

 @throws ClassCastException if the class of the specified element prevents it from being added
     to the given queue
 @throws IllegalArgumentException if some property of the specified element prevents it from
     being added to the given queue]]>
      </doc>
    </method>
    <method name="sleepUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sleepFor" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)} uninterruptibly.

 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="sleepUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sleepFor" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)} uninterruptibly.]]>
      </doc>
    </method>
    <method name="tryAcquireUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="semaphore" type="java.util.concurrent.Semaphore"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code semaphore.}{@link Semaphore#tryAcquire(int, long, TimeUnit) tryAcquire(1,
 timeout, unit)} uninterruptibly.

 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="tryAcquireUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="semaphore" type="java.util.concurrent.Semaphore"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code semaphore.}{@link Semaphore#tryAcquire(int, long, TimeUnit) tryAcquire(1,
 timeout, unit)} uninterruptibly.

 @since 18.0]]>
      </doc>
    </method>
    <method name="tryAcquireUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="semaphore" type="java.util.concurrent.Semaphore"/>
      <param name="permits" type="int"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code semaphore.}{@link Semaphore#tryAcquire(int, long, TimeUnit) tryAcquire(permits,
 timeout, unit)} uninterruptibly.

 @since 33.4.0 (but since 28.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="tryAcquireUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="semaphore" type="java.util.concurrent.Semaphore"/>
      <param name="permits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code semaphore.}{@link Semaphore#tryAcquire(int, long, TimeUnit) tryAcquire(permits,
 timeout, unit)} uninterruptibly.

 @since 18.0]]>
      </doc>
    </method>
    <method name="tryLockUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lock" type="java.util.concurrent.locks.Lock"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code lock.}{@link Lock#tryLock(long, TimeUnit) tryLock(timeout, unit)}
 uninterruptibly.

 @since 33.4.0 (but since 30.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="tryLockUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lock" type="java.util.concurrent.locks.Lock"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code lock.}{@link Lock#tryLock(long, TimeUnit) tryLock(timeout, unit)}
 uninterruptibly.

 @since 30.0]]>
      </doc>
    </method>
    <method name="awaitTerminationUninterruptibly"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ExecutorService"/>
      <doc>
      <![CDATA[Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
 awaitTermination(long, TimeUnit)} uninterruptibly with no timeout.

 @since 30.0]]>
      </doc>
    </method>
    <method name="awaitTerminationUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ExecutorService"/>
      <param name="timeout" type="java.time.Duration"/>
      <doc>
      <![CDATA[Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
 awaitTermination(long, TimeUnit)} uninterruptibly.

 @since 33.4.0 (but since 30.0 in the JRE flavor)]]>
      </doc>
    </method>
    <method name="awaitTerminationUninterruptibly" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executor" type="java.util.concurrent.ExecutorService"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
 awaitTermination(long, TimeUnit)} uninterruptibly.

 @since 30.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for treating interruptible operations as uninterruptible. In all cases, if a thread is
 interrupted during such a call, the call continues to block until the result is available or the
 timeout elapses, and only then re-interrupts the thread.

 @author Anthony Zana
 @since 10.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.util.concurrent.Uninterruptibles -->
</package>
<package name="com.google.common.xml">
  <!-- start class com.google.common.xml.XmlEscapers -->
  <class name="XmlEscapers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="xmlContentEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Escaper} instance that escapes special characters in a string so it can
 safely be included in an XML document as element content. See section <a
 href="http://www.w3.org/TR/2008/REC-xml-20081126/#syntax">2.4</a> of the XML specification.

 <p><b>Note:</b> Double and single quotes are not escaped, so it is <b>not safe</b> to use this
 escaper to escape attribute values. Use {@link #xmlContentEscaper} if the output can appear in
 element content or {@link #xmlAttributeEscaper} in attribute values.

 <p>This escaper substitutes {@code 0xFFFD} for non-whitespace control characters and the
 character values {@code 0xFFFE} and {@code 0xFFFF} which are not permitted in XML. For more
 detail see section <a href="http://www.w3.org/TR/2008/REC-xml-20081126/#charsets">2.2</a> of
 the XML specification.

 <p>This escaper does not escape non-ASCII characters to their numeric character references
 (NCR). Any non-ASCII characters appearing in the input will be preserved in the output.
 Specifically "\r" (carriage return) is preserved in the output, which may result in it being
 silently converted to "\n" when the XML is parsed.

 <p>This escaper does not treat surrogate pairs specially and does not perform Unicode
 validation on its input.]]>
      </doc>
    </method>
    <method name="xmlAttributeEscaper" return="com.google.common.escape.Escaper"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@link Escaper} instance that escapes special characters in a string so it can
 safely be included in XML document as an attribute value. See section <a
 href="http://www.w3.org/TR/2008/REC-xml-20081126/#AVNormalize">3.3.3</a> of the XML
 specification.

 <p>This escaper substitutes {@code 0xFFFD} for non-whitespace control characters and the
 character values {@code 0xFFFE} and {@code 0xFFFF} which are not permitted in XML. For more
 detail see section <a href="http://www.w3.org/TR/2008/REC-xml-20081126/#charsets">2.2</a> of
 the XML specification.

 <p>This escaper does not escape non-ASCII characters to their numeric character references
 (NCR). However, horizontal tab {@code '\t'}, line feed {@code '\n'} and carriage return {@code
 '\r'} are escaped to a corresponding NCR {@code "&#x9;"}, {@code "&#xA;"}, and {@code "&#xD;"}
 respectively. Any other non-ASCII characters appearing in the input will be preserved in the
 output.

 <p>This escaper does not treat surrogate pairs specially and does not perform Unicode
 validation on its input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[{@code Escaper} instances suitable for strings to be included in XML attribute values and
 elements' text contents. When possible, avoid manual escaping by using templating systems and
 high-level APIs that provide autoescaping. For example, consider <a
 href="http://www.xom.nu/">XOM</a>.

 <p><b>Note:</b> Currently the escapers provided by this class do not escape any characters
 outside the ASCII character range. Unlike HTML escaping the XML escapers will not escape
 non-ASCII characters to their numeric entity replacements. These XML escapers provide the minimal
 level of escaping to ensure that the output can be safely included in a Unicode XML document.

 <p>For details on the behavior of the escapers in this class, see sections <a
 href="http://www.w3.org/TR/2008/REC-xml-20081126/#charsets">2.2</a> and <a
 href="http://www.w3.org/TR/2008/REC-xml-20081126/#syntax">2.4</a> of the XML specification.

 @author Alex Matevossian
 @author David Beaumont
 @since 15.0]]>
    </doc>
  </class>
  <!-- end class com.google.common.xml.XmlEscapers -->
</package>

</api>
