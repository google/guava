<!DOCTYPE HTML>
<html lang>
<head>
<!-- Generated by javadoc (23) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: com.google.common.base, class: Strings">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../resource-files/stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> * Copyright (C) 2010 The Guava Authors</span>
<span class="source-line-no">003</span><span id="line-3"> *</span>
<span class="source-line-no">004</span><span id="line-4"> * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except</span>
<span class="source-line-no">005</span><span id="line-5"> * in compliance with the License. You may obtain a copy of the License at</span>
<span class="source-line-no">006</span><span id="line-6"> *</span>
<span class="source-line-no">007</span><span id="line-7"> * http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">008</span><span id="line-8"> *</span>
<span class="source-line-no">009</span><span id="line-9"> * Unless required by applicable law or agreed to in writing, software distributed under the License</span>
<span class="source-line-no">010</span><span id="line-10"> * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express</span>
<span class="source-line-no">011</span><span id="line-11"> * or implied. See the License for the specific language governing permissions and limitations under</span>
<span class="source-line-no">012</span><span id="line-12"> * the License.</span>
<span class="source-line-no">013</span><span id="line-13"> */</span>
<span class="source-line-no">014</span><span id="line-14"></span>
<span class="source-line-no">015</span><span id="line-15">package com.google.common.base;</span>
<span class="source-line-no">016</span><span id="line-16"></span>
<span class="source-line-no">017</span><span id="line-17">import static com.google.common.base.Preconditions.checkArgument;</span>
<span class="source-line-no">018</span><span id="line-18">import static com.google.common.base.Preconditions.checkNotNull;</span>
<span class="source-line-no">019</span><span id="line-19">import static java.lang.Math.min;</span>
<span class="source-line-no">020</span><span id="line-20">import static java.util.logging.Level.WARNING;</span>
<span class="source-line-no">021</span><span id="line-21"></span>
<span class="source-line-no">022</span><span id="line-22">import com.google.common.annotations.GwtCompatible;</span>
<span class="source-line-no">023</span><span id="line-23">import com.google.common.annotations.VisibleForTesting;</span>
<span class="source-line-no">024</span><span id="line-24">import java.util.logging.Logger;</span>
<span class="source-line-no">025</span><span id="line-25">import org.jspecify.annotations.Nullable;</span>
<span class="source-line-no">026</span><span id="line-26"></span>
<span class="source-line-no">027</span><span id="line-27">/**</span>
<span class="source-line-no">028</span><span id="line-28"> * Static utility methods pertaining to {@code String} or {@code CharSequence} instances.</span>
<span class="source-line-no">029</span><span id="line-29"> *</span>
<span class="source-line-no">030</span><span id="line-30"> * @author Kevin Bourrillion</span>
<span class="source-line-no">031</span><span id="line-31"> * @since 3.0</span>
<span class="source-line-no">032</span><span id="line-32"> */</span>
<span class="source-line-no">033</span><span id="line-33">@GwtCompatible</span>
<span class="source-line-no">034</span><span id="line-34">public final class Strings {</span>
<span class="source-line-no">035</span><span id="line-35">  private Strings() {}</span>
<span class="source-line-no">036</span><span id="line-36"></span>
<span class="source-line-no">037</span><span id="line-37">  /**</span>
<span class="source-line-no">038</span><span id="line-38">   * Returns the given string if it is non-null; the empty string otherwise.</span>
<span class="source-line-no">039</span><span id="line-39">   *</span>
<span class="source-line-no">040</span><span id="line-40">   * @param string the string to test and possibly return</span>
<span class="source-line-no">041</span><span id="line-41">   * @return {@code string} itself if it is non-null; {@code ""} if it is null</span>
<span class="source-line-no">042</span><span id="line-42">   */</span>
<span class="source-line-no">043</span><span id="line-43">  public static String nullToEmpty(@Nullable String string) {</span>
<span class="source-line-no">044</span><span id="line-44">    return Platform.nullToEmpty(string);</span>
<span class="source-line-no">045</span><span id="line-45">  }</span>
<span class="source-line-no">046</span><span id="line-46"></span>
<span class="source-line-no">047</span><span id="line-47">  /**</span>
<span class="source-line-no">048</span><span id="line-48">   * Returns the given string if it is nonempty; {@code null} otherwise.</span>
<span class="source-line-no">049</span><span id="line-49">   *</span>
<span class="source-line-no">050</span><span id="line-50">   * @param string the string to test and possibly return</span>
<span class="source-line-no">051</span><span id="line-51">   * @return {@code string} itself if it is nonempty; {@code null} if it is empty or null</span>
<span class="source-line-no">052</span><span id="line-52">   */</span>
<span class="source-line-no">053</span><span id="line-53">  public static @Nullable String emptyToNull(@Nullable String string) {</span>
<span class="source-line-no">054</span><span id="line-54">    return Platform.emptyToNull(string);</span>
<span class="source-line-no">055</span><span id="line-55">  }</span>
<span class="source-line-no">056</span><span id="line-56"></span>
<span class="source-line-no">057</span><span id="line-57">  /**</span>
<span class="source-line-no">058</span><span id="line-58">   * Returns {@code true} if the given string is null or is the empty string.</span>
<span class="source-line-no">059</span><span id="line-59">   *</span>
<span class="source-line-no">060</span><span id="line-60">   * &lt;p&gt;Consider normalizing your string references with {@link #nullToEmpty}. If you do, you can</span>
<span class="source-line-no">061</span><span id="line-61">   * use {@link String#isEmpty()} instead of this method, and you won't need special null-safe forms</span>
<span class="source-line-no">062</span><span id="line-62">   * of methods like {@link String#toUpperCase} either. Or, if you'd like to normalize "in the other</span>
<span class="source-line-no">063</span><span id="line-63">   * direction," converting empty strings to {@code null}, you can use {@link #emptyToNull}.</span>
<span class="source-line-no">064</span><span id="line-64">   *</span>
<span class="source-line-no">065</span><span id="line-65">   * @param string a string reference to check</span>
<span class="source-line-no">066</span><span id="line-66">   * @return {@code true} if the string is null or is the empty string</span>
<span class="source-line-no">067</span><span id="line-67">   */</span>
<span class="source-line-no">068</span><span id="line-68">  public static boolean isNullOrEmpty(@Nullable String string) {</span>
<span class="source-line-no">069</span><span id="line-69">    return Platform.stringIsNullOrEmpty(string);</span>
<span class="source-line-no">070</span><span id="line-70">  }</span>
<span class="source-line-no">071</span><span id="line-71"></span>
<span class="source-line-no">072</span><span id="line-72">  /**</span>
<span class="source-line-no">073</span><span id="line-73">   * Returns a string, of length at least {@code minLength}, consisting of {@code string} prepended</span>
<span class="source-line-no">074</span><span id="line-74">   * with as many copies of {@code padChar} as are necessary to reach that length. For example,</span>
<span class="source-line-no">075</span><span id="line-75">   *</span>
<span class="source-line-no">076</span><span id="line-76">   * &lt;ul&gt;</span>
<span class="source-line-no">077</span><span id="line-77">   *   &lt;li&gt;{@code padStart("7", 3, '0')} returns {@code "007"}</span>
<span class="source-line-no">078</span><span id="line-78">   *   &lt;li&gt;{@code padStart("2010", 3, '0')} returns {@code "2010"}</span>
<span class="source-line-no">079</span><span id="line-79">   * &lt;/ul&gt;</span>
<span class="source-line-no">080</span><span id="line-80">   *</span>
<span class="source-line-no">081</span><span id="line-81">   * &lt;p&gt;See {@link java.util.Formatter} for a richer set of formatting capabilities.</span>
<span class="source-line-no">082</span><span id="line-82">   *</span>
<span class="source-line-no">083</span><span id="line-83">   * @param string the string which should appear at the end of the result</span>
<span class="source-line-no">084</span><span id="line-84">   * @param minLength the minimum length the resulting string must have. Can be zero or negative, in</span>
<span class="source-line-no">085</span><span id="line-85">   *     which case the input string is always returned.</span>
<span class="source-line-no">086</span><span id="line-86">   * @param padChar the character to insert at the beginning of the result until the minimum length</span>
<span class="source-line-no">087</span><span id="line-87">   *     is reached</span>
<span class="source-line-no">088</span><span id="line-88">   * @return the padded string</span>
<span class="source-line-no">089</span><span id="line-89">   */</span>
<span class="source-line-no">090</span><span id="line-90">  public static String padStart(String string, int minLength, char padChar) {</span>
<span class="source-line-no">091</span><span id="line-91">    checkNotNull(string); // eager for GWT.</span>
<span class="source-line-no">092</span><span id="line-92">    if (string.length() &gt;= minLength) {</span>
<span class="source-line-no">093</span><span id="line-93">      return string;</span>
<span class="source-line-no">094</span><span id="line-94">    }</span>
<span class="source-line-no">095</span><span id="line-95">    StringBuilder sb = new StringBuilder(minLength);</span>
<span class="source-line-no">096</span><span id="line-96">    for (int i = string.length(); i &lt; minLength; i++) {</span>
<span class="source-line-no">097</span><span id="line-97">      sb.append(padChar);</span>
<span class="source-line-no">098</span><span id="line-98">    }</span>
<span class="source-line-no">099</span><span id="line-99">    sb.append(string);</span>
<span class="source-line-no">100</span><span id="line-100">    return sb.toString();</span>
<span class="source-line-no">101</span><span id="line-101">  }</span>
<span class="source-line-no">102</span><span id="line-102"></span>
<span class="source-line-no">103</span><span id="line-103">  /**</span>
<span class="source-line-no">104</span><span id="line-104">   * Returns a string, of length at least {@code minLength}, consisting of {@code string} appended</span>
<span class="source-line-no">105</span><span id="line-105">   * with as many copies of {@code padChar} as are necessary to reach that length. For example,</span>
<span class="source-line-no">106</span><span id="line-106">   *</span>
<span class="source-line-no">107</span><span id="line-107">   * &lt;ul&gt;</span>
<span class="source-line-no">108</span><span id="line-108">   *   &lt;li&gt;{@code padEnd("4.", 5, '0')} returns {@code "4.000"}</span>
<span class="source-line-no">109</span><span id="line-109">   *   &lt;li&gt;{@code padEnd("2010", 3, '!')} returns {@code "2010"}</span>
<span class="source-line-no">110</span><span id="line-110">   * &lt;/ul&gt;</span>
<span class="source-line-no">111</span><span id="line-111">   *</span>
<span class="source-line-no">112</span><span id="line-112">   * &lt;p&gt;See {@link java.util.Formatter} for a richer set of formatting capabilities.</span>
<span class="source-line-no">113</span><span id="line-113">   *</span>
<span class="source-line-no">114</span><span id="line-114">   * @param string the string which should appear at the beginning of the result</span>
<span class="source-line-no">115</span><span id="line-115">   * @param minLength the minimum length the resulting string must have. Can be zero or negative, in</span>
<span class="source-line-no">116</span><span id="line-116">   *     which case the input string is always returned.</span>
<span class="source-line-no">117</span><span id="line-117">   * @param padChar the character to append to the end of the result until the minimum length is</span>
<span class="source-line-no">118</span><span id="line-118">   *     reached</span>
<span class="source-line-no">119</span><span id="line-119">   * @return the padded string</span>
<span class="source-line-no">120</span><span id="line-120">   */</span>
<span class="source-line-no">121</span><span id="line-121">  public static String padEnd(String string, int minLength, char padChar) {</span>
<span class="source-line-no">122</span><span id="line-122">    checkNotNull(string); // eager for GWT.</span>
<span class="source-line-no">123</span><span id="line-123">    if (string.length() &gt;= minLength) {</span>
<span class="source-line-no">124</span><span id="line-124">      return string;</span>
<span class="source-line-no">125</span><span id="line-125">    }</span>
<span class="source-line-no">126</span><span id="line-126">    StringBuilder sb = new StringBuilder(minLength);</span>
<span class="source-line-no">127</span><span id="line-127">    sb.append(string);</span>
<span class="source-line-no">128</span><span id="line-128">    for (int i = string.length(); i &lt; minLength; i++) {</span>
<span class="source-line-no">129</span><span id="line-129">      sb.append(padChar);</span>
<span class="source-line-no">130</span><span id="line-130">    }</span>
<span class="source-line-no">131</span><span id="line-131">    return sb.toString();</span>
<span class="source-line-no">132</span><span id="line-132">  }</span>
<span class="source-line-no">133</span><span id="line-133"></span>
<span class="source-line-no">134</span><span id="line-134">  /**</span>
<span class="source-line-no">135</span><span id="line-135">   * Returns a string consisting of a specific number of concatenated copies of an input string. For</span>
<span class="source-line-no">136</span><span id="line-136">   * example, {@code repeat("hey", 3)} returns the string {@code "heyheyhey"}.</span>
<span class="source-line-no">137</span><span id="line-137">   *</span>
<span class="source-line-no">138</span><span id="line-138">   * @param string any non-null string</span>
<span class="source-line-no">139</span><span id="line-139">   * @param count the number of times to repeat it; a nonnegative integer</span>
<span class="source-line-no">140</span><span id="line-140">   * @return a string containing {@code string} repeated {@code count} times (the empty string if</span>
<span class="source-line-no">141</span><span id="line-141">   *     {@code count} is zero)</span>
<span class="source-line-no">142</span><span id="line-142">   * @throws IllegalArgumentException if {@code count} is negative</span>
<span class="source-line-no">143</span><span id="line-143">   */</span>
<span class="source-line-no">144</span><span id="line-144">  public static String repeat(String string, int count) {</span>
<span class="source-line-no">145</span><span id="line-145">    checkNotNull(string); // eager for GWT.</span>
<span class="source-line-no">146</span><span id="line-146"></span>
<span class="source-line-no">147</span><span id="line-147">    if (count &lt;= 1) {</span>
<span class="source-line-no">148</span><span id="line-148">      checkArgument(count &gt;= 0, "invalid count: %s", count);</span>
<span class="source-line-no">149</span><span id="line-149">      return (count == 0) ? "" : string;</span>
<span class="source-line-no">150</span><span id="line-150">    }</span>
<span class="source-line-no">151</span><span id="line-151"></span>
<span class="source-line-no">152</span><span id="line-152">    // IF YOU MODIFY THE CODE HERE, you must update StringsRepeatBenchmark</span>
<span class="source-line-no">153</span><span id="line-153">    final int len = string.length();</span>
<span class="source-line-no">154</span><span id="line-154">    final long longSize = (long) len * (long) count;</span>
<span class="source-line-no">155</span><span id="line-155">    final int size = (int) longSize;</span>
<span class="source-line-no">156</span><span id="line-156">    if (size != longSize) {</span>
<span class="source-line-no">157</span><span id="line-157">      throw new ArrayIndexOutOfBoundsException("Required array size too large: " + longSize);</span>
<span class="source-line-no">158</span><span id="line-158">    }</span>
<span class="source-line-no">159</span><span id="line-159"></span>
<span class="source-line-no">160</span><span id="line-160">    final char[] array = new char[size];</span>
<span class="source-line-no">161</span><span id="line-161">    string.getChars(0, len, array, 0);</span>
<span class="source-line-no">162</span><span id="line-162">    int n;</span>
<span class="source-line-no">163</span><span id="line-163">    for (n = len; n &lt; size - n; n &lt;&lt;= 1) {</span>
<span class="source-line-no">164</span><span id="line-164">      System.arraycopy(array, 0, array, n, n);</span>
<span class="source-line-no">165</span><span id="line-165">    }</span>
<span class="source-line-no">166</span><span id="line-166">    System.arraycopy(array, 0, array, n, size - n);</span>
<span class="source-line-no">167</span><span id="line-167">    return new String(array);</span>
<span class="source-line-no">168</span><span id="line-168">  }</span>
<span class="source-line-no">169</span><span id="line-169"></span>
<span class="source-line-no">170</span><span id="line-170">  /**</span>
<span class="source-line-no">171</span><span id="line-171">   * Returns the longest string {@code prefix} such that {@code a.toString().startsWith(prefix) &amp;&amp;</span>
<span class="source-line-no">172</span><span id="line-172">   * b.toString().startsWith(prefix)}, taking care not to split surrogate pairs. If {@code a} and</span>
<span class="source-line-no">173</span><span id="line-173">   * {@code b} have no common prefix, returns the empty string.</span>
<span class="source-line-no">174</span><span id="line-174">   *</span>
<span class="source-line-no">175</span><span id="line-175">   * @since 11.0</span>
<span class="source-line-no">176</span><span id="line-176">   */</span>
<span class="source-line-no">177</span><span id="line-177">  public static String commonPrefix(CharSequence a, CharSequence b) {</span>
<span class="source-line-no">178</span><span id="line-178">    checkNotNull(a);</span>
<span class="source-line-no">179</span><span id="line-179">    checkNotNull(b);</span>
<span class="source-line-no">180</span><span id="line-180"></span>
<span class="source-line-no">181</span><span id="line-181">    int maxPrefixLength = min(a.length(), b.length());</span>
<span class="source-line-no">182</span><span id="line-182">    int p = 0;</span>
<span class="source-line-no">183</span><span id="line-183">    while (p &lt; maxPrefixLength &amp;&amp; a.charAt(p) == b.charAt(p)) {</span>
<span class="source-line-no">184</span><span id="line-184">      p++;</span>
<span class="source-line-no">185</span><span id="line-185">    }</span>
<span class="source-line-no">186</span><span id="line-186">    if (validSurrogatePairAt(a, p - 1) || validSurrogatePairAt(b, p - 1)) {</span>
<span class="source-line-no">187</span><span id="line-187">      p--;</span>
<span class="source-line-no">188</span><span id="line-188">    }</span>
<span class="source-line-no">189</span><span id="line-189">    return a.subSequence(0, p).toString();</span>
<span class="source-line-no">190</span><span id="line-190">  }</span>
<span class="source-line-no">191</span><span id="line-191"></span>
<span class="source-line-no">192</span><span id="line-192">  /**</span>
<span class="source-line-no">193</span><span id="line-193">   * Returns the longest string {@code suffix} such that {@code a.toString().endsWith(suffix) &amp;&amp;</span>
<span class="source-line-no">194</span><span id="line-194">   * b.toString().endsWith(suffix)}, taking care not to split surrogate pairs. If {@code a} and</span>
<span class="source-line-no">195</span><span id="line-195">   * {@code b} have no common suffix, returns the empty string.</span>
<span class="source-line-no">196</span><span id="line-196">   *</span>
<span class="source-line-no">197</span><span id="line-197">   * @since 11.0</span>
<span class="source-line-no">198</span><span id="line-198">   */</span>
<span class="source-line-no">199</span><span id="line-199">  public static String commonSuffix(CharSequence a, CharSequence b) {</span>
<span class="source-line-no">200</span><span id="line-200">    checkNotNull(a);</span>
<span class="source-line-no">201</span><span id="line-201">    checkNotNull(b);</span>
<span class="source-line-no">202</span><span id="line-202"></span>
<span class="source-line-no">203</span><span id="line-203">    int maxSuffixLength = min(a.length(), b.length());</span>
<span class="source-line-no">204</span><span id="line-204">    int s = 0;</span>
<span class="source-line-no">205</span><span id="line-205">    while (s &lt; maxSuffixLength &amp;&amp; a.charAt(a.length() - s - 1) == b.charAt(b.length() - s - 1)) {</span>
<span class="source-line-no">206</span><span id="line-206">      s++;</span>
<span class="source-line-no">207</span><span id="line-207">    }</span>
<span class="source-line-no">208</span><span id="line-208">    if (validSurrogatePairAt(a, a.length() - s - 1)</span>
<span class="source-line-no">209</span><span id="line-209">        || validSurrogatePairAt(b, b.length() - s - 1)) {</span>
<span class="source-line-no">210</span><span id="line-210">      s--;</span>
<span class="source-line-no">211</span><span id="line-211">    }</span>
<span class="source-line-no">212</span><span id="line-212">    return a.subSequence(a.length() - s, a.length()).toString();</span>
<span class="source-line-no">213</span><span id="line-213">  }</span>
<span class="source-line-no">214</span><span id="line-214"></span>
<span class="source-line-no">215</span><span id="line-215">  /**</span>
<span class="source-line-no">216</span><span id="line-216">   * True when a valid surrogate pair starts at the given {@code index} in the given {@code string}.</span>
<span class="source-line-no">217</span><span id="line-217">   * Out-of-range indexes return false.</span>
<span class="source-line-no">218</span><span id="line-218">   */</span>
<span class="source-line-no">219</span><span id="line-219">  @VisibleForTesting</span>
<span class="source-line-no">220</span><span id="line-220">  static boolean validSurrogatePairAt(CharSequence string, int index) {</span>
<span class="source-line-no">221</span><span id="line-221">    return index &gt;= 0</span>
<span class="source-line-no">222</span><span id="line-222">        &amp;&amp; index &lt;= (string.length() - 2)</span>
<span class="source-line-no">223</span><span id="line-223">        &amp;&amp; Character.isHighSurrogate(string.charAt(index))</span>
<span class="source-line-no">224</span><span id="line-224">        &amp;&amp; Character.isLowSurrogate(string.charAt(index + 1));</span>
<span class="source-line-no">225</span><span id="line-225">  }</span>
<span class="source-line-no">226</span><span id="line-226"></span>
<span class="source-line-no">227</span><span id="line-227">  /**</span>
<span class="source-line-no">228</span><span id="line-228">   * Returns the given {@code template} string with each occurrence of {@code "%s"} replaced with</span>
<span class="source-line-no">229</span><span id="line-229">   * the corresponding argument value from {@code args}; or, if the placeholder and argument counts</span>
<span class="source-line-no">230</span><span id="line-230">   * do not match, returns a best-effort form of that string. Will not throw an exception under</span>
<span class="source-line-no">231</span><span id="line-231">   * normal conditions.</span>
<span class="source-line-no">232</span><span id="line-232">   *</span>
<span class="source-line-no">233</span><span id="line-233">   * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; For most string-formatting needs, use {@link String#format String.format},</span>
<span class="source-line-no">234</span><span id="line-234">   * {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the</span>
<span class="source-line-no">235</span><span id="line-235">   * full range of &lt;a</span>
<span class="source-line-no">236</span><span id="line-236">   * href="https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax"&gt;format</span>
<span class="source-line-no">237</span><span id="line-237">   * specifiers&lt;/a&gt;, and alert you to usage errors by throwing {@link</span>
<span class="source-line-no">238</span><span id="line-238">   * java.util.IllegalFormatException}.</span>
<span class="source-line-no">239</span><span id="line-239">   *</span>
<span class="source-line-no">240</span><span id="line-240">   * &lt;p&gt;In certain cases, such as outputting debugging information or constructing a message to be</span>
<span class="source-line-no">241</span><span id="line-241">   * used for another unchecked exception, an exception during string formatting would serve little</span>
<span class="source-line-no">242</span><span id="line-242">   * purpose except to supplant the real information you were trying to provide. These are the cases</span>
<span class="source-line-no">243</span><span id="line-243">   * this method is made for; it instead generates a best-effort string with all supplied argument</span>
<span class="source-line-no">244</span><span id="line-244">   * values present. This method is also useful in environments such as GWT where {@code</span>
<span class="source-line-no">245</span><span id="line-245">   * String.format} is not available. As an example, method implementations of the {@link</span>
<span class="source-line-no">246</span><span id="line-246">   * Preconditions} class use this formatter, for both of the reasons just discussed.</span>
<span class="source-line-no">247</span><span id="line-247">   *</span>
<span class="source-line-no">248</span><span id="line-248">   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; Only the exact two-character placeholder sequence {@code "%s"} is</span>
<span class="source-line-no">249</span><span id="line-249">   * recognized.</span>
<span class="source-line-no">250</span><span id="line-250">   *</span>
<span class="source-line-no">251</span><span id="line-251">   * @param template a string containing zero or more {@code "%s"} placeholder sequences. {@code</span>
<span class="source-line-no">252</span><span id="line-252">   *     null} is treated as the four-character string {@code "null"}.</span>
<span class="source-line-no">253</span><span id="line-253">   * @param args the arguments to be substituted into the message template. The first argument</span>
<span class="source-line-no">254</span><span id="line-254">   *     specified is substituted for the first occurrence of {@code "%s"} in the template, and so</span>
<span class="source-line-no">255</span><span id="line-255">   *     forth. A {@code null} argument is converted to the four-character string {@code "null"};</span>
<span class="source-line-no">256</span><span id="line-256">   *     non-null values are converted to strings using {@link Object#toString()}.</span>
<span class="source-line-no">257</span><span id="line-257">   * @since 25.1</span>
<span class="source-line-no">258</span><span id="line-258">   */</span>
<span class="source-line-no">259</span><span id="line-259">  // TODO(diamondm) consider using Arrays.toString() for array parameters</span>
<span class="source-line-no">260</span><span id="line-260">  public static String lenientFormat(</span>
<span class="source-line-no">261</span><span id="line-261">      @Nullable String template, @Nullable Object @Nullable ... args) {</span>
<span class="source-line-no">262</span><span id="line-262">    template = String.valueOf(template); // null -&gt; "null"</span>
<span class="source-line-no">263</span><span id="line-263"></span>
<span class="source-line-no">264</span><span id="line-264">    if (args == null) {</span>
<span class="source-line-no">265</span><span id="line-265">      args = new Object[] {"(Object[])null"};</span>
<span class="source-line-no">266</span><span id="line-266">    } else {</span>
<span class="source-line-no">267</span><span id="line-267">      for (int i = 0; i &lt; args.length; i++) {</span>
<span class="source-line-no">268</span><span id="line-268">        args[i] = lenientToString(args[i]);</span>
<span class="source-line-no">269</span><span id="line-269">      }</span>
<span class="source-line-no">270</span><span id="line-270">    }</span>
<span class="source-line-no">271</span><span id="line-271"></span>
<span class="source-line-no">272</span><span id="line-272">    // start substituting the arguments into the '%s' placeholders</span>
<span class="source-line-no">273</span><span id="line-273">    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);</span>
<span class="source-line-no">274</span><span id="line-274">    int templateStart = 0;</span>
<span class="source-line-no">275</span><span id="line-275">    int i = 0;</span>
<span class="source-line-no">276</span><span id="line-276">    while (i &lt; args.length) {</span>
<span class="source-line-no">277</span><span id="line-277">      int placeholderStart = template.indexOf("%s", templateStart);</span>
<span class="source-line-no">278</span><span id="line-278">      if (placeholderStart == -1) {</span>
<span class="source-line-no">279</span><span id="line-279">        break;</span>
<span class="source-line-no">280</span><span id="line-280">      }</span>
<span class="source-line-no">281</span><span id="line-281">      builder.append(template, templateStart, placeholderStart);</span>
<span class="source-line-no">282</span><span id="line-282">      builder.append(args[i++]);</span>
<span class="source-line-no">283</span><span id="line-283">      templateStart = placeholderStart + 2;</span>
<span class="source-line-no">284</span><span id="line-284">    }</span>
<span class="source-line-no">285</span><span id="line-285">    builder.append(template, templateStart, template.length());</span>
<span class="source-line-no">286</span><span id="line-286"></span>
<span class="source-line-no">287</span><span id="line-287">    // if we run out of placeholders, append the extra args in square braces</span>
<span class="source-line-no">288</span><span id="line-288">    if (i &lt; args.length) {</span>
<span class="source-line-no">289</span><span id="line-289">      builder.append(" [");</span>
<span class="source-line-no">290</span><span id="line-290">      builder.append(args[i++]);</span>
<span class="source-line-no">291</span><span id="line-291">      while (i &lt; args.length) {</span>
<span class="source-line-no">292</span><span id="line-292">        builder.append(", ");</span>
<span class="source-line-no">293</span><span id="line-293">        builder.append(args[i++]);</span>
<span class="source-line-no">294</span><span id="line-294">      }</span>
<span class="source-line-no">295</span><span id="line-295">      builder.append(']');</span>
<span class="source-line-no">296</span><span id="line-296">    }</span>
<span class="source-line-no">297</span><span id="line-297"></span>
<span class="source-line-no">298</span><span id="line-298">    return builder.toString();</span>
<span class="source-line-no">299</span><span id="line-299">  }</span>
<span class="source-line-no">300</span><span id="line-300"></span>
<span class="source-line-no">301</span><span id="line-301">  private static String lenientToString(@Nullable Object o) {</span>
<span class="source-line-no">302</span><span id="line-302">    if (o == null) {</span>
<span class="source-line-no">303</span><span id="line-303">      return "null";</span>
<span class="source-line-no">304</span><span id="line-304">    }</span>
<span class="source-line-no">305</span><span id="line-305">    try {</span>
<span class="source-line-no">306</span><span id="line-306">      return o.toString();</span>
<span class="source-line-no">307</span><span id="line-307">    } catch (Exception e) {</span>
<span class="source-line-no">308</span><span id="line-308">      // Default toString() behavior - see Object.toString()</span>
<span class="source-line-no">309</span><span id="line-309">      String objectToString =</span>
<span class="source-line-no">310</span><span id="line-310">          o.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(o));</span>
<span class="source-line-no">311</span><span id="line-311">      // Logger is created inline with fixed name to avoid forcing Proguard to create another class.</span>
<span class="source-line-no">312</span><span id="line-312">      Logger.getLogger("com.google.common.base.Strings")</span>
<span class="source-line-no">313</span><span id="line-313">          .log(WARNING, "Exception during lenientFormat for " + objectToString, e);</span>
<span class="source-line-no">314</span><span id="line-314">      return "&lt;" + objectToString + " threw " + e.getClass().getName() + "&gt;";</span>
<span class="source-line-no">315</span><span id="line-315">    }</span>
<span class="source-line-no">316</span><span id="line-316">  }</span>
<span class="source-line-no">317</span><span id="line-317">}</span>




























































</pre>
</div>
</main>
</body>
</html>
